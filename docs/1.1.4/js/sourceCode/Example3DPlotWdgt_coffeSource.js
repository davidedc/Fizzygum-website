// Generated by CoffeeScript 1.12.7
window.Example3DPlotWdgt_coffeSource = '# REQUIRES Point3D\n\nclass Example3DPlotWdgt extends Widget\n\n\n  vertices: nil\n  quads: nil\n  currentAngle: nil\n  planeGrid: nil\n  graphGrid: nil\n  previousMousePoint: nil\n  autoRotate: true\n  ratio: nil\n\n  # a parameter for a slider to control,\n  # so to show interactive graph/plot\n  parameterValue: 0\n\n  constructor: ->\n    super()\n    @defaultRejectDrags = true\n    @isLockingToPanels = true\n\n    @fps = 0\n    world.addSteppingMorph @\n\n    @setColor new Color 255, 125, 125\n    @rawSetExtent new Point 200, 200\n\n\n\n    @edges = []\n\n    @quads = []\n    \n    @currentAngle = 0\n\n    @step()\n\n  colloquialName: ->\n    "3D plot"\n\n  setParameter: (parameterValue, ignored, connectionsCalculationToken, superCall) ->\n    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken\n    @parameterValue = parameterValue\n    @calculateNewPlotValues()\n\n  reactToTargetConnection: ->\n    @calculateNewPlotValues()\n\n  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->\n    if !menuEntriesStrings? \n      menuEntriesStrings = []\n      functionNamesStrings = []\n    menuEntriesStrings.push "param"\n    functionNamesStrings.push "setParameter"\n\n    if @addShapeSpecificNumericalSetters?\n      [menuEntriesStrings, functionNamesStrings] = @addShapeSpecificNumericalSetters menuEntriesStrings, functionNamesStrings\n\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n  # ---------------------------------------------------------------\n  # Outside of a stack, the plot can take any dimension.\n  # When IN a stack, then we\n  # want the content to force the ratio of the window so that the\n  # plot grows/shrinks in both dimensions harmoniously as the\n  # page is widened/narrowed.\n\n  justDropped: (whereIn) ->\n    super\n    if (whereIn instanceof SimpleVerticalStackPanelWdgt) and !(whereIn instanceof WindowWdgt)\n      @constrainToRatio()\n\n  holderWindowJustDropped: (whereIn) ->\n    if (whereIn instanceof SimpleVerticalStackPanelWdgt) and !(whereIn instanceof WindowWdgt)\n      @constrainToRatio()\n\n  constrainToRatio: ->\n    if @layoutSpecDetails?\n      @ratio = @width() / @height()\n      @layoutSpecDetails.canSetHeightFreely = false\n      # force a resize, so the slide and the window\n      # it\'s in will take the right ratio, and hence\n      # the content will take the whole window it\'s in.\n      # Note that the height of 0 here is ignored since\n      # "rawSetWidthSizeHeightAccordingly" will\n      # calculate the height.\n      @rawSetExtent new Point @width(), 0\n\n  holderWindowJustBeenGrabbed: (whereFrom) ->\n    if whereFrom instanceof SimpleVerticalStackPanelWdgt\n      @freeFromRatioConstraints()\n\n  justBeenGrabbed: (whereFrom) ->\n    if whereFrom instanceof SimpleVerticalStackPanelWdgt\n      @freeFromRatioConstraints()\n\n  freeFromRatioConstraints: ->\n    if @layoutSpecDetails?\n      @layoutSpecDetails.canSetHeightFreely = true\n      @ratio = nil\n\n      availableHeight = world.height() - 20\n      if @parent.height() > availableHeight\n        @parent.rawSetExtent (new Point Math.min((@width()/@height()) * availableHeight, world.width()), availableHeight).round()\n        @parent.fullRawMoveTo world.hand.position().subtract @parent.extent().floorDivideBy 2\n        @parent.fullRawMoveWithin world\n\n  rawSetWidthSizeHeightAccordingly: (newWidth) ->\n    if @ratio?\n      @rawSetExtent new Point newWidth, Math.round(newWidth / @ratio)\n    else\n      super\n  # -----------------------------------------------------------------\n\n  step: ->\n    if @autoRotate\n      @currentAngle++\n    @calculateNewPlotValues()\n\n  calculateNewPlotValues: ->\n    @vertices = []\n\n    @graphGrid = new Grid3D 21, 21, []\n\n    for i in [-1..1] by 0.1\n      for j in [-1..1] by 0.1\n        @vertices.push new Point3D i, j, (Math.sin(i*@parameterValue/30)) + (Math.sin(i*3 + @currentAngle/160) + Math.cos(j*3 + @currentAngle/160))/2\n        @graphGrid.vertexIndexes.push @vertices.length - 1\n\n\n    @planeGrid = new PlaneGrid3D 21, 21\n\n    for i in [-1..1] by 0.1\n      @vertices.push new Point3D i, -1, 0\n      @planeGrid.vertexIndexes.push @vertices.length - 1\n      @vertices.push new Point3D i, 1, 0\n      @planeGrid.vertexIndexes.push @vertices.length - 1\n\n    for j in [-1..1] by 0.1\n      @vertices.push new Point3D -1, j, 0\n      @planeGrid.vertexIndexes.push @vertices.length - 1\n      @vertices.push new Point3D 1, j, 0\n      @planeGrid.vertexIndexes.push @vertices.length - 1\n\n\n    @changed()\n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->\n\n    if @preliminaryCheckNothingToDraw clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return nil\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @backgroundTransparency\n\n      # paintRectangle here is made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, this is why\n      # it\'s called before the scaling.\n      @paintRectangle aContext, al, at, w, h, @backgroundColor\n      aContext.scale pixelRatio, pixelRatio\n\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n\n      @renderingHelper aContext, new Color(255, 255, 255), appliedShadow\n\n      aContext.restore()\n\n      # paintHighlight here is made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, this is why\n      # it\'s called outside the effect of the scaling\n      # (after the restore).\n      @paintHighlight aContext, al, at, w, h\n\n  mouseMove: (pos, mouseButton) ->\n    if world.hand.draggingSomething() then return\n    if mouseButton == \'left\'\n        if @previousMousePoint?\n          @currentAngle +=  @previousMousePoint.x - pos.x\n        @previousMousePoint = pos\n\n  mouseDownLeft: (pos) ->\n    @autoRotate = false\n    @bringToForeground()\n\n  mouseUpLeft: ->\n    @autoRotate = true\n\n  mouseLeave: ->\n    @autoRotate = true\n\n  renderingHelper: (context, color, appliedShadow) ->\n\n    height = @height()\n    width = @width()\n\n    # clean the background\n    if appliedShadow?\n      context.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @alpha\n      context.fillStyle = (new Color 80, 80, 80).toString()\n      context.fillRect 0, 0, width, height\n      # let\'s avoid paint 3d stuff twice because\n      # of the shadow\n      return\n\n    context.fillStyle = WorldMorph.preferencesAndSettings.editableItemBackgroundColor.toString()\n    context.fillRect 0, 0, width, height\n\n\n    squareDim = Math.min width, height\n    context.translate (width-squareDim)/2, (height-squareDim)/2\n\n    points = []\n\n    context.strokeStyle = \'black\'\n    originalAlpha = context.globalAlpha\n    context.globalAlpha = 0.6\n\n    context.scale squareDim/300, squareDim/300\n\n    for eachVertex in @vertices\n      newPoint = eachVertex.rotateX(90).rotateY(@currentAngle/2).translateXYZ(0,0.5,0).project(300, 300, 220, 3)\n      newPoint.y -= squareDim * 1/6\n      points.push newPoint\n\n    for eachQuad in @quads\n      context.beginPath()\n      context.moveTo points[eachQuad[0]].x, points[eachQuad[0]].y\n      context.lineTo points[eachQuad[1]].x, points[eachQuad[1]].y\n      context.lineTo points[eachQuad[2]].x, points[eachQuad[2]].y\n      context.lineTo points[eachQuad[3]].x, points[eachQuad[3]].y\n      context.closePath()\n      context.stroke()\n\n    for eachEdge in @edges\n      context.beginPath()\n      context.moveTo points[eachEdge[0]].x, points[eachEdge[0]].y\n      context.lineTo points[eachEdge[1]].x, points[eachEdge[1]].y\n      context.closePath()\n      context.stroke()\n\n\n    context.beginPath()\n\n    # draw the "horizontals" in the grid (each point x,y with x+1,y)\n    for i in [0...@graphGrid.width-1]\n      for j in [0...@graphGrid.height]\n        if i+1+j*@graphGrid.width < @graphGrid.vertexIndexes.length\n          context.moveTo points[@graphGrid.vertexIndexes[i+j*@graphGrid.width]].x, points[@graphGrid.vertexIndexes[i+j*@graphGrid.width]].y\n          context.lineTo points[@graphGrid.vertexIndexes[(i+1)+j*@graphGrid.width]].x, points[@graphGrid.vertexIndexes[(i+1)+j*@graphGrid.width]].y\n\n    # draw the "verticals" in the grid (each point x,y with x,y+1)\n    for i in [0...@graphGrid.width]\n      for j in [0...@graphGrid.height-1]\n        if i+(j+1)*@graphGrid.width < @graphGrid.vertexIndexes.length\n          context.moveTo points[@graphGrid.vertexIndexes[i+j*@graphGrid.width]].x, points[@graphGrid.vertexIndexes[i+j*@graphGrid.width]].y\n          context.lineTo points[@graphGrid.vertexIndexes[i+(j+1)*@graphGrid.width]].x, points[@graphGrid.vertexIndexes[i+(j+1)*@graphGrid.width]].y\n\n    context.closePath()\n\n    context.strokeStyle = \'black\'\n    context.stroke()\n\n\n\n    context.beginPath()\n\n    for i in [0...@planeGrid.width-1]\n      context.moveTo points[@planeGrid.vertexIndexes[2*i]].x, points[@planeGrid.vertexIndexes[2*i]].y\n      context.lineTo points[@planeGrid.vertexIndexes[2*i+1]].x, points[@planeGrid.vertexIndexes[2*i+1]].y\n\n    for i in [@planeGrid.width-1...@planeGrid.width+@planeGrid.height]\n      context.moveTo points[@planeGrid.vertexIndexes[2*i]].x, points[@planeGrid.vertexIndexes[2*i]].y\n      context.lineTo points[@planeGrid.vertexIndexes[2*i+1]].x, points[@planeGrid.vertexIndexes[2*i+1]].y\n\n    context.closePath()\n\n    context.strokeStyle = \'grey\'\n    context.stroke()\n\n\n    context.globalAlpha = originalAlpha\n\n';
