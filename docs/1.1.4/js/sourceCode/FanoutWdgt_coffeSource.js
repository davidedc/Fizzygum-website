// Generated by CoffeeScript 1.12.7
window.FanoutWdgt_coffeSource = 'class FanoutWdgt extends Widget\n\n  @augmentWith ControllerMixin\n\n  pinUp: nil\n  pinDown: nil\n  pinLeft: nil\n  pinRight: nil\n  inputValue: nil\n\n  constructor: (@color) ->\n    super\n    @appearance = new FanoutAppearance @\n\n    @pinUp = new FanoutPinWdgt()\n    @pinDown = new FanoutPinWdgt()\n    @pinLeft = new FanoutPinWdgt()\n    @pinRight = new FanoutPinWdgt()\n\n    @add @pinUp\n    @add @pinDown\n    @add @pinLeft\n    @add @pinRight\n\n    @invalidateLayout()\n\n  setInput: (newvalue, ignored, connectionsCalculationToken, superCall) ->\n    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken\n    @inputValue = newvalue\n    @updateTarget()\n\n  updateTarget: ->\n    for target in @children\n      if target instanceof FanoutPinWdgt\n        target.setInput @inputValue, nil, @connectionsCalculationToken\n    return\n\n  stringSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "input"\n    functionNamesStrings.push "setInput"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "input"\n    functionNamesStrings.push "setInput"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n  colorSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "input"\n    functionNamesStrings.push "setInput"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n  rawSetExtent: (aPoint) ->\n    super\n    @invalidateLayout()\n\n  doLayout: (newBoundsForThisLayout) ->\n    if !window.recalculatingLayouts\n      debugger\n\n    if !newBoundsForThisLayout?\n      if @desiredExtent?\n        newBoundsForThisLayout = @desiredExtent\n        @desiredExtent = nil\n      else\n        newBoundsForThisLayout = @extent()\n\n      if @desiredPosition?\n        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout\n        @desiredPosition = nil\n      else\n        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout\n\n    if @isCollapsed()\n      @layoutIsValid = true\n      @notifyChildrenThatParentHasReLayouted()\n      return\n\n    @rawSetBounds newBoundsForThisLayout\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Widget. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    trackChanges.push false\n\n    height = @height()\n    width = @width()\n\n    squareDim = Math.min width, height\n\n     # p0 is the origin, the origin being in the bottom-left corner\n    p0 = @topLeft()\n\n    # now the origin is in the middle of the widget\n    p0 = p0.add new Point width/2, height/2\n    \n    # now the origin is in the top left corner of the\n    # square centered in the morph\n    p0 = p0.subtract new Point squareDim/2, squareDim/2\n\n    pinSize = (new Point 22 * squareDim/100, 22*squareDim/100).round()\n\n    @pinUp.setExtent pinSize\n    @pinDown.setExtent pinSize\n    @pinLeft.setExtent pinSize\n    @pinRight.setExtent pinSize\n\n    @pinUp.fullRawMoveTo (p0.add new Point 39 * squareDim/100, 1 * squareDim/100).round()\n    @pinDown.fullRawMoveTo (p0.add new Point 39 * squareDim/100, 77 * squareDim/100).round()\n    @pinLeft.fullRawMoveTo (p0.add new Point 1 * squareDim/100, 39 * squareDim/100).round()\n    @pinRight.fullRawMoveTo (p0.add new Point 77 * squareDim/100, 39 * squareDim/100).round()\n\n\n    trackChanges.pop()\n    @fullChanged()\n\n    @layoutIsValid = true\n    @notifyChildrenThatParentHasReLayouted()\n\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()';
