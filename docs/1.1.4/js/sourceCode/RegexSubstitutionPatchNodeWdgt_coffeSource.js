// Generated by CoffeeScript 1.12.7
window.RegexSubstitutionPatchNodeWdgt_coffeSource = '# REQUIRES ControllerMixin\n\nclass RegexSubstitutionPatchNodeWdgt extends Widget\n\n  @augmentWith ControllerMixin\n\n  regexEntryField: nil\n  defaultContents: nil\n  textMorph: nil\n\n  substitutionTextArea: nil\n  substitutionTextAreaText: nil\n\n  outputTextArea: nil\n  outputTextAreaText: nil\n\n  output: nil\n\n  input1: nil\n  input2: nil\n  input3: nil\n  input4: nil\n\n  # we need to keep track of which inputs are\n  # connected becayse we wait for those to be\n  # all updated before the node fires\n  setInput1IsConnected: false\n  setInput2IsConnected: false\n  setInput3IsConnected: false\n  setInput4IsConnected: false\n\n  # to keep track of whether each input is\n  # up-to-date or not\n  input1connectionsCalculationToken: 314\n  input2connectionsCalculationToken: 314\n  input3connectionsCalculationToken: 314\n  input4connectionsCalculationToken: 314\n\n  # the external padding is the space between the edges\n  # of the container and all of its internals. The reason\n  # you often set this to zero is because windows already put\n  # contents inside themselves with a little padding, so this\n  # external padding is not needed. Useful to keep it\n  # separate and know that it\'s working though.\n  externalPadding: 0\n  # the internal padding is the space between the internal\n  # components. It doesn\'t necessarily need to be equal to the\n  # external padding\n  internalPadding: 5\n\n  constructor: (@defaultContents = "") ->\n    super new Point 200,400\n    @buildAndConnectChildren()\n\n  colloquialName: ->\n    "Regex subst. patch node"\n\n  setInput1: (newvalue, ignored, connectionsCalculationToken, superCall) ->\n    debugger\n    if !superCall and connectionsCalculationToken == @input1connectionsCalculationToken then return else if !connectionsCalculationToken? then @input1connectionsCalculationToken = getRandomInt -20000, 20000 else @input1connectionsCalculationToken = connectionsCalculationToken\n    @input1 = newvalue\n    @updateTarget @input1connectionsCalculationToken\n\n  setInput2: (newvalue, ignored, connectionsCalculationToken, superCall) ->\n    debugger\n    if !superCall and connectionsCalculationToken == @input2connectionsCalculationToken then return else if !connectionsCalculationToken? then @input2connectionsCalculationToken = getRandomInt -20000, 20000 else @input2connectionsCalculationToken = connectionsCalculationToken\n    @input2 = newvalue\n    @updateTarget @input2connectionsCalculationToken\n\n  setInput3: (newvalue, ignored, connectionsCalculationToken, superCall) ->\n    debugger\n    if !superCall and connectionsCalculationToken == @input3connectionsCalculationToken then return else if !connectionsCalculationToken? then @input3connectionsCalculationToken = getRandomInt -20000, 20000 else @input3connectionsCalculationToken = connectionsCalculationToken\n    @input3 = newvalue\n    @updateTarget @input3connectionsCalculationToken\n\n  setInput4: (newvalue, ignored, connectionsCalculationToken, superCall) ->\n    debugger\n    if !superCall and connectionsCalculationToken == @input4connectionsCalculationToken then return else if !connectionsCalculationToken? then @input4connectionsCalculationToken = getRandomInt -20000, 20000 else @input4connectionsCalculationToken = connectionsCalculationToken\n    @input4 = newvalue\n    @updateTarget @input4connectionsCalculationToken\n\n  # the bang makes the node fire the current output value\n  bang: (newvalue, ignored, connectionsCalculationToken, superCall) ->\n    debugger\n    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken\n    @updateTarget @connectionsCalculationToken, true\n\n  openTargetPropertySelector: (ignored, ignored2, theTarget) ->\n    [menuEntriesStrings, functionNamesStrings] = theTarget.numericalSetters()\n    menu = new MenuMorph @, false, @, true, true, "choose target property:"\n    for i in [0...menuEntriesStrings.length]\n      menu.addMenuItem menuEntriesStrings[i], true, @, "setTargetAndActionWithOnesPickedFromMenu", nil, nil, nil, nil, nil, theTarget, functionNamesStrings[i]\n    if menuEntriesStrings.length == 0\n      menu = new MenuMorph @, false, @, true, true, "no target properties available"\n    menu.popUpAtHand()\n\n  updateTarget: (tokenToCheckIfEqual, directFireViaBang) ->\n    debugger\n\n    if !@setInput1IsConnected and\n     !@setInput2IsConnected and\n     !@setInput3IsConnected and\n     !@setInput4IsConnected\n      return\n\n    okToFire = true\n    if @setInput1IsConnected\n      if @input1connectionsCalculationToken != tokenToCheckIfEqual\n        okToFire = false\n    if @setInput2IsConnected\n      if @input2connectionsCalculationToken != tokenToCheckIfEqual\n        okToFire = false\n    if @setInput3IsConnected\n      if @input3connectionsCalculationToken != tokenToCheckIfEqual\n        okToFire = false\n    if @setInput4IsConnected\n      if @input4connectionsCalculationToken != tokenToCheckIfEqual\n        okToFire = false\n\n    # if we are firing via bang then we use\n    # the existing output value, we don\'t\n    # recalculate a new one\n    if okToFire and !directFireViaBang\n      # note that we calculate an output value\n      # even if this node has no target. This\n      # is because the node might be visualising the\n      # output in some other way.\n      @doCalculation()\n\n    # if all the connected inputs are fresh OR we\n    # are firing via bang, then at this point we\n    # are going to update the target with the output\n    # value.\n    if okToFire or directFireViaBang      \n      @fireOutputToTarget tokenToCheckIfEqual\n\n    return    \n\n  fireOutputToTarget: (calculationToken) ->\n    # mark this node as fired.\n    # if the update DOES come from the "bang!", then\n    # @connectionsCalculationToken has already been updated\n    # but we keep it simple and re-assign it here, not\n    # worth complicating things with an additional check\n    @connectionsCalculationToken = calculationToken\n\n    if @action and @action != ""\n      @target[@action].call @target, @output, nil, @connectionsCalculationToken\n\n  reactToTargetConnection: ->\n    # we generate a new calculation token, that\'s OK because\n    # we are definitely not in the middle of the calculation here\n    # but we might be starting a new chain of calculations\n    @fireOutputToTarget getRandomInt -20000, 20000\n\n  doCalculation: ->\n    if @textMorph.text != ""\n\n      # from: https://stackoverflow.com/a/22763959\n      regParts = @textMorph.text.match(/^\\/(.*?)\\/([gim]*)$/)\n      if regParts\n        # the parsed pattern had delimiters and modifiers. handle them. \n        regexp = new RegExp(regParts[1], regParts[2])\n      else\n        # we got pattern string without delimiters\n        regexp = new RegExp(@textMorph.text)\n\n      @output = @input1.replace regexp, @substitutionTextAreaText.text\n      @outputTextAreaText.setText @output\n\n\n  stringSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "bang!", "in1", "in2", "in3", "in4"\n    functionNamesStrings.push "bang", "setInput1", "setInput2", "setInput3", "setInput4"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "bang!", "in1", "in2", "in3", "in4"\n    functionNamesStrings.push "bang", "setInput1", "setInput2", "setInput3", "setInput4"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->\n    super\n    menu.addLine()\n    menu.addMenuItem "set target", true, @, "openTargetSelector", "select another morph\\nwhose numerical property\\nwill be " + "controlled by this one"\n\n\n  buildAndConnectChildren: ->\n    debugger\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n    @regexEntryField = new SimplePlainTextScrollPanelWdgt @defaultContents, false, 5\n    @regexEntryField.disableDrops()\n    @regexEntryField.contents.disableDrops()\n    @regexEntryField.color = new Color 255, 255, 255\n    @textMorph = @regexEntryField.textWdgt\n    @textMorph.backgroundColor = new Color 0,0,0,0\n    @textMorph.setFontName nil, nil, @textMorph.monoFontStack\n    @textMorph.isEditable = true\n    @textMorph.enableSelecting()\n    @add @regexEntryField\n\n    @substitutionTextArea = new SimplePlainTextScrollPanelWdgt @defaultContents, false, 5\n    @substitutionTextArea.disableDrops()\n    @substitutionTextArea.contents.disableDrops()\n    @substitutionTextArea.color = new Color 255, 255, 255\n    @substitutionTextAreaText = @substitutionTextArea.textWdgt\n    @substitutionTextAreaText.backgroundColor = new Color 0,0,0,0\n    @substitutionTextAreaText.setFontName nil, nil, @substitutionTextAreaText.monoFontStack\n    @substitutionTextAreaText.isEditable = true\n    @substitutionTextAreaText.enableSelecting()\n    @add @substitutionTextArea\n\n    @outputTextArea = new SimplePlainTextScrollPanelWdgt @defaultContents, false, 5\n    @outputTextArea.disableDrops()\n    @outputTextArea.contents.disableDrops()\n    @outputTextArea.color = new Color 255, 255, 255\n    @outputTextAreaText = @outputTextArea.textWdgt\n    @outputTextAreaText.backgroundColor = new Color 0,0,0,0\n    @outputTextAreaText.setFontName nil, nil, @outputTextAreaText.monoFontStack\n    @outputTextAreaText.isEditable = false\n    @add @outputTextArea\n\n\n    @invalidateLayout()\n\n  doLayout: (newBoundsForThisLayout) ->\n    if !window.recalculatingLayouts\n      debugger\n\n    if @isCollapsed()\n      @layoutIsValid = true\n      @notifyChildrenThatParentHasReLayouted()\n      return\n\n    super\n    debugger\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Widget. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    trackChanges.push false\n\n    availableHeight = @height() - 2 * @externalPadding - 2 * @internalPadding\n    text1Height = Math.round(availableHeight * 1/4)\n    text2Height = Math.round(availableHeight * 1/4)\n    text3Height = Math.round(availableHeight * 2/4)\n\n    textBottom = @top() + @externalPadding + text1Height\n\n    if @regexEntryField.parent == @\n      @regexEntryField.fullRawMoveTo new Point @left() + @externalPadding, @top() + @externalPadding\n      @regexEntryField.rawSetExtent new Point @width() - 2 * @externalPadding, text1Height\n\n    if @substitutionTextArea.parent == @\n      @substitutionTextArea.fullRawMoveTo new Point @left() + @externalPadding, @regexEntryField.bottom() + @internalPadding\n      @substitutionTextArea.rawSetExtent new Point @width() - 2 * @externalPadding, text2Height\n\n    if @outputTextArea.parent == @\n      @outputTextArea.fullRawMoveTo new Point @left() + @externalPadding, @substitutionTextArea.bottom() + @internalPadding\n      @outputTextArea.rawSetExtent new Point @width() - 2 * @externalPadding, text3Height\n\n\n    trackChanges.pop()\n    @fullChanged()\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n    @layoutIsValid = true\n    @notifyChildrenThatParentHasReLayouted()\n\n';
