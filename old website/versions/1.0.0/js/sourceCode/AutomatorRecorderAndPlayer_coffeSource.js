// Generated by CoffeeScript 1.10.0
window.AutomatorRecorderAndPlayer_coffeSource = '##########################################################################################\n# REQUIRES SystemTestsReferenceImage\n# REQUIRES SystemTestsSystemInfo\n# REQUIRES globalFunctions\n\n# How to load/play a test:\n# from the Chrome console (Option-Command-J) OR Safari console (Option-Command-C):\n# world.automatorRecorderAndPlayer.loadAndRunSingleTestFromName("SystemTest_inspectorResizingOKEvenWhenTakenApart")\n\n# How to inspect the screenshot differences:\n# after having played a test with some failing screenshots\n# comparisons:\n# from the Chrome console (Option-Command-J) OR Safari console (Option-Command-C):\n# window.world.automatorRecorderAndPlayer.saveFailedScreenshots()\n# it will save a zip file containing three files for each failure:\n# 1) the png of the obtained screenshot (different from the expected)\n# 2) the .js file containing the data for the obtained screenshot\n# (in case it\'s OK and should be added to the "good screenshots")\n# 3) a .png file highlighting the differences in red.\n\n# How to record a test:\n# window.world.automatorRecorderAndPlayer.startTestRecording(\'nameOfTheTest\')\n# ...do the test...\n# window.world.automatorRecorderAndPlayer.stopTestRecording()\n# if you want to verify the test on the spot:\n# window.world.automatorRecorderAndPlayer.startTestPlayingWithSlideIntro()\n\n# For recording screenshot data at any time -\n# can be used for screenshot comparisons during the test:\n# window.world.automatorRecorderAndPlayer.takeScreenshot()\n\n# How to save the test:\n# window.world.automatorRecorderAndPlayer.saveTest()\n# The created zip will contain both the test and the\n# related reference images.\n\n# What to do with the saved zip file:\n# These files inside the zip package need to be added\n# to the\n#   ./src/tests directory\n# Then the project will need to be recompiled.\n# At this point the\n#   ./build/indexWithTests.html\n# page will automatically load all the tests and\n# images. See "how to load/play a test" above\n# to read how to load and play a test.\n\nclass AutomatorRecorderAndPlayer\n  automatorCommandsSequence: []\n  @RECORDING: 0\n  @PLAYING: 1\n  @IDLE: 2\n  @state: 2\n  playingAllSystemTests: false\n  indexOfSystemTestBeingPlayed: 0\n  timeOfPreviouslyRecordedCommand: null\n  handMorph: null\n  worldMorph: null\n  collectedImages: [] # array of SystemTestsReferenceImage\n  collectedFailureImages: [] # array of SystemTestsReferenceImage\n  testName: \'\'\n  testDescription: \'no description\'\n  testTags: [\'noTags\']\n  @loadedImages: {}\n  @loadedImagesToBeKeptForLaterDiff: {}\n  ongoingTestPlayingTask: null\n  timeOfPreviouslyPlayedCommand: 0\n  indexOfTestCommandBeingPlayedFromSequence: 0\n\n  @animationsPacingControl: false\n  @alignmentOfMorphIDsMechanism: false\n  @hidingOfMorphsGeometryInfoInLabels: false\n  @hidingOfMorphsNumberIDInLabels: false\n  @hidingOfMorphsContentExtractInLabels: false\n\n  # this is a special place where the\n  # "take pic" command places the image\n  # data of a morph.\n  # the test player will wait for this data\n  # before doing the comparison.\n  imageDataOfAParticularMorph: null\n  lastMouseDownCommand: null\n  lastMouseUpCommand: null\n  selectedTestsBasedOnTags: []\n\n  numberOfGroups: 1\n  groupToBeRun: 0\n\n  atLeastOneTestHasBeenRun: false\n  allTestsPassedSoFar: true\n\n  testDuration: 0\n  allTestsDuration: 0\n  millisOfTestSoFar: 0\n  millisOfAllTestsSoFar: 0\n\n  forceSlowTestPlaying: false\n  forceTurbo: false\n  forceSkippingInBetweenMouseMoves: false\n  forceRunningInBetweenMouseMoves: false\n\n  currentlyPlayingTestName: ""\n\n  tagsCollectedWhileRecordingTest: []\n  failedTests: []\n\n  constructor: (@worldMorph, @handMorph) ->\n\n  clearCommandSeqAndImagesRelatedToTest: (testName) ->\n    # we assume that no-one is going to\n    # write a tests with more than\n    # 100 reference images/screenshots\n    for imageNumber in [0...100]\n      # each of these is an array that could contain\n      # multiple screenshots for different browser/os\n      # configuration, we are clearing the variable\n      # containing the array\n      console.log "deleting #{testName}_image_#{imageNumber}"\n      delete AutomatorRecorderAndPlayer.loadedImages["#{testName}_image_#{imageNumber}"]\n    console.log "deleting SystemTest_#{testName}"\n    window["#{testName}" + "_automationCommands"] = null\n    delete window["#{testName}" + "_automationCommands"]\n\n  # clear any test with the same name\n  # that might be loaded\n  # and all the images related to it\n  clearAnyDataRelatedToTest: (testName) ->\n    # we assume that no-one is going to\n    # write a tests with more than\n    # 100 reference images/screenshots\n    @clearCommandSeqAndImagesRelatedToTest testName\n    delete window["#{testName}"]\n  \n  startTestRecording: (ignored, ingnored2, @testName, @testDescription, @testTags) ->\n    # if test name not provided, then\n    # prompt the user for it\n    if not @testName?\n      @testName = prompt("Please enter a test name", "test1")\n    if not @testDescription?\n      @testDescription = prompt("Please enter a test description", "no description")\n    if not @testTags?\n      @testTags = prompt("Please enter test tags separated by commas", "noTags")\n      @testTags = @testTags.replace(/[ ]+/g, "")\n      @testTags = @testTags.split(",")\n\n    # if you choose the same name\n    # of a previously loaded tests,\n    # confusing things might happen such\n    # as comparison with loaded screenshots\n    # so we want to clear the data related\n    # to the chosen name\n    @clearAnyDataRelatedToTest @testName\n\n    @automatorCommandsSequence = []\n    @tagsCollectedWhileRecordingTest = []\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.RECORDING\n\n  stopTestRecording: ->\n    AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.IDLE\n\n\n  # gonna use this in a callback so need\n  # to make this one a double-arrow\n  stopTestPlaying: ->\n    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.stopTestRec)\n    console.log "wrapping up the playing of the test"\n    \n    # seems that if focus is on canvas\n    # then updates to DOM get coalesced so\n    # much that the highlights/flashed\n    # on the test console are super-late\n    # or completely lost. So we need to\n    # temporarily remove the tab index at\n    # the start of the test and then\n    # put it back when the test playing is\n    # complete\n    world.worldCanvas.tabIndex = "1"\n\n    fade \'singleTestProgressIndicator\', 1, 0, 10, new Date().getTime()\n    fade \'singleTestProgressBarWrap\', 1, 0, 10, new Date().getTime()\n    fade \'allTestsProgressIndicator\', 1, 0, 10, new Date().getTime()\n    fade \'allTestsProgressBarWrap\', 1, 0, 10, new Date().getTime()\n    fade \'numberOfTestsDoneIndicator\', 1, 0, 10, new Date().getTime()\n\n\n    SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole "test complete"\n    AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.IDLE\n\n    # hide indicator of mouse pointer\n    mousePointerIndicator = document.getElementById(\'mousePointerIndicator\')\n    mousePointerIndicator.style.display = \'none\'\n    \n    # There is a background interval that polls\n    # to check whether it\'s time/condition to play\n    # the next queued command. Remove it.\n    indexOfTask = @worldMorph.otherTasksToBeRunOnStep.indexOf(@ongoingTestPlayingTask)\n    @worldMorph.otherTasksToBeRunOnStep.splice(indexOfTask, 1)\n    @worldMorph.initEventListeners()\n    \n    @indexOfTestCommandBeingPlayedFromSequence = 0\n    @clearCommandSeqAndImagesRelatedToTest @testsList()[@indexOfSystemTestBeingPlayed]\n\n    if @playingAllSystemTests\n      @runNextSystemTest()\n\n  showTestSource: ->\n    window.open("data:text/text;charset=utf-8," + encodeURIComponent(JSON.stringify( @automatorCommandsSequence, null, 4 )))\n\n  turnOnAnimationsPacingControl: ->\n    @constructor.animationsPacingControl = true\n    SystemTestsControlPanelUpdater.highlightOnLink SystemTestsControlPanelUpdater.tieAnimations\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOnAnimationsPacingControl @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n\n  turnOffAnimationsPacingControl: ->\n    @constructor.animationsPacingControl = false\n    SystemTestsControlPanelUpdater.highlightOffLink SystemTestsControlPanelUpdater.tieAnimations\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOffAnimationsPacingControl @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n\n  turnOnAlignmentOfMorphIDsMechanism: ->\n    @constructor.alignmentOfMorphIDsMechanism = true\n    SystemTestsControlPanelUpdater.highlightOnLink SystemTestsControlPanelUpdater.alignMorphIDs\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOnAlignmentOfMorphIDsMechanism @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffAlignmentOfMorphIDsMechanism: ->\n    @constructor.alignmentOfMorphIDsMechanism = false\n    SystemTestsControlPanelUpdater.highlightOffLink SystemTestsControlPanelUpdater.alignMorphIDs\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOffAlignmentOfMorphIDsMechanism @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOnHidingOfMorphsGeometryInfoInLabels: ->\n    @constructor.hidingOfMorphsGeometryInfoInLabels = true\n    SystemTestsControlPanelUpdater.highlightOnLink SystemTestsControlPanelUpdater.hideGeometry\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOnHidingOfMorphsGeometryInfoInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffHidingOfMorphsGeometryInfoInLabels: ->\n    @constructor.hidingOfMorphsGeometryInfoInLabels = false\n    SystemTestsControlPanelUpdater.highlightOffLink SystemTestsControlPanelUpdater.hideGeometry\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOffHidingOfMorphsGeometryInfoInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOnHidingOfMorphsContentExtractInLabels: ->\n    @constructor.hidingOfMorphsContentExtractInLabels = true\n    SystemTestsControlPanelUpdater.highlightOnLink SystemTestsControlPanelUpdater.hideMorphContentExtracts\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOnHidingOfMorphsContentExtractInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffHidingOfMorphsContentExtractInLabels: ->\n    @constructor.hidingOfMorphsContentExtractInLabels = false\n    SystemTestsControlPanelUpdater.highlightOffLink SystemTestsControlPanelUpdater.hideMorphContentExtracts\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOffHidingOfMorphsContentExtractInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOnHidingOfMorphsNumberIDInLabels: ->\n    @constructor.hidingOfMorphsNumberIDInLabels = true\n    SystemTestsControlPanelUpdater.highlightOnLink SystemTestsControlPanelUpdater.hideMorphIDs\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOnHidingOfMorphsNumberIDInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  turnOffHidingOfMorphsNumberIDInLabels: ->\n    @constructor.hidingOfMorphsNumberIDInLabels = false\n    SystemTestsControlPanelUpdater.highlightOffLink SystemTestsControlPanelUpdater.hideMorphIDs\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandTurnOffHidingOfMorphsNumberIDInLabels @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n\n  addMouseMoveCommand: (pageX, pageY, floatDraggingSomething, button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandMouseMove pageX, pageY, floatDraggingSomething, button, buttons, ctrlKey, shiftKey, altKey, metaKey, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addMouseChangeCommand: (upOrDown, button, buttons, ctrlKey, shiftKey, altKey, metaKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandMouseButtonChange upOrDown, button, buttons, ctrlKey, shiftKey, altKey, metaKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, @\n    @lastMouseDownCommand = systemTestCommand\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addMouseClickCommand: (button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandMouseClick button, ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, @\n    @lastMouseDownCommand = systemTestCommand\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  # note that we give for granted that double click\n  # is always on the left button\n  addMouseDoubleClickCommand: (ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandMouseDoubleClick ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, @\n    @lastMouseDownCommand = systemTestCommand\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  # note that we give for granted that triple click\n  # is always on the left button\n  addMouseTripleClickCommand: (ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandMouseTripleClick ctrlKey, morphUniqueIDString, morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph, @\n    @lastMouseDownCommand = systemTestCommand\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n\n  addOpenContextMenuCommand: (context) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    #@removeLastMouseUpAndMouseDownCommands()\n    systemTestCommand = new AutomatorCommandOpenContextMenu context, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addCommandLeftOrRightClickOnMenuItem: (mouseButton, labelString, occurrenceNumber) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    #@removeLastMouseUpAndMouseDownCommands()\n    systemTestCommand = new AutomatorCommandLeftOrRightClickOnMenuItem mouseButton, labelString, occurrenceNumber, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  # doesn\'t *actually* remove the command\n  # because you do need to wait the time.\n  # because for example the bubbles pop-up\n  # after some time.\n  # You could remove the commands and note down\n  # how much was the wait on each and charge it to\n  # the next command but that would be very messy.\n  #removeLastMouseUpAndMouseDownCommands: ->\n  #  @lastMouseDownCommand.transformIntoDoNothingCommand()\n  #  @lastMouseUpCommand.transformIntoDoNothingCommand()\n\n  addKeyPressCommand: (charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandKeyPress charCode, symbol, shiftKey, ctrlKey, altKey, metaKey, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addKeyDownCommand: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandKeyDown scanCode, shiftKey, ctrlKey, altKey, metaKey, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addKeyUpCommand: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandKeyUp scanCode, shiftKey, ctrlKey, altKey, metaKey, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addCutCommand: () ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandCut null, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addCopyCommand: () ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandCopy null, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addPasteCommand: (clipboardText) ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandPaste clipboardText, @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addGrabCommand: ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandGrab @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addDropCommand: ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandDrop @\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  resetWorld: ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    systemTestCommand = new AutomatorCommandResetWorld @\n    window[systemTestCommand.automatorCommandName].replayFunction @, null\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n\n  addTestComment: ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    # note how we take the time before we prompt the\n    # user so we can show the message sooner when playing\n    # the test - i.e. the message will appear at the time\n    # the user got the prompt window rather than when she\n    # actually wrote the message...\n    # So we anticipate the message so the user can actually have\n    # the time to read it before the test moves on with the\n    # next steps.\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    comment = prompt("enter comment", "your comment here")\n    systemTestCommand = new AutomatorCommandShowComment comment, @\n    @automatorCommandsSequence.push systemTestCommand\n\n  evaluateString: ->\n    return if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n    # we record the time here instead of after the user has\n    # dismissed the prompt, since we run the command right on the back\n    # of the action that precedes it, otherwise there would be a wait.\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    command = prompt("enter command", "your command here")\n    systemTestCommand = new AutomatorCommandEvaluateString command, @\n    debugger\n    window[systemTestCommand.automatorCommandName].replayFunction @, systemTestCommand\n    @automatorCommandsSequence.push systemTestCommand\n\n  checkStringsOfItemsInMenuOrderImportant: (stringOfItemsInMenuInOriginalOrder) ->\n    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.checkMenuEntriesInOrder)\n    @checkStringsOfItemsInMenu(stringOfItemsInMenuInOriginalOrder, true)\n\n  checkStringsOfItemsInMenuOrderUnimportant: (stringOfItemsInMenuInOriginalOrder) ->\n    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.checkMenuEntriesNotInOrder)\n    @checkStringsOfItemsInMenu(stringOfItemsInMenuInOriginalOrder, false)\n\n  checkStringsOfItemsInMenu: (stringOfItemsInMenuInOriginalOrder, orderMatters) ->\n    console.log "checkStringsOfItemsInMenu"\n    menuAtPointer = @handMorph.menuAtPointer()\n    console.log menuAtPointer\n\n    stringOfItemsInCurrentMenuInOriginalOrder = []\n\n    if menuAtPointer?\n      for eachMenuItem in menuAtPointer.items\n        stringOfItemsInCurrentMenuInOriginalOrder.push eachMenuItem[0]\n    else\n      errorMessage = "FAIL was expecting a menu under the pointer"\n      console.log errorMessage\n      testBeingPlayed = @testsList()[@indexOfSystemTestBeingPlayed]\n      if @failedTests.indexOf(testBeingPlayed) < 0 then @failedTests.push(testBeingPlayed)\n      document.getElementById(\'numberOfFailedTests\').innerHTML = "- " + @failedTests.length + " failed"\n      @allTestsPassedSoFar = false\n      document.getElementById("background").style.background = "red"\n      if SystemTestsControlPanelUpdater?\n        SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole errorMessage\n      @stopTestPlaying()\n\n    switch AutomatorRecorderAndPlayer.state\n      when AutomatorRecorderAndPlayer.RECORDING\n        if orderMatters\n          systemTestCommand =\n            new AutomatorCommandCheckStringsOfItemsInMenuOrderImportant stringOfItemsInCurrentMenuInOriginalOrder, @\n        else\n          systemTestCommand =\n            new AutomatorCommandCheckStringsOfItemsInMenuOrderUnimportant stringOfItemsInCurrentMenuInOriginalOrder, @\n\n        @automatorCommandsSequence.push systemTestCommand\n        @timeOfPreviouslyRecordedCommand = new Date().getTime()\n      when AutomatorRecorderAndPlayer.PLAYING\n        giveSuccess = =>\n          if orderMatters\n            message = "PASS Strings in menu are same and in same order"\n          else\n            message = "PASS Strings in menu are same (not considering order)"\n          if SystemTestsControlPanelUpdater?\n            SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n        giveError = =>\n          if orderMatters\n            @allTestsPassedSoFar = false\n            document.getElementById("background").style.background = "red"\n            errorMessage =\n              "FAIL Strings in menu doesn\'t match or order is incorrect. Was expecting: " +\n                stringOfItemsInMenuInOriginalOrder + " found: " + stringOfItemsInCurrentMenuInOriginalOrder\n            testBeingPlayed = @testsList()[@indexOfSystemTestBeingPlayed]\n            if @failedTests.indexOf(testBeingPlayed) < 0 then @failedTests.push(testBeingPlayed)\n            document.getElementById(\'numberOfFailedTests\').innerHTML = "- " + @failedTests.length + " failed"\n          else\n            @allTestsPassedSoFar = false\n            document.getElementById("background").style.background = "red"\n            errorMessage =\n              "FAIL Strings in menu doesn\'t match (even not considering order). Was expecting: " +\n                stringOfItemsInMenuInOriginalOrder + " found: " + stringOfItemsInCurrentMenuInOriginalOrder\n            testBeingPlayed = @testsList()[@indexOfSystemTestBeingPlayed]\n            if @failedTests.indexOf(testBeingPlayed) < 0 then @failedTests.push(testBeingPlayed)\n            document.getElementById(\'numberOfFailedTests\').innerHTML = "- " + @failedTests.length + " failed"\n          if SystemTestsControlPanelUpdater?\n            SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole errorMessage\n          @stopTestPlaying()\n      \n        menuListIsSame = true\n\n        # the reason why we make a copy here is the following:\n        # if you kept the original array then this could happen:\n        # you record a test and then you play it back and then you save it\n        # the array is always the same and could get mutated during the play\n        # (because it could be sorted). So when you save the test, you\n        # save the ordered array instead of the original.\n        copyOfstringOfItemsInMenuInOriginalOrder = arrayShallowCopy(stringOfItemsInMenuInOriginalOrder)\n\n        # if the order doesn\'t matter then we need to\n        # sort the strings first so we compare regardless\n        # of the original order\n        if !orderMatters\n          stringOfItemsInCurrentMenuInOriginalOrder.sort()\n          copyOfstringOfItemsInMenuInOriginalOrder.sort()\n\n        if stringOfItemsInCurrentMenuInOriginalOrder.length == copyOfstringOfItemsInMenuInOriginalOrder.length\n          for itemNumber in [0...copyOfstringOfItemsInMenuInOriginalOrder.length]\n            if copyOfstringOfItemsInMenuInOriginalOrder[itemNumber] != stringOfItemsInCurrentMenuInOriginalOrder[itemNumber]\n              menuListIsSame = false\n              console.log copyOfstringOfItemsInMenuInOriginalOrder[itemNumber] + " != " + stringOfItemsInCurrentMenuInOriginalOrder[itemNumber] + " at " + itemNumber\n        else\n          menuListIsSame = false\n\n        if menuListIsSame\n          giveSuccess()\n        else\n          giveError()\n\n  checkNumberOfItemsInMenu: (numberOfItems) ->\n    SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.checkNumnberOfItems)\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      menuAtPointer = @handMorph.menuAtPointer()\n      console.log menuAtPointer\n      if menuAtPointer?\n        numberOfItems = menuAtPointer.items.length\n        console.log "found " + numberOfItems + " number of items "\n      else\n        console.log "was expecting a menu under the pointer"\n        numberOfItems = 0\n      systemTestCommand = new AutomatorCommandCheckNumberOfItemsInMenu numberOfItems, @\n      @automatorCommandsSequence.push systemTestCommand\n      @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    else if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      menuAtPointer = @handMorph.menuAtPointer()\n      giveSuccess = =>\n        message = "PASS Number of items in menu matches. Note that count includes line separators. Found: " + menuAtPointer.items.length\n        if SystemTestsControlPanelUpdater?\n          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n      giveError = =>\n        @allTestsPassedSoFar = false\n        document.getElementById("background").style.background = "red"\n        errorMessage = "FAIL Number of items in menu doesn\'t match. Note that count includes line separators. Was expecting: " + numberOfItems + " found: " + menuAtPointer.items.length\n        testBeingPlayed = @testsList()[@indexOfSystemTestBeingPlayed]\n        if @failedTests.indexOf(testBeingPlayed) < 0 then @failedTests.push(testBeingPlayed)\n        document.getElementById(\'numberOfFailedTests\').innerHTML = "- " + @failedTests.length + " failed"\n        if SystemTestsControlPanelUpdater?\n          SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole errorMessage\n        @stopTestPlaying()\n      if menuAtPointer?\n        if numberOfItems != menuAtPointer.items.length\n          giveError()\n        else\n          giveSuccess()\n      else\n          giveError()\n\n  takeScreenshot: (whichMorph = @worldMorph) ->\n    console.log "taking screenshot"\n    imageName = "SystemTest_"+@testName+"_image_" + (@collectedImages.length + 1)\n    systemTestCommand = new AutomatorCommandScreenshot imageName, @, whichMorph != @worldMorph\n\n    imageData = whichMorph.fullImageAsItAppearsOnScreen()\n\n    takenScreenshot = new SystemTestsReferenceImage(imageName,imageData, new SystemTestsSystemInfo())\n    unless AutomatorRecorderAndPlayer.loadedImages["#{imageName}"]?\n      AutomatorRecorderAndPlayer.loadedImages["#{imageName}"] = []\n    AutomatorRecorderAndPlayer.loadedImages["#{imageName}"].push takenScreenshot\n    @collectedImages.push takenScreenshot\n    @automatorCommandsSequence.push systemTestCommand\n    @timeOfPreviouslyRecordedCommand = new Date().getTime()\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.RECORDING\n      return systemTestCommand\n\n  # a lenghty method because there\n  # is a lot of API dancing, but the\n  # concept is really easy: return\n  # a new canvas with an image that is\n  # red in all areas where the\n  # "expected" and "obtained" images\n  # are different.\n  # So it neatly highlights where the differences\n  # are.\n  subtractScreenshots: (expected, obtained, diffNumber, andThen) ->\n    console.log "subtractScreenshots"\n    expectedCanvas = document.createElement "canvas"\n    expectedImage = new Image\n    # unfortunately the operation of loading\n    # the base64 data into the image is asynchronous\n    # (seems to work immediately in Chrome but it\'s\n    # recommended to consider it asynchronous)\n    # so here we need to chain two callbacks\n    # to make it all work, as we need to load\n    # two such images.\n    expectedImage.onload = =>\n      console.log "expectedCanvas.imageData: " + expectedCanvas.imageData\n      expectedCanvas.width = expectedImage.width\n      expectedCanvas.height = expectedImage.height\n      expectedCanvasContext = expectedCanvas.getContext "2d"\n      console.log "expectedCanvas.width: " + expectedCanvas.width\n      console.log "expectedCanvas.height: " + expectedCanvas.height\n      expectedCanvasContext.drawImage(expectedImage,0,0)\n      expectedImageData = expectedCanvasContext.getImageData(0, 0, expectedCanvas.width, expectedCanvas.height)\n\n      obtainedCanvas = document.createElement "canvas"\n      obtainedImage = new Image\n      obtainedImage.onload = =>\n        obtainedCanvas.width = obtainedImage.width\n        obtainedCanvas.height = obtainedImage.height\n\n        if (obtainedImage.width != expectedImage.width) or\n        (obtainedImage.height != expectedImage.height)\n          # this happens when comparing screenshots\n          # coming from screens with different\n          # pixelRatios. The resulting diff image\n          # would be very glitchy and strange and\n          # just maningless so skip the process\n          return\n\n        obtainedCanvasContext = obtainedCanvas.getContext "2d"\n        obtainedCanvasContext.drawImage(obtainedImage,0,0)\n        obtainedImageData = obtainedCanvasContext.getImageData(0, 0, obtainedCanvas.width, obtainedCanvas.height)\n\n        subtractionCanvas = document.createElement "canvas"\n        subtractionCanvas.width = obtainedImage.width\n        subtractionCanvas.height = obtainedImage.height\n        subtractionCanvasContext = subtractionCanvas.getContext("2d")\n        subtractionCanvasContext.drawImage(obtainedImage,0,0)\n        subtractionImageData = subtractionCanvasContext.getImageData(0, 0, subtractionCanvas.width, subtractionCanvas.height)\n\n        i = 0\n        equalPixels = 0\n        differentPixels = 0\n\n        while i < subtractionImageData.data.length\n          if obtainedImageData.data[i] != expectedImageData.data[i] or\n             obtainedImageData.data[i+1] != expectedImageData.data[i+1] or\n             obtainedImageData.data[i+2] != expectedImageData.data[i+2]\n            subtractionImageData.data[i] = 255\n            subtractionImageData.data[i+1] = 0\n            subtractionImageData.data[i+2] = 0\n            differentPixels++\n          else\n            equalPixels++\n          i += 4\n        console.log "equalPixels: " + equalPixels\n        console.log "differentPixels: " + differentPixels\n        subtractionCanvasContext.putImageData subtractionImageData, 0, 0\n        #errorRatio = Math.ceil((differentPixels/(equalPixels+differentPixels))*1000)\n        errorRatio = differentPixels\n        andThen subtractionCanvas, expected, errorRatio, diffNumber\n\n      obtainedImage.src = obtained.imageData\n\n    expectedImage.src = expected.imageData\n\n  compareScreenshots: (testNameWithImageNumber, screenshotTakenOfAParticularMorph = false) ->\n   SystemTestsControlPanelUpdater.blinkLink(SystemTestsControlPanelUpdater.takeScreenshot)\n\n   if screenshotTakenOfAParticularMorph\n     console.log "comparing pic of a particular morph"\n     # todo this seems broken, this image data is not\n     # actually fetched anywhere?\n     screenshotObtained = @imageDataOfAParticularMorph\n     @imageDataOfAParticularMorph = null\n   else\n     console.log "comparing pic of whole desktop"\n     screenshotObtained = @worldMorph.fullImageAsItAppearsOnScreen()\n   \n   console.log "trying to match screenshot: " + testNameWithImageNumber\n   console.log "length of obtained: " + screenshotObtained.length\n\n   # There can be multiple files for the same image, since\n   # the images vary according to OS and Browser, so for\n   # each image of each test there is an array of candidates\n   # to be checked. If any of them matches in terms of pixel data,\n   # then fine, otherwise complain...\n   #\n   # in "loadedImagesToBeKeptForLaterDiff" we keep the images\n   # related to the failed tests. If we don\'t keep those\n   # in this reference, they are disposed of and garbage collected\n   # since they are quite big and they accumulate.\n   AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff["#{testNameWithImageNumber}"] = AutomatorRecorderAndPlayer.loadedImages["#{testNameWithImageNumber}"]\n   for eachImage in AutomatorRecorderAndPlayer.loadedImages["#{testNameWithImageNumber}"]\n     console.log "length of obtained: " + eachImage.imageData.length\n     if eachImage.imageData == screenshotObtained\n      message = "PASS - screenshot " + eachImage.fileName + " matched"\n      AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff["#{testNameWithImageNumber}"] = null\n      delete AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff["#{testNameWithImageNumber}"]\n      console.log message\n      if SystemTestsControlPanelUpdater?\n        SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n      return\n   # OK none of the images we loaded matches the one we\n   # just took. Hence create a SystemTestsReferenceImage\n   # that we can let the user download - it will contain\n   # the image actually obtained (rather than the one\n   # we should have seen)\n   message = "FAIL - no screenshots like this one"\n   console.log message\n   @allTestsPassedSoFar = false\n   document.getElementById("background").style.background = "red"\n   if SystemTestsControlPanelUpdater?\n     SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole message\n   obtainedImageName = "obtained-" + eachImage.imageName\n   obtainedImage = new SystemTestsReferenceImage(obtainedImageName,screenshotObtained, new SystemTestsSystemInfo())\n   @collectedFailureImages.push obtainedImage\n   testBeingPlayed = @testsList()[@indexOfSystemTestBeingPlayed]\n   if @failedTests.indexOf(testBeingPlayed) < 0 then @failedTests.push(testBeingPlayed)\n   document.getElementById(\'numberOfFailedTests\').innerHTML = "- " + @failedTests.length + " failed"\n\n  runningInSlowMode: ->\n    if @forceSlowTestPlaying then return true\n    if @forceRunningInBetweenMouseMoves then return false\n    if @forceSkippingInBetweenMouseMoves then return false\n    if @forceTurbo then return false\n    if window["#{@currentlyPlayingTestName}"]?.skipInbetweenMouseMoves then return false\n\n  replayTestCommands: ->\n   commandToBePlayed = @automatorCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence]\n   # console.log "examining command: " + commandToBePlayed.automatorCommandName + " at: " + commandToBePlayed.millisecondsSincePreviousCommand +\n   #   " time now: " + timeNow + " we are at: " + (timeNow - @timeOfPreviouslyPlayedCommand)\n\n\n\n   # for the screenshot, the replay is going\n   # to consist in comparing the image data.\n   # in case the screenshot is made of the entire world\n   # then the comparison can happen now.\n   # in case the screenshot is made of a particular\n   # morph then we want to wait that the world\n   # has taken that screenshot image data and put\n   # it in here.\n   # search for imageDataOfAParticularMorph everywhere\n   # to see where the image data is created and\n   # put there.\n   if commandToBePlayed.automatorCommandName == "AutomatorCommandScreenshot" and commandToBePlayed.screenshotTakenOfAParticularMorph\n     if not @imageDataOfAParticularMorph?\n       # no image data of morph, so just wait\n       return\n\n   #if commandToBePlayed.automatorCommandName == "AutomatorCommandScreenshot"\n   # @automatorCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence + 1].millisecondsSincePreviousCommand = 0\n   # debugger\n\n   runCurrentCommandImmediately = false\n   if ((window["#{@currentlyPlayingTestName}"]?.supportsTurboPlayback) and (!@forceSlowTestPlaying)) or @forceTurbo\n     if (@indexOfTestCommandBeingPlayedFromSequence >= 1) and\n      (@indexOfTestCommandBeingPlayedFromSequence < (@automatorCommandsSequence.length - 1))\n        consecutiveMouseMoves = 0\n        while true\n          previousCommand1 = @automatorCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence - 1]\n          commandToBePlayed = @automatorCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence]\n          nextCommand1 = @automatorCommandsSequence[@indexOfTestCommandBeingPlayedFromSequence + 1]\n          if previousCommand1.automatorCommandName == "AutomatorCommandMouseMove" and\n           nextCommand1.automatorCommandName == "AutomatorCommandMouseMove" and\n           commandToBePlayed.automatorCommandName == "AutomatorCommandMouseMove"\n            consecutiveMouseMoves++\n            #if (consecutiveMouseMoves % 6) != 0\n            if (consecutiveMouseMoves % 10000) != 0\n              if (!window["#{@currentlyPlayingTestName}"]?.skipInbetweenMouseMoves and (!@forceSkippingInBetweenMouseMoves)) or @forceRunningInBetweenMouseMoves\n                window[commandToBePlayed.automatorCommandName].replayFunction.call @,@,commandToBePlayed\n              timeUntilNextCommand = commandToBePlayed.millisecondsSincePreviousCommand or 0\n              @millisOfTestSoFar += timeUntilNextCommand\n              @millisOfAllTestsSoFar += timeUntilNextCommand\n              console.log ">>>>>> skipping mousemove"\n              @indexOfTestCommandBeingPlayedFromSequence++\n            else\n              runCurrentCommandImmediately = true\n              break\n          else\n            runCurrentCommandImmediately = true\n            break\n\n\n   timeNow = (new Date()).getTime()\n   timeUntilNextCommand = commandToBePlayed.millisecondsSincePreviousCommand or 0\n   \n   if world.outstandingTimerTriggeredOperationsCounter.length == 0 and\n    (\n      runCurrentCommandImmediately or\n      (timeNow - @timeOfPreviouslyPlayedCommand >= timeUntilNextCommand)\n    )\n\n     console.log ">>>>>> doing "  + commandToBePlayed.automatorCommandName\n\n     @millisOfTestSoFar += timeUntilNextCommand\n     @millisOfAllTestsSoFar += timeUntilNextCommand\n\n     #console.log "running command: " + commandToBePlayed.automatorCommandName + " " + @indexOfTestCommandBeingPlayedFromSequence + " / " + @automatorCommandsSequence.length + " ms: " + @millisOfTestSoFar + " / " + @testDuration\n     window[commandToBePlayed.automatorCommandName].replayFunction.call @,@,commandToBePlayed\n\n     document.getElementById(\'singleTestProgressIndicator\').innerHTML = "test: " + Math.floor((@millisOfTestSoFar / @testDuration)*100) + "%" + " done"\n     document.getElementById(\'singleTestProgressBar\').style.left =  (Math.floor((@millisOfTestSoFar / @testDuration)*100)) + "%"\n\n     document.getElementById(\'allTestsProgressIndicator\').innerHTML = "all: " + Math.floor((@millisOfAllTestsSoFar / @allTestsDuration)*100) + "%" + " done"\n     document.getElementById(\'allTestsProgressBar\').style.left =  (Math.floor((@millisOfAllTestsSoFar / @allTestsDuration)*100)) + "%"\n\n     @timeOfPreviouslyPlayedCommand = timeNow\n     @indexOfTestCommandBeingPlayedFromSequence++\n     if @indexOfTestCommandBeingPlayedFromSequence == @automatorCommandsSequence.length\n       console.log "stopping the test player"\n       @stopTestPlaying()\n\n  calculateTotalTimeOfThisTest: ->\n    testDuration = 0\n    for eachCommand in @automatorCommandsSequence\n      if eachCommand.millisecondsSincePreviousCommand?\n        testDuration += eachCommand.millisecondsSincePreviousCommand\n    @testDuration = testDuration\n\n  startTestPlayingSlow: ->\n    @forceSlowTestPlaying = true\n    @startTestPlaying()\n\n  startTestPlayingFastSkipInbetweenMouseMoves: ->\n    @forceTurbo = true\n    @forceSkippingInBetweenMouseMoves = true\n    @startTestPlaying()\n\n  startTestPlayingFastRunInbetweenMouseMoves: ->\n    @forceTurbo = true\n    @forceRunningInBetweenMouseMoves = true\n    @startTestPlaying()\n\n  startTestPlaying: ->\n\n\n    # seems that if focus is on canvas\n    # then updates to DOM get coalesced so\n    # much that the highlights/flashed\n    # on the test console are super-late\n    # or completely lost. So we need to\n    # temporarily remove the tab index at\n    # the start of the test and then\n    # put it back when the test playing is\n    # complete\n    world.worldCanvas.tabIndex = "-1"\n\n    AutomatorRecorderAndPlayer.state = AutomatorRecorderAndPlayer.PLAYING\n    @atLeastOneTestHasBeenRun = true\n    @constructor.animationsPacingControl = true\n    @worldMorph.removeEventListeners()\n\n    @currentlyPlayingTestName = @testsList()[@indexOfSystemTestBeingPlayed]\n    if window["#{@currentlyPlayingTestName}"]?\n      @testDuration = window["#{@currentlyPlayingTestName}"].testDuration\n\n    if window["#{@currentlyPlayingTestName}"].grabDragThreshold?\n      WorldMorph.preferencesAndSettings.grabDragThreshold = window["#{@currentlyPlayingTestName}"].grabDragThreshold\n\n    @millisOfTestSoFar = 0\n    @ongoingTestPlayingTask = (=> @replayTestCommands())\n    @worldMorph.otherTasksToBeRunOnStep.push @ongoingTestPlayingTask\n\n    document.getElementById(\'numberOfTestsDoneIndicator\').innerHTML = "test " + (@indexOfSystemTestBeingPlayed + 1) + " of " + @testsList().length\n\n\n  startTestPlayingWithSlideIntro: ->\n    @startTestPlaying()\n    @setUpIntroSlide()\n\n  setUpIntroSlide: ->\n    fade \'singleTestProgressIndicator\', 0, 1, 10, new Date().getTime()\n    fade \'singleTestProgressBarWrap\', 0, 1, 10, new Date().getTime()\n    fade \'allTestsProgressIndicator\', 0, 1, 10, new Date().getTime()\n    fade \'allTestsProgressBarWrap\', 0, 1, 10, new Date().getTime()\n    fade \'numberOfTestsDoneIndicator\', 0, 1, 10, new Date().getTime()\n\n    fade \'testTitleAndDescription\', 0, 1, 10, new Date().getTime()\n\n    presentableTestName = @currentlyPlayingTestName.replace /SystemTest_/g, ""\n    presentableTestName = decamelize presentableTestName, " "\n    presentableTestName = presentableTestName.charAt(0).toUpperCase() + presentableTestName.slice(1)\n    presentableTestName = \'"\' + presentableTestName + \'"\'\n    testTitleAndDescription.innerHTML =  presentableTestName\n    testTitleAndDescription.innerHTML = testTitleAndDescription.innerHTML + "<br><br><small>(#{@currentlyPlayingTestName})</small>"\n    testTitleAndDescription.innerHTML = testTitleAndDescription.innerHTML + "<br><br><small>" + window["#{@currentlyPlayingTestName}"].description + "</small>"\n    setTimeout \\\n      =>\n        fade \'testTitleAndDescription\', 1, 0, 2000, new Date().getTime()        \n      , 4000\n\n\n  testMetadataFileContentCreator: ->\n    # these here below is just one string\n    # spanning multiple lines, which\n    # includes the testName and commands\n    # in the right places.\n\n    testToBeSerialized = {}\n    testToBeSerialized.timeRecorded = new Date()\n    testToBeSerialized.description = @testDescription\n    testToBeSerialized.tags = @testTags.concat @tagsCollectedWhileRecordingTest\n    testToBeSerialized.systemInfo = new SystemTestsSystemInfo()\n    @calculateTotalTimeOfThisTest()\n    testToBeSerialized.testDuration = @testDuration\n    testToBeSerialized.supportsTurboPlayback = true\n    testToBeSerialized.skipInbetweenMouseMoves = true\n    testToBeSerialized.grabDragThreshold = WorldMorph.preferencesAndSettings.grabDragThreshold\n\n    """\n  // This Automator file is automatically\n  // created.\n  // If this is a test,\n  // this file (and related reference images)\n  // can be copied in the /src/tests folder\n  // to make them available in the testing\n  // environment.\n  var SystemTest_#{@testName};\n\n  SystemTest_#{@testName} = #{JSON.stringify(testToBeSerialized, null, 4)};\n    """\n\n  automatorCommandsFileContentCreator: (commands) ->\n    # these here below is just one string\n    # spanning multiple lines, which\n    # includes the testName and commands\n    # in the right places.\n\n    testToBeSerialized = {}\n    testToBeSerialized.automatorCommandsSequence = commands\n    testNameExtended = @testName + "_automationCommands"\n\n    """\n  // This Automator file is automatically\n  // created.\n  // It this is a test,\n  // this file (and related reference images)\n  // can be copied in the /src/tests folder\n  // to make them available in the testing\n  // environment.\n  var SystemTest_#{testNameExtended}\n\n  SystemTest_#{testNameExtended} = #{JSON.stringify(testToBeSerialized, null, 4)}\n    """\n\n  saveFailedScreenshots: ->\n    zip = new JSZip()\n    \n    AutomatorRecorderAndPlayer.loadedImages = AutomatorRecorderAndPlayer.loadedImagesToBeKeptForLaterDiff\n\n    # debugger\n    # save all the images, each as a .png and .js file\n    # the png is for quick browsing, while the js contains\n    # the pixel data and the metadata of which configuration\n    # the picture was recorded with.\n    # (we expect the screenshots to be different across\n    # browsers and OSs)\n    # Note that the .js files are saved so the content\n    # doesn\'t contain "obtained-" anywhere in metadata\n    # (as it should, in theory) so that, if the\n    # screenshot is good, the file can just be\n    # renamed and moved together with the "good"\n    # screenshots.\n    for image in @collectedFailureImages\n      image.addToZipAsJSIgnoringItsAnObtained zip\n      \n      # let\'s also save the png file so it\'s easier to browse the data\n      # note that these png files are not copied over into the\n      # build directory.\n      image.addToZipAsPNG zip\n\n    # create and save all diff .png images\n    # the diff images just highlight in red\n    # the parts that differ from any one\n    # of the "good" screenshots\n    # (remember, there can be more than one\n    # good screenshot, we pick the first one\n    # we find)\n    renamerScript = ""\n    systemInfo = new SystemTestsSystemInfo()\n    pixelRatioString = (""+pixelRatio).replace(/\\.+/g, "_")\n\n    for i in [0...@collectedFailureImages.length]\n      failedImage = @collectedFailureImages[i]\n\n      aGoodImageName = (failedImage).imageName.replace("obtained-", "")\n      filenameForScript = aGoodImageName.replace(/_image_.*/g, "")\n      renamerScript += "rm " + "../Fizzygum-tests/tests/" + filenameForScript + "/automation-assets/" +\n              systemInfo.os.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.osVersion.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.browser.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.browserVersion.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              "devicePixelRatio_" + pixelRatioString + "/" +\n              aGoodImageName + "-*\\n"\n      # someone could get rid of the pixelRatio directories\n      # that don\'t apply to him/her (say, to save space)\n      # so make sure you create it if it doesn\'t exist.\n      renamerScript += "mkdir -p " + "../Fizzygum-tests/tests/" + filenameForScript + "/automation-assets/" +\n              systemInfo.os.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.osVersion.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.browser.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.browserVersion.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              "devicePixelRatio_" + pixelRatioString + "\\n"\n      renamerScript += "cp " + (failedImage).imageName + "-* ../Fizzygum-tests/tests/" + filenameForScript + "/automation-assets/" +\n              systemInfo.os.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.osVersion.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.browser.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.browserVersion.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              "devicePixelRatio_" + pixelRatioString + "/\\n\\n"\n\n\n      setOfGoodImages = AutomatorRecorderAndPlayer.loadedImages[aGoodImageName]\n      diffNumber = 0\n      for eachGoodImage in setOfGoodImages\n        diffNumber++\n        # note the asynchronous operation here - this is because\n        # the subtractScreenshots needs to create some Images and\n        # load them with data from base64 string. The operation\n        # of loading the data is asynchronous...\n        @subtractScreenshots failedImage, eachGoodImage, diffNumber, (subtractionCanvas, failedImage, errorRatio, diffNumber) ->\n          console.log "zipping diff file:" + "diff-"+failedImage.imageName+".png"\n          zip.file(\n            "diff-"+\n            failedImage.imageName +\n            "-error-" +\n            errorRatio+\n            "-diffNumber-"+\n            diffNumber+\n            ".png"\n          , subtractionCanvas.toDataURL().replace(/^data:image\\/png;base64,/, ""), {base64: true})\n\n    renamerScript += "# take away all the \'obtained\' prefixes in all the files" + "\\n"\n    renamerScript += "find ../Fizzygum-tests/tests/ -name \'obtained-*\' -type f -exec bash -c \'mv \\"$1\\" \\"${1/\\\\/obtained-//}\\"\' -- {} \\\\;" + "\\n"\n\n    zip.file "replace_all_images.sh", renamerScript\n\n    # OK the images are all put in the zip\n    # asynchronously. So, in theory what we should do is to\n    # check that we have all the image packed\n    # and then save the zip. In practice we just wait\n    # some time (200ms for each image)\n    # and then save the zip.\n    setTimeout \\\n      =>\n        console.log "saving failed screenshots"\n        if navigator.userAgent.search("Safari") >= 0 and navigator.userAgent.search("Chrome") < 0\n          # Safari can\'t save blobs nicely with a nice\n          # file name, see\n          # http://stuk.github.io/jszip/documentation/howto/write_zip.html\n          # so what this does is it saves a file "Unknown". User\n          # then has to rename it and open it.\n          location.href="data:application/zip;base64," + zip.generate({type:"base64"})\n        else\n          console.log "not safari"\n          content = zip.generate({type:"blob"})\n          saveAs(content, "SystemTest_#{@testName}_failedScreenshots.zip")        \n      , (@collectedFailureImages.length+1) * 200 \n\n\n\n  saveTest: ->\n    zip = new JSZip()\n\n    blob = @testMetadataFileContentCreator()\n    zip.file "SystemTest_#{@testName}.js", blob\n\n    blob = @automatorCommandsFileContentCreator window.world.automatorRecorderAndPlayer.automatorCommandsSequence\n    testNameExtended = @testName + "_automationCommands"\n    zip.file "SystemTest_#{testNameExtended}.js", blob\n    \n    # save all the images, each as a .png and .js file\n    # the png is for quick browsing, while the js contains\n    # the pixel data and the metadata of which configuration\n    # the picture was recorded with.\n    # (we expect the screenshots to be different across\n    # browsers and OSs)\n    for image in @collectedImages\n      image.addToZipAsJS zip\n      \n      # let\'s also save the png file so it\'s easier to browse the data\n      # note that these png files are not copied over into the\n      # build directory.\n      image.addToZipAsPNG zip\n    \n\n    if navigator.userAgent.search("Safari") >= 0 and navigator.userAgent.search("Chrome") < 0\n      # Safari can\'t save blobs nicely with a nice\n      # file name, see\n      # http://stuk.github.io/jszip/documentation/howto/write_zip.html\n      # so what this does is it saves a file "Unknown". User\n      # then has to rename it and open it.\n      console.log "safari"\n      location.href="data:application/zip;base64," + zip.generate({type:"base64"})\n    else\n      console.log "not safari"\n      content = zip.generate({type:"blob"})\n      saveAs(content, "SystemTest_#{@testName}.zip")    \n\n  loadTest: (testNumber, andThenDoThis)->\n    script = document.createElement(\'script\')\n    script.src = "js/tests/"+@testsList()[testNumber] + "_automationCommands.js"\n\n    # todo: you should be able to remove the script once it\'s loaded/executed...\n    # any implication of that? debugger still working OK finding the source code?\n    script.onload = =>\n      @loadImagesOfTest testNumber, andThenDoThis\n\n    document.head.appendChild script\n\n  loadImagesOfTest: (testNumber, andThenDoThis)->\n\n    for eachCommand in window[(@testsList()[testNumber])+ "_automationCommands"].automatorCommandsSequence\n      if eachCommand.screenShotImageName?\n        pureImageName = eachCommand.screenShotImageName\n        for eachAssetInManifest in AutomatorRecorderAndPlayer.testsAssetsManifest\n          if eachAssetInManifest.contains pureImageName\n            # todo: you should be able to remove the script once it\'s loaded/executed...\n            # any implication of that? debugger still working OK finding the source code?\n            script = document.createElement(\'script\')\n            ###\n            systemInfo = new SystemTestsSystemInfo()\n            # some devices have non-integer pixel ratios so\n            # let\'s handle the dot there.\n            pixelRatioString = (""+pixelRatio).replace(/\\.+/g, "_")\n            alert "js/tests/assets/" +\n              systemInfo.os.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.osVersion.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.browser.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              systemInfo.browserVersion.replace(/\\s+/g, "-").replace(/\\.+/g, "_") + "/" +\n              "devicePixelRatio_" + pixelRatioString + "/" +\n              eachAssetInManifest +\n              ".js"\n            ###\n            script.src = "js/tests/assets/"+ eachAssetInManifest + ".js"\n            document.head.appendChild script\n\n    setTimeout \\\n      =>\n        andThenDoThis()\n      , 1000\n\n\n  testsList: ->\n    preselectionBeforeSplittingGroups = null\n    if @selectedTestsBasedOnTags.length != 0\n      preselectionBeforeSplittingGroups = @selectedTestsBasedOnTags\n    else\n      preselectionBeforeSplittingGroups = AutomatorRecorderAndPlayer.testsManifest\n\n    console.log "tests list before partitioning and picking: " + preselectionBeforeSplittingGroups\n\n    console.log "tests list after partitioning and picking: " + preselectionBeforeSplittingGroups.chunk(Math.ceil(preselectionBeforeSplittingGroups.length / @numberOfGroups))[@groupToBeRun]\n\n    actualTestList = preselectionBeforeSplittingGroups.chunk(Math.ceil(preselectionBeforeSplittingGroups.length / @numberOfGroups))[@groupToBeRun]\n\n    return actualTestList\n\n\n  loadTestMetadata: (testNumber, andThen)->\n\n    if testNumber >= AutomatorRecorderAndPlayer.testsManifest.length\n      andThen()\n      return\n\n    script = document.createElement(\'script\')\n    script.src = "js/tests/" + AutomatorRecorderAndPlayer.testsManifest[testNumber] + ".js"\n\n    # todo: you should be able to remove the script once it\'s loaded/executed...\n    # any implication of that? debugger still working OK finding the source code?\n    script.onload = =>\n      @loadTestMetadata(testNumber+1, andThen)\n\n    document.head.appendChild script\n\n\n  loadTestsMetadata: (andThen) ->\n    @loadTestMetadata 0, andThen\n\n  loadAndRunSingleTestFromName: (testName) ->\n    testNumber = AutomatorRecorderAndPlayer.testsManifest.indexOf("SystemTest_inspectorResizingOKEvenWhenTakenApart")\n    debugger\n    @loadTestMetadata testNumber, =>\n      debugger\n      @loadTest testNumber, =>\n        debugger\n        SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole "playing test: " + testName\n        @automatorCommandsSequence = window[(testName)+ "_automationCommands"].automatorCommandsSequence\n        @startTestPlaying()\n\n\n  runNextSystemTest: ->\n    @indexOfSystemTestBeingPlayed++\n    if @indexOfSystemTestBeingPlayed >= @testsList().length\n      SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole "finished all tests"\n      world.nextStartupAction()\n      return\n    # Here we load the test dynamically,\n    # by injecting a script that loads the js files\n    # with the data. Better this than loading\n    # all the tests data at once, we might only\n    # need a few tests rather than all of them.\n    @loadTest @indexOfSystemTestBeingPlayed, =>\n      SystemTestsControlPanelUpdater.addMessageToSystemTestsConsole "playing test: " + @testsList()[@indexOfSystemTestBeingPlayed]\n      @automatorCommandsSequence = window[(@testsList()[@indexOfSystemTestBeingPlayed])+ "_automationCommands"].automatorCommandsSequence\n      @startTestPlayingWithSlideIntro()\n\n  # Select tests based on test names, or tags, or special\n  # tag "all" to select them all.\n  #\n  # Examples to try from cosole:\n  # world.automatorRecorderAndPlayer.selectTestsFromTagsOrTestNames(["shadow"]);\n  # world.automatorRecorderAndPlayer.selectTestsFromTagsOrTestNames(["bubble"]);\n  # world.automatorRecorderAndPlayer.selectTestsFromTagsOrTestNames(["shadow", "bubble"]);\n  # world.automatorRecorderAndPlayer.selectTestsFromTagsOrTestNames(["all"]);\n  # world.automatorRecorderAndPlayer.selectTestsFromTagsOrTestNames(["SystemTest_buildAllMorphs", "SystemTest_compositeMorphsHaveCorrectShadow"]);\n  # world.automatorRecorderAndPlayer.selectTestsFromTagsOrTestNames(["bubble", "SystemTest_buildAllMorphs", "SystemTest_compositeMorphsHaveCorrectShadow"]);\n\n  selectTestsFromTagsOrTestNames: (wantedTagsOrNamesArray) ->\n    console.log "selectTestsFromTagsOrTestNames"\n    # we proceed here to FIRST load all the\n    # metadata of all the tests, then\n    # we check the tags.\n\n    # First name the callback that doest the\n    # tags/names checks after the metadata\n    # of all the tests is loaded.\n    selectTheTestsBasedOnTags = \\\n      =>\n        @selectedTestsBasedOnTags = []\n        for eachTest in AutomatorRecorderAndPlayer.testsManifest\n          for eachWantedTagOrName in wantedTagsOrNamesArray\n            # special tag/name "all" matches all the tests\n            if eachWantedTagOrName == "all"\n              if (@selectedTestsBasedOnTags.indexOf eachTest) < 0\n                @selectedTestsBasedOnTags.push eachTest\n              continue\n            if eachWantedTagOrName == eachTest\n              if (@selectedTestsBasedOnTags.indexOf eachTest) < 0\n                @selectedTestsBasedOnTags.push eachTest\n              continue\n            if (window[eachTest].tags.indexOf eachWantedTagOrName) >= 0\n              if (@selectedTestsBasedOnTags.indexOf eachTest) < 0\n                @selectedTestsBasedOnTags.push eachTest\n              continue\n\n        console.log @selectedTestsBasedOnTags\n\n    # load the metadata of all the tests\n    # and pass the callback to be run\n    # when all the metadata is loaded.\n    @loadTestsMetadata(selectTheTestsBasedOnTags)\n\n\n  runAllSystemTestsForceSlow: ->\n    @forceSlowTestPlaying = true\n    @runAllSystemTests()\n\n  runAllSystemTestsForceFastSkipInbetweenMouseMoves: ->\n    @forceTurbo = true\n    @forceSkippingInBetweenMouseMoves = true\n    @runAllSystemTests()\n\n  runAllSystemTestsForceFastRunInbetweenMouseMoves: ->\n    @forceTurbo = true\n    @forceRunningInBetweenMouseMoves = true\n    @runAllSystemTests()\n\n\n  runAllSystemTests: ->\n    @failedTests = []\n    console.log "runAllSystemTests"\n    @millisOfAllTestsSoFar = 0\n\n    # we proceed here to FIRST load all the\n    # metadata of all the tests, then\n    # one by one as needed we need the automatorCommands\n    # and the assets.\n\n    # First name the callback that starts the\n    # running of the tests after the metadata\n    # of all the tests is loaded.\n    actuallyRunTheTests = \\\n      =>\n        actualTestList = @testsList()\n        @allTestsDuration = 0\n        #debugger\n        for eachTest in actualTestList\n          @allTestsDuration += window["#{eachTest}"].testDuration\n\n        @playingAllSystemTests = true\n        @indexOfSystemTestBeingPlayed = -1\n        @runNextSystemTest()\n\n    # load the metadata of all the tests\n    # and pass the callback to be run\n    # when all the metadata is loaded.\n    @loadTestsMetadata(actuallyRunTheTests)\n    console.log "Running system tests: " + @testsList()\n\n';
