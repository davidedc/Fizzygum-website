// Generated by CoffeeScript 1.10.0
window.BackBufferMixin_coffeSource = '# //////////////////////////////////////////////////////////\n\n# these comments below needed to figure out dependencies between classes\n# REQUIRES globalFunctions\n\n# A BackBuffer is a canvas that a morph can keep for\n# two reasons:\n#   1) as a cache\n#   2) because the morph has inherently a "raster" nature\n#      such as the canvas where you can run a turtle to\n#      draw stuff, or a Morph where you want to have\n#      pixel-based filters.\n#\n# The cache use is useful for morphs that ideally\n#  * have a small extent\n#  * have an expensive painting process\n#  * are repainted often\n#\n# (Note that the cache for the time being is only\n# for the very morph, not for the whole of the\n# hierarchy.)\n#\n# Ideal use of a cache is text because painting text\n# can be a lengthy operation.\n# Worst possible use of a cache is the large\n# desktop background rectangle, where a lot of memory\n# would be wasted for saving a very short painting\n# operation.\n#\n# In theory the backing store use should be transparent and\n# automatic, driven perhaps by dynamic considerations,\n# but we are not there yet.\n\nBackBufferMixin =\n  # klass properties here:\n  # none\n\n  # instance properties to follow:\n  onceAddedClassProperties: (fromClass) ->\n    @addInstanceProperties fromClass,\n\n      # note that image contains only the CURRENT morph, not the composition of this\n      # morph with all of the submorphs. I.e. for an inspector, this will only\n      # contain the background of the window pane. Not any of its contents.\n      # for the worldMorph, this only contains the background\n      backBuffer: null\n      backBufferContext: null\n\n      # just a flag to indicate that the\n      # backBufferContext value can be derived from others\n      backBufferContext_isDerivedValue: true\n\n      # as seen by the " * pixelRatio " parts in the code,\n      # this function returns actual pixels, not logical pixels.\n      # Hence, these values are only good outside of the\n      # scope of the scaling due to the pixelRatio\n      calculateKeyValues: (aContext, clippingRectangle) ->\n        area = clippingRectangle.intersect(@boundingBox()).round()\n        # test whether anything that we are going to be drawing\n        # is visible (i.e. within the clippingRectangle)\n        if area.isNotEmpty()\n          delta = @position().neg()\n          src = area.translateBy(delta).round()\n          \n          # the " * pixelRatio " multiplications\n          # tranform logical pixels into actual pixels.\n          sl = src.left() * pixelRatio\n          st = src.top() * pixelRatio\n          al = area.left() * pixelRatio\n          at = area.top() * pixelRatio\n          # @backBuffer.width and @backBuffer.height are already in\n          # physical coordinates so no need to adjust for pixelratio\n          w = Math.min(src.width() * pixelRatio, @backBuffer.width - sl)\n          h = Math.min(src.height() * pixelRatio, @backBuffer.height - st)\n        return [area,sl,st,al,at,w,h]\n\n      isTransparentAt: (aPoint) ->\n        @bounds.debugIfFloats()\n        if @boundsContainPoint aPoint\n          return false  if @texture\n          data = @getPixelColor aPoint\n          # check the 4th byte - the Alpha (RGBA)\n          return data.a is 0\n        false\n\n      # Morph pixel access:\n      getPixelColor: (aPoint) ->\n        [@backBuffer, @backBufferContext] = @createRefreshOrGetBackBuffer()\n        point = aPoint.toLocalCoordinatesOf @\n        data = @backBufferContext.getImageData point.x * pixelRatio, point.y * pixelRatio, 1, 1\n        new Color data.data[0], data.data[1], data.data[2], data.data[3]\n\n\n      # This method only paints this very morph\'s "image",\n      # it doesn\'t descend the children\n      # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n      # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n      # Note that this morph might paint something on the screen even if\n      # it\'s not a "leaf".\n      paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n        @justBeforeBeingPainted?()\n\n        if !@visibleBasedOnIsVisibleProperty() or @isCollapsed()\n          return null\n\n        [@backBuffer, @backBufferContext] = @createRefreshOrGetBackBuffer()\n\n        if !@backBuffer?\n          return null\n\n        [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n        if area.isNotEmpty()\n          if w < 1 or h < 1\n            return null\n\n          aContext.save()\n\n          aContext.globalAlpha = @alpha\n\n          aContext.drawImage @backBuffer,\n            Math.round(sl),\n            Math.round(st),\n            Math.round(w),\n            Math.round(h),\n            Math.round(al),\n            Math.round(at),\n            Math.round(w),\n            Math.round(h)\n\n          aContext.restore()\n\n          # paintHighlight is usually made to work with\n          # al, at, w, h which are actual pixels\n          # rather than logical pixels, so it\'s generally used\n          # outside the effect of the scaling because\n          # of the pixelRatio\n          @paintHighlight aContext, al, at, w, h\n';
