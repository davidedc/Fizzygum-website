// Generated by CoffeeScript 1.10.0
window.BasicCalculatedValue_coffeSource = '# just a draft, it\'s not meant to compile or work\n# just yet, we are just assembling things\n\n# REQUIRES ProfilerData\n\nclass BasicCalculatedVal extends GroundVal\n  # sometimes we know that the cached val\n  # might be out of date but we don\'t want to\n  # trigger a recalculation to actually check.\n  # This is what this flag tracks.\n  # Note that this flag has no meaning if this Val\n  # is @directlyOrIndirectlyDependsOnAParentVal, as in that case\n  # we always have to fetch the val rather than\n  # hope to have a good cached version.\n  lastCalculatedValContentMaybeOutdated: true\n  lastCalculatedValContent: undefined\n  # this is needed because during the recalculation step\n  # we don\'t want to process the notifications that\n  # we receive about our args changing, that\n  # would be messy and wasteful.\n  holdOffFromPropagatingChanges: false\n\n  # this val might be referenced by parent Morph or\n  # children Morphs dynamically so they way to find this\n  # val might be through the name as a string\n  constructor: (@valName, @functionToRecalculate, @localInputVals, parentArgsNames, childrenArgsNames, @ownerMorph) ->\n    super(@valName, null, @ownerMorph)\n\n    ProfilerData.reactiveValues_createdBasicCalculatedValues++\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      collectionOfChildrenValuesNames = ""\n      for eachName in childrenArgsNames\n        collectionOfChildrenValuesNames = collectionOfChildrenValuesNames + ", " + eachName\n      console.log "building BasicCalculatedVal named " + @valName + " in morph "+ @ownerMorph.uniqueIDString() + " depending on children variables: " + collectionOfChildrenValuesNames\n    \n    # we don\'t mark immediately this value as\n    # depending on parent, the reason is that there might be\n    # no parent morph to this one, so in some circumstances\n    # this value\'s content can actually just be treated as\n    # a normal value that doesn\'t need to automatically\n    # fetch values for some of its arguments, and which\n    # notification of changes can actually be believed.\n    # As soon as a parent Morph is added, then this doesn\'t\n    # hold true anymore - this Value stops notifying the\n    # other dependent values of changes because it doesn\'t\n    # get the changes from the parent values itself...\n    #@directlyOrIndirectlyDependsOnAParentVal = true\n\n    @args = new Args(@)\n    @args.setup_AddAllLocalArgVals @localInputVals\n    @args.setup_AddAllParentArgNames parentArgsNames\n    @args.setup_AddAllChildrenArgNames childrenArgsNames\n\n\n  # Given that this Val if a pure function depending\n  # on some args, we want to know at all times\n  # whether the args change. If the don\'t, then we\n  # know that there is no need to recalculate the present\n  # val. So this method is used by all the args\n  # of this val to notify whether they have changed\n  # or not.\n  # It\'s important to note that this method can be\n  # called for two reasons:\n  # 1) an arg has just been recalculated. Hence\n  #    we know exactly its val\n  # 2) an arg has just maybe changed because\n  #    he knows that one of HIS args has changed\n  #    but since we want to minimise recalculations we\n  #    don\'t know what the new val is, just that\n  #    maybe it has changed. \n  # There is one exception: all args\n  # that depend on a parent val (directly or indirectly)\n  # never notify anybody. This is because if a parent had\n  # to notify all the directly or indirectly connected\n  # vals, in general it could be\n  # very expensive, as for example there could be 50\n  # children to notify (and they might to notify other\n  # connected vals). What happens instead is that when\n  # this val is calculated, all args that depend on\n  # a parent (directly or indirectly) are\n  # always re-fetched, we just\n  # can\'t trust them to have notified us of their change...\n  # this method never triggers a recalculation!\n  # we could receive this because\n  #   - a recalculation has happened down the line\n  #     and we know the actual val of the\n  #     changed arg\n  #   - some invalidation has happened down the line\n  #     and hence the arg *might* have changed\n  #     but we don\'t know the actual val.\n  # We just need to keep track of which args might\n  # need recalculation and which ones are surely the\n  # same as the version we used for our last calculation.\n  #argMightHaveChanged: (changedArgVal) ->\n  #\n  #  if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n  #    console.log "marking argument " + changedArgVal.valName + " connected to morph " + changedArgVal.ownerMorph.uniqueIDString() + " as \\"might have changed\\" "\n  #\n  #  changedArg = @args.argById[changedArgVal.id]\n  #  if changedArg.markedForRemoval or @holdOffFromPropagatingChanges then return\n  #  changedArg.checkBasedOnSignature()\n  #  if !@directlyOrIndirectlyDependsOnAParentVal\n  #    @checkAndPropagateChangeBasedOnArgChange()\n\n\n\n  propagateChangeOfThisValIfNeeded: (newValContent) ->\n    debugger\n    if newValContent.signature == @lastCalculatedValContent.signature\n      @heal()\n    else # newValContent.signature != @lastCalculatedValContent.signature\n      if @lastCalculatedValContentMaybeOutdated == false\n        notifyDependentParentOrLocalValsOfPotentialChange()\n        # note that @lastCalculatedValContentMaybeOutdated\n        # remains false because we are sure of this value\n        # as we just calculated\n\n  # this method is called either by the user/system\n  # because it\'s time to get the val, or it\'s\n  # called by another val which is being asked to\n  # return its val recursively.\n  # this method could trigger a recalculation of some\n  # args, and of this val itself (obviously\n  # this whole apparatus is to minimise recalculations).\n  # Even if this\n  # particular function *might* be cheap to compute,\n  # the "dirty" parameters of its input might not be cheap\n  # to calculate.\n  # fetchVal is an apt name because it doesn\'t necessarily\n  # recalculate the val (although it might need to) and it\n  # doesn\'t just look it up either. It\'s some sort of retrieval.\n  fetchVal: ->\n    if @lastCalculatedValContentMaybeOutdated is false\n      return @lastCalculatedValContent\n    \n    oneOrMoreArgsHaveActuallyChanged = false\n    oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged or @args.fetchAllArgsDirectlyOrIndirectlyCalculatedFromParent()\n    oneOrMoreArgsHaveActuallyChanged = oneOrMoreArgsHaveActuallyChanged or @args.fetchAllRemainingArgsNeedingRecalculation()\n\n    if oneOrMoreArgsHaveActuallyChanged      \n      # functionToRecalculate must always return\n      # an object with a calculated default signature\n      # in the .signature property\n      newValContent =\n        @functionToRecalculate \\\n          @args.argById,\n          @args.localArgByName,\n          @args.parentArgByName,\n          @args.childrenArgByName,\n          @args.childrenArgByNameCount\n\n      @signature = newValContent.signature\n      @lastCalculatedValContent = newValContent\n      if !@directlyOrIndirectlyDependsOnAParentVal\n        @propagateChangeOfThisValIfNeeded newValContent\n    return @lastCalculatedValContent\n      \n    \n\n';
