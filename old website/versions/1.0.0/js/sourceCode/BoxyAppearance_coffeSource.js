// Generated by CoffeeScript 1.10.0
window.BoxyAppearance_coffeSource = '# BoxyAppearance //////////////////////////////////////////////////////////////\n\nclass BoxyAppearance extends Appearance\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  getCornerRadius: ->\n    if @morph.cornerRadius?\n      return @morph.cornerRadius\n    else\n      return 4\n\n  constructor: (morph) ->\n    super morph\n\n  isTransparentAt: (aPoint) ->\n    # first quickly check if the point is even\n    # within the bounding box\n    if !@morph.boundsContainPoint aPoint\n      return true\n \n    thisMorphPosition = @morph.position()\n    radius = Math.max @getCornerRadius(), 0\n \n    relativePoint = new Point aPoint.x - thisMorphPosition.x, aPoint.y - thisMorphPosition.y\n\n    # top left corner\n    if relativePoint.x < radius and relativePoint.y < radius\n      if relativePoint.distanceTo(new Point radius,radius) > radius\n        return true\n\n    # top right corner\n    else if relativePoint.x > @morph.width() - radius and relativePoint.y < radius\n      if relativePoint.distanceTo(new Point @morph.width() - radius,radius) > radius\n        return true\n\n    # bottom left corner\n    else if relativePoint.x < radius and relativePoint.y > @morph.height() - radius\n      if relativePoint.distanceTo(new Point radius, @morph.height() - radius) > radius\n        return true\n\n    # bottom right corner\n    else if relativePoint.x > @morph.width() - radius and relativePoint.y > @morph.height() - radius\n      if relativePoint.distanceTo(new Point @morph.width() - radius, @morph.height() - radius) > radius\n        return true\n\n\n    return false\n  \n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if @morph.preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = @morph.alpha\n\n      aContext.scale pixelRatio, pixelRatio\n      morphPosition = @morph.position()\n      aContext.translate morphPosition.x, morphPosition.y\n      aContext.fillStyle = @morph.color.toString()\n      \n      aContext.beginPath()\n      @outlinePath aContext, Math.max @getCornerRadius(), 0\n      aContext.closePath()\n      aContext.fill()\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio (i.e. after the restore)\n      @paintHighlight aContext, al, at, w, h\n\n  \n  outlinePath: (context, radius) ->\n    offset = radius\n    w = @morph.width()\n    h = @morph.height()\n    # top left:\n    context.arc offset, offset, radius, degreesToRadians(-180), degreesToRadians(-90), false\n    # top right:\n    context.arc w - offset, offset, radius, degreesToRadians(-90), degreesToRadians(-0), false\n    # bottom right:\n    context.arc w - offset, h - offset, radius, degreesToRadians(0), degreesToRadians(90), false\n    # bottom left:\n    context.arc offset, h - offset, radius, degreesToRadians(90), degreesToRadians(180), false\n\n  cornerRadiusPopout: (menuItem)->\n    @morph.prompt menuItem.parent.title + "\\ncorner\\nradius:",\n      @morph,\n      "setCornerRadius",\n      @morph.cornerRadius.toString(),\n      null,\n      0,\n      100,\n      true\n  \n  # Boxy menus:\n  addShapeSpecificMenus: (menu) ->\n    menu.addLine()\n    menu.addItem "corner radius...", true, @, "cornerRadiusPopout", "set the corner\'s\\nradius"\n    menu.addItem "pick inset...", true, @morph, "pickInset", "put a morph as inset"\n    menu\n  \n  addShapeSpecificNumericalSetters: (list) ->\n    list.push "setCornerRadius"\n    list\n';
