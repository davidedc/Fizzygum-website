// Generated by CoffeeScript 1.10.0
window.CodeCompiler_coffeSource = '###\n## CodeCompiler makes available the user sketch\n## (written in simplified syntax) as a runnable javascript function.\n## Also note that CodeCompiler might return a program\n## that substituted the program passed as input.\n## This is because doOnce statements get transformed by pre-prending a\n## tick once they are run, which prevents them from being run again.\n## Note that CodeCompiler doesn\'t run the user sketch, it just\n## makes it available to the ProgramRunner.\n###\n\nclass CodeCompiler\n  currentCodeString: null\n  codePreprocessor: null\n  lastCorrectOutput: null\n\n  whitespaceCheck: /^\\s*$/\n\n  constructor: (@eventRouter) ->\n    # the code compiler needs the CodePreprocessor\n    \n    @codePreprocessor = new CodePreprocessor()\n    #@codePreprocessor = new CodePreprocessor()\n\n\n  compileCode: (code) ->\n\n    @currentCodeString = code\n\n    output = {}\n\n    # we do a couple of special resets when\n    # the code is the empty string.\n    if @whitespaceCheck.test(code)\n      output.status = \'empty\'\n      return output\n\n    [code, error] = @codePreprocessor.preprocessAndBindFunctionsToThis code\n\n    # if \'error\' is anything else then undefined then it\n    # means that the process of translation has found\n    # some glaringly missing pieces. In which case,\n    # we report the error and skip the coffeescript\n    # to javascript translation step.\n    if error?\n      output.status = \'error\'\n      output.error = error\n      return output\n\n    try\n      compiledOutput = CoffeeScript.compile(code,\n        bare: "on"\n      )\n    catch e\n      # coffescript compiler has caught a syntax error.\n      output.status = \'error\'\n      output.error = e\n      return output\n\n    # You might want to change the frame count from the program\n    # just like you can in Processing, but it turns out that when\n    # you ASSIGN a value to the frame variable inside\n    # the coffeescript code, the coffeescript to javascript translator\n    # declares a *local* frame variable, so changes to the frame\n    # count get lost from one frame to the next.\n    # TODO: There must be a way to tell coffeescript to accept\n    # some variables as global, for the time being let\'s put\n    # the cheap hack in place i.e. remove any local declaration that the\n    # coffeescript to javascript translator inserts.\n    compiledOutput = compiledOutput.replace(/var frame/, ";")\n\n    # elegant way to not use eval\n    functionFromCompiledCode = new Function(compiledOutput)\n\n    output.status = \'parsed\'\n    output.program = functionFromCompiledCode\n    @lastCorrectOutput = output\n\n    return output\n\n  # this function is used externally after the code has been\n  # run, so we need to attach it to the CodeCompiler object.\n  addCheckMarksAndUpdateCodeAndNotifyChange: \\\n      (CodeCompiler, doOnceOccurrencesLineNumbers) ->\n    elaboratedSource = undefined\n    elaboratedSourceByLine = undefined\n    drawFunction = undefined\n    \n    # if we are here, the following has happened: someone has added an element\n    # to the doOnceOccurrencesLineNumbers array. This can only have happened\n    # when a doOnce block is run, because we manipulate each doOnce block\n    # so that in its first line the line number of the block is pushed into\n    # the doOnceOccurrencesLineNumbers array.\n    # So, the doOnceOccurrencesLineNumbers array contains all and only the lines\n    # of each doOnce block that has been run. Which could be more than one,\n    # because when we start the program we could have more than one\n    # doOnce that has to run.\n    elaboratedSource = @currentCodeString\n    \n    # we know the line number of each doOnce block that has been run\n    # so we go there and add a tick next to each doOnce to indicate\n    # that it has been run.\n    elaboratedSourceByLine = elaboratedSource.split("\\n")\n    for eachLine in doOnceOccurrencesLineNumbers\n      elaboratedSourceByLine[eachLine] =\n        elaboratedSourceByLine[eachLine].replace(\n          /(^|\\s+)doOnce([ \\t]*.*)$/gm, "$1âœ“doOnce$2")\n    elaboratedSource = elaboratedSourceByLine.join("\\n")\n    \n    # puts the new code (where the doOnce that have been executed have\n    # tickboxes put back) in the editor. Which will trigger a re-registration\n    # of the new code.\n    @eventRouter.emit("code-updated-by-livecodelab", elaboratedSource)\n    #alert elaboratedSource\n    \n    # no need to recompile the code here\n    # because it\'s already recompiled with the "emit" done just\n    # above. The editor update triggers an updateCode and a\n    # compileCode. So no need to do anything here, just\n    # return the output program produced by the last compilation\n    # cause it\'s up to date.\n    return @lastCorrectOutput.program\n\n';
