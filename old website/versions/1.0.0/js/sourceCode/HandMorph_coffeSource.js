// Generated by CoffeeScript 1.10.0
window.HandMorph_coffeSource = '# HandMorph ///////////////////////////////////////////////////////////\n\n# The mouse cursor. Note that it\'s not a child of the WorldMorph, this Morph\n# is never added to any other morph. [TODO] Find out why and write explanation.\n# Not to be confused with the HandleMorph\n\nclass HandMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  world: null\n  mouseButton: null\n  # used for example to check that\n  # mouseDown and mouseUp happen on the\n  # same Morph (otherwise clicks happen for\n  # example when resizing a button via the\n  # handle)\n  mouseDownMorph: null\n  mouseDownPosition: null\n  morphToGrab: null\n  grabOrigin: null\n  mouseOverList: null\n  temporaries: null\n  touchHoldTimeout: null\n  doubleClickMorph: null\n  tripleClickMorph: null\n  nonFloatDraggedMorph: null\n  nonFloatDragPositionWithinMorphAtStart: null\n  # this is useful during nonFloatDrags to pass the morph\n  # the delta position since the last invokation\n  previousNonFloatDraggingPos: null\n\n  constructor: (@world) ->\n    @mouseOverList = []\n    @temporaries = []\n    super()\n    @minimumExtent = new Point 0,0\n    @silentRawSetBounds Rectangle.EMPTY\n\n  clippedThroughBounds: ->\n    @checkClippedThroughBoundsCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    @clippedThroughBoundsCache = @boundingBox()\n    return @clippedThroughBoundsCache\n\n  clipThrough: ->\n    @checkClipThroughCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    @clipThroughCache = @boundingBox()\n    return @clipThroughCache\n  \n  # HandMorph navigation:\n  topMorphUnderPointer: ->\n    result = @world.topMorphSuchThat (m) =>\n      m.clippedThroughBounds().containsPoint(@position()) and\n        m.visibleBasedOnIsVisibleProperty() and\n        !m.isCollapsed() and\n        (m.noticesTransparentClick or (not m.isTransparentAt(@position()))) and\n        (m not instanceof ShadowMorph) and\n        # we exclude the Caret here because\n        #  a) it messes up things on double-click as it appears under\n        #     the mouse after the first clicks\n        #  b) the caret disappears as soon as a menu appears, so it\n        #     would be confusing to select a caret.\n        # I drafted an alternative implementation where we manage\n        # those situations without being radical in this filtering-out\n        # but it was quite a bit more complicated.\n        (m not instanceof CaretMorph) and\n        # exclude morphs we use for highlighting\n        # other morphs\n        !m.morphThisMorphIsHighlighting? and\n        !m.morphThisMorphIsPinouting?\n    if result?\n      return result\n    else\n      return @world\n\n  menuAtPointer: ->\n    result = @world.topMorphSuchThat (m) =>\n      m.clippedThroughBounds().containsPoint(@position()) and\n        m.visibleBasedOnIsVisibleProperty() and\n        !m.isCollapsed() and\n        (m.noticesTransparentClick or\n        (not m.isTransparentAt(@position()))) and (m instanceof MenuMorph)\n    return result\n\n\n\n  openContextMenuAtPointer: (morphTheMenuIsAbout) ->\n    # note that the morphs that the menu\n    # belongs to might not be under the mouse.\n    # It usually is, but in cases\n    # where a system test is playing against\n    # a world setup that has varied since the\n    # recording, this could be the case.\n\n    # these three are checks and actions that normally\n    # would happen on MouseDown event, but we\n    # removed that event as we collapsed the down and up\n    # into this coalesced higher-level event,\n    # but we still need to make these checks and actions\n    @destroyTemporaryHandlesAndLayoutAdjustersIfHandHasNotActionedThem morphTheMenuIsAbout\n    @stopEditingIfActionIsElsewhere morphTheMenuIsAbout\n\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      fade \'rightMouseButtonIndicator\', 0, 1, 10, new Date().getTime()\n      setTimeout \\\n        =>\n          fade \'rightMouseButtonIndicator\', 1, 0, 500, new Date().getTime()\n        , 100\n    \n    contextMenu = morphTheMenuIsAbout.contextMenu()\n    while !contextMenu and morphTheMenuIsAbout.parent\n      morphTheMenuIsAbout = morphTheMenuIsAbout.parent\n      contextMenu = morphTheMenuIsAbout.contextMenu()\n\n    if contextMenu \n      contextMenu.popUpAtHand morphTheMenuIsAbout.firstContainerMenu()\n\n\n  # not used in ZK yet\n  allMorphsAtPointer: ->\n    return @world.collectAllChildrenBottomToTopSuchThat (m) =>\n      m.visibleBasedOnIsVisibleProperty() and\n      !m.isCollapsed() and\n      m.clippedThroughBounds().containsPoint @position()\n  \n  \n  \n  # HandMorph floatDragging and dropping:\n  #\n  # floatDrag \'n\' drop events, method(arg) -> receiver:\n  #\n  #   prepareToBeGrabbed(handMorph) -> grabTarget\n  #   reactToGrabOf(grabbedMorph) -> oldParent\n  #   wantsDropOf(morphToDrop) ->  newParent\n  #   justDropped(handMorph) -> droppedMorph\n  #   reactToDropOf(droppedMorph, handMorph) -> newParent\n  #\n  dropTargetFor: (aMorph) ->\n    target = @topMorphUnderPointer()\n    until target.wantsDropOf aMorph\n      target = target.parent\n    target\n  \n  grab: (aMorph, displacementDueToGrabDragThreshold) ->\n    return null  if aMorph instanceof WorldMorph\n    oldParent = aMorph.parent\n    if !@floatDraggingSomething()\n\n      @world.automatorRecorderAndPlayer.addGrabCommand()\n      if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n        action = "grab"\n        arr = window.world.automatorRecorderAndPlayer.tagsCollectedWhileRecordingTest\n        if action not in arr\n          arr.push action\n\n\n      @world.stopEditing()\n      if displacementDueToGrabDragThreshold?\n        aMorph.fullMoveTo aMorph.position().add displacementDueToGrabDragThreshold\n      @grabOrigin = aMorph.situation()\n      aMorph.prepareToBeGrabbed? @\n      @add aMorph\n      # you must add the shadow\n      # after the morph has been added\n      # because "@add aMorph" causes\n      # the morph to be painted potentially\n      # for the first time.\n      # The shadow needs the image of the\n      # morph to make the shadow, so\n      # this is why we add the shadow after\n      # the morph has been added.\n      # Note that Morphs can specify the look\n      # (i.e. offset blur and color)\n      # of their shadow (e.g. Menus have a particular one\n      # so they all seem to float at a particular height)\n      # but here when we grab morphs we\n      # specify a particular look for the shadow.\n      # This is a particularly "floaty" shadow\n      # which illustrates how things being dragged\n      # are above anything else.\n      aMorph.addFullShadow new Point(7, 7), 0.2\n      \n      #debugger\n      @fullChanged()\n      # this gives an occasion to the old parent\n      # morph to adjust itself e.g. the scrollmorph\n      # readjusts itself if you take some morphs\n      # out of it.\n      oldParent.reactToGrabOf aMorph  if oldParent and oldParent.reactToGrabOf\n\n  floatDraggingSomething: ->\n    if @children.length > 0 then true else false\n\n  nonFloatDraggingSomething: ->\n    return @nonFloatDraggedMorph?\n\n\n  drop: ->\n    if @floatDraggingSomething()\n\n      @world.automatorRecorderAndPlayer.addDropCommand()\n      if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n        action = "drop"\n        arr = window.world.automatorRecorderAndPlayer.tagsCollectedWhileRecordingTest\n        if action not in arr\n          arr.push action\n\n      morphToDrop = @children[0]\n      target = @dropTargetFor morphToDrop\n      @fullChanged()\n      target.add morphToDrop\n      morphToDrop.fullChanged()\n\n      @children = []\n      @rawSetExtent new Point()\n      morphToDrop.justDropped? @\n      if target.reactToDropOf\n        target.reactToDropOf morphToDrop, @\n    #else\n    #  alert "if you never see this alert then you can delete the test"\n  \n  # HandMorph event dispatching:\n  #\n  #    mouse events:\n  #\n  #   mouseDownLeft\n  #   mouseDownRight\n  #   mouseClickLeft\n  #   mouseClickRight\n  #   mouseDoubleClick\n  #   mouseEnter\n  #   mouseLeave\n  #   mouseEnterfloatDragging\n  #   mouseLeavefloatDragging\n  #   mouseMove\n  #   mouseScroll\n  #\n  # Note that some handlers don\'t want the event but the\n  # interesting parameters of the event. This is because\n  # the testing harness only stores the interesting parameters\n  # rather than a multifaceted and sometimes browser-specific\n  # event object.\n\n  destroyTemporaryHandlesAndLayoutAdjustersIfHandHasNotActionedThem: (actionedMorph) ->\n    if @world.temporaryHandlesAndLayoutAdjusters.length > 0\n      if actionedMorph not in @world.temporaryHandlesAndLayoutAdjusters\n        for eachTemporaryHandlesAndLayoutAdjusters in @world.temporaryHandlesAndLayoutAdjusters\n          eachTemporaryHandlesAndLayoutAdjusters.destroy()\n        @world.temporaryHandlesAndLayoutAdjusters = []\n\n  stopEditingIfActionIsElsewhere: (actionedMorph) ->\n    if @world.caret?\n      # there is a caret on the screen\n      # depending on what the user is clicking on,\n      # we might need to close an ongoing edit\n      # operation, which means deleting the\n      # caret and un-selecting anything that was selected.\n      # Note that we don\'t want to interrupt an edit\n      # if the user is invoking/clicking on anything\n      # inside a menu, because the invoked function\n      # might do something with the selection\n      # (for example doSelection takes the current selection).\n      if actionedMorph isnt @world.caret.target\n        # user clicked on something other than what the\n        # caret is attached to\n        mostRecentlyCreatedMenu = world.mostRecentlyCreatedMenu()\n        if mostRecentlyCreatedMenu?\n          unless mostRecentlyCreatedMenu.isAncestorOf actionedMorph\n            # only dismiss editing if the actionedMorph the user\n            # clicked on is not part of a menu.\n            @world.stopEditing()\n        # there is no menu at all, in which case\n        # we know there was an editing operation going\n        # on that we need to stop\n        else\n          @world.stopEditing()\n\n  pointerPositionFractionalInMorph: (theMorph) ->\n    [relativeXPos, relativeYPos] = @pointerPositionPixelsInMorph theMorph\n    fractionalXPos = relativeXPos / theMorph.width()\n    fractionalYPos = relativeYPos / theMorph.height()\n    return [fractionalXPos, fractionalYPos]\n\n  pointerPositionPixelsInMorph: (theMorph) ->\n    relativePos = @position().toLocalCoordinatesOf theMorph\n    return [relativePos.x, relativePos.y]\n\n  processMouseDown: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    @destroyTemporaries()\n    @morphToGrab = null\n\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      if button is 2 or ctrlKey\n        fade \'rightMouseButtonIndicator\', 0, 1, 10, new Date().getTime()\n      else\n        fade \'leftMouseButtonIndicator\', 0, 1, 10, new Date().getTime()\n\n\n    @mouseDownPosition = @position()\n\n    # check whether we are in the middle\n    # of a floatDrag/drop operation\n    if @floatDraggingSomething()\n      @drop()\n      @mouseButton = null\n    else\n      morph = @topMorphUnderPointer()\n\n      @destroyTemporaryHandlesAndLayoutAdjustersIfHandHasNotActionedThem morph\n      @stopEditingIfActionIsElsewhere morph\n\n      @morphToGrab = morph.rootForGrab()\n      if button is 2 or ctrlKey\n        @mouseButton = "right"\n        actualClick = "mouseDownRight"\n        expectedClick = "mouseClickRight"\n      else\n        @mouseButton = "left"\n        actualClick = "mouseDownLeft"\n        expectedClick = "mouseClickLeft"\n\n      @mouseDownMorph = morph\n      @mouseDownMorph = @mouseDownMorph.parent  until @mouseDownMorph[expectedClick]\n\n      \n      while !morph[actualClick]?\n        if morph.parent?\n          morph = morph.parent\n        else\n          break\n\n      if morph[actualClick]?\n        morph[actualClick] @position()\n      #morph = morph.parent  until morph[actualClick]\n      #morph[actualClick] @position()\n  \n  # touch events, see:\n  # https://developer.apple.com/library/safari/documentation/appleapplications/reference/safariwebcontent/HandlingEvents/HandlingEvents.html\n  # A long touch emulates a right click. This is done via\n  # setting a timer 400ms after the touch which triggers\n  # a right mouse click. Any touch event before then just\n  # resets the timer, so one has to hold the finger in\n  # position for the right click to happen.\n  processTouchStart: (event) ->\n    event.preventDefault()\n    WorldMorph.preferencesAndSettings.isTouchDevice = true\n    clearInterval @touchHoldTimeout\n    if event.touches.length is 1\n      # simulate mouseRightClick\n      @touchHoldTimeout = setInterval(=>\n        @processMouseDown 2 # button 2 is the right one\n        @processMouseUp 2 # button 2 is the right one, we don\'t use this parameter\n        event.preventDefault() # I don\'t think that this is needed\n        clearInterval @touchHoldTimeout\n      , 400)\n      @processMouseMove event.touches[0].pageX, event.touches[0].pageY # update my position\n      @processMouseDown 0 # button zero is the left button\n  \n  processTouchMove: (event) ->\n    # Prevent scrolling on this element\n    event.preventDefault()\n\n    if event.touches.length is 1\n      touch = event.touches[0]\n      @processMouseMove touch.pageX, touch.pageY\n      clearInterval @touchHoldTimeout\n  \n  processTouchEnd: (event) ->\n    # note that the mouse down event handler\n    # that is calling this method has ALREADY\n    # added a mousedown command\n\n    WorldMorph.preferencesAndSettings.isTouchDevice = true\n    clearInterval @touchHoldTimeout\n    @processMouseUp 0 # button zero is the left button, we don\'t use this parameter\n  \n   # note that the button param is not used,\n   # but adding it for consistency...\n  processMouseUp: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      if button is 2\n        fade \'rightMouseButtonIndicator\', 1, 0, 500, new Date().getTime()\n      else\n        fade \'leftMouseButtonIndicator\', 1, 0, 500, new Date().getTime()\n\n    morph = @topMorphUnderPointer()\n\n    alreadyRecordedLeftOrRightClickOnMenuItem = false\n    @destroyTemporaries()\n    world.freshlyCreatedMenus = []\n\n    @nonFloatDraggedMorph = null\n\n    if @floatDraggingSomething()\n      @drop()\n    else\n      @previousNonFloatDraggingPos = null\n      # let\'s check if the user clicked on a menu item,\n      # in which case we add a special dedicated command\n      # [TODO] you need to do some of this only if you\n      # are recording a test, it\'s worth saving\n      # these steps...\n      #debugger\n      ignored = null\n      toDestructure = morph.parentThatIsA MenuItemMorph\n      if toDestructure?\n        [menuItemMorph, ignored]= toDestructure\n        if menuItemMorph\n          # we check whether the menuitem is actually part\n          # of an activeMenu. Keep in mind you could have\n          # detached a menuItem and placed it on any other\n          # morph so you need to ascertain that you\'ll\n          # find it in the activeMenu later on...\n          mostRecentlyCreatedMenu = world.mostRecentlyCreatedMenu()\n          if mostRecentlyCreatedMenu == menuItemMorph.parent\n            labelString = menuItemMorph.labelString\n            occurrenceNumber = menuItemMorph.howManySiblingsBeforeMeSuchThat (m) ->\n              m.labelString == labelString\n            # this method below is also going to remove\n            # the mouse down/up commands that have\n            # recently/just been added.\n            @world.automatorRecorderAndPlayer.addCommandLeftOrRightClickOnMenuItem(@mouseButton, labelString, occurrenceNumber + 1)\n            alreadyRecordedLeftOrRightClickOnMenuItem = true\n\n      # TODO check if there is any other\n      # possibility other than mouseButton being "left"\n      # or "right". If it can only be one of those\n      # that you can simplify this nested if below\n      # and avoid using actionAlreadyProcessed\n      if @mouseButton is "left"\n        expectedClick = "mouseClickLeft"\n      else\n        expectedClick = "mouseClickRight"\n        if @mouseButton\n          if !alreadyRecordedLeftOrRightClickOnMenuItem\n            # this being a right click, pop\n            # up a menu as needed.\n            @world.automatorRecorderAndPlayer.addOpenContextMenuCommand morph.uniqueIDString()\n\n      # trigger the action\n      until morph[expectedClick]\n        morph = morph.parent\n        if not morph?\n          break\n      if morph?\n        if morph == @mouseDownMorph\n\n          switch expectedClick\n            when "mouseClickLeft"\n              pointerAndMorphInfo = world.getPointerAndMorphInfo()\n              world.automatorRecorderAndPlayer.addMouseClickCommand 0, null, pointerAndMorphInfo...\n              morph.mouseUpLeft? @position(), button, buttons, ctrlKey, shiftKey, altKey, metaKey\n            when "mouseClickRight"\n              pointerAndMorphInfo = world.getPointerAndMorphInfo()\n              world.automatorRecorderAndPlayer.addMouseClickCommand 2, null, pointerAndMorphInfo...\n              morph.mouseUpRight? @position(), button, buttons, ctrlKey, shiftKey, altKey, metaKey\n\n          # fire the click\n          morph[expectedClick] @position(), button, buttons, ctrlKey, shiftKey, altKey, metaKey\n          #console.log ">>> sent event " + expectedClick + " to: " + morph\n\n          # also send doubleclick if the\n          # two clicks happen on the same morph\n          doubleClickInvoked = false\n\n          if @doubleClickMorph?\n            if @doubleClickMorph == morph\n              @doubleClickMorph = null\n              disableConsecutiveClicksFromSingleClicksDueToFastTests = false\n              if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n                if !window.world.automatorRecorderAndPlayer.runningInSlowMode()\n                  disableConsecutiveClicksFromSingleClicksDueToFastTests = true\n              if !disableConsecutiveClicksFromSingleClicksDueToFastTests\n                @processDoubleClick morph\n                doubleClickInvoked = true\n                # triple-click detection starts here, it\'s just\n                # like chaining a second double-click detection\n                # once this double-click has just been detected\n                # right here.\n                @rememberTripleClickMorphsForAWhile morph\n            else\n              @rememberDoubleClickMorphsForAWhile morph\n          else\n            @rememberDoubleClickMorphsForAWhile morph\n\n          # also send tripleclick if the\n          # three clicks happen on the same morph\n          # Don\'t do anything if a double-click has\n          # just been invoked because you\'d immediately\n          # fire a tripleClick\n          # This pargraph of code is basically the same\n          # as the previous one.\n          if !doubleClickInvoked\n            if @tripleClickMorph?\n              #debugger\n              if @tripleClickMorph == morph\n                @tripleClickMorph = null\n                disableConsecutiveClicksFromSingleClicksDueToFastTests = false\n                if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n                  if !window.world.automatorRecorderAndPlayer.runningInSlowMode()\n                    disableConsecutiveClicksFromSingleClicksDueToFastTests = true\n                if !disableConsecutiveClicksFromSingleClicksDueToFastTests\n                  @processTripleClick morph\n              else\n                @rememberTripleClickMorphsForAWhile morph\n            else\n              @rememberTripleClickMorphsForAWhile morph\n\n      @cleanupMenuMorphs expectedClick, morph\n    @mouseButton = null\n\n  rememberDoubleClickMorphsForAWhile: (morph) ->\n    @doubleClickMorph = morph\n    setTimeout (=>\n      if @doubleClickMorph?\n        console.log "single click"\n      @doubleClickMorph = null\n      return false\n    ), 300\n\n  # basically the same as rememberDoubleClickMorphsForAWhile\n  rememberTripleClickMorphsForAWhile: (morph) ->\n    @tripleClickMorph = morph\n    setTimeout (=>\n      if @tripleClickMorph?\n        console.log "not a triple click, just a double click"\n      @tripleClickMorph = null\n      return false\n    ), 500\n\n  cleanupMenuMorphs: (expectedClick, morph)->\n\n    world.hierarchyOfClickedMorphs = []\n\n    # not that all the actions due to the clicked\n    # morphs have been performed, now we can destroy\n    # morphs queued up for destruction\n    # which might include menus...\n    # if we destroyed menus earlier, the\n    # actions that come from the click\n    # might be mangled, e.g. adding a menu\n    # to a destroyed menu, etc.\n    world.destroyMorphsMarkedForDestruction()\n\n    # remove menus that have requested\n    # to be removed when a click happens outside\n    # of their bounds OR the bounds of their\n    # children\n    #if expectedClick == "mouseClickLeft"\n    # collect all morphs up the hierarchy of\n    # the one the user clicked on.\n    # (including the one the user clicked on)\n    world.hierarchyOfClickedMorphs = [morph]\n    ascendingMorphs = morph\n    while ascendingMorphs.parent?\n      ascendingMorphs = ascendingMorphs.parent\n      world.hierarchyOfClickedMorphs.push ascendingMorphs\n    \n    # go through the morphs that wanted a notification\n    # in case there is a click outside of them or any\n    # of their children morphs.\n    # Check which ones are not in the hierarchy of the clicked morphs\n    # and call their callback.\n    console.log "morphs wanting to be notified: " + world.morphsDetectingClickOutsideMeOrAnyOfMeChildren\n    console.log "hierarchy of clicked morphs: " + world.hierarchyOfClickedMorphs\n    \n\n\n    # here we do a shallow copy of world.morphsDetectingClickOutsideMeOrAnyOfMeChildren\n    # because we might remove elements of the array while we\n    # iterate on it (as we destroy menus that want to be destroyed\n    # when the user clicks outside of them or their children)\n    # so we need to do a shallow copy to avoid to mangle the for loop\n    morphsDetectingClickOutsideMeOrAnyOfMeChildren = arrayShallowCopy world.morphsDetectingClickOutsideMeOrAnyOfMeChildren\n    for eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren in morphsDetectingClickOutsideMeOrAnyOfMeChildren\n      if eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren not in world.hierarchyOfClickedMorphs\n        # skip the freshly created menus as otherwise we might\n        # destroy them immediately\n        if eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren not in world.freshlyCreatedMenus\n          if eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[0]?\n            eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren[eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[0]].call eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren, eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[1], eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[2], eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[3]\n\n  processDoubleClick: (morph = @topMorphUnderPointer()) ->\n    pointerAndMorphInfo = world.getPointerAndMorphInfo morph\n    world.automatorRecorderAndPlayer.addMouseDoubleClickCommand null, pointerAndMorphInfo...\n\n    @destroyTemporaries()\n    if @floatDraggingSomething()\n      @drop()\n    else\n      morph = morph.parent  while morph and not morph.mouseDoubleClick\n      morph.mouseDoubleClick @position() if morph\n    @mouseButton = null\n\n  processTripleClick: (morph = @topMorphUnderPointer()) ->\n    pointerAndMorphInfo = world.getPointerAndMorphInfo morph\n    world.automatorRecorderAndPlayer.addMouseTripleClickCommand null, pointerAndMorphInfo...\n\n    @destroyTemporaries()\n    if @floatDraggingSomething()\n      @drop()\n    else\n      morph = morph.parent  while morph and not morph.mouseTripleClick\n      morph.mouseTripleClick @position() if morph\n    @mouseButton = null\n  \n  processMouseScroll: (event) ->\n    morph = @topMorphUnderPointer()\n    morph = morph.parent  while morph and not morph.mouseScroll\n\n    morph.mouseScroll (event.detail / -3) or ((if Object::hasOwnProperty.call(event,\'wheelDeltaY\') then event.wheelDeltaY / 120 else event.wheelDelta / 120)), event.wheelDeltaX / 120 or 0  if morph\n  \n  \n  #\n  # drop event:\n  #\n  #        droppedImage\n  #        droppedSVG\n  #        droppedAudio\n  #        droppedText\n  #\n  processDrop: (event) ->\n    #\n    #    find out whether an external image or audio file was dropped\n    #    onto the world canvas, turn it into an offscreen canvas or audio\n    #    element and dispatch the\n    #    \n    #        droppedImage(canvas, name)\n    #        droppedSVG(image, name)\n    #        droppedAudio(audio, name)\n    #    \n    #    events to interested Morphs at the mouse pointer\n    #    if none of the above content types can be determined, the file contents\n    #    is dispatched as an ArrayBuffer to interested Morphs:\n    #\n    #    ```droppedBinary(anArrayBuffer, name)```\n\n    files = (if event instanceof FileList then event else (event.target.files || event.dataTransfer.files))\n    url = (if event.dataTransfer then event.dataTransfer.getData("URL") else null)\n    txt = (if event.dataTransfer then event.dataTransfer.getData("Text/HTML") else null)\n    targetDrop = @topMorphUnderPointer()\n    img = new Image()\n\n    readSVG = (aFile) ->\n      pic = new Image()\n      frd = new FileReader()\n      target = target.parent  until target.droppedSVG\n      pic.onload = ->\n        target.droppedSVG pic, aFile.name\n      frd = new FileReader()\n      frd.onloadend = (e) ->\n        pic.src = e.target.result\n      frd.readAsDataURL aFile\n\n    readImage = (aFile) ->\n      pic = new Image()\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedImage\n      pic.onload = ->\n        canvas = newCanvas new Point pic.width, pic.height\n        canvas.getContext("2d").drawImage pic, 0, 0\n        targetDrop.droppedImage canvas, aFile.name\n\n      frd = new FileReader()\n      frd.onloadend = (e) ->\n        pic.src = e.target.result\n\n      frd.readAsDataURL aFile\n\n    readAudio = (aFile) ->\n      snd = new Audio()\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedAudio\n      frd.onloadend = (e) ->\n        snd.src = e.target.result\n        targetDrop.droppedAudio snd, aFile.name\n      frd.readAsDataURL aFile\n    \n    readText = (aFile) ->\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedText\n      frd.onloadend = (e) ->\n        targetDrop.droppedText e.target.result, aFile.name\n      frd.readAsText aFile\n\n\n    readBinary = (aFile) ->\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedBinary\n      frd.onloadend = (e) ->\n        targetDrop.droppedBinary e.target.result, aFile.name\n      frd.readAsArrayBuffer aFile\n\n    parseImgURL = (html) ->\n      url = ""\n      start = html.indexOf "<img src=\\""\n      return null  if start is -1\n      start += 10\n      for i in [start...html.length]\n        c = html[i]\n        return url  if c is "\\""\n        url = url.concat c\n      null\n    \n    if files.length\n      for file in files\n        if file.type.contains("svg") && !WorldMorph.preferencesAndSettings.rasterizeSVGs\n          readSVG file\n        else if file.type.indexOf("image") is 0\n          readImage file\n        else if file.type.indexOf("audio") is 0\n          readAudio file\n        else if file.type.indexOf("text") is 0\n          readText file\n        else\n          readBinary file\n    else if url\n      if url.slice(url.lastIndexOf(".") + 1).toLowerCase() in ["gif", "png", "jpg", "jpeg", "bmp"]\n        target = target.parent  until target.droppedImage\n        img = new Image()\n        img.onload = ->\n          canvas = newCanvas new Point img.width, img.height\n          canvas.getContext("2d").drawImage img, 0, 0\n          target.droppedImage canvas\n        img.src = url\n    else if txt\n      targetDrop = targetDrop.parent  until targetDrop.droppedImage\n      img = new Image()\n      img.onload = ->\n        canvas = newCanvas new Point img.width, img.height\n        canvas.getContext("2d").drawImage img, 0, 0\n        targetDrop.droppedImage canvas\n      src = parseImgURL txt\n      img.src = src  if src\n  \n  \n  # HandMorph tools\n  destroyTemporaries: ->\n    #\n    # temporaries are just an array of morphs which will be deleted upon\n    # the next mouse click, or whenever another temporary Morph decides\n    # that it needs to remove them. The primary purpose of temporaries is\n    # to display tools tips of speech bubble help.\n    #\n    @temporaries.forEach (morph) =>\n      unless morph.isClickable and morph.boundsContainPoint @position()\n        morph = morph.destroy()\n        @temporaries.remove morph\n  \n  \n  # HandMorph floatDragging optimization\n  fullRawMoveBy: (delta) ->\n    if delta.isZero() then return\n    trackChanges.push false\n    #console.log "move 2"\n    @breakNumberOfRawMovesAndResizesCaches()\n    super delta\n    trackChanges.pop()\n    @fullChanged()\n\n  processMouseMove: (worldX, worldY, button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    #startProcessMouseMove = new Date().getTime()\n    pos = new Point worldX, worldY\n    @fullRawMoveTo pos\n\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      mousePointerIndicator = document.getElementById "mousePointerIndicator"\n      mousePointerIndicator.style.display = \'block\'\n      posInDocument = getDocumentPositionOf @world.worldCanvas\n      mousePointerIndicator.style.left = (posInDocument.x + worldX - (mousePointerIndicator.clientWidth/2)) + \'px\'\n      mousePointerIndicator.style.top = (posInDocument.y + worldY - (mousePointerIndicator.clientHeight/2)) + \'px\'\n\n    # determine the new mouse-over-list.\n    # Spacial multiplexing\n    # (search "multiplexing" for the other parts of\n    # code where this matters)\n    # There are two interpretations of what this\n    # list should be:\n    #   1) all morphs "pierced through" by the pointer\n    #   2) all morphs parents of the topmost morph under the pointer\n    # 2 is what is used in Cuis\n    \n    # commented-out implementation of 1):\n    # mouseOverNew = @allMorphsAtPointer().reverse()\n    topMorph = @topMorphUnderPointer()\n    mouseOverNew = topMorph.allParentsTopToBottom()\n\n    @determineGrabs pos, topMorph, mouseOverNew\n\n    @dispatchEventsFollowingMouseMove mouseOverNew\n\n  checkDraggingTreshold: ->\n    # UNFORTUNATELY OLD tests didn\'t take the correction into account,\n    # pointers inevitably have some "noise", so to avoid that\n    # a simple clicking (which could be done for example for\n    # selection purposes or to pick a position for a cursor)\n    # turns into a drag, so we add\n    # a grab/drag distance threshold.\n    # Note that even if the mouse moves a bit, we are still\n    # picking up the correct morph that was under the mouse when\n    # the mouse down happened.\n    # Also we correct for the initial displacement\n    # due to the threshold, so really when user starts dragging\n    # it should pick up the EXACT point where the click happened,\n    # not a "later" point once the threshold is passed.\n\n    # so we have to bypass this mechanism for those.\n    displacementDueToGrabDragThreshold = null\n    skipGrabDragThreshold = false\n    \n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      currentlyPlayingTestName = world.automatorRecorderAndPlayer.currentlyPlayingTestName\n      if !window["#{currentlyPlayingTestName}"].grabDragThreshold?\n        skipGrabDragThreshold = true\n\n    if !skipGrabDragThreshold\n      if @morphToGrab.parent != world or (!@morphToGrab.isEditable? or @morphToGrab.isEditable )\n        if (@mouseDownPosition.distanceTo @position()) < WorldMorph.preferencesAndSettings.grabDragThreshold\n          return [true,null]\n      displacementDueToGrabDragThreshold = @position().subtract @mouseDownPosition\n\n    return [false, displacementDueToGrabDragThreshold]\n\n  determineGrabs: (pos, topMorph, mouseOverNew) ->\n    if (!@nonFloatDraggingSomething()) and (!@floatDraggingSomething()) and (@mouseButton is "left")\n      morph = topMorph.rootForGrab()\n      topMorph.mouseMove pos  if topMorph.mouseMove\n\n      # if a morph is marked for grabbing, just grab it\n      if @morphToGrab\n        if @morphToGrab.isTemplate\n          [skipDragging, displacementDueToGrabDragThreshold] = @checkDraggingTreshold()\n          if skipDragging then return\n\n          morph = @morphToGrab.fullCopy()\n          morph.isTemplate = false\n          # this flag is not used anymore but not sure\n          # if anything should replace this.\n          # keeping it as a comment as a breadcrumb\n          # morph.isfloatDraggable = true\n          @grab morph, displacementDueToGrabDragThreshold\n          @grabOrigin = @morphToGrab.situation()\n\n        else if @morphToGrab.isFloatDraggable()\n          [skipDragging, displacementDueToGrabDragThreshold] = @checkDraggingTreshold()\n          if skipDragging then return\n\n          morph = @morphToGrab\n          @grab morph, displacementDueToGrabDragThreshold\n\n        else\n          # non-float drags are for things such as sliders\n          # and resize handles.\n          # you could have the concept of de-noising, but\n          # actually it seems nicer to have a "springy"\n          # reaction to a slider with some noise.\n          # Users don\'t seem to click on a slider for any other\n          # reason than to move it (as opposed to selecting them\n          # or picking a position for a cursor), so it\'s OK.\n          @nonFloatDraggedMorph = @morphToGrab          \n          @nonFloatDragPositionWithinMorphAtStart =\n            # if we ever will need to compensate for the grab/drag\n            # treshold here, just add .subtract displacementDueToGrabDragThreshold\n            (pos.subtract @nonFloatDraggedMorph.position())\n\n\n        # if the mouse has left its fullBounds, center it\n        if morph\n          fb = morph.fullBounds()\n          unless fb.containsPoint pos\n            @rawSetExtent @extent().subtract fb.extent().floorDivideBy 2\n            @grab morph\n            @fullRawMoveTo pos\n    #endProcessMouseMove = new Date().getTime()\n    #timeProcessMouseMove = endProcessMouseMove - startProcessMouseMove\n    #console.log(\'Execution time ProcessMouseMove: \' + timeProcessMouseMove)\n\n\n    if @nonFloatDraggingSomething()\n      #console.log "nonFloatDraggedMorph: " + @nonFloatDraggedMorph\n\n      # OK so this is an interesting choice. You can avoid\n      # this next line and have ZK to behave like OSX where you\n      # can scroll on a pane without bringing its window in the\n      # foreground. OR you can have the window to automatically\n      # pop into the foreground. I\'m liking the OSX style\n      # so I\'m leaving this commented-out, but it\'s there.\n      # TODO this could be a setting somewhere in ZK.\n      # @nonFloatDraggedMorph.bringToForegroud()\n\n      if @mouseButton\n        if @previousNonFloatDraggingPos?\n          deltaDragFromPreviousCall = pos.subtract @previousNonFloatDraggingPos\n        else\n          deltaDragFromPreviousCall = null\n        @previousNonFloatDraggingPos = pos.copy()\n        @nonFloatDraggedMorph.nonFloatDragging?(@nonFloatDragPositionWithinMorphAtStart, pos, deltaDragFromPreviousCall)\n    \n    #\n    # original, more cautious code for grabbing Morphs,\n    # retained in case of needing to fall back:\n    #\n    #   if (morph === this.morphToGrab) {\n    #     if (morph.isfloatDraggable) {\n    #       this.grab(morph);\n    #     } else if (morph.isTemplate) {\n    #       morph = morph.fullCopy();\n    #       morph.isTemplate = false;\n    #       morph.isfloatDraggable = true;\n    #       this.grab(morph);\n    #     }\n    #   }\n    #\n\n  reCheckMouseEntersAndMouseLeavesAfterPotentialGeometryChanges: ->\n    topMorph = @topMorphUnderPointer()\n    mouseOverNew = topMorph.allParentsTopToBottom()\n    @dispatchEventsFollowingMouseMove mouseOverNew\n\n  dispatchEventsFollowingMouseMove: (mouseOverNew) ->\n\n    @mouseOverList.forEach (old) =>\n      unless old in mouseOverNew\n        old.mouseLeave?()\n        old.mouseLeavefloatDragging?()  if @mouseButton\n\n    mouseOverNew.forEach (newMorph) =>\n      \n      # send mouseMove only if mouse actually moved,\n      # otherwise it will fire also when the user\n      # simply clicks\n      if !@mouseDownPosition? or !@mouseDownPosition.eq @position()\n        newMorph.mouseMove?(@position(), @mouseButton)\n      \n      unless newMorph in @mouseOverList\n        newMorph.mouseEnter?()\n        newMorph.mouseEnterfloatDragging?()  if @mouseButton\n\n      # autoScrolling support:\n      if @floatDraggingSomething()\n          if newMorph instanceof ScrollFrameMorph\n              if !newMorph.boundingBox().insetBy(\n                WorldMorph.preferencesAndSettings.scrollBarSize * 3\n                ).containsPoint @position()\n                  newMorph.startAutoScrolling()\n\n    @mouseOverList = mouseOverNew\n';
