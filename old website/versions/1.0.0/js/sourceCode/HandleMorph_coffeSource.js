// Generated by CoffeeScript 1.10.0
window.HandleMorph_coffeSource = '# HandleMorph ////////////////////////////////////////////////////////\n# not to be confused with the HandMorph\n# I am a resize / move handle that can be attached to any Morph\n\n# this comment below is needed to figure out dependencies between classes\n# REQUIRES globalFunctions\n\nclass HandleMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n\n  target: null\n  inset: null\n  type: null\n\n  state: 0\n  STATE_NORMAL: 0\n  STATE_HIGHLIGHTED: 1\n\n  constructor: (@target = null, @type = "resizeBothDimensionsHandle") ->\n    if @target?.padding?\n      @inset = new Point @target.padding, @target.padding\n    else\n      @inset = new Point 0, 0\n    super()\n    @color = new Color 255, 255, 255\n    @noticesTransparentClick = true\n    size = WorldMorph.preferencesAndSettings.handleSize\n    @silentRawSetExtent new Point size, size\n    if @target\n      @target.add @\n    @updateResizerHandlePosition()\n\n  isFloatDraggable: ->\n    if @parent?\n\n      # an instance of ScrollFrameMorph is also an instance of FrameMorph\n      # so gotta do this check first ahead of next paragraph.\n      #if @parentThatIsA(ScrollFrameMorph)?\n      #  return false\n\n      if @parent instanceof WorldMorph\n        return true\n    return false\n\n\n  parentHasReLayouted: ->\n    if @parent.layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING\n      # you can\'t resize a morph that is subject to a\n      # non-trivial freefloating layout.\n      # rather, you have to use specialised adjusters.\n      # so this handle has to go away now.\n      @destroy()\n    else\n      @updateResizerHandlePosition()\n      @moveInFrontOfSiblings()\n      super\n\n  updateResizerHandlePosition: ->\n    if @target\n      # collapse some of the handles if the\n      # morph gets too small because they\n      # become unusable anyways once they\n      # overlap\n      switch @type\n        when "moveHandle"\n          if @target.width() < 2 * @width()\n            @hide()\n            return\n          else\n            @show()\n        when "resizeHorizontalHandle"\n          if @target.height() < 3 * @height()\n            @hide()\n            return\n          else\n            @show()\n        when "resizeVerticalHandle"\n          if @target.width() < 3 * @width()\n            @hide()\n            return\n          else\n            @show()\n\n      @silentUpdateResizerHandlePosition()\n      @changed()\n\n  silentUpdateResizerHandlePosition: ->\n    if @target\n        switch @type\n          when "resizeBothDimensionsHandle"\n            @silentFullRawMoveTo @target.bottomRight().subtract @extent().add @inset\n          when "moveHandle"\n            @silentFullRawMoveTo @target.topLeft().add @inset\n          when "resizeHorizontalHandle"\n            offsetFromMiddlePoint = new Point @extent().x + @inset.x, Math.floor(@extent().y/2)\n            @silentFullRawMoveTo @target.rightCenter().subtract offsetFromMiddlePoint\n          when "resizeVerticalHandle"\n            offsetFromMiddlePoint = new Point Math.floor(@extent().x/2), @extent().y + @inset.y\n            @silentFullRawMoveTo @target.bottomCenter().subtract offsetFromMiddlePoint\n  \n  \n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if @preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = @alpha\n\n      aContext.scale pixelRatio, pixelRatio\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n\n      if @state == @STATE_NORMAL\n        @handleMorphRenderingHelper aContext, @color, new Color 100, 100, 100\n      if @state == @STATE_HIGHLIGHTED\n        @handleMorphRenderingHelper aContext, new Color(255, 255, 255), new Color(200, 200, 255)\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio (i.e. after the restore)\n      @paintHighlight aContext, al, at, w, h\n\n  doPath: (context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown) ->\n    context.beginPath()\n    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftUp.x, 0.5 + leftArrowPoint.y + arrowPieceLeftUp.y\n    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftDown.x, 0.5 + leftArrowPoint.y + arrowPieceLeftDown.y\n\n    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y\n    context.lineTo 0.5 + rightArrowPoint.x, 0.5 + rightArrowPoint.y\n\n    context.lineTo 0.5 + rightArrowPoint.x + arrowPieceRightUp.x, 0.5 + rightArrowPoint.y + arrowPieceRightUp.y\n    context.moveTo 0.5 + rightArrowPoint.x, 0.5 + rightArrowPoint.y\n    context.lineTo 0.5 + rightArrowPoint.x + arrowPieceRightDown.x, 0.5 + rightArrowPoint.y + arrowPieceRightDown.y\n\n    context.closePath()\n    context.stroke()\n\n  drawHandle: (context) ->\n    if @type is "resizeHorizontalHandle" or @type is "moveHandle"\n      p0 = @bottomLeft().subtract(@position())\n      p0 = p0.subtract new Point 0, Math.ceil(@height()/2)\n      \n      leftArrowPoint = p0.add new Point Math.ceil(@width()/15), 0\n\n      rightArrowPoint = p0.add new Point @width() - Math.ceil(@width()/14), 0\n      arrowPieceLeftUp = new Point Math.ceil(@width()/5),-Math.ceil(@height()/5)\n      arrowPieceLeftDown = new Point Math.ceil(@width()/5),Math.ceil(@height()/5)\n      arrowPieceRightUp = new Point -Math.ceil(@width()/5),-Math.ceil(@height()/5)\n      arrowPieceRightDown = new Point -Math.ceil(@width()/5),Math.ceil(@height()/5)\n      @doPath context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown\n\n    if @type is "resizeVerticalHandle" or @type is "moveHandle"\n      p0 = @bottomCenter().subtract @position()\n      \n      leftArrowPoint = p0.add new Point 0, -Math.ceil(@height()/14)\n\n      rightArrowPoint = p0.add new Point 0, -@height() + Math.ceil(@height()/15)\n      arrowPieceLeftUp = new Point -Math.ceil(@width()/5), -Math.ceil(@height()/5)\n      arrowPieceLeftDown = new Point Math.ceil(@width()/5), -Math.ceil(@height()/5)\n      arrowPieceRightUp = new Point -Math.ceil(@width()/5), Math.ceil(@height()/5)\n      arrowPieceRightDown = new Point Math.ceil(@width()/5), Math.ceil(@height()/5)\n      @doPath context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown\n\n\n    if @type is "resizeBothDimensionsHandle"\n      leftArrowPoint = @extent().floorDivideBy 7\n      rightArrowPoint = @bottomRight().subtract(@position()).subtract @extent().floorDivideBy 7\n\n      arrowPieceLeftUp = new Point Math.ceil(@width()/4), 0\n      arrowPieceLeftDown = new Point 0, Math.ceil(@height()/4)\n      arrowPieceRightUp = new Point 0,-Math.ceil(@width()/4)\n      arrowPieceRightDown = new Point -Math.ceil(@width()/4),0\n\n      @doPath(context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown)\n\n  handleMorphRenderingHelper: (context, color, shadowColor) ->\n    context.lineWidth = 1\n    context.lineCap = "round"\n\n    # give it a good shadow so that\n    # it\'s visible also when on light\n    # background. Do that by painting it\n    # twice, slightly translated, in\n    # darker color.\n    context.save()\n    context.strokeStyle = shadowColor.toString()\n    context.translate 1,1\n    @drawHandle context\n    context.translate 1,0\n    @drawHandle context\n    context.restore()\n\n    context.strokeStyle = color.toString()\n    @drawHandle context\n\n\n  \n\n  # implement dummy methods in here\n  # so the handle catches the clicks and\n  # prevents the parent from doing anything.\n  mouseClickLeft: ->\n  mouseUpLeft: ->\n  \n  # same here, the handle doesn\'t want to propagate\n  # anything, otherwise the handle on a button\n  # will trigger the button when resizing.\n  mouseDownLeft: (pos) ->\n    return null  unless @target\n    @target.bringToForegroud()\n\n  nonFloatDragging: (nonFloatDragPositionWithinMorphAtStart, pos) ->\n    newPos = pos.subtract nonFloatDragPositionWithinMorphAtStart\n    switch @type\n      when "resizeBothDimensionsHandle"\n        newExt = newPos.add(@extent().add(@inset)).subtract @target.position()\n        @target.setExtent newExt\n      # the position of this handle will be changed when the\n      # parentHasReLayouted method of this handle will be called\n      # as the parent has re-layouted following the rawSetExtent call just\n      # made.\n      when "moveHandle"\n        @target.fullMoveTo newPos.subtract @inset\n      when "resizeHorizontalHandle"\n        newWidth = newPos.x + @extent().x + @inset.x - @target.left()\n        @target.setWidth newWidth\n      when "resizeVerticalHandle"\n        newHeight = newPos.y + @extent().y + @inset.y - @target.top()\n        @target.setHeight newHeight\n  \n  \n  # HandleMorph floatDragging and dropping:\n  rootForGrab: ->\n    @\n  \n  # HandleMorph events:\n  mouseEnter: ->\n    console.log "<<<<<< handle mousenter"\n    @state = @STATE_HIGHLIGHTED\n    @changed()\n  \n  mouseLeave: ->\n    console.log "<<<<<< handle mouseleave"\n    @state = @STATE_NORMAL\n    @changed()\n\n  makeHandleSolidWithParentMorph: (ignored, ignored2, morphAttachedTo)->\n    @target = morphAttachedTo\n    @target.add @\n    @updateResizerHandlePosition()\n    @noticesTransparentClick = true\n\n    \n  # HandleMorph menu:\n  attach: ->\n    choices = world.plausibleTargetAndDestinationMorphs @\n    menu = new MenuMorph false, @, true, true, "choose target:"\n    if choices.length > 0\n      choices.forEach (each) =>\n        menu.addItem each.toString().slice(0, 50) + " ➜", true, @, \'makeHandleSolidWithParentMorph\', null, null, null, null, null, each, null, true\n    else\n      # the ideal would be to not show the\n      # "attach" menu entry at all but for the\n      # time being it\'s quite costly to\n      # find the eligible morphs to attach\n      # to, so for now let\'s just calculate\n      # this list if the user invokes the\n      # command, and if there are no good\n      # morphs then show some kind of message.\n      menu = new MenuMorph false, @, true, true, "no morphs to attach to"\n    menu.popUpAtHand @firstContainerMenu() if choices.length\n';
