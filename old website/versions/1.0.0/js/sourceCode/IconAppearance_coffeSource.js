// Generated by CoffeeScript 1.10.0
window.IconAppearance_coffeSource = '# IconAppearance //////////////////////////////////////////////////////////////\n\nclass IconAppearance extends Appearance\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  # default icon is a circle\n  paintFunctionSource: """\n    fillColor = @color\n    context.beginPath()\n    context.moveTo 100.5, 7\n    context.bezierCurveTo 50.05, 7, 9, 48.04, 9, 98.5\n    context.bezierCurveTo 9, 148.95, 50.05, 190, 100.5, 190\n    context.bezierCurveTo 150.95, 190, 192, 148.95, 192, 98.5\n    context.bezierCurveTo 192, 48.04, 150.95, 7, 100.5, 7\n    context.closePath()\n    context.moveTo 100.5, 20.39\n    context.bezierCurveTo 143.72, 20.39, 178.61, 55.28, 178.61, 98.5\n    context.bezierCurveTo 178.61, 141.72, 143.72, 176.61, 100.5, 176.61\n    context.bezierCurveTo 57.28, 176.61, 22.39, 141.72, 22.39, 98.5\n    context.bezierCurveTo 22.39, 55.28, 57.28, 20.39, 100.5, 20.39\n    context.closePath()\n    context.fillStyle = fillColor\n    context.fill()\n    """\n\n\n  constructor: (morph, paintFunction) ->\n    super morph\n    \n    if paintFunction?\n      @paintFunctionSource = paintFunction\n      @compilePaintFunction()\n    else\n      # use the default icon image (a simple circle)\n      @compilePaintFunction()\n\n\n  compilePaintFunction: ->\n    try\n      console.log "compiling icon: " + @paintFunctionSource\n      compiledOutput = CoffeeScript.compile(@paintFunctionSource,\n        bare: "on"\n      )\n      console.log compiledOutput\n    catch e\n      # coffescript compiler has caught a syntax error.\n      @inform err\n      return\n\n    @paintFunction = new Function \'context\', compiledOutput\n\n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if @morph.preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = @morph.alpha\n\n      aContext.scale pixelRatio, pixelRatio\n\n      morphPosition = @morph.position()\n      #aContext.translate morphPosition.x, morphPosition.y\n      #debugger\n\n      height = @morph.height()\n      width = @morph.width()\n\n\n      preferredSize = new Point 200, 200\n      scaleW = Math.abs(width / preferredSize.width())\n      scaleH = Math.abs(height / preferredSize.height())\n\n\n      # default: stretch\n      # nothing to do\n\n\n      # aspect fit\n      scaleW = Math.min(scaleW, scaleH)\n      scaleH = scaleW\n\n      # aspect fill\n      #scaleW = Math.max(scaleW, scaleH)\n      #scaleH = scaleW\n\n      # center\n      #scaleW = 1\n      #scaleH = 1\n\n      result = new Rectangle(Math.min(0, preferredSize.width()), Math.min(0, preferredSize.height()), Math.abs(preferredSize.width()), Math.abs(preferredSize.height()))\n      result2W = result.width() * scaleW\n      result2H = result.height() * scaleH\n      result2X = @morph.left() + (width - (result2W)) / 2\n      result2Y = @morph.top() + (height - (result2H)) / 2\n\n      result = new Rectangle result2X, result2Y, result2X + result2W, result2Y + result2H\n\n\n      aContext.translate(result.left(), result.top())\n      aContext.scale(result.width() / preferredSize.width(), result.height() / preferredSize.height())\n\n      ## at this point, you draw in a squareSize x squareSize\n      ## canvas, and it gets painted in a square that fits\n      ## the morph, right in the middle.\n      @paintFunction aContext\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio (i.e. after the restore)\n      #@paintHighlight aContext, al, at, w, h\n\n  oval: (context, x, y, w, h) ->\n    context.save()\n    context.beginPath()\n    context.translate x, y\n    context.scale w / 2, h / 2\n    context.arc 1, 1, 1, 0, 2 * Math.PI, false\n    context.closePath()\n    context.restore()\n    return\n\n  arc: (context, x, y, w, h, startAngle, endAngle, isClosed) ->\n    context.save()\n    context.beginPath()\n    context.translate x, y\n    context.scale w / 2, h / 2\n    context.arc 1, 1, 1, Math.PI / 180 * startAngle, Math.PI / 180 * endAngle, false\n    if isClosed\n      context.lineTo 1, 1\n      context.closePath()\n    context.restore()\n    return\n\n  paintFunction: (context) ->\n\n';
