// Generated by CoffeeScript 1.10.0
window.InspectorMorph2_coffeSource = '# InspectorMorph2 //////////////////////////////////////////////////////\n\nclass InspectorMorph2 extends WindowMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  target: null\n  currentProperty: null\n  showing: "attributes"\n  markOwnershipOfProperties: true\n  # panes:\n  list: null\n  detail: null\n\n  classesButtons: null\n  classesNames: null\n  angledArrows: null\n  hierarchyHeaderString: null\n  propertyHeaderString: null\n\n  showMethodsOnButton: null\n  showMethodsOffButton: null\n  showMethodsToggle: null\n\n  showFieldsOnButton: null\n  showFieldsOffButton: null\n  showFieldsToggle: null\n\n  showInheritedOnButton: null\n  showInheritedOffButton: null\n  showInheritedToggle: null\n\n  showOwnPropsOnlyOnButton: null\n  showOwnPropsOnlyOffButton: null\n  showOwnPropsOnlyToggle: null\n\n  lastLabelInHierarchy: null\n  lastArrowInHierarchy: null\n\n  hierarchyBackgroundPanel: null\n\n  showingFields: true\n  showingMethods: true\n  showingInherited: false\n  showingOwnPropsOnly: false\n\n  addPropertyButton: null\n  renamePropertyButton: null\n  removePropertyButton: null\n  saveButton: null\n\n  showFields: ->\n    if !@showingFields\n      @showingFields = true\n      @buildAndConnectChildren()\n\n  showMethods: ->\n    if !@showingMethods\n      @showingMethods = true\n      @buildAndConnectChildren()\n\n  showInherited: ->\n    if !@showingInherited\n      @showingInherited = true\n      @buildAndConnectChildren()\n\n  showOwnPropsOnly: ->\n    if !@showingOwnPropsOnly\n      @showingOwnPropsOnly = true\n      @buildAndConnectChildren()\n\n  hideFields: ->\n    if @showingFields\n      @showingFields = false\n      @buildAndConnectChildren()\n\n  hideMethods: ->\n    if @showingMethods\n      @showingMethods = false\n      @buildAndConnectChildren()\n\n  hideInherited: ->\n    if @showingInherited\n      @showingInherited = false\n      @buildAndConnectChildren()\n\n  hideOwnPropsOnly: ->\n    if @showingOwnPropsOnly\n      @showingOwnPropsOnly = false\n      @buildAndConnectChildren()\n\n  constructor: (@target) ->\n    debugger\n    @classesButtons = []\n    @classesNames = []\n    @angledArrows = []\n    super @target.toString()\n  \n  setTarget: (target) ->\n    @target = target\n    @currentProperty = null\n    @buildAndConnectChildren()\n  \n  buildAndConnectChildren: ->\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n    # remove all submorhs i.e. panes and buttons\n    # THE ONES THAT ARE STILL\n    # submorphs of the inspector. If they\n    # have been peeled away, they still live\n    @fullDestroyChildren()\n\n    super\n    attribs = []\n    @classesButtons = []\n    @classesNames = []\n    @angledArrows = []\n\n    # properties list. Note that this picks up ALL properties\n    # (enumerable such as strings and un-enumerable such as functions)\n    # of the whole prototype chain.\n    #\n    #   a) some of these are DECLARED as part of the class that defines the object\n    #   and are proprietary to the object. These are shown RED\n    # \n    #   b) some of these are proprietary to the object but are initialised by\n    #   code higher in the prototype chain. These are shown GREEN\n    #\n    #   c) some of these are not proprietary, i.e. they belong to an object up\n    #   the chain of prototypes. These are shown BLUE\n    #\n    # todo: show the static methods and variables in yet another color.\n    \n    for property of @target\n      # dummy condition, to be refined\n      attribs.push property  if property\n\n    if !@showingMethods\n      attribs = attribs.filter (prop) => !isFunction @target[prop]\n\n    if !@showingFields\n      attribs = attribs.filter (prop) => isFunction @target[prop]\n\n    # if we don\'t show inherited props, then we let through two types of props (each side of the "or"\n    # takes care of one type):\n    #   1) the ones that are defined in the immediate class of the object (i.e. are own properties of the prototype)\n    #   2) the ones that are just stitched to the object but are in none of the classes upwards i.e.\n    #      are not a reachable property from the prototype\n    if !@showingInherited\n      attribs = attribs.filter (prop) => @target.constructor.prototype.hasOwnProperty(prop) or (prop not of @target.constructor.prototype)\n\n    if @showingOwnPropsOnly\n      attribs = attribs.filter (prop) => @target.hasOwnProperty(prop)\n\n    console.log "attribs: " + attribs\n\n\n    # caches the own methods of the object\n    if @markOwnershipOfProperties\n      targetOwnMethods = Object.getOwnPropertyNames @target.constructor::\n      #alert targetOwnMethods\n\n    if @target?\n      goingUpTargetProtChain = @target.__proto__\n      while goingUpTargetProtChain.constructor.name != "Object"\n        @classesNames.push goingUpTargetProtChain.constructor.name\n        goingUpTargetProtChain = goingUpTargetProtChain.__proto__\n\n    @hierarchyBackgroundPanel = new RectangleMorph()\n    @hierarchyBackgroundPanel.setColor new Color 255,255,255,.2\n    @add @hierarchyBackgroundPanel\n\n    counter = 0\n    for eachNamedClass in @classesNames\n      classButton = new SimpleButtonMorph true, @, "openClassInspector", (new StringMorph2 eachNamedClass),null,null,null,null,eachNamedClass\n      @classesButtons.push classButton\n      @add classButton\n\n      # the top class doesn\'t get an arrow pointing upwards\n      if counter > 0\n        angledArrow = new AngledArrowUpLeftIconMorph new Color 0,0,0\n        @angledArrows.push angledArrow\n        @add angledArrow\n\n      counter++\n\n    @lastLabelInHierarchy = new TextMorph "this object"\n    @add @lastLabelInHierarchy\n    @lastArrowInHierarchy = new AngledArrowUpLeftIconMorph new Color 0,0,0\n    @add @lastArrowInHierarchy\n\n    @showMethodsOnButton = new SimpleButtonMorph true, @, "hideMethods", (new StringMorph2 "methods: on").alignCenter()\n    @showMethodsOffButton = new SimpleButtonMorph true, @, "showMethods", (new StringMorph2 "methods: off").alignCenter()\n    @showMethodsToggle = new ToggleButtonMorph @showMethodsOnButton, @showMethodsOffButton, if @showingMethods then 0 else 1\n    @add @showMethodsToggle\n\n    @showFieldsOnButton = new SimpleButtonMorph true, @, "hideFields", (new StringMorph2 "fields: on").alignCenter()\n    @showFieldsOffButton = new SimpleButtonMorph true, @, "showFields", (new StringMorph2 "fields: off").alignCenter()\n    @showFieldsToggle = new ToggleButtonMorph @showFieldsOnButton, @showFieldsOffButton, if @showingFields then 0 else 1\n    @add @showFieldsToggle\n\n    @showInheritedOnButton = new SimpleButtonMorph true, @, "hideInherited", (new StringMorph2 "inherited: on").alignCenter()\n    @showInheritedOffButton = new SimpleButtonMorph true, @, "showInherited", (new StringMorph2 "inherited: off").alignCenter()\n    @showInheritedToggle = new ToggleButtonMorph @showInheritedOnButton, @showInheritedOffButton, if @showingInherited then 0 else 1\n    @add @showInheritedToggle\n\n    @buildAndConnectObjOwnPropsButton()\n\n    @addPropertyButton = new SimpleButtonMorph true, @, "addPropertyPopout", (new StringMorph2 "add...").alignCenter()\n    @add @addPropertyButton\n    @renamePropertyButton = new SimpleButtonMorph true, @, "renamePropertyPopout", (new StringMorph2 "rename...").alignCenter()\n    @add @renamePropertyButton\n    @removePropertyButton = new SimpleButtonMorph true, @, "removeProperty", (new StringMorph2 "remove").alignCenter()\n    @add @removePropertyButton\n    @saveButton = new SimpleButtonMorph true, @, "save", (new StringMorph2 "save").alignCenter()\n    @add @saveButton\n\n\n\n    # open a new inspector, just on objects so\n    # the idea is that you can view / change\n    # its fields\n    doubleClickAction = =>\n      if !isObject @currentProperty\n        return\n      inspector = new InspectorMorph2 @currentProperty\n      inspector.fullRawMoveTo world.hand.position()\n      inspector.fullRawMoveWithin world\n      world.add inspector\n      inspector.changed()\n\n    @list = new ListMorph(\n      @, # target\n      "selectionFromList", #action\n      (if @target instanceof Array then attribs else attribs.sort()), #elements\n      null, #labelGetter\n      @filterProperties(targetOwnMethods), #format\n      doubleClickAction #doubleClickAction\n    )\n    @list.disableDrops()\n\n    # we know that the content of this list in this pane is not going to need the\n    # step function, so we disable that from here by setting it to null, which\n    # prevents the recursion to children. We could have disabled that from the\n    # constructor of MenuMorph, but who knows, maybe someone might intend to use a MenuMorph\n    # with some animated content? We know that in this specific case it won\'t need animation so\n    # we set that here. Note that the ListMorph itself does require animation because of the\n    # scrollbars, but the MenuMorph (which contains the actual list contents)\n    # in this context doesn\'t.\n    world.removeSteppingMorph @list.listContents\n    @add @list\n\n    # we add a Morph alignment here because adjusting IDs whenever\n    # we add or remove methods is a pain...\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n\n    # details pane\n    @detail = new ScrollFrameMorph()\n    @detail.disableDrops()\n    @detail.contents.disableDrops()\n    @detail.isTextLineWrapping = true\n    @detail.color = new Color 255, 255, 255\n    ctrl = new TextMorph ""\n    ctrl.isEditable = true\n    ctrl.enableSelecting()\n    ctrl.setReceiver @target\n    @detail.setContents ctrl, 2\n    @add @detail\n\n    @hierarchyHeaderString = new StringMorph2 "Hierarchy"\n    @hierarchyHeaderString.toggleHeaderLine()\n    @hierarchyHeaderString.alignCenter()\n    @add @hierarchyHeaderString\n\n\n    @propertyHeaderString = new StringMorph2 "Properties"\n    @propertyHeaderString.toggleHeaderLine()\n    @propertyHeaderString.alignCenter()\n    @add @propertyHeaderString\n\n    # resizer\n    @resizer = new HandleMorph @\n\n    # update layout\n    @layoutSubmorphs()\n\n  buildAndConnectObjOwnPropsButton: ->\n    @showOwnPropsOnlyOnButton = new SimpleButtonMorph true, @, "hideOwnPropsOnly", (new StringMorph2 "obj own props only: on").alignCenter()\n    @showOwnPropsOnlyOffButton = new SimpleButtonMorph true, @, "showOwnPropsOnly", (new StringMorph2 "obj own props only: off").alignCenter()\n    @showOwnPropsOnlyToggle = new ToggleButtonMorph @showOwnPropsOnlyOnButton, @showOwnPropsOnlyOffButton, if @showingOwnPropsOnly then 0 else 1\n    @add @showOwnPropsOnlyToggle\n\n  openClassInspector: (ignored,ignored2,className) ->\n    classInspector = new ClassInspectorMorph window[className].prototype\n    classInspector.fullRawMoveTo world.hand.position()\n    classInspector.setExtent new Point 560,410\n    classInspector.fullRawMoveWithin world\n    world.add classInspector\n    classInspector.bringToForegroud()\n    debugger\n    classInspector.changed()\n\n  showAttributes: ->\n    @showing = "attributes"\n    @buildAndConnectChildren()\n\n  showAttributesAndMethods: ->\n    @showing = "all"\n    @buildAndConnectChildren()\n\n  highlightOwnershipOfProperties: ->\n    @markOwnershipOfProperties = not @markOwnershipOfProperties\n    @buildAndConnectChildren()\n\n  filterProperties: (targetOwnMethods)->\n    if @markOwnershipOfProperties\n      return [\n        # give color criteria from the most general to the most specific\n        [new Color(0, 0, 180),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            true\n        ],\n        [new Color(0, 180, 0),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            @target.constructor.prototype.hasOwnProperty(element)\n        ]\n      ]\n    else\n      return null\n\n  selectionFromList: (selected) ->\n    if selected == undefined then return\n\n    val = @target[selected]\n    @currentProperty = val\n\n    # functions should have a source somewhere\n    # either in the object or in a superclass,\n    # try to find it.\n    if isFunction(val)\n      if @target[selected + "_source"]?\n          val = @target[selected + "_source"]\n      else\n        goingUpTargetProtChain = @target\n        while goingUpTargetProtChain != Object\n          if goingUpTargetProtChain.constructor.klass.propertiesSources[selected]?\n            val = goingUpTargetProtChain.constructor.klass.propertiesSources[selected]\n            break\n          goingUpTargetProtChain = goingUpTargetProtChain.__proto__\n      txt = val.toString()\n    else\n      # this is for finding the static variables\n      if val is undefined\n        val = @target.constructor[selected]\n      \n      if val is null\n        txt = "null"\n      else if isString val\n        txt = \'"\'+val+\'"\'\n      else\n        txt = val.toString()\n\n    cnts = new TextMorph txt\n    cnts.isEditable = true\n    cnts.enableSelecting()\n    cnts.setReceiver @target\n    @detail.setContents cnts, 2\n  \n  layoutSubmorphs: (morphStartingTheChange = null) ->\n    super morphStartingTheChange\n    console.log "fixing the layout of the inspector"\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Morph. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    trackChanges.push false\n\n\n    classDiagrHeight = Math.floor(@height() / 3)\n\n    labelLeft = @label.left()\n    labelBottom = @label.bottom() + 2\n\n    @hierarchyHeaderString.fullRawMoveTo new Point(Math.round(@left() + @padding), Math.round(labelBottom + @padding))\n    @hierarchyHeaderString.rawSetExtent new Point @width() - 2 * @padding,15\n\n\n    # classes diagram\n    justAcounter = 0\n    anotherCount = 0\n    # reverse works in-place, so we need to remember\n    # to put them back right after we are done\n    @classesButtons.reverse()\n    for eachClassButton in @classesButtons\n      if eachClassButton.parent == @\n        eachClassButton.fullRawMoveTo new Point(Math.round(@left() + 2 * @padding + justAcounter), Math.round(@hierarchyHeaderString.bottom() + 2*@padding + justAcounter))\n        eachClassButton.rawSetExtent new Point 120, 15\n\n        # the top class doesn\'t get an arrow pointing upwards\n        if anotherCount > 0\n          @angledArrows[anotherCount-1].parent == @\n          @angledArrows[anotherCount-1].fullRawMoveTo new Point(eachClassButton.left() - 15, Math.round(eachClassButton.top()))\n          @angledArrows[anotherCount-1].rawSetExtent new Point 15, 15\n\n        justAcounter += 20\n\n      anotherCount++\n    @classesButtons.reverse()\n    @layoutLastLabelInHierarchy Math.round(@left() + 2 * @padding + justAcounter), Math.round(@hierarchyHeaderString.bottom() + 2*@padding + justAcounter)\n\n    @hierarchyBackgroundPanel.fullRawMoveTo new Point @left() + @padding, @hierarchyHeaderString.bottom() + @padding\n    @hierarchyBackgroundPanel.rawSetExtent new Point @width() - 2 * @padding, justAcounter + 20 + @padding\n\n    @propertyHeaderString.fullRawMoveTo new Point @left() + @padding , @hierarchyBackgroundPanel.bottom()+ @padding\n    @propertyHeaderString.rawSetExtent new Point @width() - 2 * @padding , 15\n\n    listWidth = Math.floor((@width() - 3 * @padding) / 3)\n    detailWidth = 2*listWidth\n\n    @layoutOwnPropsOnlyToggle @propertyHeaderString.bottom() + @padding, listWidth, detailWidth\n\n    # list\n    listHeight = (@bottom() - 2 * @padding - 15) - (@showMethodsToggle.bottom() + @padding)\n    if @list.parent == @\n      @list.fullRawMoveTo new Point @left() + @padding, @showMethodsToggle.bottom() + @padding\n      @list.rawSetExtent new Point listWidth, listHeight\n\n    # detail\n    if @detail.parent == @\n      @detail.fullRawMoveTo new Point @list.right() + @padding, @list.top()\n      @detail.rawSetExtent new Point(detailWidth, listHeight).round()\n\n    @addPropertyButton.fullRawMoveTo new Point @left() + @padding, @bottom() - 15 - @padding\n    @addPropertyButton.rawSetExtent new Point (listWidth - 2 * @padding)/3,15\n\n    @renamePropertyButton.fullRawMoveTo new Point @addPropertyButton.right() + @padding, @bottom() - 15 - @padding\n    @renamePropertyButton.rawSetExtent new Point (listWidth - 2 * @padding)/3,15\n\n    @removePropertyButton.fullRawMoveTo new Point @renamePropertyButton.right() + @padding, @bottom() - 15 - @padding\n    @removePropertyButton.rawSetExtent new Point (listWidth - 2 * @padding)/3,15\n\n    @saveButton.fullRawMoveTo new Point @right() - @width()/4 - 2*@padding - WorldMorph.preferencesAndSettings.handleSize, @bottom() - 15 - @padding\n    @saveButton.rawSetExtent new Point @width()/4,15\n\n    trackChanges.pop()\n    @fullChanged()\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n  layoutOwnPropsOnlyToggle: (height, listWidth, detailWidth) ->\n\n    @showMethodsToggle.fullRawMoveTo new Point @left()+@padding , height\n    @showMethodsToggle.rawSetExtent (new Point (listWidth-@padding)/ 2,15).round()\n\n    @showFieldsToggle.fullRawMoveTo new Point @showMethodsToggle.right() + @padding, height\n    @showFieldsToggle.rawSetExtent (new Point (listWidth-@padding)/ 2,15).round()\n\n    @showInheritedToggle.fullRawMoveTo new Point @showFieldsToggle.right() + @padding, height\n    @showInheritedToggle.rawSetExtent (new Point (detailWidth-@padding)/ 2,15).round()\n\n    @showOwnPropsOnlyToggle.fullRawMoveTo new Point @showInheritedToggle.right() + @padding, height\n    @showOwnPropsOnlyToggle.rawSetExtent (new Point (detailWidth-@padding)/ 2,15).round()\n\n\n  layoutLastLabelInHierarchy: (posx, posy) ->\n    if @lastLabelInHierarchy.parent == @\n      @lastLabelInHierarchy.fullRawMoveTo new Point posx, posy\n      @lastLabelInHierarchy.rawSetExtent new Point 150, 15\n\n    if @lastArrowInHierarchy.parent == @\n      @lastArrowInHierarchy.fullRawMoveTo new Point posx - 15, posy\n      @lastArrowInHierarchy.rawSetExtent new Point 15, 15\n\n\n  notifyInstancesOfSourceChange: (propertiesArray)->\n    @target.sourceChanged()\n  \n  #InspectorMorph2 editing ops:\n  save: ->\n    txt = @detail.contents.children[0].text.toString()\n    propertyName = @list.selected.labelString\n    # inject code will also break the layout and the morph\n    @target.injectProperty propertyName, txt\n\n  # TODO should have a removeProperty method in Morph (and in the classes somehow)\n  # rather than here \n  addProperty: (ignoringThis, morphWithProperty) ->\n    prop = morphWithProperty.text.text\n    if prop?\n      if prop.getValue?\n        prop = prop.getValue()\n      @target[prop] = null\n      @buildAndConnectChildren()\n      @notifyInstancesOfSourceChange([prop])\n  \n  addPropertyPopout: ->\n    @prompt "new property name:", @, "addProperty", "property" # Chrome cannot handle empty strings (others do)\n\n  # TODO should have a removeProperty method in Morph (and in the classes somehow)\n  # rather than here \n  renameProperty: (ignoringThis, morphWithProperty) ->\n    propertyName = @list.selected.labelString\n    prop = morphWithProperty.text.text\n    if prop.getValue?\n      prop = prop.getValue()\n    try\n      delete @target[propertyName]\n      @target[prop] = @currentProperty\n    catch err\n      @inform err\n    @buildAndConnectChildren()\n    @notifyInstancesOfSourceChange([prop, propertyName])\n  \n  renamePropertyPopout: ->\n    propertyName = @list.selected.labelString\n    @prompt "property name:", @, "renameProperty", propertyName\n  \n  # TODO should have a removeProperty method in Morph (and in the classes somehow)\n  # rather than here \n  removeProperty: ->\n    propertyName = @list.selected.labelString\n    try\n      delete @target[propertyName]\n\n      @currentProperty = null\n      @buildAndConnectChildren()\n      @notifyInstancesOfSourceChange([propertyName])\n    catch err\n      @inform err\n';
