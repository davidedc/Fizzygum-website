// Generated by CoffeeScript 1.10.0
window.LayoutElementAdderOrDropletMorph_coffeSource = '# LayoutElementAdderOrDropletMorph //////////////////////////////////////////////////////\n\n# this comment below is needed to figure out dependencies between classes\n# REQUIRES LayoutSpec\n\n\nclass LayoutElementAdderOrDropletMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n  _acceptsDrops: true\n\n  constructor: ->\n    super()\n    @setColor new Color 0, 0, 0\n    @setMinAndMaxBoundsAndSpreadability (new Point 15,15) , (new Point 15,15), LayoutSpec.SPREADABILITY_HANDLES\n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if @preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = @alpha\n\n      # paintRectangle here is made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, this is why\n      # it\'s called before the scaling.\n      @paintRectangle aContext, al, at, w, h, @color\n      aContext.scale pixelRatio, pixelRatio\n\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n\n      @spacerMorphRenderingHelper aContext, new Color(255, 255, 255), new Color(200, 200, 255)\n\n      aContext.restore()\n\n      # paintHighlight here is made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, this is why\n      # it\'s called outside the effect of the scaling\n      # (after the restore).\n      @paintHighlight aContext, al, at, w, h\n\n  drawHandle: (context) ->\n    height = @height()\n    width = @width()\n\n    squareDim = Math.min width/2, height/2\n\n    # p0 is the origin, the origin being in the bottom-left corner\n    p0 = @bottomLeft().subtract(@position())\n\n    # now the origin if on the left edge, in the top 2/3 of the morph\n    p0 = p0.subtract new Point 0, Math.ceil 2 * height/3\n    \n    # now the origin is in the middle height of the morph,\n    # on the left edge of the square incribed in the morph\n    p0 = p0.add new Point (width -  squareDim)/2, 0\n\n    \n    plusSignLeft = p0.add new Point Math.ceil(squareDim/15), 0\n    plusSignRight = p0.add new Point squareDim - Math.ceil(squareDim/15), 0\n    plusSignTop = p0.add new Point Math.ceil(squareDim/2), -Math.ceil(squareDim/3)\n    plusSignBottom = p0.add new Point Math.ceil(squareDim/2), Math.ceil(squareDim/3)\n\n    context.beginPath()\n    context.moveTo 0.5 + plusSignLeft.x, 0.5 + plusSignLeft.y\n    context.lineTo 0.5 + plusSignRight.x, 0.5 + plusSignRight.y\n    context.moveTo 0.5 + plusSignTop.x, 0.5 + plusSignTop.y\n    context.lineTo 0.5 + plusSignBottom.x, 0.5 + plusSignBottom.y\n\n    # now the new origin is in the lower part of the morph, so\n    # we can put an arrow there.\n    p0 = p0.add new Point 0, Math.ceil 1*height/3\n    arrowFlapSize = Math.ceil squareDim/8\n    arrowSignLeft = p0.add new Point arrowFlapSize, 0\n    arrowSignRight = p0.add new Point squareDim - arrowFlapSize, 0\n    arrowUp = arrowSignRight.add new Point -arrowFlapSize, -arrowFlapSize\n    arrowDown = arrowSignRight.add new Point -arrowFlapSize, arrowFlapSize\n    context.moveTo 0.5 + arrowSignLeft.x, 0.5 + arrowSignLeft.y\n    context.lineTo 0.5 + arrowSignRight.x, 0.5 + arrowSignRight.y\n\n    context.lineTo 0.5 + arrowUp.x, 0.5 + arrowUp.y\n    context.moveTo 0.5 + arrowSignRight.x, 0.5 + arrowSignRight.y\n    context.lineTo 0.5 + arrowDown.x, 0.5 + arrowDown.y\n\n\n    context.closePath()\n    context.stroke()\n\n\n  spacerMorphRenderingHelper: (context, color, shadowColor) ->\n    context.lineWidth = 1\n    context.lineCap = "round"\n\n    # give it a good shadow so that\n    # it\'s visible also when on light\n    # background. Do that by painting it\n    # twice, slightly translated, in\n    # darker color.\n    context.save()\n    context.strokeStyle = shadowColor.toString()\n    @drawHandle context\n    context.restore()\n\n    context.strokeStyle = color.toString()\n    @drawHandle context\n\n  mouseClickLeft: ->\n    @bringToForegroud()\n    # if the adder/droplet is on its own, free floating, then\n    # put a supporting morph underneath it and put the adder/droplet\n    # in a layout.\n    if @layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING\n      newMorph = new Morph()\n      @parent.add newMorph\n      newMorph.rawSetBounds @boundingBox()\n      newMorph.add @, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n      newMorph.showAdders()\n\n    @addAsSiblingAfterMe \\\n      (new LayoutElementAdderOrDropletMorph()),\n      null,\n      LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n\n  reactToDropOf: (morphBeingDropped) ->\n    @addAsSiblingAfterMe \\\n      morphBeingDropped,\n      null,\n      LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED    \n    @destroy()\n\n  mouseEnter: ->\n    @setColor new Color 100, 100, 100\n  \n  mouseLeave: ->\n    @setColor new Color 0, 0, 0\n\n\n';
