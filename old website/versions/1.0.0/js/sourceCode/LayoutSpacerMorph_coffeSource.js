// Generated by CoffeeScript 1.10.0
window.LayoutSpacerMorph_coffeSource = '# LayoutSpacerMorph //////////////////////////////////////////////////////\n\n# this comment below is needed to figure out dependencies between classes\n# REQUIRES LayoutSpec\n\n\nclass LayoutSpacerMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n  thisSpacerIsTransparent: false\n\n  constructor: (spacerWeight = 1) ->\n    super()\n    @setColor new Color 0, 0, 0\n    @setMinAndMaxBoundsAndSpreadability (new Point 0,0) , (new Point 1,1), spacerWeight * LayoutSpec.SPREADABILITY_SPACERS\n    @minimumExtent = new Point 0,0\n\n  makeSpacersTransparent: ->\n    if !@thisSpacerIsTransparent\n      @thisSpacerIsTransparent = true\n      @changed()\n    super\n\n  makeSpacersOpaque: ->\n    if @thisSpacerIsTransparent\n      @thisSpacerIsTransparent = false\n      @changed()\n    super\n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if @thisSpacerIsTransparent\n      return\n\n    if @preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = @alpha\n\n      # paintRectangle here is made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, this is why\n      # it\'s called before the scaling.\n      @paintRectangle aContext, al, at, w, h, @color\n      aContext.scale pixelRatio, pixelRatio\n\n\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n\n      @spacerMorphRenderingHelper aContext, new Color(255, 255, 255), new Color(200, 200, 255)\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio (i.e. after the restore)\n      @paintHighlight aContext, al, at, w, h\n\n  doPath: (context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown) ->\n    context.beginPath()\n    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftUp.x, 0.5 + leftArrowPoint.y + arrowPieceLeftUp.y\n    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftDown.x, 0.5 + leftArrowPoint.y + arrowPieceLeftDown.y\n\n    #context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y\n    #context.lineTo 0.5 + rightArrowPoint.x, 0.5 + rightArrowPoint.y\n\n    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftUp.x, 0.5 + leftArrowPoint.y\n\n    spaceInBetweenArrowAndMiddle =  Math.abs @width()/2 - (0.5 + leftArrowPoint.x + arrowPieceLeftUp.x)\n\n    ## the squiggly part\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftUp.x + 1*spaceInBetweenArrowAndMiddle/3, 0.5 + leftArrowPoint.y + arrowPieceLeftUp.y/2\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftUp.x + 2*spaceInBetweenArrowAndMiddle/3, 0.5 + leftArrowPoint.y + arrowPieceLeftDown.y/2\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftUp.x + 3*spaceInBetweenArrowAndMiddle/3, 0.5 + leftArrowPoint.y + arrowPieceLeftUp.y/2\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftUp.x + 4*spaceInBetweenArrowAndMiddle/3, 0.5 + leftArrowPoint.y + arrowPieceLeftDown.y/2\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftUp.x + 5*spaceInBetweenArrowAndMiddle/3, 0.5 + leftArrowPoint.y + arrowPieceLeftUp.y/2\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftUp.x + 6*spaceInBetweenArrowAndMiddle/3, 0.5 + leftArrowPoint.y\n\n    context.lineTo 0.5 + rightArrowPoint.x, 0.5 + rightArrowPoint.y\n\n    context.moveTo 0.5 + rightArrowPoint.x, 0.5 + rightArrowPoint.y\n\n    context.lineTo 0.5 + rightArrowPoint.x + arrowPieceRightUp.x, 0.5 + rightArrowPoint.y + arrowPieceRightUp.y\n    context.moveTo 0.5 + rightArrowPoint.x, 0.5 + rightArrowPoint.y\n    context.lineTo 0.5 + rightArrowPoint.x + arrowPieceRightDown.x, 0.5 + rightArrowPoint.y + arrowPieceRightDown.y\n\n    context.closePath()\n    context.stroke()\n\n  drawReplacerMorph: (context) ->\n    p0 = @bottomLeft().subtract @position()\n    p0 = p0.subtract new Point 0, Math.ceil @height()/2\n    \n    leftArrowPoint = p0.add new Point Math.ceil(@width()/15), 0\n\n    rightArrowPoint = p0.add new Point @width() - Math.ceil(@width()/14), 0\n    arrowPieceLeftUp = new Point Math.ceil(@width()/5), -Math.ceil(@height()/5)\n    arrowPieceLeftDown = new Point Math.ceil(@width()/5), Math.ceil(@height()/5)\n    arrowPieceRightUp = new Point -Math.ceil(@width()/5), -Math.ceil(@height()/5)\n    arrowPieceRightDown = new Point -Math.ceil(@width()/5), Math.ceil(@height()/5)\n    @doPath(context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown)\n\n\n  spacerMorphRenderingHelper: (context, color, shadowColor) ->\n    context.lineWidth = 1\n    context.lineCap = "round"\n\n    # give it a good shadow so that\n    # it\'s visible also when on light\n    # background. Do that by painting it\n    # twice, slightly translated, in\n    # darker color.\n    context.save()\n    context.strokeStyle = shadowColor.toString()\n    @drawReplacerMorph context\n    context.restore()\n\n    context.strokeStyle = color.toString()\n    @drawReplacerMorph context\n';
