// Generated by CoffeeScript 1.10.0
window.ListMorph_coffeSource = '# ListMorph ///////////////////////////////////////////////////////////\n\nclass ListMorph extends ScrollFrameMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n  \n  elements: null\n  labelGetter: null\n  format: null\n  listContents: null # a MenuMorph with the contents of the list\n  selected: null # actual element currently selected\n  active: null # menu item representing the selected element\n  action: null\n  target: null\n  doubleClickAction: null\n\n  constructor: (\n    @target,\n    @action,\n    @elements = [],\n    @labelGetter = (element) ->\n        return element  if isString element\n        return element.toSource()  if element.toSource\n        element.toString()\n    ,\n\n    @format = [],\n    @doubleClickAction = null\n    ) ->\n    #\n    #    passing a format is optional. If the format parameter is specified\n    #    it has to be of the following pattern:\n    #\n    #        [\n    #            [<color>, <single-argument predicate>],\n    #            [\'bold\', <single-argument predicate>],\n    #            [\'italic\', <single-argument predicate>],\n    #            ...\n    #        ]\n    #\n    #    multiple conditions can be passed in such a format list, the\n    #    last predicate to evaluate true when given the list element sets\n    #    the given format category (color, bold, italic).\n    #    If no condition is met, the default format (color black, non-bold,\n    #    non-italic) will be assigned.\n    #    \n    #    An example of how to use formats can be found in the InspectorMorph\'s\n    #    "markOwnProperties" mechanism.\n    #\n    #debugger\n    super()\n    @contents.disableDrops()\n    @color = new Color 255, 255, 255\n    @buildAndConnectChildren() # builds the list contents\n    # it\'s important to leave the step as the default noOperation\n    # instead of null because the scrollbars (inherited from scrollframe)\n    # need the step function to react to mouse floatDrag.\n  \n  # builds the list contents\n  buildAndConnectChildren: ->\n    if @listContents\n      @listContents = @listContents.destroy()\n    @listContents = new MenuMorph true, @, false, false, null, null\n    @elements = ["(empty)"]  if !@elements.length\n    trackChanges.push false\n    @elements.forEach (element) =>\n      color = null\n      bold = false\n      italic = false\n      @format.forEach (pair) ->\n        if pair[1].call null, element\n          switch pair[0]\n            when \'bold\'\n              bold = true\n            when \'italic\'\n              italic = true\n            else # assume it\'s a color\n              color = pair[0]\n\n      #labelString,\n      #action,\n      #hint,\n      #color,\n      #bold = false,\n      #italic = false,\n      #doubleClickAction # optional, when used as list contents\n\n      @listContents.addItem(\n        @labelGetter(element), # labelString\n        true,\n        @, # target\n        "select", # action\n        null, # hint\n        color, # color\n        bold, # bold\n        italic, # italic\n        @doubleClickAction # doubleClickAction\n      )\n\n    trackChanges.pop()\n    @listContents.silentFullRawMoveTo @contents.position()\n    @listContents.reLayout()\n    \n    @add @listContents\n  \n  select: (item, trigger) ->\n    @selected = item\n    @active = trigger\n    if @action\n      if typeof @action is "function"\n        console.log "listmorph selection invoked with function"\n        debugger\n        @action.call @target, item.labelString\n      else # assume it\'s a String\n        @target[@action].call @target, item.labelString\n  \n  rawSetExtent: (aPoint) ->\n    unless aPoint.eq @extent()\n      #console.log "move 3"\n      @breakNumberOfRawMovesAndResizesCaches()\n      lb = @listContents.boundingBox()\n      nb = @bounds.origin.corner @bounds.origin.add aPoint\n      if nb.right() > lb.right() and nb.width() <= lb.width()\n        @listContents.fullRawMoveRightSideTo nb.right()\n      if nb.bottom() > lb.bottom() and nb.height() <= lb.height()\n        @listContents.fullRawMoveBottomSideTo nb.bottom()\n      super aPoint\n';
