// Generated by CoffeeScript 1.10.0
window.ProgramRunner_coffeSource = '###\n## ProgramRunner manages the running function as it runs. E.g. this is not a\n## translation step, this is managing things such as the actually running of the\n## latest "stable" function and keeping track of when a function appears\n## to be stable, and reinstating the last stable function if the current one\n## throws a runtime error.\n###\n\n\nclass ProgramRunner\n  \n  # this array is used to keep track of all the instances of "doOnce" in the\n  # code we need to keep this so we can put the ticks next to doOnce once\n  # that doOnce block has run.\n  doOnceOccurrencesLineNumbers = []\n  \n  # contains the draw function as a Function object. Never mind the\n  # initialisation as an empty string.\n  drawFunction = ""\n  \n  consecutiveFramesWithoutRunTimeError = 0\n\n  # contains the last stable draw function as a Function object. Never mind the\n  # initialisation as an empty string.\n  lastStableProgram = null\n\n  # contains the code that is meant to be run, as a string.\n  # note that it might be impossible to run it because of errors, in which case\n  # LiveCodeLab might be running an older version.\n  currentCodeString = ""\n  \n  constructor: (@eventRouter, @codeCompiler, @globalScope) ->\n\n  addToScope: (scope) ->\n\n    scope.addFunction(\'addDoOnce\', (a) => @addDoOnce(a))\n    scope.addFunction(\'run\', (a,b) => @run(a,b))\n\n  # the run function is used so one can write\n  #   a = <box>\n  #   run a\n  # instead of\n  #   a = <box>\n  #   a()\n  # Note that the pre-processor appends an arrow\n  # after "run", so that\n  #   run <box> 2\n  # becomes\n  #   \n  run: (functionToBeRun, chainedFunction) ->\n    # in the case "run <box> 2" the box is\n    # already painted here.\n\n    # in the case "run <box>"\n    # we have to paint it now\n    if isFunction functionToBeRun\n      functionToBeRun()\n\n    if isFunction chainedFunction\n      chainedFunction()\n\n  # This is the function called from the compiled code to add the doOnce line\n  addDoOnce: (lineNum) ->\n    @doOnceOccurrencesLineNumbers.push lineNum\n\n  reset: () ->\n    @consecutiveFramesWithoutRunTimeError = 0\n    @drawFunction = () -> {}\n    @lastStableProgram = () -> {}\n\n  setProgram: (drawFunc) ->\n    @consecutiveFramesWithoutRunTimeError = 0\n    @drawFunction = drawFunc\n\n  resetTrackingOfDoOnceOccurrences: ->\n    @doOnceOccurrencesLineNumbers = []\n\n  putTicksNextToDoOnceBlocksThatHaveBeenRun: ->\n    codeCompiler = @codeCompiler\n    if @doOnceOccurrencesLineNumbers.length\n      p = codeCompiler.addCheckMarksAndUpdateCodeAndNotifyChange(\n        codeCompiler, @doOnceOccurrencesLineNumbers\n      )\n      @setProgram(p)\n\n  runProgram: ->\n    # this invokation below could be throwing an error,\n    # in which case the lines afterwards are not executed\n    # and the exception is propagated to the callee of this function,\n    # which is the main animation loop.\n    @drawFunction()\n    \n    # if we are here it means that the draw function didn\'t generate\n    # any runtime errors, so we increment a counter that tells how long\n    # this program has been stable for.\n    # Beyond 5 frames, we consider this program as "stable" and we save\n    # it in a special variable.\n    # This "stability" counter is obviously reset anytime the program is changed\n    # so the new version too gets an opportunity to be tested and saved.\n    @consecutiveFramesWithoutRunTimeError += 1\n    if @consecutiveFramesWithoutRunTimeError is 5\n      @lastStableProgram = @drawFunction\n      @eventRouter.emit("livecodelab-running-stably")\n\n  runLastWorkingProgram: ->\n    # mark the program as flawed and register the previous stable one.\n    @consecutiveFramesWithoutRunTimeError = 0\n    @drawFunction = @lastStableProgram\n\n';
