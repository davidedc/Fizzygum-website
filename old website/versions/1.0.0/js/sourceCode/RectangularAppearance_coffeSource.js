// Generated by CoffeeScript 1.10.0
window.RectangularAppearance_coffeSource = '# RectangularAppearance //////////////////////////////////////////////////////////////\n\nclass RectangularAppearance extends Appearance\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  isTransparentAt: (aPoint) ->\n    if @morph.boundingBoxTight().containsPoint aPoint\n      return false\n    if @morph.backgroundTransparency? and @morph.backgroundColor?\n      if @morph.backgroundTransparency > 0\n        if @morph.boundsContainPoint aPoint\n          return false\n    return true\n\n  # paintHighlight can work in two patterns:\n  #  * passing actual pixels, when used\n  #    outside the effect of the scope of\n  #    "scale pixelRatio, pixelRatio", or\n  #  * passing logical pixels, when used\n  #    inside the effect of the scope of\n  #    "scale pixelRatio, pixelRatio", or\n  # Mostly, the first pattern is used.\n  paintHighlight: (aContext, al, at, w, h) ->\n    if !@morph.highlighted\n      return\n\n    # paintRectangle here is usually made to work with\n    # al, at, w, h which are actual pixels\n    # rather than logical pixels.\n    @morph.paintRectangle \\\n      aContext,\n      al, at, w, h,\n      "orange",\n      0.5,\n      true # push and pop the context\n\n\n  # This method only paints this very morph\n  # i.e. it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer,\n  # which eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if @morph.preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return null\n\n    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      @morph.justBeforeBeingPainted?()\n\n      aContext.save()\n      aContext.globalAlpha = @morph.alpha\n      aContext.fillStyle = @morph.color.toString()\n\n      if !@morph.color?\n        debugger\n\n\n      # paintRectangle is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio\n\n      # paint the background\n      toBePainted = new Rectangle al, at, al + w, at + h\n      @morph.paintRectangle aContext, toBePainted.left(), toBePainted.top(), toBePainted.width(), toBePainted.height(), @morph.backgroundColor, @morph.backgroundTransparency\n\n      # now paint the actual morph, which is a rectangle\n      # (potentially inset because of the padding)\n      toBePainted = toBePainted.intersect @morph.boundingBoxTight().scaleBy pixelRatio\n      @morph.paintRectangle aContext, toBePainted.left(), toBePainted.top(), toBePainted.width(), toBePainted.height(), @morph.color\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio\n      @paintHighlight aContext, al, at, w, h\n';
