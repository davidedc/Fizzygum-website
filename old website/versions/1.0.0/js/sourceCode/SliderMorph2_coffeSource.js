// Generated by CoffeeScript 1.10.0
window.SliderMorph2_coffeSource = '# SliderMorph2 ///////////////////////////////////////////////////\n\n# SliderMorph2 is like SliderMorph but actually gives out values\n# within the whole intended range, while SliderMorph has some\n# bugs where values are given within a smaller interval of\n# the range.\n\n# In previous versions the user could force an orientation, so\n# that one could have a vertical slider even if the slider is\n# more wide than tall. Simplified that code because it doesn\'t\n# look like a common need.\n\n# Sliders (and hence slider button morphs)\n# are also used in the ScrollMorphs .\n\n# this comment below is needed to figure out dependencies between classes\n# REQUIRES globalFunctions\n# REQUIRES ControllerMixin\n\nclass SliderMorph2 extends CircleBoxMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith ControllerMixin\n\n  target: null\n  action: null\n  start: null\n  stop: null\n  value: null\n  size: null\n  offset: null\n  button: null\n  argumentToAction: null\n\n  constructor: (\n    @start = 0,\n    @stop = 100,\n    @value = 50,\n    @size = 10,\n    @color = (new Color 0, 0, 0)\n    ) ->\n    @button = new SliderButtonMorph()\n    super  # if null, then a vertical one will be created\n    @alpha = 0.1\n    @silentRawSetExtent new Point 20, 100\n    @silentAdd @button\n\n  imBeingAddedTo: (newParentMorph) ->\n    @reLayout()\n    \n    # might happen in phase of deserialization that\n    # the button reference here is still a string\n    # so skip in that case\n    if @button? and @button instanceof SliderButtonMorph\n      @button.reLayout()\n      \n    @changed()\n\n  rawSetExtent: (aPoint) -> \n    unless aPoint.eq @extent()\n      #console.log "move 17"\n      @breakNumberOfRawMovesAndResizesCaches()  \n      super aPoint\n      # my backing store had just been updated\n      # in the call of super, now\n      # it\'s the time of the button\n      @button.reLayout()\n    \n  rangeSize: ->\n    @stop - @start + 1\n  \n  ratio: ->\n    @size / @rangeSize()\n  \n  unitSize: ->\n    # might happen in phase of deserialization that\n    # the button reference here is still a string\n    # so skip in that case\n    if !(@button? and @button instanceof SliderButtonMorph)\n      return 1\n    if @autoOrientation() is "vertical"\n      return (@height() - @button.height()) / @rangeSize()\n    else\n      return (@width() - @button.width()) / @rangeSize()\n    \n  updateValue: ->\n    if @autoOrientation() is "vertical"\n      relPos = @button.top() - @top()\n    else\n      relPos = @button.left() - @left()\n    newvalue = Math.round relPos / @unitSize() + @start\n    if @value != newvalue\n      @value = newvalue\n      @updateTarget()\n  \n  updateTarget: ->\n    if @action\n      if typeof @action is "function"\n        console.log "scrollbar invoked with function"\n        debugger\n        @action.call @target, Math.max(@value - 1, @start), @target\n      else # assume it\'s a String\n        console.log ">>>>>>>>>> @start: " + @start\n        console.log ">>>>>>>>>> @value - 1: " + (@value - 1)\n        console.log ">>>>>>>>>> Math.max(@value - 1, @start): " + (Math.max(@value - 1, @start))\n        #if (Math.max(@value - 1, @start)) == 0\n        #  debugger\n        @target[@action].call @target, Math.max(@value - 1, @start), @argumentToAction\n    \n  \n  # SliderMorph2 menu:\n  developersMenu: ->\n    menu = super()\n    menu.addItem "show value", true, @, "showValue", "display a dialog box\\nshowing the selected number"\n    menu.addItem "floor...", true, @, (->\n      @prompt menu.title + "\\nfloor:",\n        @setStart,\n        @start.toString(),\n        null,\n        0,\n        @stop - @size,\n        true\n    ), "set the minimum value\\nwhich can be selected"\n    menu.addItem "ceiling...", true, @, (->\n      @prompt menu.title + "\\nceiling:",\n        @setStop,\n        @stop.toString(),\n        null,\n        @start + @size,\n        @size * 100,\n        true\n    ), "set the maximum value\\nwhich can be selected"\n    menu.addItem "button size...", true, @, (->\n      @prompt menu.title + "\\nbutton size:",\n        @setSize,\n        @size.toString(),\n        null,\n        1,\n        @stop - @start,\n        true\n    ), "set the range\\ncovered by\\nthe slider button"\n    menu.addLine()\n    menu.addItem "set target", true, @, "setTarget", "select another morph\\nwhose numerical property\\nwill be " + "controlled by this one"\n    menu\n  \n  showValue: ->\n    @inform @value\n  \n  userSetStart: (num) ->\n    # for context menu demo purposes\n    @start = Math.max num, @stop\n\n  \n  # once you set all the properties of a slider you\n  # call this method so it updates itself\n  updateSpecs: (start, stop, value, size)->\n    if start? then @start = start\n    if stop? then @stop = stop\n    if value? then @value = value\n    if size? then @size = size\n    @reLayout()\n    \n    @button.reLayout()\n    \n    # if the parent is the same as the target\n    # then issue a fullChanged on the parent.\n    # It\'s likely to be duplicate, which doesn\'t\n    # matter, but it will consolidate the updates\n    # of the scrollbars too\n    if @parent != @target\n      @changed()\n    else\n      @parent.fullChanged()\n  \n  setStart: (numOrMorphGivingNum) ->\n\n    if numOrMorphGivingNum.getValue?\n      num = numOrMorphGivingNum.getValue()\n    else\n      num = numOrMorphGivingNum\n\n    # for context menu demo purposes\n    if typeof num is "number"\n      @start = Math.min Math.max(num, 0), @stop - @size\n    else\n      newStart = parseFloat num\n      @start = Math.min Math.max(newStart, 0), @stop - @size  unless isNaN newStart\n    @value = Math.max @value, @start\n    @updateTarget()\n    @reLayout()\n    \n    @button.reLayout()\n    \n    @changed()\n  \n  setStop: (numOrMorphGivingNum) ->\n\n    if numOrMorphGivingNum.getValue?\n      num = numOrMorphGivingNum.getValue()\n    else\n      num = numOrMorphGivingNum\n\n    # for context menu demo purposes\n    if typeof num is "number"\n      @stop = Math.max num, @start + @size\n    else\n      newStop = parseFloat num\n      @stop = Math.max newStop, @start + @size  unless isNaN newStop\n    @value = Math.min @value, @stop\n    @updateTarget()\n    @reLayout()\n    \n    @button.reLayout()\n    \n    @changed()\n  \n  setSize: (sizeOrMorphGivingSize) ->\n    if sizeOrMorphGivingSize.getValue?\n      size = sizeOrMorphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    # for context menu demo purposes\n    if typeof size is "number"\n      @size = Math.min Math.max(size, 0), @stop - @start\n    else\n      newSize = parseFloat size\n      @size = Math.min Math.max(newSize, 0), @stop - @start  unless isNaN newSize\n    @value = Math.min @value, @stop - @size\n    # it just so happens that, as hoped but somewhat\n    # unexpectedly, as the slider resizes,\n    # the resize mechanism is such that the\n    # button keeps the same value, so there\n    # is no need to update the target.\n    #@updateTarget()\n    @reLayout()\n    \n    @button.reLayout()\n    \n    @changed()\n  \n  # setTarget: -> taken form the ControllerMixin\n\n  swapTargetsTHISNAMEISRANDOM: (ignored, ignored2, theTarget, each) ->\n    @target = theTarget\n    @action = each\n  \n  setTargetSetter: (ignored, ignored2, theTarget) ->\n    choices = theTarget.numericalSetters()\n    menu = new MenuMorph false, @, true, true, "choose target property:"\n    choices.forEach (each) =>\n      menu.addItem each, true, @, "swapTargetsTHISNAMEISRANDOM", null, null, null, null, null,theTarget, each\n    if choices.length == 0\n      menu = new MenuMorph false, @, true, true, "no target properties available"\n    menu.popUpAtHand @firstContainerMenu()\n\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    list = super()\n    list.push "setStart", "setStop", "setSize"\n    list\n  \n  ';
