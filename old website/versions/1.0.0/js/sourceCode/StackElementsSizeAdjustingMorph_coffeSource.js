// Generated by CoffeeScript 1.10.0
window.StackElementsSizeAdjustingMorph_coffeSource = '# StackElementsSizeAdjustingMorph\n\n\n\nclass StackElementsSizeAdjustingMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n\n  hand: null\n  indicator: null\n  category: \'Morphic-Layouts\'\n\n\n  constructor: ->\n    super()\n    @noticesTransparentClick = true\n    #@setColor new Color 0, 255, 0\n    @setMinAndMaxBoundsAndSpreadability (new Point 5,5) , (new Point 5,5), LayoutSpec.SPREADABILITY_HANDLES\n    @minimumExtent = new Point 0,0\n\n  # HandleMorph floatDragging and dropping:\n  rootForGrab: ->\n    @\n\n  @includeInNewMorphMenu: ->\n    # Return true for all classes that can be instantiated from the menu\n    return false\n\n  nonFloatDragging: (nonFloatDragPositionWithinMorphAtStart, pos, deltaDragFromPreviousCall) ->\n\n    # the user is in the process of dragging but didn\'t\n    # actually move the mouse yet\n    if !deltaDragFromPreviousCall?\n      return\n\n    leftMorph = @lastSiblingBeforeMeSuchThat (m) ->\n      m.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n\n    rightMorph = @firstSiblingAfterMeSuchThat (m) ->\n      m.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n\n    if leftMorph? and rightMorph?\n      lmdd = leftMorph.getMaxDim()\n      rmdd = rightMorph.getMaxDim()\n \n      #if (lmdd.x + deltaDragFromPreviousCall.x > 0) and (rmdd.x - deltaDragFromPreviousCall.x > 0)\n      #  leftMorph.setDesiredDim new Point((lmdd.x + deltaDragFromPreviousCall.x), lmdd.y)\n      #  rightMorph.setDesiredDim new Point((rmdd.x - deltaDragFromPreviousCall.x), rmdd.y)\n\n      \n\n      # the factor "Math.max(lmdd.x,rmdd.x)/100" here below is because\n      # spacers have huge max factors, so we need to scale the\n      # change based on how much the biggest max factor is.\n      biggestMaxOfTheTwo = Math.max Math.abs(lmdd.x), Math.abs(rmdd.x)\n      deltaX = (deltaDragFromPreviousCall.x * Math.pow(biggestMaxOfTheTwo,1.07)) * 500\n      console.log " deltax 2 : " + deltaX + " lmdd.x: " + lmdd.x + " rmdd.x: " + rmdd.x\n      deltaX = deltaX / (@parent.width() * 700)\n\n      totalMax = 0\n      for C in @parent.children\n        totalMax += C.getMaxDim().x\n\n      debugger\n      deltaX = deltaX * (totalMax / biggestMaxOfTheTwo)\n\n      console.log "(@parent.width() * 100): " + (@parent.width() * 100) + " deltax 3: " + deltaX\n\n      until (lmdd.x + deltaX > 0) and (rmdd.x - deltaX > 0)\n        deltaX = deltaX / 2\n\n      console.log " deltax 4 : " + deltaX\n\n      prev = leftMorph.getMaxDim().x - leftMorph.getDesiredDim().x + rightMorph.getMaxDim().x - rightMorph.getDesiredDim().x\n      leftMorph.setMaxDim new Point lmdd.x + deltaX, lmdd.y\n      rightMorph.setMaxDim new Point rmdd.x - deltaX, rmdd.y\n      newone = leftMorph.getMaxDim().x - leftMorph.getDesiredDim().x + rightMorph.getMaxDim().x - rightMorph.getDesiredDim().x\n      if prev != newone\n        leftMorph.setMaxDim lmdd\n        rightMorph.setMaxDim rmdd\n      #console.log "leftMorph.getMaxDim().x : " + leftMorph.getMaxDim().x \n      #console.log "leftMorph.getDesiredDim().x: " + leftMorph.getDesiredDim().x\n      #console.log "rightMorph.getMaxDim().x: " + rightMorph.getMaxDim().x\n      #console.log "rightMorph.getDesiredDim().x: " + rightMorph.getDesiredDim().x \n      console.log "should be constant: " + (leftMorph.getMaxDim().x - leftMorph.getDesiredDim().x + rightMorph.getMaxDim().x - rightMorph.getDesiredDim().x)\n\n\n  # TODO: this mechanism to show the right cursor is 90%\n  # there but could be better. The cursor changes to normal\n  # as soon as the pointer gets out of the adjuster, which\n  # happens while nonFloatDragging. It\'s not a big deal\n  # and it\'s simpler, but something one could improve.\n  mouseEnter: ->\n    document.getElementById("world").style.cursor = "col-resize"\n  \n  mouseLeave: ->\n    document.getElementById("world").style.cursor = "auto"\n\n  ###\n  adoptWidgetsColor: (paneColor) ->\n    super adoptWidgetsColor paneColor\n    @color = paneColord\n\n  cursor: ->\n    if @owner.direction == "#horizontal"\n      Cursor.resizeLeft()\n    else\n      Cursor.resizeTop()\n  ###\n\n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n    if @preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = @alpha\n\n      # paintRectangle here is made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, this is why\n      # it\'s called before the scaling.\n      @paintRectangle aContext, al, at, w, h, @color\n      aContext.scale pixelRatio, pixelRatio\n\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n      aContext.fillStyle = @color.toString()\n      \n      centerX = @bounds.width() / 2\n      centerY = @bounds.height() / 2\n      radius = Math.min centerX, centerY\n      radius = radius - radius / 20\n      aContext.beginPath()\n      aContext.arc centerX, centerY, radius, 0, 2 * Math.PI, false\n      aContext.fillStyle = \'Gray\'\n      aContext.fill()\n      aContext.closePath()\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio (i.e. after the restore)\n      @paintHighlight aContext, al, at, w, h\n\n';
