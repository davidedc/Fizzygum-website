// Generated by CoffeeScript 1.10.0
window.UpperRightTriangleAppearance_coffeSource = '# UpperRightTriangleAppearance //////////////////////////////////////////////////////////////\n\nclass UpperRightTriangleAppearance extends Appearance\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  constructor: (morph) ->\n    super morph\n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if @morph.preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = @morph.alpha\n\n      aContext.scale pixelRatio, pixelRatio\n      morphPosition = @morph.position()\n      aContext.translate morphPosition.x, morphPosition.y\n\n      @renderingHelper aContext, @morph.color\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio (i.e. after the restore)\n      @paintHighlight aContext, al, at, w, h\n\n  renderingHelper: (context, color) ->\n    context.lineWidth = 1\n    context.lineCap = "round"\n\n    # give it a good shadow so that\n    # it\'s visible also when on light\n    # background. Do that by painting it\n    # twice, slightly translated, in\n    # darker color.\n    context.save()\n\n    context.fillStyle = color.toString()\n\n    context.beginPath()\n    context.moveTo 0, 0\n    context.lineTo @morph.width(), @morph.height()\n    context.lineTo @morph.width(), 0\n    context.closePath()\n    context.fill()\n\n    context.restore()\n\n  isTransparentAt: (aPoint) ->\n    # first quickly check if the point is even\n    # within the bounding box\n    if !@morph.boundsContainPoint aPoint\n      return true\n \n    thisMorphPosition = @morph.position()\n \n    relativePoint = new Point aPoint.x - thisMorphPosition.x, aPoint.y - thisMorphPosition.y\n\n    if relativePoint.x / relativePoint.y < @morph.width()/@morph.height()\n      return true\n\n\n    return false\n\n';
