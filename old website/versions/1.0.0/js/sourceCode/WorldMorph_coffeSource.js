// Generated by CoffeeScript 1.10.0
window.WorldMorph_coffeSource = '# WorldMorph //////////////////////////////////////////////////////////\n\n# these comments below needed to figure out dependencies between classes\n# REQUIRES globalFunctions\n# REQUIRES PreferencesAndSettings\n# REQUIRES Color\n# REQUIRES ProfilingDataCollector\n# REQUIRES SystemTestsControlPanelUpdater\n\n# The WorldMorph takes over the canvas on the page\nclass WorldMorph extends FrameMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  # We need to add and remove\n  # the event listeners so we are\n  # going to put them all in properties\n  # here.\n  # dblclickEventListener: null\n  mousedownEventListener: null\n  touchstartEventListener: null\n  mouseupEventListener: null\n  touchendEventListener: null\n  mousemoveEventListener: null\n  touchmoveEventListener: null\n  gesturestartEventListener: null\n  gesturechangeEventListener: null\n  contextmenuEventListener: null\n  # Note how there can be two handlers for\n  # keyboard events.\n  # This one is attached\n  # to the canvas and reaches the currently\n  # blinking caret if there is one.\n  # See below for the other potential\n  # handler. See "initVirtualKeyboard"\n  # method to see where and when this input and\n  # these handlers are set up.\n  keydownEventListener: null\n  keyupEventListener: null\n  keypressEventListener: null\n  mousewheelEventListener: null\n  DOMMouseScrollEventListener: null\n  copyEventListener: null\n  pasteEventListener: null\n  clipboardTextIfTestRunning: null\n  errorConsole: null\n\n  # the string for the last serialised morph\n  # is kept in here, to make serialization\n  # and deserialization tests easier.\n  # The alternative would be to refresh and\n  # re-start the tests from where they left...\n  lastSerializationString: ""\n\n  # Note how there can be two handlers\n  # for keyboard events. This one is\n  # attached to a hidden\n  # "input" div which keeps track of the\n  # text that is being input.\n  inputDOMElementForVirtualKeyboardKeydownEventListener: null\n  inputDOMElementForVirtualKeyboardKeyupEventListener: null\n  inputDOMElementForVirtualKeyboardKeypressEventListener: null\n\n  keyComboResetWorldEventListener: null\n  keyComboTurnOnAnimationsPacingControl: null\n  keyComboTurnOffAnimationsPacingControl: null\n  keyComboTakeScreenshotEventListener: null\n  keyComboStopTestRecordingEventListener: null\n  keyComboTakeScreenshotEventListener: null\n  keyComboCheckStringsOfItemsInMenuOrderImportant: null\n  keyComboCheckStringsOfItemsInMenuOrderUnimportant: null\n  keyComboAddTestCommentEventListener: null\n  keyComboCheckNumberOfMenuItemsEventListener: null\n\n  dragoverEventListener: null\n  dropEventListener: null\n  resizeEventListener: null\n  otherTasksToBeRunOnStep: []\n\n  # these variables shouldn\'t be static to the WorldMorph, because\n  # in pure theory you could have multiple worlds in the same\n  # page with different settings\n  # (but anyways, it was global before, so it\'s not any worse than before)\n  @preferencesAndSettings: null\n  @currentTime: null\n  showRedraws: false\n  doubleCheckCachedMethodsResults: false\n  automatorRecorderAndPlayer: null\n\n  # this is the actual reference to the canvas\n  # on the html page, where the world is\n  # finally painted to.\n  worldCanvas: null\n  worldCanvasContext: null\n\n  canvasForTextMeasurements: null\n  canvasContextForTextMeasurements: null\n  cacheForTextMeasurements: null\n  cacheForTextParagraphSplits: null\n  cacheForParagraphsWordsSplits: null\n  cacheForParagraphsWrappingData: null\n  cacheForTextWrappingData: null\n  cacheForTextBreakingIntoLinesTopLevel: null\n\n  # By default the world will always fill\n  # the entire page, also when browser window\n  # is resized.\n  # When this flag is set, the onResize callback\n  # automatically adjusts the world size.\n  automaticallyAdjustToFillEntireBrowserAlsoOnResize: true\n\n  # keypad keys map to special characters\n  # so we can trigger test actions\n  # see more comments below\n  @KEYPAD_TAB_mappedToThaiKeyboard_A: "ฟ"\n  @KEYPAD_SLASH_mappedToThaiKeyboard_B: "ิ"\n  @KEYPAD_MULTIPLY_mappedToThaiKeyboard_C: "แ"\n  @KEYPAD_DELETE_mappedToThaiKeyboard_D: "ก"\n  @KEYPAD_7_mappedToThaiKeyboard_E: "ำ"\n  @KEYPAD_8_mappedToThaiKeyboard_F: "ด"\n  @KEYPAD_9_mappedToThaiKeyboard_G: "เ"\n  @KEYPAD_MINUS_mappedToThaiKeyboard_H: "้"\n  @KEYPAD_4_mappedToThaiKeyboard_I: "ร"\n  @KEYPAD_5_mappedToThaiKeyboard_J: "่" # looks like empty string but isn\'t :-)\n  @KEYPAD_6_mappedToThaiKeyboard_K: "า"\n  @KEYPAD_PLUS_mappedToThaiKeyboard_L: "ส" \n  @KEYPAD_1_mappedToThaiKeyboard_M: "ท"\n  @KEYPAD_2_mappedToThaiKeyboard_N: "ท"\n  @KEYPAD_3_mappedToThaiKeyboard_O: "ื"\n  @KEYPAD_ENTER_mappedToThaiKeyboard_P: "น"\n  @KEYPAD_0_mappedToThaiKeyboard_Q: "ย"\n  @KEYPAD_DOT_mappedToThaiKeyboard_R: "พ"\n\n  morphsDetectingClickOutsideMeOrAnyOfMeChildren: []\n  hierarchyOfClickedMorphs: []\n  markedForDestruction: []\n  freshlyCreatedMenus: []\n  openMenus: []\n\n  # boot-up state machine\n  @BOOT_COMPLETE: 2\n  @EXECUTING_URL_ACTIONS: 1\n  @JUST_STARTED: 0\n  @bootState: 0\n  @ongoingUrlActionNumber: 0\n\n  @frameCount: 0\n  @numberOfAddsAndRemoves: 0\n  @numberOfVisibilityFlagsChanges: 0\n  @numberOfCollapseFlagsChanges: 0\n  @numberOfRawMovesAndResizes: 0\n\n  broken: null\n  duplicatedBrokenRectsTracker: null\n  numberOfDuplicatedBrokenRects: 0\n  numberOfMergedSourceAndDestination: 0\n\n  morphsToBeHighlighted: []\n  currentHighlightingMorphs: []\n  morphsBeingHighlighted: []\n\n  morphsToBePinouted: []\n  currentPinoutingMorphs: []\n  morphsBeingPinouted: []\n\n  steppingMorphs: []\n\n  underTheCarpetMorph: null\n\n  events: []\n\n  # Some operations are triggered by a callback\n  # actioned via a timeout\n  # e.g. see the cut and paste callbacks.\n  # In such cases, we count how many outstanding\n  # callbacks there are of this kind\n  # (by adding elements to this stack when the\n  # callback is scheduled, and popping them when\n  # the callback is executed), so that\n  # we can tell the automator player to PAUSE\n  # execution of actions until the scheduled\n  # callbacks are called. This is so turbo-mode macros\n  # can be still run at maximum speed.\n  # The alternative is to run at normal speed the\n  # macros containing such cases, which\n  # indeed would also take care of the problem\n  # (as the callbacks are likely satisfied at running\n  # time in the same span of time as when the macro\n  # was recorded), but the "slow-play"\n  # solution is more ad-hoc and is much much slower.\n  outstandingTimerTriggeredOperationsCounter: []\n\n  isFloatDraggable: ->\n    return false\n\n\n  constructor: (\n      @worldCanvas,\n      @automaticallyAdjustToFillEntireBrowserAlsoOnResize = true\n      ) ->\n\n    # The WorldMorph is the very first morph to\n    # be created.\n\n    # We first need to initialise\n    # some Color constants, like\n    #   Color.red\n    # See the comment at the beginning of the\n    # color class on why this piece of code\n    # is here instead of somewhere else.\n    for colorName, colorValue of Color.colourNamesValues\n      Color["#{colorName}"] = new Color colorValue[0], colorValue[1], colorValue[2]\n    # The colourNamesValues data structure is\n    # redundant at this point.\n    delete Color.colourNamesValues\n\n    super()\n    WorldMorph.preferencesAndSettings = new PreferencesAndSettings()\n    console.log WorldMorph.preferencesAndSettings.menuFontName\n    @color = new Color 205, 205, 205 # (130, 130, 130)\n    @alpha = 1\n\n    # additional properties:\n    @stamp = Date.now() # reference in multi-world setups\n    @isDevMode = false\n    @hand = new HandMorph @\n    @keyboardEventsReceiver = null\n    @lastEditedText = null\n    @caret = null\n    @temporaryHandlesAndLayoutAdjusters = []\n    @inputDOMElementForVirtualKeyboard = null\n\n    if @automaticallyAdjustToFillEntireBrowserAlsoOnResize and !window.location.href.contains "worldWithSystemTestHarness"\n      @stretchWorldToFillEntirePage()\n    else\n      @sizeCanvasToTestScreenResolution()\n\n    # @worldCanvas.width and height here are in phisical pixels\n    # so we want to bring them back to logical pixels\n    @silentRawSetBounds new Rectangle 0, 0, @worldCanvas.width / pixelRatio, @worldCanvas.height / pixelRatio\n\n    @initEventListeners()\n    @automatorRecorderAndPlayer = new AutomatorRecorderAndPlayer @, @hand\n\n    @worldCanvasContext = @worldCanvas.getContext "2d"\n\n    @canvasForTextMeasurements = newCanvas()\n    @canvasContextForTextMeasurements = @canvasForTextMeasurements.getContext "2d"\n    @canvasContextForTextMeasurements.scale pixelRatio, pixelRatio\n    @canvasContextForTextMeasurements.textAlign = "left"\n    @canvasContextForTextMeasurements.textBaseline = "bottom"\n\n    # when using an inspector it\'s not uncommon to render\n    # 400 labels just for the properties, so trying to size\n    # the cache accordingly...\n    @cacheForTextMeasurements = new LRUCache 1000, 1000*60*60*24\n    @cacheForTextParagraphSplits = new LRUCache 300, 1000*60*60*24\n    @cacheForParagraphsWordsSplits = new LRUCache 300, 1000*60*60*24\n    @cacheForParagraphsWrappingData = new LRUCache 300, 1000*60*60*24\n    @cacheForTextWrappingData = new LRUCache 300, 1000*60*60*24\n    @cacheForImmutableBackBuffers = new LRUCache 1000, 1000*60*60*24\n    @cacheForTextBreakingIntoLinesTopLevel = new LRUCache 10, 1000*60*60*24\n\n\n    @changed()\n\n  boot: ->\n\n    if !window.location.href.contains "worldWithSystemTestHarness"\n      @contextMenu= ->\n        if @isDevMode\n          menu = new MenuMorph false, @, true, true, "Fizzygum"\n        else\n          menu = new MenuMorph false, @, true, true, "Morphic"\n        if @isDevMode\n          menu.addItem "parts bin ➜", false, @, "popUpDemoMenu", "sample morphs"\n          menu.addItem "delete all", true, @, "fullDestroy"\n        menu\n      @setColor new Color 244,243,244\n\n\n    # boot-up state machine\n    console.log "booting"\n    @underTheCarpetMorph = new UnderTheCarpetMorph()\n    WorldMorph.bootState = WorldMorph.JUST_STARTED\n\n    ProfilingDataCollector.enableProfiling()\n    ProfilingDataCollector.enableBrokenRectsProfiling()\n\n    WorldMorph.ongoingUrlActionNumber= 0\n    startupActions = getParameterByName "startupActions"\n    console.log "startupActions: " + startupActions\n    if startupActions?\n      @nextStartupAction()\n\n    if !window.location.href.contains "worldWithSystemTestHarness"\n      @errorConsole = new ErrorsLogViewerMorph "Errors", @, "modifyCodeToBeInjected", "no errors yet, phewww!"\n      @add @errorConsole\n      @errorConsole.fullRawMoveTo new Point 190,10\n      @errorConsole.rawSetExtent new Point 550,415\n      @errorConsole.hide()\n\n      welcomeTitle = new StringMorph2 "Welcome to Fizzygum!"\n      welcomeTitle.isEditable = true\n      @add welcomeTitle\n      welcomeTitle.togglefittingSpecWhenBoundsTooLarge()\n      welcomeTitle.fullRawMoveTo new Point 40, 15\n      welcomeTitle.rawSetExtent new Point 271, 35\n\n      version = new StringMorph2 "version 2017-05-26"\n      version.isEditable = true\n      @add version\n      version.togglefittingSpecWhenBoundsTooLarge()\n      version.fullRawMoveTo new Point 41, 47\n      version.rawSetExtent new Point 134, 15\n\n      welcomeMessage = """\n      ...a small dynamic web desktop environment for experimenting with live programming, prototyping and mashups.\n\n      Right-click on the desktop to try more widgets!\n      """\n\n      welcomeBody = new TextMorph2 welcomeMessage,null,null,null,null,null,null,null\n      welcomeBody.isEditable = true\n      @add welcomeBody\n      welcomeBody.fullRawMoveTo new Point 37, 80\n      welcomeBody.rawSetExtent new Point 340, 175\n\n      reconfPaint = new ReconfigurablePaintMorph()\n      @add reconfPaint\n      reconfPaint.fullRawMoveTo new Point 35, 275\n      reconfPaint.setExtent new Point 460, 400\n\n      fmm = new FridgeMagnetsMorph()\n      @add fmm\n      fmm.fullRawMoveTo new Point 505, 275\n      fmm.setExtent new Point 570, 400\n\n      acm = new AnalogClockMorph()\n      @add acm\n      acm.fullRawMoveTo new Point 860, 40\n      acm.setExtent new Point 200, 200\n\n  # some test urls:\n\n  # this one contains two actions, two tests each, but only\n  # the second test is run for the second group.\n  # file:///Users/daviddellacasa/Fizzygum/Fizzygum-builds/latest/worldWithSystemTestHarness.html?startupActions=%7B%0D%0A++%22paramsVersion%22%3A+0.1%2C%0D%0A++%22actions%22%3A+%5B%0D%0A++++%7B%0D%0A++++++%22name%22%3A+%22runTests%22%2C%0D%0A++++++%22testsToRun%22%3A+%5B%22bubble%22%5D%0D%0A++++%7D%2C%0D%0A++++%7B%0D%0A++++++%22name%22%3A+%22runTests%22%2C%0D%0A++++++%22testsToRun%22%3A+%5B%22shadow%22%2C+%22SystemTest_basicResize%22%5D%2C%0D%0A++++++%22numberOfGroups%22%3A+2%2C%0D%0A++++++%22groupToBeRun%22%3A+1%0D%0A++++%7D++%5D%0D%0A%7D\n  #\n  # just one simple quick test about shadows\n  #file:///Users/daviddellacasa/Fizzygum/Fizzygum-builds/latest/worldWithSystemTestHarness.html?startupActions=%7B%0A%20%20%22paramsVersion%22%3A%200.1%2C%0A%20%20%22actions%22%3A%20%5B%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%22name%22%3A%20%22runTests%22%2C%0A%20%20%20%20%20%20%22testsToRun%22%3A%20%5B%22shadow%22%5D%0A%20%20%20%20%7D%0A%20%20%5D%0A%7D\n\n  nextStartupAction: ->\n    startupActions = JSON.parse getParameterByName "startupActions"\n\n    if (!startupActions?) or (WorldMorph.ongoingUrlActionNumber == startupActions.actions.length)\n      WorldMorph.bootState = WorldMorph.BOOT_COMPLETE\n      WorldMorph.ongoingUrlActionNumber = 0\n      if window.location.href.indexOf("worldWithSystemTestHarness") != -1\n        if @automatorRecorderAndPlayer.atLeastOneTestHasBeenRun\n          if @automatorRecorderAndPlayer.allTestsPassedSoFar\n            document.getElementById("background").style.background = "green"\n\n    if WorldMorph.bootState == WorldMorph.BOOT_COMPLETE\n      return\n\n    console.log "nextStartupAction " + (WorldMorph.ongoingUrlActionNumber+1) + " / " + startupActions.actions.length\n\n    currentAction = startupActions.actions[WorldMorph.ongoingUrlActionNumber]\n    if currentAction.name == "runTests"\n      @automatorRecorderAndPlayer.selectTestsFromTagsOrTestNames(currentAction.testsToRun)\n\n      if currentAction.numberOfGroups?\n        @automatorRecorderAndPlayer.numberOfGroups = currentAction.numberOfGroups\n      else\n        @automatorRecorderAndPlayer.numberOfGroups = 1\n      if currentAction.groupToBeRun?\n        @automatorRecorderAndPlayer.groupToBeRun = currentAction.groupToBeRun\n      else\n        @automatorRecorderAndPlayer.groupToBeRun = 0\n\n      if currentAction.forceSlowTestPlaying?\n        @automatorRecorderAndPlayer.forceSlowTestPlaying = true\n      if currentAction.forceTurbo?\n        @automatorRecorderAndPlayer.forceTurbo = true\n      if currentAction.forceSkippingInBetweenMouseMoves?\n        @automatorRecorderAndPlayer.forceSkippingInBetweenMouseMoves = true\n      if currentAction.forceRunningInBetweenMouseMoves?\n        @automatorRecorderAndPlayer.forceRunningInBetweenMouseMoves = true\n\n      @automatorRecorderAndPlayer.runAllSystemTests()\n    WorldMorph.ongoingUrlActionNumber++\n\n  getMorphViaTextLabel: ([textDescription, occurrenceNumber, numberOfOccurrences]) ->\n    allCandidateMorphsWithSameTextDescription = \n      @allChildrenTopToBottomSuchThat (m) ->\n        m.getTextDescription() == textDescription\n\n    return allCandidateMorphsWithSameTextDescription[occurrenceNumber]\n\n  mostRecentlyCreatedMenu: ->\n    mostRecentMenu = null\n    mostRecentMenuID = -1\n\n    # we have to check which menus\n    # are actually open, because\n    # the destroy() function used\n    # everywhere is not recursive and\n    # that\'s where we update the @openMenus\n    # array so we have to doublecheck here\n    # note how we examine the array in reverse order\n    # because we might delete its elements\n    for i in [(@openMenus.length-1).. 0] by -1\n      if @openMenus[i].isOrphan()\n        @openMenus.splice i, 1\n\n    for eachMenu in @openMenus\n      if eachMenu.instanceNumericID >= mostRecentMenuID\n        mostRecentMenu = eachMenu\n    return mostRecentMenu\n\n  # see roundNumericIDsToNextThousand method in\n  # Morph for an explanation of why we need this\n  # method.\n  alignIDsOfNextMorphsInSystemTests: ->\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE\n      # Check which objects end with the word Morph\n      theWordMorph = "Morph"\n      listOfMorphsClasses = (Object.keys(window)).filter (i) ->\n        i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1\n      for eachMorphClass in listOfMorphsClasses\n        console.log "bumping up ID of class: " + eachMorphClass\n        window[eachMorphClass].roundNumericIDsToNextThousand?()\n\n  destroyMorphsMarkedForDestruction: ->\n    for eachMorph in @markedForDestruction\n      eachMorph.destroy()\n    @markedForDestruction = []\n  \n  # World Morph broken rects debugging\n  # not using it anywhere\n  brokenFor: (aMorph) ->\n    # private\n    fb = aMorph.fullBounds()\n    @broken.filter (rect) ->\n      rect.isIntersecting fb\n  \n  \n  # fullPaintIntoAreaOrBlitFromBackBuffer results into actual painting of pices of\n  # morphs done\n  # by the paintIntoAreaOrBlitFromBackBuffer function.\n  # The paintIntoAreaOrBlitFromBackBuffer function is defined in Morph.\n  fullPaintIntoAreaOrBlitFromBackBuffer: (aContext, aRect) ->\n    # invokes the Morph\'s fullPaintIntoAreaOrBlitFromBackBuffer, which has only three implementations:\n    #  * the default one by Morph which just invokes the paintIntoAreaOrBlitFromBackBuffer of all children\n    #  * the interesting one in FrameMorph which a) narrows the dirty\n    #    rectangle (intersecting it with its border\n    #    since the FrameMorph clips at its border) and b) stops recursion on all\n    #    the children that are outside such intersection.\n    #  * this implementation which just takes into account that the hand\n    #    (which could contain a Morph being floatDragged)\n    #    is painted on top of everything.\n    super aContext, aRect\n    # the mouse cursor is always drawn on top of everything\n    # and it\'s not attached to the WorldMorph.\n    @hand.fullPaintIntoAreaOrBlitFromBackBuffer aContext, aRect\n\n  clippedThroughBounds: ->\n    @checkClippedThroughBoundsCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    @clippedThroughBoundsCache = @boundingBox()\n    return @clippedThroughBoundsCache\n\n  clipThrough: ->\n    @checkClipThroughCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    @clipThroughCache = @boundingBox()\n    return @clipThroughCache\n\n  pushBrokenRect: (brokenMorph, theRect, isSrc) ->\n    if @duplicatedBrokenRectsTracker[theRect.toString()]?\n      @numberOfDuplicatedBrokenRects++\n    else\n      if isSrc\n        brokenMorph.srcBrokenRect = @broken.length\n      else\n        brokenMorph.dstBrokenRect = @broken.length\n      if !theRect?\n        debugger\n      # if @broken.length == 0\n      #  debugger\n      @broken.push theRect\n    @duplicatedBrokenRectsTracker[theRect.toString()] = true\n\n  mergeBrokenRectsIfCloseOrPushBoth: (brokenMorph, sourceBroken, destinationBroken) ->\n    mergedBrokenRect = sourceBroken.merge destinationBroken\n    mergedBrokenRectArea = mergedBrokenRect.area()\n    sumArea = sourceBroken.area() + destinationBroken.area()\n    #console.log "mergedBrokenRectArea: " + mergedBrokenRectArea + " (sumArea + sumArea/10): " + (sumArea + sumArea/10)\n    if mergedBrokenRectArea < sumArea + sumArea/10\n      @pushBrokenRect brokenMorph, mergedBrokenRect, true\n      @numberOfMergedSourceAndDestination++\n    else\n      @pushBrokenRect brokenMorph, sourceBroken, true\n      @pushBrokenRect brokenMorph, destinationBroken, false\n\n\n  checkARectWithHyerarchy: (aRect, brokenMorph, isSrc) ->\n    brokenMorphAncestor = brokenMorph\n\n    #if brokenMorph instanceof SliderMorph\n    #  debugger\n\n    while brokenMorphAncestor.parent?\n      brokenMorphAncestor = brokenMorphAncestor.parent\n      if brokenMorphAncestor.srcBrokenRect?\n        if !@broken[brokenMorphAncestor.srcBrokenRect]?\n          debugger\n        if @broken[brokenMorphAncestor.srcBrokenRect].containsRectangle aRect\n          if isSrc\n            @broken[brokenMorph.srcBrokenRect] = null\n            brokenMorph.srcBrokenRect = null\n          else\n            @broken[brokenMorph.dstBrokenRect] = null\n            brokenMorph.dstBrokenRect = null\n        else if aRect.containsRectangle @broken[brokenMorphAncestor.srcBrokenRect]\n          @broken[brokenMorphAncestor.srcBrokenRect] = null\n          brokenMorphAncestor.srcBrokenRect = null\n\n      if brokenMorphAncestor.dstBrokenRect?\n        if !@broken[brokenMorphAncestor.dstBrokenRect]?\n          debugger\n        if @broken[brokenMorphAncestor.dstBrokenRect].containsRectangle aRect\n          if isSrc\n            @broken[brokenMorph.srcBrokenRect] = null\n            brokenMorph.srcBrokenRect = null\n          else\n            @broken[brokenMorph.dstBrokenRect] = null\n            brokenMorph.dstBrokenRect = null\n        else if aRect.containsRectangle @broken[brokenMorphAncestor.dstBrokenRect]\n          @broken[brokenMorphAncestor.dstBrokenRect] = null\n          brokenMorphAncestor.dstBrokenRect = null      \n\n\n  rectAlreadyIncludedInParentBrokenMorph: ->\n    for brokenMorph in window.morphsThatMaybeChangedGeometryOrPosition\n        if brokenMorph.srcBrokenRect?\n          aRect = @broken[brokenMorph.srcBrokenRect]\n          @checkARectWithHyerarchy aRect, brokenMorph, true\n        if brokenMorph.dstBrokenRect?\n          aRect = @broken[brokenMorph.dstBrokenRect]\n          @checkARectWithHyerarchy aRect, brokenMorph, false\n\n    for brokenMorph in window.morphsThatMaybeChangedFullGeometryOrPosition\n        if brokenMorph.srcBrokenRect?\n          aRect = @broken[brokenMorph.srcBrokenRect]\n          @checkARectWithHyerarchy aRect, brokenMorph\n        if brokenMorph.dstBrokenRect?\n          aRect = @broken[brokenMorph.dstBrokenRect]\n          @checkARectWithHyerarchy aRect, brokenMorph\n\n  cleanupSrcAndDestRectsOfMorphs: ->\n    for brokenMorph in window.morphsThatMaybeChangedGeometryOrPosition\n      brokenMorph.srcBrokenRect = null\n      brokenMorph.dstBrokenRect = null\n    for brokenMorph in window.morphsThatMaybeChangedFullGeometryOrPosition\n      brokenMorph.srcBrokenRect = null\n      brokenMorph.dstBrokenRect = null\n\n\n  fleshOutBroken: ->\n    #if window.morphsThatMaybeChangedGeometryOrPosition.length > 0\n    #  debugger\n\n    sourceBroken = null\n    destinationBroken = null\n\n    for brokenMorph in window.morphsThatMaybeChangedGeometryOrPosition\n\n      # let\'s see if this Morph that marked itself as broken\n      # was actually painted in the past frame.\n      # If it was then we have to clean up the "before" area\n      # even if the Morph is not visible anymore\n      if brokenMorph.clippedBoundsWhenLastPainted?\n        if brokenMorph.clippedBoundsWhenLastPainted.isNotEmpty()\n          sourceBroken = brokenMorph.clippedBoundsWhenLastPainted\n\n        #if brokenMorph!= world and (brokenMorph.clippedBoundsWhenLastPainted.containsPoint (new Point(10,10)))\n        #  debugger\n\n      # for the "destination" broken rectangle we can actually\n      # check whether the Morph is still visible because we\n      # can skip the destination rectangle in that case\n      # (not the source one!)\n      unless brokenMorph.surelyNotShowingUpOnScreenBasedOnVisibilityCollapseAndOrphanage()\n        # @clippedThroughBounds() should be smaller area\n        # than bounds because it clips\n        # the bounds based on the clipping morphs up the\n        # hierarchy\n        boundsToBeChanged = brokenMorph.clippedThroughBounds()\n\n        if boundsToBeChanged.isNotEmpty()\n          destinationBroken = boundsToBeChanged.spread()\n          #if brokenMorph!= world and (boundsToBeChanged.spread().containsPoint new Point 10, 10)\n          #  debugger\n\n\n      if sourceBroken? and destinationBroken?\n        @mergeBrokenRectsIfCloseOrPushBoth brokenMorph, sourceBroken, destinationBroken\n      else if sourceBroken? or destinationBroken?\n        if sourceBroken?\n          @pushBrokenRect brokenMorph, sourceBroken, true\n        else\n          @pushBrokenRect brokenMorph, destinationBroken, true\n\n      brokenMorph.geometryOrPositionPossiblyChanged = false\n      brokenMorph.clippedBoundsWhenLastPainted = null\n\n    \n\n  fleshOutFullBroken: ->\n    #if window.morphsThatMaybeChangedFullGeometryOrPosition.length > 0\n    #  debugger\n\n    sourceBroken = null\n    destinationBroken = null\n\n    for brokenMorph in window.morphsThatMaybeChangedFullGeometryOrPosition\n\n      if brokenMorph.fullClippedBoundsWhenLastPainted?\n        if brokenMorph.fullClippedBoundsWhenLastPainted.isNotEmpty()\n          sourceBroken = brokenMorph.fullClippedBoundsWhenLastPainted\n\n      # for the "destination" broken rectangle we can actually\n      # check whether the Morph is still visible because we\n      # can skip the destination rectangle in that case\n      # (not the source one!)\n      unless brokenMorph.surelyNotShowingUpOnScreenBasedOnVisibilityCollapseAndOrphanage()\n\n        boundsToBeChanged = brokenMorph.fullClippedBounds()\n\n        if boundsToBeChanged.isNotEmpty()\n          destinationBroken = boundsToBeChanged.spread()\n          #if brokenMorph!= world and (boundsToBeChanged.spread().containsPoint (new Point(10,10)))\n          #  debugger\n      \n   \n      if sourceBroken? and destinationBroken?\n        @mergeBrokenRectsIfCloseOrPushBoth brokenMorph, sourceBroken, destinationBroken\n      else if sourceBroken? or destinationBroken?\n        if sourceBroken?\n          @pushBrokenRect brokenMorph, sourceBroken, true\n        else\n          @pushBrokenRect brokenMorph, destinationBroken, true\n\n      brokenMorph.fullGeometryOrPositionPossiblyChanged = false\n      brokenMorph.fullClippedBoundsWhenLastPainted = null\n\n\n  showBrokenRects: (aContext) ->\n    aContext.save()\n    aContext.globalAlpha = 0.5\n    aContext.scale pixelRatio, pixelRatio\n \n    for eachBrokenRect in @broken\n      if eachBrokenRect?\n        randomR = Math.round Math.random() * 255\n        randomG = Math.round Math.random() * 255\n        randomB = Math.round Math.random() * 255\n\n        aContext.fillStyle = "rgb("+randomR+","+randomG+","+randomB+")"\n        aContext.fillRect  Math.round(eachBrokenRect.origin.x),\n            Math.round(eachBrokenRect.origin.y),\n            Math.round(eachBrokenRect.width()),\n            Math.round(eachBrokenRect.height())\n    aContext.restore()\n\n\n  # layouts are recalculated like so:\n  # there will be several subtrees\n  # that will need relayout.\n  # So take the head of any subtree and re-layout it\n  # The relayout might or might not visit all the subnodes\n  # of the subtree, because you might have a subtree\n  # that lives inside a floating morph, in which\n  # case it\'s not re-layout.\n  # So, a subtree might not be healed in one go,\n  # rather we keep track of what\'s left to heal and\n  # we apply the same process: we heal from the head node\n  # and take out of the list what\'s healed in that step,\n  # and we continue doing so until there is nothing else\n  # to heal.\n  recalculateLayouts: ->\n\n    until morphsThatMaybeChangedLayout.length == 0\n\n      # find the first Morph which has a broken layout,\n      # take out of queue all the others\n      loop\n        tryThisMorph = morphsThatMaybeChangedLayout[morphsThatMaybeChangedLayout.length - 1]\n        if tryThisMorph.layoutIsValid\n          morphsThatMaybeChangedLayout.pop()\n          if morphsThatMaybeChangedLayout.length == 0\n            return\n        else\n          break\n\n      # now that you have a Morph with a broken layout\n      # go up the chain of broken layouts as much as\n      # possible\n      # QUESTION: would it be safer instead to start from the\n      # very top invalid morph, i.e. on the way to the top,\n      # stop at the last morph with an invalid layout\n      # instead of stopping at the first morph with a\n      # valid layout...\n      while tryThisMorph.parent?\n        if tryThisMorph.parent.layoutIsValid\n          break\n        tryThisMorph = tryThisMorph.parent\n\n      # so now you have a "top" element up a chain\n      # of morphs with broken layout. Go do a\n      # doLayout on it, so it might fix a bunch of those\n      # on the chain (but not all)\n      tryThisMorph.doLayout()\n\n  clearGeometryOrPositionPossiblyChangedFlags: ->\n    for m in window.morphsThatMaybeChangedGeometryOrPosition\n      m.geometryOrPositionPossiblyChanged = false\n\n  clearFullGeometryOrPositionPossiblyChangedFlags: ->\n    for m in window.morphsThatMaybeChangedFullGeometryOrPosition\n      m.fullGeometryOrPositionPossiblyChanged = false\n\n  updateBroken: ->\n    #console.log "number of broken rectangles: " + @broken.length\n    @broken = []\n    @duplicatedBrokenRectsTracker = {}\n    @numberOfDuplicatedBrokenRects = 0\n    @numberOfMergedSourceAndDestination = 0\n\n    @fleshOutFullBroken()\n    @fleshOutBroken()\n    @rectAlreadyIncludedInParentBrokenMorph()\n    @cleanupSrcAndDestRectsOfMorphs()\n\n    @clearGeometryOrPositionPossiblyChangedFlags()\n    @clearFullGeometryOrPositionPossiblyChangedFlags()\n\n    window.morphsThatMaybeChangedGeometryOrPosition = []\n    window.morphsThatMaybeChangedFullGeometryOrPosition = []\n    #ProfilingDataCollector.profileBrokenRects @broken, @numberOfDuplicatedBrokenRects, @numberOfMergedSourceAndDestination\n\n    # each broken rectangle requires traversing the scenegraph to\n    # redraw what\'s overlapping it. Not all Morphs are traversed\n    # in particular the following can stop the recursion:\n    #  - invisible Morphs\n    #  - FrameMorphs that don\'t overlap the broken rectangle\n    # Since potentially there is a lot of traversal ongoin for\n    # each broken rectangle, one might want to consolidate overlapping\n    # and nearby rectangles.\n\n    window.healingRectanglesPhase = true\n    @broken.forEach (rect) =>\n      if !rect?\n        return\n      @fullPaintIntoAreaOrBlitFromBackBuffer @worldCanvasContext, rect  if rect.isNotEmpty()\n    if world.showRedraws\n      @showBrokenRects @worldCanvasContext\n\n    @broken = []\n    @duplicatedBrokenRectsTracker = {}\n    @numberOfDuplicatedBrokenRects = 0\n    @numberOfMergedSourceAndDestination = 0\n\n    window.healingRectanglesPhase = false\n    if trackChanges.length != 1 and trackChanges[0] != true\n      alert "trackChanges array should have only one element (true)"\n\n  addPinoutingMorphs: ->\n    for eachPinoutingMorph in @currentPinoutingMorphs.slice()\n      if eachPinoutingMorph.morphThisMorphIsPinouting in @morphsToBePinouted\n        if eachPinoutingMorph.morphThisMorphIsPinouting.hasMaybeChangedGeometryOrPosition()\n          # reposition the pinout morph if needed\n          peekThroughBox = eachPinoutingMorph.morphThisMorphIsPinouting.clippedThroughBounds()\n          eachPinoutingMorph.fullRawMoveTo new Point(peekThroughBox.right() + 10,peekThroughBox.top())\n\n      else\n        @currentPinoutingMorphs.remove eachPinoutingMorph\n        @morphsBeingPinouted.remove eachPinoutingMorph.morphThisMorphIsPinouting\n        eachPinoutingMorph.morphThisMorphIsPinouting = null\n        eachPinoutingMorph.destroy()\n\n    for eachMorphNeedingPinout in @morphsToBePinouted.slice()\n      if eachMorphNeedingPinout not in @morphsBeingPinouted\n        hM = new StringMorph2 eachMorphNeedingPinout.toString()\n        world.add hM\n        hM.morphThisMorphIsPinouting = eachMorphNeedingPinout\n        peekThroughBox = eachMorphNeedingPinout.clippedThroughBounds()\n        hM.fullRawMoveTo new Point(peekThroughBox.right() + 10,peekThroughBox.top())\n        hM.setColor new Color 0, 0, 255\n        hM.setWidth 400\n        @currentPinoutingMorphs.push hM\n        @morphsBeingPinouted.push eachMorphNeedingPinout\n  \n  addHighlightingMorphs: ->\n    for eachHighlightingMorph in @currentHighlightingMorphs.slice()\n      if eachHighlightingMorph.morphThisMorphIsHighlighting in @morphsToBeHighlighted\n        if eachHighlightingMorph.morphThisMorphIsHighlighting.hasMaybeChangedGeometryOrPosition()\n          eachHighlightingMorph.rawSetBounds eachHighlightingMorph.morphThisMorphIsHighlighting.clippedThroughBounds()\n      else\n        @currentHighlightingMorphs.remove eachHighlightingMorph\n        @morphsBeingHighlighted.remove eachHighlightingMorph.morphThisMorphIsHighlighting\n        eachHighlightingMorph.morphThisMorphIsHighlighting = null\n        eachHighlightingMorph.destroy()\n\n    for eachMorphNeedingHighlight in @morphsToBeHighlighted.slice()\n      if eachMorphNeedingHighlight not in @morphsBeingHighlighted\n        hM = new RectangleMorph()\n        world.add hM\n        hM.morphThisMorphIsHighlighting = eachMorphNeedingHighlight\n        hM.rawSetBounds eachMorphNeedingHighlight.clippedThroughBounds()\n        hM.setColor new Color 0, 0, 255\n        hM.setAlphaScaled 50\n        @currentHighlightingMorphs.push hM\n        @morphsBeingHighlighted.push eachMorphNeedingHighlight\n\n\n  playQueuedEvents: ->\n    for i in [0...@events.length] by 2\n      eventType = @events[i]\n      # note that these events are actually strings\n      # in the case of clipboard events. Since\n      # for security reasons clipboard access is not\n      # allowed outside of the event listener, we\n      # have to work with text here.\n      event = @events[i+1]\n\n      switch eventType\n\n        when "inputDOMElementForVirtualKeyboardKeydownEventListener"\n          @keyboardEventsReceiver.processKeyDown event  if @keyboardEventsReceiver\n\n          if event.keyIdentifier is "U+0009" or event.keyIdentifier is "Tab"\n            @keyboardEventsReceiver.processKeyPress event  if @keyboardEventsReceiver\n\n        when "inputDOMElementForVirtualKeyboardKeyupEventListener"\n          # dispatch to keyboard receiver\n          if @keyboardEventsReceiver\n            # so far the caret is the only keyboard\n            # event handler and it has no keyup\n            # handler\n            if @keyboardEventsReceiver.processKeyUp\n              @keyboardEventsReceiver.processKeyUp event  \n\n        when "inputDOMElementForVirtualKeyboardKeypressEventListener"\n          @keyboardEventsReceiver.processKeyPress event  if @keyboardEventsReceiver\n\n        when "mousedownEventListener"\n          @processMouseDown event.button, event.buttons, event.ctrlKey, event.shiftKey, event.altKey, event.metaKey\n\n        when "touchstartEventListener"\n          @hand.processTouchStart event\n\n        when "mouseupEventListener"\n          @processMouseUp  event.button, event.ctrlKey, event.buttons, event.shiftKey, event.altKey, event.metaKey\n\n        when "touchendEventListener"\n          @hand.processTouchEnd event\n\n        when "mousemoveEventListener"\n          posInDocument = getDocumentPositionOf @worldCanvas\n          # events from JS arrive in page coordinates,\n          # we turn those into world coordinates\n          # instead.\n          worldX = event.pageX - posInDocument.x\n          worldY = event.pageY - posInDocument.y\n          @processMouseMove worldX, worldY, event.button, event.buttons, event.ctrlKey, event.shiftKey, event.altKey, event.metaKey\n\n        when "touchmoveEventListener"\n          @hand.processTouchMove event\n\n        when "keydownEventListener"\n          @processKeydown event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n\n        when "keyupEventListener"\n          @processKeyup event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n\n        when "keypressEventListener"\n          @processKeypress event, event.keyCode, @getChar(event), event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n\n        when "mousewheelEventListener"\n          @hand.processMouseScroll event\n\n        when "DOMMouseScrollEventListener"\n          @hand.processMouseScroll event\n\n        when "cutEventListener"\n          # note that "event" here is actually a string,\n          # for security reasons clipboard access is not\n          # allowed outside of the event listener, we\n          # have to work with text here.\n          @processCut event\n\n        when "copyEventListener"\n          # note that "event" here is actually a string,\n          # for security reasons clipboard access is not\n          # allowed outside of the event listener, we\n          # have to work with text here.\n          @processCopy event\n\n        when "pasteEventListener"\n          # note that "event" here is actually a string,\n          # for security reasons clipboard access is not\n          # allowed outside of the event listener, we\n          # have to work with text here.\n          @processPaste event\n\n        when "dropEventListener"\n          @hand.processDrop event\n\n        when "resizeEventListener"\n          @stretchWorldToFillEntirePage()  if @automaticallyAdjustToFillEntireBrowserAlsoOnResize\n\n    @events = []\n\n\n  doOneCycle: ->\n    WorldMorph.currentTime = Date.now()\n    # console.log TextMorph.instancesCounter + " " + StringMorph.instancesCounter\n\n    @playQueuedEvents()\n\n    # most notably replays test actions at the right time\n    @runOtherTasksStepFunction()\n    \n    @runChildrensStepFunction()\n    @hand.reCheckMouseEntersAndMouseLeavesAfterPotentialGeometryChanges()\n    @recalculateLayouts()\n    @addPinoutingMorphs()\n    @addHighlightingMorphs()\n    @updateBroken()\n    WorldMorph.frameCount++\n\n  addSteppingMorph: (theMorph) ->\n    if @steppingMorphs.indexOf(theMorph) == -1\n      @steppingMorphs.push theMorph\n\n  removeSteppingMorph: (theMorph) ->\n    if @steppingMorphs.indexOf(theMorph) != -1\n      @steppingMorphs.remove theMorph\n\n  # Morph stepping:\n  runChildrensStepFunction: ->\n\n    # make a shallow copy of the array before iterating over\n    # it in the case some morph destroyes itself and takes itself\n    # out of the array thus changing it in place and mangling the\n    # stepping.\n    # TODO all these array modifications should be immutable...\n    steppingMorphs = arrayShallowCopy @steppingMorphs\n\n    for eachSteppingMorph in steppingMorphs\n      if eachSteppingMorph.isBeingFloatDragged()\n        continue\n      # for objects where @fps is defined, check which ones are due to be stepped\n      # and which ones want to wait.\n      elapsedMilliseconds = WorldMorph.currentTime - eachSteppingMorph.lastTime\n      if eachSteppingMorph.fps > 0\n        millisecondsRemainingToWaitedFrame = (1000 / eachSteppingMorph.fps) - elapsedMilliseconds\n      else\n        # if fps 0 or negative, then just run as fast as possible,\n        # so 0 milliseconds remaining to the next invokation\n        millisecondsRemainingToWaitedFrame = 0\n      \n      # We could fire at the exact due time or when the time is past by\n      # firing when remaining ms is <= 0\n      # Or like in this case we can fire slightly earlier so to compensate\n      # for when we come to fire late for one reason or the other.\n      # There is no excat science in choosing to fire\n      # a ms earlier here, it\'s quite random.\n      # This whole mechanism will need to be remade anyways.\n      if millisecondsRemainingToWaitedFrame <= 1\n        eachSteppingMorph.lastTime = WorldMorph.currentTime\n        if eachSteppingMorph.onNextStep\n          nxt = eachSteppingMorph.onNextStep\n          eachSteppingMorph.onNextStep = null\n          nxt.call eachSteppingMorph\n        if !eachSteppingMorph.step?\n          debugger\n        try\n          eachSteppingMorph.step()\n        catch err\n          @errorConsole.popUpWithError err\n\n\n  \n  runOtherTasksStepFunction : ->\n    for task in @otherTasksToBeRunOnStep\n      #console.log "running a task: " + task\n      task()\n\n  sizeCanvasToTestScreenResolution: ->\n    @worldCanvas.width = Math.round(960 * pixelRatio)\n    @worldCanvas.height = Math.round(440 * pixelRatio)\n    @worldCanvas.style.width = "960px"\n    @worldCanvas.style.height = "440px"\n\n    bkground = document.getElementById("background")\n    bkground.style.width = "960px"\n    bkground.style.height = "720px"\n    bkground.style.backgroundColor = "gb(245, 245, 245)"\n\n  stretchWorldToFillEntirePage: ->\n    pos = getDocumentPositionOf @worldCanvas\n    clientHeight = window.innerHeight\n    clientWidth = window.innerWidth\n    if pos.x > 0\n      @worldCanvas.style.position = "absolute"\n      @worldCanvas.style.left = "0px"\n      pos.x = 0\n    if pos.y > 0\n      @worldCanvas.style.position = "absolute"\n      @worldCanvas.style.top = "0px"\n      pos.y = 0\n    # scrolled down b/c of viewport scaling\n    clientHeight = document.documentElement.clientHeight  if document.body.scrollTop\n    # scrolled left b/c of viewport scaling\n    clientWidth = document.documentElement.clientWidth  if document.body.scrollLeft\n    if @worldCanvas.width isnt clientWidth\n      @worldCanvas.width = (clientWidth * pixelRatio)\n      @worldCanvas.style.width = clientWidth + "px"\n      @rawSetWidth clientWidth\n    if @worldCanvas.height isnt clientHeight\n      @worldCanvas.height = (clientHeight * pixelRatio)\n      @worldCanvas.style.height = clientHeight + "px"\n      @rawSetHeight clientHeight\n    @children.forEach (child) =>\n      child.reactToWorldResize? @boundingBox()\n  \n    \n  \n  # WorldMorph events:\n  initVirtualKeyboard: ->\n    if @inputDOMElementForVirtualKeyboard\n      document.body.removeChild @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard = null\n    unless (WorldMorph.preferencesAndSettings.isTouchDevice and WorldMorph.preferencesAndSettings.useVirtualKeyboard)\n      return\n    @inputDOMElementForVirtualKeyboard = document.createElement "input"\n    @inputDOMElementForVirtualKeyboard.type = "text"\n    @inputDOMElementForVirtualKeyboard.style.color = "transparent"\n    @inputDOMElementForVirtualKeyboard.style.backgroundColor = "transparent"\n    @inputDOMElementForVirtualKeyboard.style.border = "none"\n    @inputDOMElementForVirtualKeyboard.style.outline = "none"\n    @inputDOMElementForVirtualKeyboard.style.position = "absolute"\n    @inputDOMElementForVirtualKeyboard.style.top = "0px"\n    @inputDOMElementForVirtualKeyboard.style.left = "0px"\n    @inputDOMElementForVirtualKeyboard.style.width = "0px"\n    @inputDOMElementForVirtualKeyboard.style.height = "0px"\n    @inputDOMElementForVirtualKeyboard.autocapitalize = "none" # iOS specific\n    document.body.appendChild @inputDOMElementForVirtualKeyboard\n\n    @inputDOMElementForVirtualKeyboardKeydownEventListener = (event) =>\n      @events.push "inputDOMElementForVirtualKeyboardKeydownEventListener"\n      @events.push event\n      # Default in several browsers\n      # is for the backspace button to trigger\n      # the "back button", so we prevent that\n      # default here.\n      if event.keyIdentifier is "U+0008" or event.keyIdentifier is "Backspace"\n        event.preventDefault()  \n\n      # suppress tab override and make sure tab gets\n      # received by all browsers\n      if event.keyIdentifier is "U+0009" or event.keyIdentifier is "Tab"\n        event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keydown",\n      @inputDOMElementForVirtualKeyboardKeydownEventListener, false\n\n    @inputDOMElementForVirtualKeyboardKeyupEventListener = (event) =>\n      @events.push "inputDOMElementForVirtualKeyboardKeyupEventListener"\n      @events.push event\n      event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keyup",\n      @inputDOMElementForVirtualKeyboardKeyupEventListener, false\n\n    @inputDOMElementForVirtualKeyboardKeypressEventListener = (event) =>\n      @events.push "inputDOMElementForVirtualKeyboardKeypressEventListener"\n      @events.push event\n      event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keypress",\n      @inputDOMElementForVirtualKeyboardKeypressEventListener, false\n\n  getPointerAndMorphInfo:  (topMorphUnderPointer = @hand.topMorphUnderPointer()) ->\n    # we might eliminate this command afterwards if\n    # we find out user is clicking on a menu item\n    # or right-clicking on a morph\n    absoluteBoundsOfMorphRelativeToWorld = topMorphUnderPointer.boundingBox().asArray_xywh()\n    morphIdentifierViaTextLabel = topMorphUnderPointer.identifyViaTextLabel()\n    morphPathRelativeToWorld = topMorphUnderPointer.pathOfChildrenPositionsRelativeToWorld()\n    pointerPositionFractionalInMorph = @hand.pointerPositionFractionalInMorph topMorphUnderPointer\n    pointerPositionPixelsInMorph = @hand.pointerPositionPixelsInMorph topMorphUnderPointer\n    # note that this pointer position is in world\n    # coordinates not in page coordinates\n    pointerPositionPixelsInWorld = @hand.position()\n    isPartOfListMorph = (topMorphUnderPointer.parentThatIsA ListMorph)?\n    return [ topMorphUnderPointer.uniqueIDString(), morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph]\n\n\n  addMouseChangeCommand: (upOrDown, button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    pointerAndMorphInfo = @getPointerAndMorphInfo()\n    @automatorRecorderAndPlayer.addMouseChangeCommand upOrDown, button, buttons, ctrlKey, shiftKey, altKey, metaKey, pointerAndMorphInfo...\n\n\n  processMouseDown: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    # the recording of the test command (in case we are\n    # recording a test) is handled inside the function\n    # here below.\n    # This is different from the other methods similar\n    # to this one but there is a little bit of\n    # logic we apply in case there is a right-click,\n    # or user left or right-clicks on a menu,\n    # in which case we record a more specific test\n    # commands.\n    @addMouseChangeCommand "down", button, buttons, ctrlKey, shiftKey, altKey, metaKey\n    @hand.processMouseDown button, buttons, ctrlKey, shiftKey, altKey, metaKey\n\n  processMouseUp: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    # event.preventDefault()\n\n    @addMouseChangeCommand "up", button, buttons, ctrlKey, shiftKey, altKey, metaKey\n    @hand.processMouseUp button, buttons, ctrlKey, shiftKey, altKey, metaKey\n\n  processMouseMove: (pageX, pageY, button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    @hand.processMouseMove pageX, pageY, button, buttons, ctrlKey, shiftKey, altKey, metaKey\n    # "@hand.processMouseMove" could cause a Grab\n    # command to be issued, so we want to\n    # add the mouse move command here *after* the\n    # potential grab command.\n\n    if @hand.floatDraggingSomething()\n      if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n        action = "floatDrag"\n        arr = window.world.automatorRecorderAndPlayer.tagsCollectedWhileRecordingTest\n        if action not in arr\n          arr.push action\n    \n    @automatorRecorderAndPlayer.addMouseMoveCommand(pageX, pageY, @hand.floatDraggingSomething(), button, buttons, ctrlKey, shiftKey, altKey, metaKey)\n\n  # event.type must be keypress\n  getChar: (event) ->\n    unless event.which?\n      String.fromCharCode event.keyCode # IE\n    else if event.which isnt 0 and event.charCode isnt 0\n      String.fromCharCode event.which # the rest\n    else\n      null # special key\n\n  processKeydown: (event, scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    @automatorRecorderAndPlayer.addKeyDownCommand scanCode, shiftKey, ctrlKey, altKey, metaKey\n    if @keyboardEventsReceiver\n      @keyboardEventsReceiver.processKeyDown scanCode, shiftKey, ctrlKey, altKey, metaKey\n\n    # suppress backspace override\n    if event? and scanCode is 8\n      event.preventDefault()\n\n    # suppress tab override and make sure tab gets\n    # received by all browsers\n    if event? and scanCode is 9\n      if @keyboardEventsReceiver\n        @keyboardEventsReceiver.processKeyPress scanCode, "\\t", shiftKey, ctrlKey, altKey, metaKey\n      event.preventDefault()\n\n  processKeyup: (event, scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    @automatorRecorderAndPlayer.addKeyUpCommand scanCode, shiftKey, ctrlKey, altKey, metaKey\n    # dispatch to keyboard receiver\n    if @keyboardEventsReceiver\n      # so far the caret is the only keyboard\n      # event handler and it has no keyup\n      # handler\n      if @keyboardEventsReceiver.processKeyUp\n        @keyboardEventsReceiver.processKeyUp scanCode, shiftKey, ctrlKey, altKey, metaKey    \n    if event?\n      event.preventDefault()\n\n  processKeypress: (event, charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->\n    @automatorRecorderAndPlayer.addKeyPressCommand charCode, symbol, shiftKey, ctrlKey, altKey, metaKey\n    # This if block adapted from:\n    # http://stackoverflow.com/a/16033129\n    # it rejects the\n    # characters from the special\n    # test-command-triggering external\n    # keypad. Also there is a "00" key\n    # in such keypads which is implemented\n    # buy just a double-press of the zero.\n    # We manage that case - if that key is\n    # pressed twice we understand that it\'s\n    # that particular key. Managing this\n    # special case within Fizzygum\n    # is not best, but there aren\'t any\n    # good alternatives.\n    if event?\n      # don\'t manage external keypad if we are playing back\n      # the tests (i.e. when event is null)\n      if symbol == @constructor.KEYPAD_0_mappedToThaiKeyboard_Q\n        unless @doublePressOfZeroKeypadKey?\n          @doublePressOfZeroKeypadKey = 1\n          setTimeout (=>\n            if @doublePressOfZeroKeypadKey is 1\n              console.log "single keypress"\n            @doublePressOfZeroKeypadKey = null\n            event.keyCode = 0\n            return false\n          ), 300\n        else\n          @doublePressOfZeroKeypadKey = null\n          console.log "double keypress"\n          event.keyCode = 0\n        return false\n\n    if @keyboardEventsReceiver\n      @keyboardEventsReceiver.processKeyPress charCode, symbol, shiftKey, ctrlKey, altKey, metaKey\n    if event?\n      event.preventDefault()\n\n  # -----------------------------------------------------\n  # clipboard events processing\n  # -----------------------------------------------------\n  # clipboard events take a text instead of the event,\n  # the reason is that you can\'t access the clipboard\n  # outside of the EventListener, I presume for\n  # security reasons. So, since these process* methods\n  # are executed outside of the listeners, we really can\'t use\n  # the event and the clipboard object in the event, so\n  # we have to work with text. The clipboard IS handled, but\n  # it\'s handled in the listeners\n\n  processCut: (selectedText) ->\n    console.log "processing cut"\n    if @caret\n      # see comment on outstandingTimerTriggeredOperationsCounter\n      # above where the property is declared and initialised.\n      @outstandingTimerTriggeredOperationsCounter.push true\n      window.setTimeout ( =>\n       @caret.deleteLeft()\n       @outstandingTimerTriggeredOperationsCounter.pop()\n      ), 50, true\n\n    @automatorRecorderAndPlayer.addCutCommand selectedText\n\n  processCopy: (selectedText) ->\n    console.log "processing copy"\n    debugger\n    @automatorRecorderAndPlayer.addCopyCommand selectedText\n\n  processPaste: (clipboardText) ->\n    debugger\n      \n    if @caret\n      # Needs a few msec to execute paste\n      console.log "about to insert text: " + clipboardText\n      @automatorRecorderAndPlayer.addPasteCommand clipboardText\n\n      # see comment on outstandingTimerTriggeredOperationsCounter\n      # above where the property is declared and initialised.\n      @outstandingTimerTriggeredOperationsCounter.push true\n      window.setTimeout ( =>\n       @caret.insert clipboardText\n       @outstandingTimerTriggeredOperationsCounter.pop()\n      ), 50, true\n\n\n  # note that we don\'t register the normal click,\n  # we figure that out independently.\n  initEventListeners: ->\n    canvas = @worldCanvas\n\n    # there is indeed a "dblclick" JS event\n    # but we reproduce it internally.\n    # The reason is that we do so for "click"\n    # because we want to check that the mouse\n    # button was released in the same morph\n    # where it was pressed (cause in the DOM you\'d\n    # be pressing and releasing on the same\n    # element i.e. the canvas anyways\n    # so we receive clicks even though they aren\'t\n    # so we have to take care of the processing\n    # ourselves).\n    # So we also do the same internal\n    # processing for dblclick.\n    # Hence, don\'t register this event listener\n    # below...\n    #@dblclickEventListener = (event) =>\n    #  event.preventDefault()\n    #  @hand.processDoubleClick event\n    #canvas.addEventListener "dblclick", @dblclickEventListener, false\n\n    @mousedownEventListener = (event) =>\n      @events.push "mousedownEventListener"\n      @events.push event\n\n    canvas.addEventListener "mousedown", @mousedownEventListener, false\n\n    @touchstartEventListener = (event) =>\n      @events.push "touchstartEventListener"\n      @events.push event\n\n    canvas.addEventListener "touchstart", @touchstartEventListener , false\n    \n    @mouseupEventListener = (event) =>\n      @events.push "mouseupEventListener"\n      @events.push event\n\n    canvas.addEventListener "mouseup", @mouseupEventListener, false\n    \n    @touchendEventListener = (event) =>\n      @events.push "touchendEventListener"\n      @events.push event\n\n    canvas.addEventListener "touchend", @touchendEventListener, false\n    \n    @mousemoveEventListener = (event) =>\n      @events.push "mousemoveEventListener"\n      @events.push event\n\n    canvas.addEventListener "mousemove", @mousemoveEventListener, false\n    \n    @touchmoveEventListener = (event) =>\n      @events.push "touchmoveEventListener"\n      @events.push event\n\n    canvas.addEventListener "touchmove", @touchmoveEventListener, false\n    \n    @gesturestartEventListener = (event) =>\n      # Disable browser zoom\n      event.preventDefault()\n    canvas.addEventListener "gesturestart", @gesturestartEventListener, false\n    \n    @gesturechangeEventListener = (event) =>\n      # Disable browser zoom\n      event.preventDefault()\n    canvas.addEventListener "gesturechange", @gesturechangeEventListener, false\n    \n    @contextmenuEventListener = (event) ->\n      # suppress context menu for Mac-Firefox\n      event.preventDefault()\n    canvas.addEventListener "contextmenu", @contextmenuEventListener, false\n    \n    @keydownEventListener = (event) =>\n      @events.push "keydownEventListener"\n      @events.push event\n\n      # this paragraph is to prevent the browser going\n      # "back button" when the user presses delete backspace.\n      # taken from http://stackoverflow.com/a/2768256\n      doPrevent = false\n      if event.keyCode == 8\n        d = event.srcElement or event.target\n        if d.tagName.toUpperCase() == \'INPUT\' and\n        (d.type.toUpperCase() == \'TEXT\' or\n          d.type.toUpperCase() == \'PASSWORD\' or\n          d.type.toUpperCase() == \'FILE\' or\n          d.type.toUpperCase() == \'SEARCH\' or\n          d.type.toUpperCase() == \'EMAIL\' or\n          d.type.toUpperCase() == \'NUMBER\' or\n          d.type.toUpperCase() == \'DATE\') or\n        d.tagName.toUpperCase() == \'TEXTAREA\'\n          doPrevent = d.readOnly or d.disabled\n        else\n          doPrevent = true\n      if doPrevent\n        event.preventDefault()\n\n    canvas.addEventListener "keydown", @keydownEventListener, false\n\n    @keyupEventListener = (event) =>\n      @events.push "keyupEventListener"\n      @events.push event\n\n    canvas.addEventListener "keyup", @keyupEventListener, false\n\n    # This method also handles keypresses from a special\n    # external keypad which is used to\n    # record tests commands (such as capture screen, etc.).\n    # These external keypads are inexpensive\n    # so they are a good device for this kind\n    # of stuff.\n    # http://www.amazon.co.uk/Perixx-PERIPAD-201PLUS-Numeric-Keypad-Laptop/dp/B001R6FZLU/\n    # They keypad is mapped\n    # to Thai keyboard characters via an OSX app\n    # called keyremap4macbook (also one needs to add the\n    # Thai keyboard, which is just a click from System Preferences)\n    # Those Thai characters are used to trigger test\n    # commands. The only added complexity is about\n    # the "00" key of such keypads - see\n    # note below.\n    doublePressOfZeroKeypadKey: null\n    \n    @keypressEventListener = (event) =>\n      @events.push "keypressEventListener"\n      @events.push event\n\n    canvas.addEventListener "keypress", @keypressEventListener, false\n\n    # Safari, Chrome\n    \n    @mousewheelEventListener = (event) =>\n      @events.push "mousewheelEventListener"\n      @events.push event\n      event.preventDefault()\n\n    canvas.addEventListener "mousewheel", @mousewheelEventListener, false\n    # Firefox\n    \n    @DOMMouseScrollEventListener = (event) =>\n      @events.push "DOMMouseScrollEventListener"\n      @events.push event\n      event.preventDefault()\n\n    canvas.addEventListener "DOMMouseScroll", @DOMMouseScrollEventListener, false\n\n    # in theory there should be no scroll event on the page\n    # window.addEventListener "scroll", ((event) =>\n    #  nop # nothing to do, I just need this to set an interrupt point.\n    # ), false\n\n    # snippets of clipboard-handling code taken from\n    # http://codebits.glennjones.net/editing/setclipboarddata.htm\n    # Note that this works only in Chrome. Firefox and Safari need a piece of\n    # text to be selected in order to even trigger the copy event. Chrome does\n    # enable clipboard access instead even if nothing is selected.\n    # There are a couple of solutions to this - one is to keep a hidden textfield that\n    # handles all copy/paste operations.\n    # Another one is to not use a clipboard, but rather an internal string as\n    # local memory. So the OS clipboard wouldn\'t be used, but at least there would\n    # be some copy/paste working. Also one would need to intercept the copy/paste\n    # key combinations manually instead of from the copy/paste events.\n\n    # -----------------------------------------------------\n    # clipboard events listeners\n    # -----------------------------------------------------\n    # we deal with the clipboard here in the event listeners\n    # because for security reasons the runtime is not allowed\n    # access to the clipboards outside of here. So we do all\n    # we have to do with the clipboard here, and in every\n    # other place we work with text.\n\n    @cutEventListener = (event) =>\n      selectedText = ""\n      if @caret\n        selectedText = @caret.target.selection()\n        if event?.clipboardData\n          event.preventDefault()\n          setStatus = event.clipboardData.setData "text/plain", selectedText\n\n        if window.clipboardData\n          event.returnValue = false\n          setStatus = window.clipboardData.setData "Text", selectedText\n\n      @events.push "cutEventListener"\n      @events.push selectedText\n\n    document.body.addEventListener "cut", @cutEventListener, false\n    \n    @copyEventListener = (event) =>\n      debugger\n\n      selectedText = ""\n      if @caret\n        if clipboardTextIfTestRunning?\n          selectedText = clipboardTextIfTestRunning\n        else\n          selectedText = @caret.target.selection()\n        if event?.clipboardData\n          event.preventDefault()\n          setStatus = event.clipboardData.setData "text/plain", selectedText\n\n        if window.clipboardData\n          event.returnValue = false\n          setStatus = window.clipboardData.setData "Text", selectedText\n\n      @events.push "copyEventListener"\n      @events.push selectedText\n\n    document.body.addEventListener "copy", @copyEventListener, false\n\n    @pasteEventListener = (event) =>\n      debugger\n\n      if @caret\n        if event?\n          if event.clipboardData\n            # Look for access to data if types array is missing\n            text = event.clipboardData.getData "text/plain"\n            #url = event.clipboardData.getData("text/uri-list")\n            #html = event.clipboardData.getData("text/html")\n            #custom = event.clipboardData.getData("text/xcustom")\n          # IE event is attached to the window object\n          if window.clipboardData\n            # The schema is fixed\n            text = window.clipboardData.getData "Text"\n            #url = window.clipboardData.getData "URL"\n\n      @events.push "pasteEventListener"\n      @events.push text\n\n    document.body.addEventListener "paste", @pasteEventListener, false\n\n    #console.log "binding via mousetrap"\n\n    @keyComboResetWorldEventListener = (event) =>\n      @automatorRecorderAndPlayer.resetWorld()\n      false\n    Mousetrap.bind ["alt+d"], @keyComboResetWorldEventListener\n\n    @keyComboTurnOnAnimationsPacingControl = (event) =>\n      @automatorRecorderAndPlayer.turnOnAnimationsPacingControl()\n      false\n    Mousetrap.bind ["alt+e"], @keyComboTurnOnAnimationsPacingControl\n\n    @keyComboTurnOffAnimationsPacingControl = (event) =>\n      @automatorRecorderAndPlayer.turnOffAnimationsPacingControl()\n      false\n    Mousetrap.bind ["alt+u"], @keyComboTurnOffAnimationsPacingControl\n\n    @keyComboTakeScreenshotEventListener = (event) =>\n      @automatorRecorderAndPlayer.takeScreenshot()\n      false\n    Mousetrap.bind ["alt+c"], @keyComboTakeScreenshotEventListener\n\n    @keyComboStopTestRecordingEventListener = (event) =>\n      @automatorRecorderAndPlayer.stopTestRecording()\n      false\n    Mousetrap.bind ["alt+t"], @keyComboStopTestRecordingEventListener\n\n    @keyComboAddTestCommentEventListener = (event) =>\n      @automatorRecorderAndPlayer.addTestComment()\n      false\n    Mousetrap.bind ["alt+m"], @keyComboAddTestCommentEventListener\n\n    @keyComboCheckNumberOfMenuItemsEventListener = (event) =>\n      @automatorRecorderAndPlayer.checkNumberOfItemsInMenu()\n      false\n    Mousetrap.bind ["alt+k"], @keyComboCheckNumberOfMenuItemsEventListener\n\n    @keyComboCheckStringsOfItemsInMenuOrderImportant = (event) =>\n      @automatorRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant()\n      false\n    Mousetrap.bind ["alt+a"], @keyComboCheckStringsOfItemsInMenuOrderImportant\n\n    @keyComboCheckStringsOfItemsInMenuOrderUnimportant = (event) =>\n      @automatorRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant()\n      false\n    Mousetrap.bind ["alt+z"], @keyComboCheckStringsOfItemsInMenuOrderUnimportant\n\n    @dragoverEventListener = (event) ->\n      event.preventDefault()\n    window.addEventListener "dragover", @dragoverEventListener, false\n    \n    @dropEventListener = (event) =>\n      @events.push "dropEventListener"\n      @events.push event\n      event.preventDefault()\n    window.addEventListener "drop", @dropEventListener, false\n    \n    @resizeEventListener = =>\n      @events.push "resizeEventListener"\n      @events.push null\n\n    # this is a DOM thing, little to do with other r e s i z e methods\n    window.addEventListener "resize", @resizeEventListener, false\n    \n    ###\n    window.onbeforeunload = (e) ->\n      # If we haven\'t been passed the event get the window.event\n      e = e or window.event\n      message = \'Are you sure you want to leave?\'\n      # For IE6-8 and Firefox prior to version 4\n      if e\n        e.returnValue = message\n      # For Chrome, Safari, IE8+ and Opera 12+\n      message\n    ###\n\n  \n  removeEventListeners: ->\n    canvas = @worldCanvas\n    # canvas.removeEventListener \'dblclick\', @dblclickEventListener\n    canvas.removeEventListener \'mousedown\', @mousedownEventListener\n    canvas.removeEventListener \'touchstart\', @touchstartEventListener\n    canvas.removeEventListener \'mouseup\', @mouseupEventListener\n    canvas.removeEventListener \'touchend\', @touchendEventListener\n    canvas.removeEventListener \'mousemove\', @mousemoveEventListener\n    canvas.removeEventListener \'touchmove\', @touchmoveEventListener\n    canvas.removeEventListener \'gesturestart\', @gesturestartEventListener\n    canvas.removeEventListener \'gesturechange\', @gesturechangeEventListener\n    canvas.removeEventListener \'contextmenu\', @contextmenuEventListener\n    canvas.removeEventListener \'keydown\', @keydownEventListener\n    canvas.removeEventListener \'keyup\', @keyupEventListener\n    canvas.removeEventListener \'keypress\', @keypressEventListener\n    canvas.removeEventListener \'mousewheel\', @mousewheelEventListener\n    canvas.removeEventListener \'DOMMouseScroll\', @DOMMouseScrollEventListener\n    canvas.removeEventListener \'cut\', @cutEventListener\n    canvas.removeEventListener \'copy\', @copyEventListener\n    canvas.removeEventListener \'paste\', @pasteEventListener\n    Mousetrap.reset()\n    canvas.removeEventListener \'dragover\', @dragoverEventListener\n    canvas.removeEventListener \'drop\', @dropEventListener\n    canvas.removeEventListener \'resize\', @resizeEventListener\n  \n  mouseDownLeft: ->\n    noOperation\n  \n  mouseClickLeft: ->\n    noOperation\n  \n  mouseDownRight: ->\n    noOperation\n      \n  droppedImage: ->\n    null\n\n  droppedSVG: ->\n    null  \n\n  # WorldMorph text field tabbing:\n  nextTab: (editField) ->\n    next = @nextEntryField editField\n    if next\n      @switchTextFieldFocus editField, next\n  \n  previousTab: (editField) ->\n    prev = @previousEntryField editField\n    if prev\n      @switchTextFieldFocus editField, prev\n\n  switchTextFieldFocus: (current, next) ->\n    current.clearSelection()\n    next.bringToForegroud()\n    next.selectAll()\n    next.edit()\n\n\n  resetWorld: ->\n    @hand.drop()\n    @changed() # redraw the whole screen\n    @hand.mouseOverList = []\n    @hand.nonFloatDraggedMorph = null\n    @fullDestroyChildren()\n    # some tests might change the background\n    # color of the world so let\'s reset it.\n    @setColor new Color 205, 205, 205\n    SystemTestsControlPanelUpdater.blinkLink SystemTestsControlPanelUpdater.resetWorldLink\n    # make sure thw window is scrolled to top\n    # so we can see the test results while tests\n    # are running.\n    document.body.scrollTop = document.documentElement.scrollTop = 0    \n  \n  # There is something special about the\n  # "world" version of fullDestroyChildren:\n  # it resets the counter used to count\n  # how many morphs exist of each Morph class.\n  # That counter is also used to determine the\n  # unique ID of a Morph. So, destroying\n  # all morphs from the world causes the\n  # counts and IDs of all the subsequent\n  # morphs to start from scratch again.\n  fullDestroyChildren: ->\n    # Check which objects end with the word Morph\n    theWordMorph = "Morph"\n    ListOfMorphs = (Object.keys(window)).filter (i) ->\n      i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1\n    for eachMorphClass in ListOfMorphs\n      if eachMorphClass != "WorldMorph"\n        console.log "resetting " + eachMorphClass + " from " + window[eachMorphClass].instancesCounter\n        # the actual count is in another variable "instancesCounter"\n        # but all labels are built using instanceNumericID\n        # which is set based on lastBuiltInstanceNumericID\n        window[eachMorphClass].lastBuiltInstanceNumericID = 0\n\n    window.world.automatorRecorderAndPlayer.turnOffAnimationsPacingControl()\n    window.world.automatorRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism()\n    window.world.automatorRecorderAndPlayer.turnOffHidingOfMorphsGeometryInfoInLabels()\n    window.world.automatorRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels()\n    window.world.automatorRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels()\n\n    super()\n\n  contextMenu: ->\n    if @isDevMode\n      menu = new MenuMorph(false, \n        @, true, true, @constructor.name or @constructor.toString().split(" ")[1].split("(")[0])\n    else\n      menu = new MenuMorph false, @, true, true, "Morphic"\n    if @isDevMode\n      menu.addItem "demo ➜", false, @, "popUpDemoMenu", "sample morphs"\n      menu.addLine()\n      menu.addItem "show all", true, @, "showAllMinimised"\n      menu.addItem "hide all", true, @, "minimiseAll"\n      menu.addItem "delete all", true, @, "fullDestroy"\n      menu.addItem "move all inside", true, @, "keepAllSubmorphsWithin", "keep all submorphs\\nwithin and visible"\n      menu.addItem "inspect", true, @, "inspect", "open a window on\\nall properties"\n      menu.addItem "test menu ➜", false, @, "testMenu", "debugging and testing operations"\n      menu.addLine()\n      menu.addItem "restore display", true, @, "changed", "redraw the\\nscreen once"\n      menu.addItem "fit whole page", true, @, "stretchWorldToFillEntirePage", "let the World automatically\\nadjust to browser resizings"\n      menu.addItem "color...", true, @, "popUpColorSetter", "choose the World\'s\\nbackground color"\n      if WorldMorph.preferencesAndSettings.inputMode is PreferencesAndSettings.INPUT_MODE_MOUSE\n        menu.addItem "touch screen settings", true, WorldMorph.preferencesAndSettings, "toggleInputMode", "bigger menu fonts\\nand sliders"\n      else\n        menu.addItem "standard settings", true, WorldMorph.preferencesAndSettings, "toggleInputMode", "smaller menu fonts\\nand sliders"\n      menu.addLine()\n    \n    if window.location.href.contains "worldWithSystemTestHarness"\n      menu.addItem "system tests ➜", false, @, "popUpSystemTestsMenu", ""\n    if @isDevMode\n      menu.addItem "switch to user mode", true, @, "toggleDevMode", "disable developers\'\\ncontext menus"\n    else\n      menu.addItem "switch to dev mode", true, @, "toggleDevMode"\n    menu.addItem "about Fizzygum...", true, @, "about"\n    menu\n\n  popUpSystemTestsMenu: ->\n    menu = new MenuMorph false, @, true, true, "system tests"\n\n    menu.addItem "run system tests", true, @automatorRecorderAndPlayer, "runAllSystemTests", "runs all the system tests"\n    menu.addItem "run system tests force slow", true, @automatorRecorderAndPlayer, "runAllSystemTestsForceSlow", "runs all the system tests"\n    menu.addItem "run system tests force fast skip in-between mouse moves", true, @automatorRecorderAndPlayer, "runAllSystemTestsForceFastSkipInbetweenMouseMoves", "runs all the system tests"\n    menu.addItem "run system tests force fast run in-between mouse moves", true, @automatorRecorderAndPlayer, "runAllSystemTestsForceFastRunInbetweenMouseMoves", "runs all the system tests"\n\n    menu.addItem "start test recording", true, @automatorRecorderAndPlayer, "startTestRecording", "start recording a test"\n    menu.addItem "stop test recording", true, @automatorRecorderAndPlayer, "stopTestRecording", "stop recording the test"\n\n    menu.addItem "(re)play recorded test slow", true, @automatorRecorderAndPlayer, "startTestPlayingSlow", "start playing the test"\n    menu.addItem "(re)play recorded test fast skip in-between mouse moves", true, @automatorRecorderAndPlayer, "startTestPlayingFastSkipInbetweenMouseMoves", "start playing the test"\n    menu.addItem "(re)play recorded test  fast run in-between mouse moves", true, @automatorRecorderAndPlayer, "startTestPlayingFastRunInbetweenMouseMoves", "start playing the test"\n\n    menu.addItem "show test source", true, @automatorRecorderAndPlayer, "showTestSource", "opens a window with the source of the latest test"\n    menu.addItem "save recorded test", true, @automatorRecorderAndPlayer, "saveTest", "save the recorded test"\n    menu.addItem "save failed screenshots", true, @automatorRecorderAndPlayer, "saveFailedScreenshots", "save failed screenshots"\n\n    menu.popUpAtHand @firstContainerMenu()\n\n  create: (aMorph) ->\n    aMorph.pickUp()\n\n  createNewStackElementsSizeAdjustingMorph: ->\n    @create new StackElementsSizeAdjustingMorph()\n\n  createNewLayoutElementAdderOrDropletMorph: ->\n    @create new LayoutElementAdderOrDropletMorph()\n\n  createNewRectangleMorph: ->\n    @create new RectangleMorph()\n  createNewBoxMorph: ->\n    @create new BoxMorph()\n  createNewCircleBoxMorph: ->\n    @create new CircleBoxMorph()\n  createNewSliderMorph: ->\n    @create new SliderMorph()\n  createNewFrameMorph: ->\n    newMorph = new FrameMorph()\n    newMorph.rawSetExtent new Point 350, 250\n    @create newMorph\n  createNewScrollFrameMorph: ->\n    newMorph = new ScrollFrameMorph()\n    newMorph.adjustContentsBounds()\n    newMorph.adjustScrollBars()\n    newMorph.rawSetExtent new Point 350, 250\n    @create newMorph\n  createNewCanvas: ->\n    newMorph = new CanvasMorph()\n    newMorph.rawSetExtent new Point 350, 250\n    @create newMorph\n  createNewHandle: ->\n    @create new HandleMorph()\n  createNewString: ->\n    newMorph = new StringMorph "Hello, World!"\n    newMorph.isEditable = true\n    @create newMorph\n  createNewText: ->\n    newMorph = new TextMorph("Ich weiß nicht, was soll es bedeuten, dass ich so " +\n      "traurig bin, ein Märchen aus uralten Zeiten, das " +\n      "kommt mir nicht aus dem Sinn. Die Luft ist kühl " +\n      "und es dunkelt, und ruhig fließt der Rhein; der " +\n      "Gipfel des Berges funkelt im Abendsonnenschein. " +\n      "Die schönste Jungfrau sitzet dort oben wunderbar, " +\n      "ihr gold\'nes Geschmeide blitzet, sie kämmt ihr " +\n      "goldenes Haar, sie kämmt es mit goldenem Kamme, " +\n      "und singt ein Lied dabei; das hat eine wundersame, " +\n      "gewalt\'ge Melodei. Den Schiffer im kleinen " +\n      "Schiffe, ergreift es mit wildem Weh; er schaut " +\n      "nicht die Felsenriffe, er schaut nur hinauf in " +\n      "die Höh\'. Ich glaube, die Wellen verschlingen " +\n      "am Ende Schiffer und Kahn, und das hat mit ihrem " +\n      "Singen, die Loreley getan.")\n    newMorph.isEditable = true\n    newMorph.maxTextWidth = 300\n    @create newMorph\n  createNewSpeechBubbleMorph: ->\n    newMorph = new SpeechBubbleMorph "Hello, World!"\n    @create newMorph\n  createNewGrayPaletteMorph: ->\n    @create new GrayPaletteMorph()\n  createNewColorPaletteMorph: ->\n    @create new ColorPaletteMorph()\n  createNewColorPickerMorph: ->\n    @create new ColorPickerMorph()\n  createNewSensorDemo: ->\n    newMorph = new MouseSensorMorph()\n    newMorph.setColor new Color 230, 200, 100\n    newMorph.cornerRadius = 35\n    newMorph.alpha = 0.2\n    newMorph.rawSetExtent new Point 100, 100\n    @create newMorph\n  createNewAnimationDemo: ->\n    foo = new BouncerMorph()\n    foo.fullRawMoveTo new Point 50, 20\n    foo.rawSetExtent new Point 300, 200\n    foo.alpha = 0.9\n    foo.speed = 3\n    bar = new BouncerMorph()\n    bar.setColor new Color 50, 50, 50\n    bar.fullRawMoveTo new Point 80, 80\n    bar.rawSetExtent new Point 80, 250\n    bar.type = "horizontal"\n    bar.direction = "right"\n    bar.alpha = 0.9\n    bar.speed = 5\n    baz = new BouncerMorph()\n    baz.setColor new Color 20, 20, 20\n    baz.fullRawMoveTo new Point 90, 140\n    baz.rawSetExtent new Point 40, 30\n    baz.type = "horizontal"\n    baz.direction = "right"\n    baz.speed = 3\n    garply = new BouncerMorph()\n    garply.setColor new Color 200, 20, 20\n    garply.fullRawMoveTo new Point 90, 140\n    garply.rawSetExtent new Point 20, 20\n    garply.type = "vertical"\n    garply.direction = "up"\n    garply.speed = 8\n    fred = new BouncerMorph()\n    fred.setColor new Color 20, 200, 20\n    fred.fullRawMoveTo new Point 120, 140\n    fred.rawSetExtent new Point 20, 20\n    fred.type = "vertical"\n    fred.direction = "down"\n    fred.speed = 4\n    bar.add garply\n    bar.add baz\n    foo.add fred\n    foo.add bar\n    @create foo\n  createNewPenMorph: ->\n    @create new PenMorph()\n  underTheCarpet: ->\n    #newMorph = new MorphsListMorph()\n    newMorph = new UnderTheCarpetMorph()\n    @create newMorph\n  closingWindow: ->\n    newMorph = new WorkspaceMorph()\n    @create newMorph\n\n\n  popUpDemoMenu: (a,b,c,d) ->\n    if window.location.href.contains "worldWithSystemTestHarness"\n      menu = new MenuMorph false, @, true, true, "make a morph"\n      menu.addItem "rectangle", true, @, "createNewRectangleMorph"\n      menu.addItem "box", true, @, "createNewBoxMorph"\n      menu.addItem "circle box", true, @, "createNewCircleBoxMorph"\n      menu.addLine()\n      menu.addItem "slider", true, @, "createNewSliderMorph"\n      menu.addItem "frame", true, @, "createNewFrameMorph"\n      menu.addItem "scroll frame", true, @, "createNewScrollFrameMorph"\n      menu.addItem "canvas", true, @, "createNewCanvas"\n      menu.addItem "handle", true, @, "createNewHandle"\n      menu.addLine()\n      menu.addItem "string", true, @, "createNewString"\n      menu.addItem "text", true, @, "createNewText"\n      menu.addItem "speech bubble", true, @, "createNewSpeechBubbleMorph"\n      menu.addLine()\n      menu.addItem "gray scale palette", true, @, "createNewGrayPaletteMorph"\n      menu.addItem "color palette", true, @, "createNewColorPaletteMorph"\n      menu.addItem "color picker", true, @, "createNewColorPickerMorph"\n      menu.addLine()\n      menu.addItem "sensor demo", true, @, "createNewSensorDemo"\n      menu.addItem "animation demo", true, @, "createNewAnimationDemo"\n      menu.addItem "pen", true, @, "createNewPenMorph"\n        \n      menu.addLine()\n      menu.addItem "layout tests ➜", false, @, "layoutTestsMenu", "sample morphs"\n      menu.addLine()\n      menu.addItem "under the carpet", true, @, "underTheCarpet"\n      menu.addItem "closing window", true, @, "closingWindow"\n    else\n      menu = new MenuMorph false, @, true, true, "parts bin"\n      menu.addItem "rectangle", true, @, "createNewRectangleMorph"\n      menu.addItem "box", true, @, "createNewBoxMorph"\n      menu.addItem "circle box", true, @, "createNewCircleBoxMorph"\n      menu.addItem "slider", true, @, "createNewSliderMorph"\n      menu.addItem "frame", true, @, "createNewFrameMorph"\n      menu.addItem "scroll frame", true, @, "createNewScrollFrameMorph"\n      menu.addItem "canvas", true, @, "createNewCanvas"\n      menu.addLine()\n      menu.addItem "string", true, @, "createNewStringMorph2WithoutBackground"\n      menu.addItem "text", true, @, "createNewTextMorph2WithBackground"\n      menu.addItem "speech bubble", true, @, "createNewSpeechBubbleMorph"\n      menu.addLine()\n      menu.addItem "gray scale palette", true, @, "createNewGrayPaletteMorph"\n      menu.addItem "color palette", true, @, "createNewColorPaletteMorph"\n      menu.addItem "color picker", true, @, "createNewColorPickerMorph"\n      menu.addLine()\n      menu.addItem "analog clock", true, @, "analogClock"\n      menu.addItem "fizzytiles", true, menusHelper, "createFridgeMagnets"\n      menu.addItem "fizzypaint", true, menusHelper, "createReconfigurablePaint"\n\n    menu.popUpAtHand a.firstContainerMenu()\n\n  layoutTestsMenu: (morphTriggeringThis) ->\n    menu = new MenuMorph false, @, true, true, "Layout tests"\n    menu.addItem "adjuster morph", true, @, "createNewStackElementsSizeAdjustingMorph"\n    menu.addItem "adder/droplet", true, @, "createNewLayoutElementAdderOrDropletMorph"\n    menu.addItem "test screen 1", true, Morph, "setupTestScreen1"\n    menu.popUpAtHand morphTriggeringThis.firstContainerMenu()\n    \n  \n  toggleDevMode: ->\n    @isDevMode = not @isDevMode\n  \n  # This method is obsolete. It assumes a different meaning\n  # for "minimise" than what we have now.\n  #minimiseAll: ->\n  #  @children.forEach (child) ->\n  #    child.minimise()\n  \n  # This method is obsolete. It assumes a different meaning\n  # for "minimise" than what we have now.\n  #showAllMinimised: ->\n  #  @forAllChildrenBottomToTop (child) ->\n  #    if !child.visibleBasedOnIsVisibleProperty() or\n  #    child.isCollapsed()\n  #      child.unminimise()\n  \n  edit: (aStringMorphOrTextMorph) ->\n    # first off, if the Morph is not editable\n    # then there is nothing to do\n    # return null  unless aStringMorphOrTextMorph.isEditable\n\n    # there is only one caret in the World, so destroy\n    # the previous one if there was one.\n    if @caret\n      # empty the previously ongoing selection\n      # if there was one.\n      previouslyEditedText = @lastEditedText\n      @lastEditedText = @caret.target\n      if @lastEditedText != previouslyEditedText\n        @lastEditedText.clearSelection()\n      @caret = @caret.destroy()\n\n    # create the new Caret\n    @caret = new CaretMorph aStringMorphOrTextMorph\n    aStringMorphOrTextMorph.parent.add @caret\n    # this is the only place where the @keyboardEventsReceiver is set\n    @keyboardEventsReceiver = @caret\n\n    if WorldMorph.preferencesAndSettings.isTouchDevice and WorldMorph.preferencesAndSettings.useVirtualKeyboard\n      @initVirtualKeyboard()\n      # For touch devices, giving focus on the textbox causes\n      # the keyboard to slide up, and since the page viewport\n      # shrinks, the page is scrolled to where the texbox is.\n      # So, it is important to position the textbox around\n      # where the caret is, so that the changed text is going to\n      # be visible rather than out of the viewport.\n      pos = getDocumentPositionOf @worldCanvas\n      @inputDOMElementForVirtualKeyboard.style.top = @caret.top() + pos.y + "px"\n      @inputDOMElementForVirtualKeyboard.style.left = @caret.left() + pos.x + "px"\n      @inputDOMElementForVirtualKeyboard.focus()\n    if WorldMorph.preferencesAndSettings.useSliderForInput\n      if !aStringMorphOrTextMorph.parentThatIsA MenuMorph\n        @slide aStringMorphOrTextMorph\n  \n  # Editing can stop because of three reasons:\n  #   cancel (user hits ESC)\n  #   accept (on stringmorph, user hits enter)\n  #   user clicks/floatDrags another morph\n  stopEditing: ->\n    if @caret\n      @lastEditedText = @caret.target\n      @lastEditedText.clearSelection()\n      @lastEditedText.escalateEvent "reactToEdit", @lastEditedText\n      @caret = @caret.destroy()\n\n    # the only place where the @keyboardEventsReceiver is unset\n    # (and the hidden input is removed)\n    @keyboardEventsReceiver = null\n    if @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard.blur()\n      document.body.removeChild @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard = null\n    @worldCanvas.focus()\n    \n';
