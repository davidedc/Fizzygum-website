// Generated by CoffeeScript 1.12.7
window.EmptyButtonMorph_coffeSource = '# sends a message to a target object when pressed.\n# Doesn\'t have any particular shape, but can host\n# a morph to be used as "face"\n\n# TODO it\'s unclear to me why we pass a number of targets\n# and actions in the constructor when what we could simply\n# do is to extend this button and override the mouse events?\n\n# REQUIRES HighlightableMixin\n\nclass EmptyButtonMorph extends Widget\n\n  @augmentWith HighlightableMixin, @name\n\n  target: nil\n  action: nil\n  dataSourceMorphForTarget: nil\n  morphEnv: nil\n \n \n  doubleClickAction: nil\n  argumentToAction1: nil\n  argumentToAction2: nil\n \n  toolTipMessage: nil\n \n  ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked: true\n  \n  # tells if the button represents a morph, in which\n  # case we are going to highlight the Widget on hover\n  representsAMorph: false\n\n  padding: 0\n\n\n  # overrides to superclass\n  color: new Color 255, 255, 255\n\n  constructor: (\n      @ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked = true,\n      @target = nil,\n      @action = nil,\n\n      @faceMorph = nil,\n\n      @dataSourceMorphForTarget = nil,\n      @morphEnv,\n      @toolTipMessage = nil,\n\n      @doubleClickAction = nil,\n      @argumentToAction1 = nil,\n      @argumentToAction2 = nil,\n      @representsAMorph = false,\n      @padding = 0\n      ) ->\n\n    # additional properties:\n\n    super()\n    @defaultRejectDrags = true\n\n    #@color = new Color 255, 152, 152\n    #@color = new Color 255, 255, 255\n    if @faceMorph?\n\n      if (typeof @faceMorph) == "string"\n        @faceMorph = (new StringMorph2 @faceMorph, WorldMorph.preferencesAndSettings.textInButtonsFontSize).alignCenter()\n      @add @faceMorph\n      @invalidateLayout()\n  \n\n  doLayout: (newBoundsForThisLayout) ->\n    if !window.recalculatingLayouts\n      debugger\n\n    if !newBoundsForThisLayout?\n      if @desiredExtent?\n        newBoundsForThisLayout = @desiredExtent\n        @desiredExtent = nil\n      else\n        newBoundsForThisLayout = @extent()\n\n      if @desiredPosition?\n        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout\n        @desiredPosition = nil\n      else\n        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout\n\n    if @isCollapsed()\n      @layoutIsValid = true\n      @notifyChildrenThatParentHasReLayouted()\n      return\n\n    @rawSetBounds newBoundsForThisLayout\n\n    if @faceMorph?.parent == @\n      @faceMorph.rawSetBounds newBoundsForThisLayout.insetBy @padding\n\n    @layoutIsValid = true\n    @notifyChildrenThatParentHasReLayouted()\n\n  # TODO\n  getTextDescription: ->\n\n    \n  # TriggerMorph action:\n  trigger: ->\n    if @action? and @action != ""\n      #console.log "@target: " + @target + " @morphEnv: " + @morphEnv\n      @target[@action].call @target, @dataSourceMorphForTarget, @morphEnv, @argumentToAction1, @argumentToAction2\n    return\n\n  triggerDoubleClick: ->\n    # same as trigger() but use doubleClickAction instead of action property\n    # note that specifying a doubleClickAction is optional\n    return  unless @doubleClickAction\n    @target[@doubleClickAction]()  \n\n  \n  mouseClickLeft: ->\n    if @ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked\n      @propagateKillPopUps()\n    @trigger()\n    @escalateEvent "mouseClickLeft"\n\n  mouseDoubleClick: ->\n    @triggerDoubleClick()\n\n  # you shouldn\'t be able to drag a compound\n  # morphs containing a button by dragging the button\n  # (because you expect buttons attached to anything but the\n  # world to be "slippery", i.e.\n  # you can "skid" your drag over it in case you change\n  # your mind on pressing it)\n  # and you shouldn\'t be able to drag the button away either\n  # so the drag is entirely rejected\n  rejectDrags: ->\n    if @parent instanceof WorldMorph\n      return false\n    else\n      return @defaultRejectDrags\n\n';
