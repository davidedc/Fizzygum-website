// Generated by CoffeeScript 1.12.7
window.HandleMorph_coffeSource = '# not to be confused with the HandMorph\n# I am a resize / move handle that can be attached to any Widget\n\n# this comment below is needed to figure out dependencies between classes\n# REQUIRES globalFunctions\n\nclass HandleMorph extends Widget\n\n\n  target: nil\n  inset: nil\n  type: nil\n\n  state: 0\n  STATE_NORMAL: 0\n  STATE_HIGHLIGHTED: 1\n\n  constructor: (@target = nil, @type = "resizeBothDimensionsHandle") ->\n\n    # some minimum padding with whatever edge we\n    # end up against, it looks better\n    minimumPadding = 2\n\n    if @target?.padding?\n      @inset = new Point Math.max(@target.padding, minimumPadding), Math.max(@target.padding, minimumPadding)\n    else\n      @inset = new Point minimumPadding, minimumPadding\n    super()\n    @color = new Color 255, 255, 255\n    @noticesTransparentClick = true\n    size = WorldMorph.preferencesAndSettings.handleSize\n    @silentRawSetExtent new Point size, size\n    if @target\n      @target.add @\n    @updateResizerHandlePosition()\n\n  detachesWhenDragged: ->\n    if (@parent instanceof WorldMorph)\n      return true\n    else\n      return false\n\n  # HandleMorphs are one of the few morphs that\n  # by default don\'t stick to their parents.\n  # Also SliderButtonMorphs tend do the same (if\n  # they are attached to a SliderMorph)\n  # The "move" HandleMorph COULD grab to its\n  # parent, in fact it would be easier, however for\n  # uniformity we don\'t do that\n  grabsToParentWhenDragged: ->\n    return false\n\n  updateVisibilityAndPosition: ->\n    @updateVisibility()\n    if @parent.layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING\n      @updateResizerHandlePosition()\n      @moveInFrontOfSiblings()\n\n  updateVisibility: ->\n    # TODO rather than updating the visibility, we could\n    # just make it "inactive" and by drawing it gray, which\n    # would also look better (rather than a hole with\n    # nothing)\n    if @parent.layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING\n      @show()\n    else\n      @hide()\n\n  parentHasReLayouted: ->\n    # right now you can resize a morph only if it\'s\n    # free-floating, however this will change in the future\n    # as for example things inside vertically-stretchable\n    # Panels can potentially change their width.\n    # so this handle has to go away now.\n    @updateVisibilityAndPosition()\n    if @parent.layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING\n      super\n\n  updateResizerHandlePosition: ->\n    if @target\n      # collapse some of the handles if the\n      # morph gets too small because they\n      # become unusable anyways once they\n      # overlap\n      switch @type\n        when "moveHandle"\n          if @target.width() < 2 * @width()\n            @hide()\n            return\n          else\n            @show()\n        when "resizeHorizontalHandle"\n          if @target.height() < 3 * @height()\n            @hide()\n            return\n          else\n            @show()\n        when "resizeVerticalHandle"\n          if @target.width() < 3 * @width()\n            @hide()\n            return\n          else\n            @show()\n\n      @silentUpdateResizerHandlePosition()\n      @changed()\n\n  silentUpdateResizerHandlePosition: ->\n    if @target\n        switch @type\n          when "resizeBothDimensionsHandle"\n            @silentFullRawMoveTo @target.bottomRight().subtract @extent().add @inset\n          when "moveHandle"\n            @silentFullRawMoveTo @target.topLeft().add @inset\n          when "resizeHorizontalHandle"\n            offsetFromMiddlePoint = new Point @extent().x + @inset.x, Math.floor(@extent().y/2)\n            @silentFullRawMoveTo @target.rightCenter().subtract offsetFromMiddlePoint\n          when "resizeVerticalHandle"\n            offsetFromMiddlePoint = new Point Math.floor(@extent().x/2), @extent().y + @inset.y\n            @silentFullRawMoveTo @target.bottomCenter().subtract offsetFromMiddlePoint\n  \n  \n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->\n\n    if @preliminaryCheckNothingToDraw clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return nil\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @alpha\n\n      aContext.scale pixelRatio, pixelRatio\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n\n      if @state == @STATE_NORMAL\n        @handleMorphRenderingHelper aContext, @color, new Color 150, 150, 150\n      if @state == @STATE_HIGHLIGHTED\n        @handleMorphRenderingHelper aContext, new Color(255, 255, 255), new Color(200, 200, 255)\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio (i.e. after the restore)\n      @paintHighlight aContext, al, at, w, h\n\n  drawArrow: (context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown) ->\n    context.beginPath()\n    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftUp.x, 0.5 + leftArrowPoint.y + arrowPieceLeftUp.y\n    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y\n    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftDown.x, 0.5 + leftArrowPoint.y + arrowPieceLeftDown.y\n\n    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y\n    context.lineTo 0.5 + rightArrowPoint.x, 0.5 + rightArrowPoint.y\n\n    context.lineTo 0.5 + rightArrowPoint.x + arrowPieceRightUp.x, 0.5 + rightArrowPoint.y + arrowPieceRightUp.y\n    context.moveTo 0.5 + rightArrowPoint.x, 0.5 + rightArrowPoint.y\n    context.lineTo 0.5 + rightArrowPoint.x + arrowPieceRightDown.x, 0.5 + rightArrowPoint.y + arrowPieceRightDown.y\n\n    context.closePath()\n    context.stroke()\n\n  drawHandle: (context) ->\n\n    # horizontal arrow\n    if @type is "resizeHorizontalHandle" or @type is "moveHandle"\n      p0 = @bottomLeft().subtract(@position())\n      p0 = p0.subtract new Point 0, Math.ceil(@height()/2)\n      \n      leftArrowPoint = p0.add new Point Math.ceil(@width()/15), 0\n\n      rightArrowPoint = p0.add new Point @width() - Math.ceil(@width()/14), 0\n      arrowPieceLeftUp = new Point Math.ceil(@width()/5),-Math.ceil(@height()/5)\n      arrowPieceLeftDown = new Point Math.ceil(@width()/5),Math.ceil(@height()/5)\n      arrowPieceRightUp = new Point -Math.ceil(@width()/5),-Math.ceil(@height()/5)\n      arrowPieceRightDown = new Point -Math.ceil(@width()/5),Math.ceil(@height()/5)\n      @drawArrow context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown\n\n    # vertical arrow\n    if @type is "resizeVerticalHandle" or @type is "moveHandle"\n      p0 = @bottomCenter().subtract @position()\n      \n      leftArrowPoint = p0.add new Point 0, -Math.ceil(@height()/14)\n\n      rightArrowPoint = p0.add new Point 0, -@height() + Math.ceil(@height()/15)\n      arrowPieceLeftUp = new Point -Math.ceil(@width()/5), -Math.ceil(@height()/5)\n      arrowPieceLeftDown = new Point Math.ceil(@width()/5), -Math.ceil(@height()/5)\n      arrowPieceRightUp = new Point -Math.ceil(@width()/5), Math.ceil(@height()/5)\n      arrowPieceRightDown = new Point Math.ceil(@width()/5), Math.ceil(@height()/5)\n      @drawArrow context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown\n\n\n    # draw the traditional "striped triangle" resizer\n    if @type is "resizeBothDimensionsHandle"\n      bottomLeft = @bottomLeft().subtract(@position())\n      topRight = @topRight().subtract(@position())\n\n      bottomLeftSweep = bottomLeft.copy()\n      topRightSweep = topRight.copy()\n\n      # draw the lines sweeping from long lines\n      # down to the short ones at the corner\n      for i in [0..@height()] by 6\n        # bottomLeftSweep moves right\n        bottomLeftSweep.x = bottomLeft.x + i\n        # topRightSweep moves down\n        topRightSweep.y = topRight.y + i\n        context.beginPath()\n        context.moveTo bottomLeftSweep.x, bottomLeftSweep.y\n        context.lineTo topRightSweep.x, topRightSweep.y\n        context.closePath()\n        context.stroke()\n\n\n  handleMorphRenderingHelper: (context, color, shadowColor) ->\n    context.lineWidth = 0.5\n    context.lineCap = "round"\n\n    # give it a good shadow so that\n    # it\'s visible also when on light\n    # background. Do that by painting it\n    # twice, slightly translated, in\n    # darker color.\n    context.save()\n    context.strokeStyle = shadowColor.toString()\n    context.translate 1,1\n    @drawHandle context\n    context.translate 1,0\n    @drawHandle context\n    context.restore()\n\n    context.strokeStyle = color.toString()\n    @drawHandle context\n\n\n  \n\n  # implement dummy methods in here\n  # so the handle catches the clicks and\n  # prevents the parent from doing anything.\n  mouseClickLeft: ->\n  mouseUpLeft: ->\n  \n  # same here, the handle doesn\'t want to propagate\n  # anything, otherwise the handle on a button\n  # will trigger the button when resizing.\n  mouseDownLeft: (pos) ->\n    return nil  unless @target\n    @target.bringToForeground()\n\n  nonFloatDragging: (nonFloatDragPositionWithinMorphAtStart, pos, deltaDragFromPreviousCall) ->\n    newPos = pos.subtract nonFloatDragPositionWithinMorphAtStart\n    switch @type\n      when "resizeBothDimensionsHandle"\n        newExt = newPos.add(@extent().add(@inset)).subtract @target.position()\n        @target.setExtent newExt, @\n      # the position of this handle will be changed when the\n      # parentHasReLayouted method of this handle will be called\n      # as the parent has re-layouted following the rawSetExtent call just\n      # made.\n      when "moveHandle"\n        @target.fullMoveTo (newPos.subtract @inset), @\n      when "resizeHorizontalHandle"\n        newWidth = newPos.x + @extent().x + @inset.x - @target.left()\n        @target.setWidth newWidth\n      when "resizeVerticalHandle"\n        newHeight = newPos.y + @extent().y + @inset.y - @target.top()\n        @target.setHeight newHeight\n  \n  \n  # HandleMorph events:\n  mouseEnter: ->\n    #console.log "<<<<<< handle mousenter"\n    @state = @STATE_HIGHLIGHTED\n    @changed()\n  \n  mouseLeave: ->\n    #console.log "<<<<<< handle mouseleave"\n    @state = @STATE_NORMAL\n    @changed()\n\n  makeHandleSolidWithParentMorph: (ignored, ignored2, morphAttachedTo)->\n    @target = morphAttachedTo\n    @target.add @\n    @updateResizerHandlePosition()\n    @noticesTransparentClick = true\n\n    \n  # HandleMorph menu:\n  attach: ->\n    choices = world.plausibleTargetAndDestinationMorphs @\n    menu = new MenuMorph @, false, @, true, true, "choose target:"\n    if choices.length > 0\n      choices.forEach (each) =>\n        menu.addMenuItem (each.toString().replace "Wdgt", "").slice(0, 50) + " ➜", true, @, \'makeHandleSolidWithParentMorph\', nil, nil, nil, nil, nil, each, nil, true\n    else\n      # the ideal would be to not show the\n      # "attach" menu entry at all but for the\n      # time being it\'s quite costly to\n      # find the eligible morphs to attach\n      # to, so for now let\'s just calculate\n      # this list if the user invokes the\n      # command, and if there are no good\n      # morphs then show some kind of message.\n      menu = new MenuMorph @, false, @, true, true, "no morphs to attach to"\n    menu.popUpAtHand() if choices.length\n';
