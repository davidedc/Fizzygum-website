// Generated by CoffeeScript 1.12.7
window.ClippingAtRectangularBoundsMixin_coffeSource = '# REQUIRES globalFunctions\n\nClippingAtRectangularBoundsMixin =\n  # class properties here:\n  # none\n\n  # instance properties to follow:\n  onceAddedClassProperties: (fromClass) ->\n    @addInstanceProperties fromClass,\n\n      clipsAtRectangularBounds: true\n\n      # used for example:\n      # - to determine which morphs you can attach a morph to\n      # - for a SliderMorph\'s "set target" so you can change properties of another Widget\n      # - by the HandleMorph when you attach it to some other morph\n      # Note that this method has a slightly different\n      # version in Widget (because it doesn\'t clip)\n      plausibleTargetAndDestinationMorphs: (theMorph) ->\n        # find if I intersect theMorph,\n        # then check my children recursively\n        # exclude me if I\'m a child of theMorph\n        # (cause it\'s usually odd to attach a Widget\n        # to one of its submorphs or for it to\n        # control the properties of one of its submorphs)\n        result = []\n        if @visibleBasedOnIsVisibleProperty() and\n            !@isCollapsed() and\n            !theMorph.isAncestorOf(@) and\n            @areBoundsIntersecting(theMorph) and\n            !@anyParentPopUpMarkedForClosure()\n          result = [@]\n\n        # Since the PanelWdgt clips its children\n        # at its boundary, hence we need\n        # to check that we don\'t consider overlaps with\n        # morphs contained in this Panel that are clipped and\n        # hence *actually* not overlapping with theMorph.\n        # So continue checking the children only if the\n        # Panel itself actually overlaps.\n        if @areBoundsIntersecting theMorph\n          @children.forEach (child) ->\n            result = result.concat child.plausibleTargetAndDestinationMorphs theMorph\n\n        return result\n\n      # do nothing if the call comes from a child\n      # otherwise, if it comes from me (say, because the\n      # Panel has been moved), then\n      # do invalidate the cache as normal.\n      invalidateFullBoundsCache: (morphCalling) ->\n        if morphCalling == @\n          super @\n\n      invalidateFullClippedBoundsCache: (morphCalling) ->\n        if morphCalling == @\n          super @\n      \n      # here is the magic of a Frame: the recursion\n      # stops and we can ignore the bounds of potentially\n      # hundreds of morphs that might be in here.\n      SLOWfullBounds: ->\n        @bounds\n\n      SLOWfullClippedBounds: ->\n        if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()\n          result = Rectangle.EMPTY\n        else\n          result = @clippedThroughBounds()\n        #if this != world and result.corner.x > 400 and result.corner.y > 100 and result.origin.x ==0 and result.origin.y ==0\n        #  debugger\n        result\n\n      # Panels clip any of their children\n      # at their boundaries\n      # so there is no need to do a deep\n      # traversal to find the bounds.\n      fullBounds: ->\n        if @cachedFullBounds?\n          if world.doubleCheckCachedMethodsResults\n            if !@cachedFullBounds.eq @SLOWfullBounds()\n              debugger\n              alert "fullBounds is broken (cached)"\n          return @cachedFullBounds\n\n        result = @bounds\n\n        if world.doubleCheckCachedMethodsResults\n          if !result.eq @SLOWfullBounds()\n            debugger\n            alert "fullBounds is broken (uncached)"\n\n        @cachedFullBounds = result\n\n      fullClippedBounds: ->\n        if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()\n          result = Rectangle.EMPTY\n        else\n          if @cachedFullClippedBounds?\n            if @checkFullClippedBoundsCache == WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n              if world.doubleCheckCachedMethodsResults\n                if !@cachedFullClippedBounds.eq @SLOWfullClippedBounds()\n                  debugger\n                  alert "fullClippedBounds is broken"\n              return @cachedFullClippedBounds\n\n          result = @clippedThroughBounds()\n\n        if world.doubleCheckCachedMethodsResults\n          if !result.eq @SLOWfullClippedBounds()\n            debugger\n            alert "fullClippedBounds is broken"\n\n        @checkFullClippedBoundsCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n        @cachedFullClippedBounds = result\n\n\n\n      fullPaintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->\n        super\n\n        # after all the contents are drawn,\n        # draw the border of the Panel again.\n        # This is because the border has to be drawn inside the Frame,\n        # but the contents might paint over it. So, we need to\n        # paint them AFTER the content has been painted.\n        if !@preliminaryCheckNothingToDraw clippingRectangle, aContext\n          if !appliedShadow?\n            if !@paintStroke?\n              debugger\n            @paintStroke aContext, clippingRectangle\n\n      \n      fullPaintIntoAreaOrBlitFromBackBufferContentPotentiallyAsShadow: (aContext, clippingRectangle, appliedShadow) ->\n\n        # a PanelWdgt has the special property that all of its children\n        # are actually inside its boundary.\n        # This allows\n        # us to avoid the further traversal of potentially\n        # many many morphs if we see that the rectangle we\n        # want to paint is outside its Panel.\n        # If the rectangle we want to paint is inside the Panel\n        # then we do have to continue traversing all the\n        # children of the Frame.\n\n        # This is why as well it\'s good to use PanelWdgts whenever\n        # it\'s clear that there is a "container" case. Think\n        # for example that you could stick a small\n        # RectangleMorph (not a Frame) on the desktop and then\n        # attach a thousand\n        # CircleBoxMorphs on it.\n        # Say that the circles are all inside the rectangle,\n        # apart from four that are at the corners of the world.\n        # that\'s a nightmare scenegraph\n        # to *completely* traverse for *any* broken rectangle\n        # anywhere on the screen.\n        # The traversal is complete because a) Widgetic doesn\'t\n        # assume that the rectangle clips its children and\n        # b) the bounding rectangle (which currently is not\n        # efficiently calculated anyways) is the whole screen.\n        # So the children could be anywhere and need to be all\n        # checked for damaged areas to repaint.\n        # If the RectangleMorph is made into a Panel, one can\n        # avoid the traversal for any broken rectangle not\n        # overlapping it.\n\n        # Also note that in theory you could stop recursion on any\n        # PanelWdgt completely covered by a large opaque morph\n        # (or on any Widget which fullBounds are completely\n        # covered, for that matter). You could\n        # keep for example a list of the top n biggest opaque morphs\n        # (say, Panels and rectangles)\n        # and check that case while you traverse the list.\n        # (see https://github.com/davidedc/Fizzygum/issues/149 )\n        \n        # the part to be redrawn could be outside the Panel entirely,\n        # in which case we can stop going down the morphs inside the Panel\n        # since the whole point of the Panel is to clip everything to a specific\n        # rectangle. (note that you can\'t do the same trick with a\n        # generic tree of morphs since the root morph doesn\'t\n        # necessarily contain all the submorphs in its boundaries like\n        # the PanelWdgt does)\n        # So, check which part of the Frame should be redrawn:\n        dirtyPartOfFrame = @boundingBox().intersect clippingRectangle\n        \n        if !dirtyPartOfFrame.isEmpty()\n        \n          if aContext == world.worldCanvasContext\n            @recordDrawnAreaForNextBrokenRects()\n\n          # this draws the background of the Panel itself\n          @paintIntoAreaOrBlitFromBackBuffer aContext, dirtyPartOfFrame, appliedShadow\n\n          @children.forEach (child) =>\n            child.fullPaintIntoAreaOrBlitFromBackBuffer aContext, dirtyPartOfFrame, appliedShadow\n\n      fullPaintIntoAreaOrBlitFromBackBufferJustShadow: (aContext, clippingRectangle, appliedShadow) ->\n        clippingRectangle = clippingRectangle.translateBy -appliedShadow.offset.x, -appliedShadow.offset.y\n\n        if !@preliminaryCheckNothingToDraw clippingRectangle, aContext\n\n          # the part to be redrawn could be outside the Panel entirely,\n          # in which case we can stop going down the morphs inside the Panel\n          # since the whole point of the Panel is to clip everything to a specific\n          # rectangle.\n          # So, check which part of the Frame should be redrawn:\n          dirtyPartOfFrame = @boundingBox().intersect clippingRectangle\n          \n          # if there is no dirty part in the Panel then do nothing\n          if !dirtyPartOfFrame.isEmpty()\n\n            aContext.save()\n            aContext.translate appliedShadow.offset.x * pixelRatio, appliedShadow.offset.y * pixelRatio\n          \n            # this draws the background of the Panel itself\n            @paintIntoAreaOrBlitFromBackBuffer aContext, dirtyPartOfFrame, appliedShadow\n\n            # since the morph clips at its boundaries, then we know that all of\n            # its children are inside. Hence, if the Panel is fully opaque, then\n            # since we are just drawing the shadow, we can just\n            # draw the shadow of the Panel itself and skip all of the children.\n            if @alpha != 1\n              @children.forEach (child) =>\n                child.fullPaintIntoAreaOrBlitFromBackBuffer aContext, dirtyPartOfFrame, appliedShadow\n\n            aContext.restore()\n\n\n      # PanelWdgt scrolling optimization:\n      fullRawMoveBy: (delta) ->\n        #console.log "moving all morphs in the Panel"\n        @bounds = @bounds.translateBy delta\n        #console.log "move 1"\n        @breakNumberOfRawMovesAndResizesCaches()\n        @children.forEach (child) ->\n          child.silentFullRawMoveBy delta\n        @changed()\n';
