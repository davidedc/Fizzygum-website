// Generated by CoffeeScript 1.12.7
window.SliderMorph_coffeSource = '# Sliders (and hence slider button morphs)\n# are also used in the ScrollPanelWdgts .\n\n# In previous versions the user could force an orientation, so\n# that one could have a vertical slider even if the slider is\n# more wide than tall. Simplified that code because it doesn\'t\n# look like a common need.\n\n# this comment below is needed to figure out dependencies between classes\n# REQUIRES globalFunctions\n# REQUIRES ControllerMixin\n\nclass SliderMorph extends CircleBoxMorph\n\n  @augmentWith ControllerMixin\n\n  target: nil\n  action: nil\n\n  start: nil\n  stop: nil\n  value: nil\n  size: nil\n  offset: nil\n  button: nil\n  argumentToAction: nil\n\n  smallestValueIsAtBottomEnd: false\n\n  idealRatioWidthToHeight: 1/4\n\n  constructor: (\n    @start = 1,\n    @stop = 100,\n    @value = 50,\n    @size = 10,\n    @color = (new Color 0, 0, 0),\n    @smallestValueIsAtBottomEnd = false\n    ) ->\n    @button = new SliderButtonMorph()\n    super # if nil, then a vertical one will be created\n    @alpha = 0.1\n    @silentRawSetExtent new Point 20, 100\n    @silentAdd @button\n\n  colloquialName: ->\n    "slider"\n\n\n  initialiseDefaultVerticalStackLayoutSpec: ->\n    # use the existing VerticalStackLayoutSpec (if it\'s there)\n    if !(@layoutSpecDetails instanceof VerticalStackLayoutSpec) or !@layoutSpecDetails?\n      @layoutSpecDetails = new VerticalStackLayoutSpec 0\n\n  iHaveBeenAddedTo: (whereTo, beingDropped) ->\n    @reLayout()\n    \n    # might happen in phase of deserialization that\n    # the button reference here is still a string\n    # so skip in that case\n    if @button? and @button instanceof SliderButtonMorph\n      @button.reLayout()\n      \n    @changed()\n\n  rawSetExtent: (aPoint) ->\n    unless aPoint.eq @extent()\n      #console.log "move 17"\n      @breakNumberOfRawMovesAndResizesCaches()  \n      super aPoint\n      # my backing store had just been updated\n      # in the call of super, now\n      # it\'s the time of the button\n      @button.reLayout()\n    \n  initialiseDefaultWindowContentLayoutSpec: ->\n    @layoutSpecDetails = new WindowContentLayoutSpec PreferredSize.THIS_ONE_I_HAVE_NOW , PreferredSize.THIS_ONE_I_HAVE_NOW, 0\n    @layoutSpecDetails.resizerCanOverlapContents = false\n\n  \n  rangeSize: ->\n    @stop - @start\n  \n  ratio: ->\n    @size / @rangeSize()\n  \n  unitSize: ->\n    # might happen in phase of deserialization that\n    # the button reference here is still a string\n    # so skip in that case\n    if !(@button? and @button instanceof SliderButtonMorph)\n      return 1\n    if @autoOrientation() is "vertical"\n      return (@height() - @button.height()) / @rangeSize()\n    else\n      return (@width() - @button.width()) / @rangeSize()\n\n  setValue: (newvalue, ignored, connectionsCalculationToken, superCall) ->\n    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken\n    @value = Number(newvalue)\n    @updateTarget()\n    @reLayout()\n    \n    @button.reLayout()\n    \n    @changed()\n    \n  updateValue: ->\n    if @autoOrientation() is "vertical"\n      if @smallestValueIsAtBottomEnd\n        relPos = @bottom() - @button.bottom()\n      else\n        relPos = @button.top() - @top()\n    else\n      relPos = @button.left() - @left()\n\n    newvalue = Math.round relPos / @unitSize() + @start\n\n    if @value != newvalue\n      @setValue newvalue, nil, nil\n\n  # the bang makes the node fire the current output value\n  bang: (newvalue, ignored, connectionsCalculationToken, superCall) ->\n    debugger\n    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken\n    @updateTarget()\n\n  \n  updateTarget: ->\n    debugger\n    if @action and @action != ""\n      @target[@action].call @target, @value, @argumentToAction, @connectionsCalculationToken\n    return\n\n  reactToTargetConnection: ->\n    @updateTarget()\n\n  # SliderMorph menu:\n  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->\n    super\n    menu.addLine()\n    menu.addMenuItem "show value", true, @, "showValue", "display a dialog box\\nshowing the selected number"\n    menu.addMenuItem "floor...", true, @, (->\n      @prompt menu.title + "\\nfloor:",\n        @setStart,\n        @start.toString(),\n        nil,\n        0,\n        @stop - @size,\n        true\n    ), "set the minimum value\\nwhich can be selected"\n    menu.addMenuItem "ceiling...", true, @, (->\n      @prompt menu.title + "\\nceiling:",\n        @setStop,\n        @stop.toString(),\n        nil,\n        @start + @size,\n        @size * 100,\n        true\n    ), "set the maximum value\\nwhich can be selected"\n    menu.addMenuItem "button size...", true, @, (->\n      @prompt menu.title + "\\nbutton size:",\n        @setSize,\n        @size.toString(),\n        nil,\n        1,\n        @stop - @start,\n        true\n    ), "set the range\\ncovered by\\nthe slider button"\n    menu.addLine()\n    menu.addMenuItem "set target", true, @, "openTargetSelector", "select another morph\\nwhose numerical property\\nwill be " + "controlled by this one"\n  \n  showValue: ->\n    @inform @value\n  \n  userSetStart: (num) ->\n    @start = Math.max num, @stop\n\n  \n  # once you set all the properties of a slider you\n  # call this method so it updates itself\n  updateSpecs: (start, stop, value, size)->\n    if start? then @start = start\n    if stop? then @stop = stop\n    if value? then @value = value\n    if size? then @size = size\n    @reLayout()\n    \n    @button.reLayout()\n    \n    # if the parent is the same as the target\n    # then issue a fullChanged on the parent.\n    # It\'s likely to be duplicate, which doesn\'t\n    # matter, but it will consolidate the updates\n    # of the scrollbars too\n    if @parent != @target\n      @changed()\n    else\n      @parent.fullChanged()\n  \n  setStart: (numOrMorphGivingNum) ->\n\n    if numOrMorphGivingNum.getValue?\n      num = numOrMorphGivingNum.getValue()\n    else\n      num = numOrMorphGivingNum\n\n    if typeof num is "number"\n      @start = Math.min Math.max(num, 0), @stop - @size\n    else\n      newStart = parseFloat num\n      @start = Math.min Math.max(newStart, 0), @stop - @size  unless isNaN newStart\n    @value = Math.max @value, @start\n    @updateTarget()\n    @reLayout()\n    \n    @button.reLayout()\n    \n    @changed()\n  \n  setStop: (numOrMorphGivingNum) ->\n\n    if numOrMorphGivingNum.getValue?\n      num = numOrMorphGivingNum.getValue()\n    else\n      num = numOrMorphGivingNum\n\n    if typeof num is "number"\n      @stop = Math.max num, @start + @size\n    else\n      newStop = parseFloat num\n      @stop = Math.max newStop, @start + @size  unless isNaN newStop\n    @value = Math.min @value, @stop\n    @updateTarget()\n    @reLayout()\n    \n    @button.reLayout()\n    \n    @changed()\n  \n  mouseDownLeft: (pos) ->\n    if @button.parent == @ and ((@parent instanceof ScrollPanelWdgt) or (@parent instanceof PromptMorph))\n      world.hand.nonFloatDragMorphFarAwayToHere @button, pos\n      # in an ideal world when a widget moves under the pointer\n      # it gets all the right events like mouseEnter etc.\n      # however that\'s difficult to do, just set the "pressed"\n      # color from here\n      @button.setPressedColor()\n    else\n      @escalateEvent "mouseDownLeft", pos\n    \n\n  setSize: (sizeOrMorphGivingSize) ->\n    if sizeOrMorphGivingSize.getValue?\n      size = sizeOrMorphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    if typeof size is "number"\n      @size = Math.min Math.max(size, 1), @stop - @start\n    else\n      newSize = parseFloat size\n      @size = Math.min Math.max(newSize, 1), @stop - @start  unless isNaN newSize\n    @value = Math.min @value, @stop - @size\n    # it just so happens that, as hoped but somewhat\n    # unexpectedly, as the slider resizes,\n    # the resize mechanism is such that the\n    # button keeps the same value, so there\n    # is no need to update the target.\n    #@updateTarget()\n    @reLayout()\n    \n    @button.reLayout()\n    \n    @changed()\n  \n  # openTargetSelector: -> taken form the ControllerMixin\n  \n  openTargetPropertySelector: (ignored, ignored2, theTarget) ->\n    [menuEntriesStrings, functionNamesStrings] = theTarget.numericalSetters()\n    menu = new MenuMorph @, false, @, true, true, "choose target property:"\n    for i in [0...menuEntriesStrings.length]\n      menu.addMenuItem menuEntriesStrings[i], true, @, "setTargetAndActionWithOnesPickedFromMenu", nil, nil, nil, nil, nil, theTarget, functionNamesStrings[i]\n    if menuEntriesStrings.length == 0\n      menu = new MenuMorph @, false, @, true, true, "no target properties available"\n    menu.popUpAtHand()\n\n  stringSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "bang!", "value"\n    functionNamesStrings.push "bang", "setValue"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "bang!", "value", "start", "stop", "size"\n    functionNamesStrings.push "bang", "setValue", "setStart", "setStop", "setSize"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n  \n  colorSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "bang!"\n    functionNamesStrings.push "bang"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n  ';
