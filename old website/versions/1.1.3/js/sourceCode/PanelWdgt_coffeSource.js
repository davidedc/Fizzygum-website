// Generated by CoffeeScript 1.12.7
window.PanelWdgt_coffeSource = '# I clip my submorphs at my bounds. Which potentially saves a lot of redrawing\n# and event handling. \n# It\'s a good idea to use me whenever it\'s clear that there is a  \n# "container"/"contained" scenario going on.\n\n# REQUIRES RectangularAppearance\n# REQUIRES ClippingAtRectangularBoundsMixin\n# TODO unclear whether this actually requires RectangularAppearance\n\nclass PanelWdgt extends Widget\n\n  @augmentWith ClippingAtRectangularBoundsMixin, @name\n\n  scrollPanel: nil\n  extraPadding: 0\n  _acceptsDrops: true\n  providesAmenitiesForEditing: true\n\n  # if this Panel belongs to a ScrollPanel, then\n  # the @scrollPanel points to it\n  constructor: (@scrollPanel = nil) ->\n    super()\n    @dragsDropsAndEditingEnabled = true\n    @appearance = new RectangularAppearance @\n\n    @color = WorldMorph.preferencesAndSettings.defaultPanelsBackgroundColor\n    @strokeColor = WorldMorph.preferencesAndSettings.defaultPanelsStrokeColor\n\n    if @scrollPanel\n      @noticesTransparentClick = false\n\n  colloquialName: ->\n    "panel"\n\n  # only the desktop and folder panels have menu entries\n  # to invoke this\n  makeFolder: (ignored, ignored2, name) ->\n    debugger\n    newFolderWindow = new FolderWindowWdgt()\n    newFolderWindow.close()\n    newFolderWindow.createReference (name or world.getNextUntitledFolderShortcutName()), @\n    world.howManyUntitledShortcuts++\n    return newFolderWindow\n\n  setColor: (aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken, superCall) ->\n    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken\n\n    aColor = super aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken, true\n    # keep in synch the value of the container scrollPanel\n    # if there is one. Note that the container scrollPanel\n    # is actually not painted.\n    if @scrollPanel\n      # if the color is set using the color string literal\n      # e.g. "red" then we can\'t check equality using .eq\n      # so just skip the check and set the color\n      # TODO either all colors should be set as Color instead\n      # of strings, or this check should be smarter\n      if @scrollPanel.color?.eq?\n        if @scrollPanel.color.eq aColor\n          return\n      @scrollPanel.color = aColor\n      @scrollPanel.changed()\n\n    return aColor\n\n\n  setAlphaScaled: (alphaOrMorphGivingAlpha, morphGivingAlpha) ->\n    alpha = super(alphaOrMorphGivingAlpha, morphGivingAlpha)\n    if @scrollPanel\n      unless @scrollPanel.alpha == alpha\n        @scrollPanel.alpha = alpha\n    return alpha\n\n\n  mouseClickLeft: (pos, ignored_button, ignored_buttons, ignored_ctrlKey, shiftKey, ignored_altKey, ignored_metaKey) ->\n    @bringToForeground()\n\n    # when you click on an "empty" part of a Panel that contains\n    # a piece of text, we pass the click on to the text to it\n    # puts the caret at the end of the text.\n    # TODO the focusing and placing of the caret at the end of\n    # the text should happen via API rather than via spoofing\n    # a mouse event?\n    if @parent? and @parent instanceof ScrollPanelWdgt\n      childrenNotCarets = @children.filter (m) ->\n        !(m instanceof CaretMorph)\n      if childrenNotCarets.length == 1\n        item = @firstChildSuchThat (m) ->\n          ((m instanceof TextMorph) or\n          (m instanceof SimplePlainTextWdgt)) and m.isEditable\n        item?.mouseClickLeft item.bottomRight(), ignored_button, ignored_buttons, ignored_ctrlKey, shiftKey, ignored_altKey, ignored_metaKey\n\n\n  reactToDropOf: ->\n    if @parent?\n      if @parent.adjustContentsBounds?\n        @parent.adjustContentsBounds()\n        @parent.adjustScrollBars?()\n\n  childRemoved: (child) ->\n    if @parent?\n      @parent.grandChildRemoved?()  \n      if @parent.adjustContentsBounds?\n        @parent.adjustContentsBounds()\n        @parent.adjustScrollBars?()  \n\n  childAdded: (child) ->\n    # the BasementWdgt has a filter that can\n    # show/hide the contents of this pane\n    # based on whether they are reachable or\n    # not. So let\'s notify it.\n    if @parent?\n      @parent.grandChildAdded?()\n      if @parent.parent?\n        if @parent.parent.childAddedInScrollPanel?\n          @parent.parent.childAddedInScrollPanel child\n\n  # puts the morph in the ScrollPanel\n  # in some sparse manner and keeping it\n  # "in view"\n  addInPseudoRandomPosition: (aMorph) ->\n    width = @width()\n    height = @height()\n\n    posx = Math.abs(hashCode(aMorph.toString())) % width\n    posy = Math.abs(hashCode(aMorph.toString() + "x")) % height\n    position = @position().add new Point posx, posy\n\n    @add aMorph\n    aMorph.fullRawMoveTo position\n\n    if @parent?\n      if @parent.adjustContentsBounds?\n        @parent.adjustContentsBounds()\n        @parent.adjustScrollBars()\n\n\n  detachesWhenDragged: ->\n    if @parent?\n\n      # otherwise you could detach a Frame contained in a\n      # ScrollPanelWdgt which is very strange\n      if @parent instanceof ScrollPanelWdgt\n        return false\n\n      return super\n\n  grabsToParentWhenDragged: ->\n    if @parent?\n\n      # otherwise you could detach a Frame contained in a\n      # ScrollPanelWdgt which is very strange\n      if @parent instanceof ScrollPanelWdgt\n        if @parent.canScrollByDraggingBackground and @parent.anyScrollBarShowing()\n          return false\n        else\n          return true\n\n      return super\n\n    # doesn\'t have a parent\n    return false\n  \n  reactToGrabOf: ->\n    if @parent?\n      if @parent.adjustContentsBounds?\n        @parent.adjustContentsBounds()\n        @parent.adjustScrollBars?()\n\n  # PanelWdgt menus:\n  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->\n    super\n    if @children.length\n      menu.addLine()\n      menu.addMenuItem "move all inside", true, @, "keepAllSubmorphsWithin", "keep all submorphs\\nwithin and visible"\n  \n  keepAllSubmorphsWithin: ->\n    @children.forEach (m) =>\n      m.fullRawMoveWithin @\n\n  editButtonPressedFromWindowBar: ->\n    debugger\n    if @dragsDropsAndEditingEnabled\n      @disableDragsDropsAndEditing @\n    else\n      @enableDragsDropsAndEditing @\n\n';
