// Generated by CoffeeScript 1.12.7
window.ExampleScatterPlotWdgt_coffeSource = 'class ExampleScatterPlotWdgt extends GraphsPlotsChartsWdgt\n\n\n  graphNumber: 1\n  drawOnlyPartOfBoundingRect: false\n\n  constructor: (@drawOnlyPartOfBoundingRect)->\n    super()\n    @fps = 1\n    world.addSteppingMorph @\n\n  colloquialName: ->\n    "Scatter plot"\n\n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->\n\n    if @preliminaryCheckNothingToDraw clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return nil\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @backgroundTransparency\n\n      # paintRectangle here is made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, this is why\n      # it\'s called before the scaling.\n      @paintRectangle aContext, al, at, w, h, @backgroundColor\n      aContext.scale pixelRatio, pixelRatio\n\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n\n      @renderingHelper aContext, new Color(255, 255, 255), appliedShadow\n\n      aContext.restore()\n\n      # paintHighlight here is made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, this is why\n      # it\'s called outside the effect of the scaling\n      # (after the restore).\n      @paintHighlight aContext, al, at, w, h\n\n\n  step: ->\n    @graphNumber++\n    @changed()\n\n  renderingHelper: (context, color, appliedShadow) ->\n\n    @seed = @graphNumber\n    circleRadius = 5\n    height = @height()\n    width = @width()\n\n\n    if appliedShadow?\n      @simpleShadow context, color, appliedShadow\n      return\n\n    context.fillStyle = WorldMorph.preferencesAndSettings.editableItemBackgroundColor.toString()\n    context.fillRect 0, 0, width, height\n\n    availableHeight = height - 2 * circleRadius\n    availableWidth = width - 2 * circleRadius\n\n    context.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @alpha\n\n    context.lineWidth = 1\n\n    context.beginPath()\n    for i in [0...100]\n      widthPerc = 0.4 + @seeded_randn_bm() / 10\n      heightPerc = 0.4 + @seeded_randn_bm() / 10\n\n      context.moveTo Math.round(2 * circleRadius + availableWidth * widthPerc),Math.round(circleRadius + availableHeight * heightPerc)\n      context.arc Math.round(circleRadius + availableWidth * widthPerc),Math.round(circleRadius + availableHeight * heightPerc),circleRadius,0,2*Math.PI\n    context.strokeStyle = \'#325FA2\'\n    context.stroke()\n\n    context.beginPath()\n    for i in [0...100]\n      widthPerc = 0.6 + @seeded_randn_bm() / 10\n      heightPerc = 0.6 + @seeded_randn_bm() / 10\n\n      context.moveTo Math.round(2 * circleRadius + availableWidth * widthPerc),Math.round(circleRadius + availableHeight * heightPerc)\n      context.arc Math.round(circleRadius + availableWidth * widthPerc),Math.round(circleRadius + availableHeight * heightPerc),circleRadius,0,2*Math.PI\n\n    context.strokeStyle = \'#FF0000\'\n    context.stroke()\n\n    @drawBoundingBox context, color, appliedShadow\n\n\n';
