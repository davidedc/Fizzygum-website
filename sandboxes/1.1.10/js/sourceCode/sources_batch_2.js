

window.AnalogClockWdgt_coffeSource = "class AnalogClockWdgt extends Widget⤶⤶  hoursHandAngle: 0⤶  minutesHandAngle: 0⤶  secondsHandAngle: 0⤶  strokeSizeToClockDimensionRatio: 1/250⤶  dateLastTicked: nil⤶⤶  constructor: ->⤶⤶    @fps = 1⤶    @synchronisedStepping = true⤶    @dateLastTicked = WorldMorph.currentDate⤶    world.steppingWdgts.add @⤶⤶    super()⤶    @setColor new Color 255, 125, 125⤶    @rawSetExtent new Point 200, 200⤶    return⤶⤶  colloquialName: ->⤶    ＂analog clock＂⤶⤶  widthWithoutSpacing: ->⤶    Math.min @width(), @height()⤶⤶  rawResizeToWithoutSpacing: ->⤶    @rawSetExtent new Point @widthWithoutSpacing(), @widthWithoutSpacing()⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    super⤶    @layoutSpecDetails.canSetHeightFreely = false⤶⤶  rawSetWidthSizeHeightAccordingly: (newWidth) ->⤶    @rawSetExtent new Point newWidth, newWidth⤶⤶⤶  # This method only paints this very morph's ＂image＂,⤶  # it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which⤶  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if @preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return⤶⤶    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle⤶    if area.isNotEmpty()⤶      if w < 1 or h < 1⤶        return nil⤶⤶      aContext.save()⤶⤶      # clip out the dirty rectangle as we are⤶      # going to paint the whole of the box⤶      aContext.clipToRectangle al,at,w,h⤶⤶      aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @backgroundTransparency⤶⤶      # paintRectangle here is made to work with⤶      # al, at, w, h which are actual pixels⤶      # rather than logical pixels, this is why⤶      # it's called before the scaling.⤶      @paintRectangle aContext, al, at, w, h, @backgroundColor⤶      aContext.useLogicalPixelsUntilRestore()⤶⤶      morphPosition = @position()⤶      aContext.translate morphPosition.x, morphPosition.y⤶⤶      @renderingHelper aContext, Color.WHITE, appliedShadow⤶⤶      aContext.restore()⤶⤶      # paintHighlight here is made to work with⤶      # al, at, w, h which are actual pixels⤶      # rather than logical pixels, this is why⤶      # it's called outside the effect of the scaling⤶      # (after the restore).⤶      @paintHighlight aContext, al, at, w, h⤶⤶  step: ->⤶    @dateLastTicked = WorldMorph.currentDate⤶    @changed()⤶⤶  calculateHandsAngles: ->⤶⤶    if Automator? and⤶     Automator.animationsPacingControl and⤶     Automator.state == Automator.PLAYING⤶      @dateLastTicked = new Date 2011,10,30⤶⤶    #sec = @dateLastTicked.getSeconds()⤶    sec = @dateLastTicked.getSeconds() + @dateLastTicked.getMilliseconds()/1000⤶    min = @dateLastTicked.getMinutes()⤶    hr = @dateLastTicked.getHours()⤶    hr = if hr >= 12 then hr - 12 else hr⤶    @hoursHandAngle = hr * Math.PI / 6 + Math.PI / 360 * min + Math.PI / 21600 * sec⤶    @minutesHandAngle = Math.PI / 30 * min + Math.PI / 1800 * sec⤶    @secondsHandAngle = sec * Math.PI / 30⤶⤶  renderingHelper: (context, color, appliedShadow) ->⤶    height = @height()⤶    width = @width()⤶⤶    context.lineWidth = 1 * Math.min(width,height) * @strokeSizeToClockDimensionRatio⤶    context.lineCap = ＂round＂⤶⤶    context.save()⤶    context.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @alpha⤶⤶    squareDim = Math.min width/2, height/2⤶⤶    context.translate width/2, height/2⤶    context.scale 0.9, 0.9⤶⤶    context.rotate -Math.PI / 2⤶    context.strokeStyle = 'black'⤶    context.fillStyle = 'white'⤶    context.lineWidth = 6 * Math.min(width,height) * @strokeSizeToClockDimensionRatio⤶    context.lineCap = 'round'⤶⤶    # hour face ticks⤶    context.save()⤶    i = 0⤶    while i < 12⤶      context.beginPath()⤶      context.rotate Math.PI / 6⤶      context.moveTo squareDim*2.4/3, 0⤶      context.lineTo squareDim, 0⤶      context.stroke()⤶      i++⤶    context.restore()⤶⤶    # minute face ticks⤶    context.save()⤶    context.lineWidth = 5 * Math.min(width,height) * @strokeSizeToClockDimensionRatio⤶    i = 0⤶    while i < 60⤶      if i % 5 != 0⤶        context.beginPath()⤶        context.moveTo squareDim*2.7/3, 0⤶        context.lineTo squareDim, 0⤶        context.stroke()⤶      context.rotate Math.PI / 30⤶      i++⤶    context.restore()⤶⤶    context.fillStyle = 'black'⤶⤶    @calculateHandsAngles()⤶⤶    @drawHoursHand context, squareDim⤶    @drawMinutesHand context, squareDim⤶    @drawSecondsHand context, squareDim⤶    @drawDotInMiddleOfFace context, squareDim⤶⤶    context.beginPath()⤶    context.lineWidth = 10 * Math.min(width,height) * @strokeSizeToClockDimensionRatio⤶    context.strokeStyle = '#325FA2'⤶    context.arc 0, 0, squareDim, 0, Math.PI * 2⤶    context.stroke()⤶⤶⤶    context.restore()⤶⤶    context.strokeStyle = color.toString()⤶⤶⤶  drawHoursHand: (context, squareDim) ->⤶    height = @height()⤶    width = @width()⤶    context.save()⤶    context.rotate @hoursHandAngle⤶    context.lineWidth = 8 * Math.min(width,height) * @strokeSizeToClockDimensionRatio⤶    context.beginPath()⤶    context.moveTo -squareDim/7, 0⤶    context.lineTo squareDim/2, 0⤶    context.stroke()⤶    context.restore()⤶⤶⤶  drawMinutesHand: (context, squareDim) ->⤶    height = @height()⤶    width = @width()⤶    context.save()⤶    context.rotate @minutesHandAngle⤶    context.lineWidth = 5 * Math.min(width,height) * @strokeSizeToClockDimensionRatio⤶    context.beginPath()⤶    context.moveTo -squareDim/5, 0⤶    context.lineTo squareDim/1.3, 0⤶    context.stroke()⤶    context.restore()⤶⤶  drawSecondsHand: (context, squareDim) ->⤶    height = @height()⤶    width = @width()⤶    context.save()⤶    context.rotate @secondsHandAngle⤶    context.strokeStyle = '#D40000'⤶    context.fillStyle = '#D40000'⤶    context.lineWidth = 6 * Math.min(width,height) * @strokeSizeToClockDimensionRatio⤶    context.beginPath()⤶    context.moveTo -squareDim/5, 0⤶    context.lineTo squareDim/1.3, 0⤶    context.stroke()⤶    context.restore()⤶⤶  drawDotInMiddleOfFace: (context, squareDim) ->⤶    height = @height()⤶    width = @width()⤶    context.save()⤶    context.fillStyle = '#D40000'⤶    context.lineWidth = 6 * Math.min(width,height) * @strokeSizeToClockDimensionRatio⤶    context.beginPath()⤶    context.arc 0, 0, Math.min(width,height)/30, 0, Math.PI * 2⤶    context.fill()⤶    context.restore()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.DashboardsWdgt_coffeSource = "class DashboardsWdgt extends StretchableEditableWdgt⤶⤶  colloquialName: ->   ⤶    ＂Dashboards Maker＂⤶⤶  representativeIcon: ->⤶    new DashboardsIconWdgt⤶⤶⤶  createToolsPanel: ->⤶    # tools -------------------------------⤶    @toolsPanel = new ScrollPanelWdgt new ToolPanelWdgt⤶⤶    @toolsPanel.addMany [⤶      new TextBoxCreatorButtonWdgt⤶      new ExternalLinkCreatorButtonWdgt⤶⤶      new ScatterPlotWithAxesCreatorButtonWdgt⤶      new FunctionPlotWithAxesCreatorButtonWdgt⤶      new BarPlotWithAxesCreatorButtonWdgt⤶      new Plot3DCreatorButtonWdgt⤶⤶      new WorldMapCreatorButtonWdgt⤶      new USAMapCreatorButtonWdgt⤶      new MapPinIconWdgt⤶⤶      new SpeechBubbleWdgt⤶⤶      new ArrowNIconWdgt⤶      new ArrowSIconWdgt⤶      new ArrowWIconWdgt⤶      new ArrowEIconWdgt⤶      new ArrowNWIconWdgt⤶      new ArrowNEIconWdgt⤶      new ArrowSWIconWdgt⤶      new ArrowSEIconWdgt⤶    ]⤶⤶⤶⤶    @toolsPanel.disableDragsDropsAndEditing()⤶    @add @toolsPanel⤶    @dragsDropsAndEditingEnabled = true⤶    @invalidateLayout()⤶⤶  createNewStretchablePanel: ->⤶    @stretchableWidgetContainer = new StretchableWidgetContainerWdgt⤶    @add @stretchableWidgetContainer⤶⤶⤶  # TODO this method is the same as in the simple slide widget⤶  reLayout: ->⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    # label⤶    labelLeft = @left() + @externalPadding⤶    labelRight = @right() - @externalPadding⤶    labelBottom = @top() + @externalPadding⤶⤶    # tools -------------------------------⤶⤶    if @toolsPanel?.parent == @⤶      @toolsPanel.fullRawMoveTo new Point @left() + @externalPadding, labelBottom⤶      @toolsPanel.rawSetExtent new Point 95, @height() - 2 * @externalPadding⤶⤶⤶    # stretchableWidgetContainer --------------------------⤶⤶    stretchableWidgetContainerWidth = @width() - 2*@externalPadding⤶    ⤶    if @dragsDropsAndEditingEnabled⤶      stretchableWidgetContainerWidth -= @toolsPanel.width() + @internalPadding⤶⤶    stretchableWidgetContainerHeight =  @height() - 2 * @externalPadding⤶    if @dragsDropsAndEditingEnabled⤶      stretchableWidgetContainerLeft = @toolsPanel.right() + @internalPadding⤶    else⤶      stretchableWidgetContainerLeft = @left() + @externalPadding⤶⤶    if @stretchableWidgetContainer.parent == @⤶      @stretchableWidgetContainer.fullRawMoveTo new Point stretchableWidgetContainerLeft, labelBottom⤶      @stretchableWidgetContainer.setExtent new Point stretchableWidgetContainerWidth, stretchableWidgetContainerHeight⤶⤶    # ----------------------------------------------⤶⤶⤶    trackChanges.pop()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.PatchProgrammingWdgt_coffeSource = "class PatchProgrammingWdgt extends StretchableEditableWdgt⤶⤶  colloquialName: ->   ⤶    ＂Patch Programming＂⤶⤶  representativeIcon: ->⤶    new PatchProgrammingIconWdgt⤶⤶⤶  createToolsPanel: ->⤶    # tools -------------------------------⤶    @toolsPanel = new ScrollPanelWdgt new ToolPanelWdgt⤶⤶    @toolsPanel.addMany [⤶      new TextBoxCreatorButtonWdgt⤶      new SliderNodeCreatorButtonWdgt⤶⤶      new ColorPaletteNodeCreatorButtonWdgt⤶      new GrayscalePaletteNodeCreatorButtonWdgt⤶      new CalculatingNodeCreatorButtonWdgt⤶    ]⤶⤶⤶⤶    @toolsPanel.disableDragsDropsAndEditing()⤶    @add @toolsPanel⤶    @dragsDropsAndEditingEnabled = true⤶    @invalidateLayout()⤶⤶  createNewStretchablePanel: ->⤶    @stretchableWidgetContainer = new StretchableWidgetContainerWdgt⤶    @add @stretchableWidgetContainer⤶⤶⤶  # TODO this method is the same as in the simple slide widget⤶  reLayout: ->⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    # label⤶    labelLeft = @left() + @externalPadding⤶    labelRight = @right() - @externalPadding⤶    labelBottom = @top() + @externalPadding⤶⤶    # tools -------------------------------⤶⤶    if @toolsPanel?.parent == @⤶      @toolsPanel.fullRawMoveTo new Point @left() + @externalPadding, labelBottom⤶      @toolsPanel.rawSetExtent new Point 95, @height() - 2 * @externalPadding⤶⤶⤶    # stretchableWidgetContainer --------------------------⤶⤶    stretchableWidgetContainerWidth = @width() - 2*@externalPadding⤶    ⤶    if @dragsDropsAndEditingEnabled⤶      stretchableWidgetContainerWidth -= @toolsPanel.width() + @internalPadding⤶⤶    stretchableWidgetContainerHeight =  @height() - 2 * @externalPadding⤶    if @dragsDropsAndEditingEnabled⤶      stretchableWidgetContainerLeft = @toolsPanel.right() + @internalPadding⤶    else⤶      stretchableWidgetContainerLeft = @left() + @externalPadding⤶⤶    if @stretchableWidgetContainer.parent == @⤶      @stretchableWidgetContainer.fullRawMoveTo new Point stretchableWidgetContainerLeft, labelBottom⤶      @stretchableWidgetContainer.setExtent new Point stretchableWidgetContainerWidth, stretchableWidgetContainerHeight⤶⤶    # ----------------------------------------------⤶⤶⤶    trackChanges.pop()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ReconfigurablePaintWdgt_coffeSource = "class ReconfigurablePaintWdgt extends StretchableEditableWdgt⤶⤶  mainCanvas: nil⤶  overlayCanvas: nil⤶  pencilToolButton: nil⤶  brushToolButton: nil⤶  toothpasteToolButton: nil⤶  eraserToolButton: nil⤶  highlightedToolIconColor: new Color 245, 126, 0⤶⤶⤶  colloquialName: ->   ⤶    ＂Drawings Maker＂⤶⤶  representativeIcon: ->⤶    new PaintBucketIconWdgt⤶⤶⤶  isToolPressed: (buttonToCheckIfPressed) ->⤶    whichButtonIsSelected = @toolsPanel.whichButtonSelected()⤶    if whichButtonIsSelected?⤶      if whichButtonIsSelected == buttonToCheckIfPressed.parent⤶        return true⤶      else⤶        return false⤶    return false⤶⤶  # normally a button injects new code only when⤶  # is pressed, BUT here we make it so we inject new⤶  # code also if the tool is selected, without it to⤶  # be re-pressed. In order to do that, we⤶  # simply listen to a notification of new code being⤶  # available from a button, we check if it's selected⤶  # and in that case we tell the button to actually⤶  # inject the code.⤶  newCodeToInjectFromButton: (whichButtonHasNewCode) ->⤶    if @isToolPressed whichButtonHasNewCode⤶      whichButtonHasNewCode.injectCodeIntoTarget()⤶⤶  createNewStretchablePanel: ->⤶    # mainCanvas⤶    @stretchableWidgetContainer = new StretchableWidgetContainerWdgt new StretchableCanvasWdgt⤶    @stretchableWidgetContainer.disableDrops()⤶    @add @stretchableWidgetContainer⤶⤶    @mainCanvas = @stretchableWidgetContainer.contents⤶⤶    # overlayCanvas⤶    @overlayCanvas = new CanvasGlassTopWdgt⤶    @overlayCanvas.underlyingCanvasMorph = @mainCanvas⤶    @overlayCanvas.disableDrops()⤶    @mainCanvas.add @overlayCanvas⤶⤶    # if you clear the overlay to perfectly⤶    # transparent, then we need to set this flag⤶    # otherwise the pointer won't be reported⤶    # as moving inside the canvas.⤶    # If you give the overlay canvas even the smallest⤶    # tint then you don't need this flag.⤶    @overlayCanvas.noticesTransparentClick = true⤶⤶⤶    @overlayCanvas.injectProperty ＂mouseLeave＂, ＂＂＂⤶        # don't leave any trace behind then the pointer⤶        # moves out.⤶        (pos) ->⤶            context = @backBufferContext⤶            context.setTransform 1, 0, 0, 1, 0, 0⤶            context.clearRect 0, 0, @width() * ceilPixelRatio, @height() * ceilPixelRatio⤶            @changed()⤶    ＂＂＂⤶⤶  createToolsPanel: ->⤶    @toolsPanel = new RadioButtonsHolderMorph⤶    @add @toolsPanel⤶⤶    pencilButtonOff = new CodeInjectingSimpleRectangularButtonMorph @, @overlayCanvas, new Pencil2IconMorph⤶    pencilButtonOff.alpha = 0.1⤶    pencilButtonOff.sourceCodeToBeInjected = ＂＂＂⤶        mouseMove = (pos, mouseButton) ->⤶            if world.hand.isThisPointerDraggingSomething() then return⤶            context = @backBufferContext⤶            context.setTransform 1, 0, 0, 1, 0, 0⤶            context.clearRect 0, 0, @width() * ceilPixelRatio, @height() * ceilPixelRatio⤶            context.useLogicalPixelsUntilRestore()⤶⤶            # give it a little bit of a tint so⤶            # you can see the canvas when you take it⤶            # apart from the paint tool.⤶            #context.fillStyle = (new Color 0,255,0,0.5).toString()⤶            #context.fillRect 0, 0, @width(), @height()⤶⤶            context.translate -@bounds.origin.x, -@bounds.origin.y⤶            context.translate pos.x, pos.y⤶⤶            context.beginPath()⤶            context.lineWidth=＂2＂⤶⤶            if mouseButton == 'left'⤶                contextMain = @underlyingCanvasMorph.getContextForPainting()⤶                contextMain.translate pos.x, pos.y⤶⤶                contextMain.beginPath()⤶                contextMain.lineWidth=＂2＂⤶                contextMain.fillStyle = ＂black＂⤶                contextMain.rect(-2,-2,4,4)⤶                contextMain.fill()⤶                @underlyingCanvasMorph.changed()⤶⤶            else⤶                context.strokeStyle=＂red＂⤶                context.rect(-2,-2,4,4)⤶                context.stroke()⤶            @changed()⤶        ＂＂＂⤶⤶    pencilButtonOn = new CodeInjectingSimpleRectangularButtonMorph @, @overlayCanvas, new Pencil2IconMorph @highlightedToolIconColor⤶    pencilButtonOn.alpha = 0.1⤶    pencilButtonOn.sourceCodeToBeInjected = ＂mouseMove = -> return＂⤶⤶    @pencilToolButton = new ToggleButtonMorph pencilButtonOff, pencilButtonOn⤶⤶⤶⤶⤶    brushToolButtonOff = new CodeInjectingSimpleRectangularButtonMorph @, @overlayCanvas, new BrushIconMorph⤶    brushToolButtonOff.alpha = 0.1⤶⤶    brushToolButtonOff.sourceCodeToBeInjected = ＂＂＂⤶        mouseMove = (pos, mouseButton) ->⤶            if world.hand.isThisPointerDraggingSomething() then return⤶            context = @backBufferContext⤶            context.setTransform 1, 0, 0, 1, 0, 0⤶            context.clearRect 0, 0, @width() * ceilPixelRatio, @height() * ceilPixelRatio⤶            context.useLogicalPixelsUntilRestore()⤶⤶            context.translate -@bounds.origin.x, -@bounds.origin.y⤶            context.translate pos.x, pos.y⤶⤶            context.beginPath()⤶            context.lineWidth=＂2＂⤶⤶            if mouseButton == 'left'⤶                context.fillStyle = ＂red＂⤶⤶                contextMain = @underlyingCanvasMorph.getContextForPainting()⤶                contextMain.translate pos.x, pos.y⤶                contextMain.fillStyle = ＂black＂⤶⤶                # the brush is 16 x 16, so center it⤶                contextMain.translate -8, -8⤶⤶                # for convenience, the brush has been⤶                # drawn first using 6x6 squares, so now⤶                # scale those back⤶                contextMain.scale 1/6, 1/6⤶⤶                contextMain.beginPath()⤶                contextMain.rect 48, 0, 6, 6⤶                contextMain.rect 36, 6, 6, 6⤶                contextMain.rect 54, 6, 6, 6⤶                contextMain.rect 66, 6, 6, 6⤶                contextMain.rect 30, 12, 12, 6⤶                contextMain.rect 48, 12, 6, 6⤶                contextMain.rect 72, 12, 6, 6⤶                contextMain.rect 12, 18, 36, 6⤶                contextMain.rect 60, 18, 6, 6⤶                contextMain.rect 78, 18, 6, 6⤶                contextMain.rect 24, 24, 42, 6⤶                contextMain.rect 72, 24, 6, 6⤶                contextMain.rect 90, 24, 6, 6⤶                contextMain.rect 18, 30, 42, 6⤶                contextMain.rect 66, 30, 6, 6⤶                contextMain.rect 18, 36, 36, 6⤶                contextMain.rect 6, 36, 6, 6⤶                contextMain.rect 60, 36, 12, 6⤶                contextMain.rect 78, 36, 6, 6⤶                contextMain.rect 90, 36, 6, 6⤶                contextMain.rect 24, 42, 36, 6⤶                contextMain.rect 66, 42, 12, 6⤶                contextMain.rect 6, 48, 6, 6⤶                contextMain.rect 18, 48, 6, 6⤶                contextMain.rect 30, 48, 12, 6⤶                contextMain.rect 54, 48, 6, 6⤶                contextMain.rect 78, 48, 6, 6⤶                contextMain.rect 36, 54, 6, 12⤶                contextMain.rect 48, 54, 6, 6⤶                contextMain.rect 60, 54, 12, 6⤶                contextMain.rect 90, 54, 6, 6⤶                contextMain.rect 6, 60, 6, 6⤶                contextMain.rect 18, 60, 12, 6⤶                contextMain.rect 54, 60, 6, 12⤶                contextMain.rect 78, 60, 6, 6⤶                contextMain.rect 0, 66, 6, 6⤶                contextMain.rect 42, 66, 6, 12⤶                contextMain.rect 66, 66, 6, 6⤶                contextMain.rect 18, 72, 6, 6⤶                contextMain.rect 30, 72, 6, 6⤶                contextMain.rect 60, 78, 6, 6⤶                contextMain.rect 78, 78, 6, 6⤶                contextMain.rect 12, 84, 6, 6⤶                contextMain.rect 36, 84, 6, 6⤶                contextMain.rect 54, 84, 6, 6⤶                contextMain.rect 42, 90, 6, 6⤶                contextMain.rect 18, 6, 6, 6⤶                contextMain.rect 6, 24, 6, 6⤶                contextMain.rect 0, 42, 6, 6⤶                contextMain.fill()⤶⤶⤶                @underlyingCanvasMorph.changed()⤶⤶            else⤶                context.strokeStyle=＂green＂⤶            context.rect(-5,-5,10,10)⤶            context.stroke()⤶            @changed()⤶        ＂＂＂⤶⤶    brushToolButtonOn = new CodeInjectingSimpleRectangularButtonMorph @, @overlayCanvas, new BrushIconMorph @highlightedToolIconColor⤶    brushToolButtonOn.alpha = 0.1⤶    brushToolButtonOn.sourceCodeToBeInjected = ＂mouseMove = -> return＂⤶    @brushToolButton = new ToggleButtonMorph brushToolButtonOff, brushToolButtonOn⤶⤶⤶    toothpasteToolButtonOff = new CodeInjectingSimpleRectangularButtonMorph @, @overlayCanvas, new ToothpasteIconMorph⤶    toothpasteToolButtonOff.alpha = 0.1⤶⤶    toothpasteToolButtonOff.sourceCodeToBeInjected = ＂＂＂⤶        # Toothpaste graphics⤶        # original implementation by Ward Cunningham, from Tektronix Smalltalk⤶        # implementation of Smalltalk 80⤶        # on the Magnolia (1980-1983) and the Tek 4404 (1984)⤶        # ＂Draw spheres ala Ken Knowlton, Computer Graphics, v15 n4 p352.＂⤶⤶        paintBrush = (contextMain) ->⤶            contextMain.save()⤶            # the brush is 16 x 16, so center it⤶            contextMain.translate -8, -8⤶⤶            # for convenience, the brush has been⤶            # drawn first using 6x6 squares, so now⤶            # scale those back⤶            contextMain.scale 1/6, 1/6⤶⤶            contextMain.beginPath()⤶            contextMain.rect 48, 0, 6, 6⤶            contextMain.rect 36, 6, 6, 6⤶            contextMain.rect 54, 6, 6, 6⤶            contextMain.rect 66, 6, 6, 6⤶            contextMain.rect 30, 12, 12, 6⤶            contextMain.rect 48, 12, 6, 6⤶            contextMain.rect 72, 12, 6, 6⤶            contextMain.rect 12, 18, 36, 6⤶            contextMain.rect 60, 18, 6, 6⤶            contextMain.rect 78, 18, 6, 6⤶            contextMain.rect 24, 24, 42, 6⤶            contextMain.rect 72, 24, 6, 6⤶            contextMain.rect 90, 24, 6, 6⤶            contextMain.rect 18, 30, 42, 6⤶            contextMain.rect 66, 30, 6, 6⤶            contextMain.rect 18, 36, 36, 6⤶            contextMain.rect 6, 36, 6, 6⤶            contextMain.rect 60, 36, 12, 6⤶            contextMain.rect 78, 36, 6, 6⤶            contextMain.rect 90, 36, 6, 6⤶            contextMain.rect 24, 42, 36, 6⤶            contextMain.rect 66, 42, 12, 6⤶            contextMain.rect 6, 48, 6, 6⤶            contextMain.rect 18, 48, 6, 6⤶            contextMain.rect 30, 48, 12, 6⤶            contextMain.rect 54, 48, 6, 6⤶            contextMain.rect 78, 48, 6, 6⤶            contextMain.rect 36, 54, 6, 12⤶            contextMain.rect 48, 54, 6, 6⤶            contextMain.rect 60, 54, 12, 6⤶            contextMain.rect 90, 54, 6, 6⤶            contextMain.rect 6, 60, 6, 6⤶            contextMain.rect 18, 60, 12, 6⤶            contextMain.rect 54, 60, 6, 12⤶            contextMain.rect 78, 60, 6, 6⤶            contextMain.rect 0, 66, 6, 6⤶            contextMain.rect 42, 66, 6, 12⤶            contextMain.rect 66, 66, 6, 6⤶            contextMain.rect 18, 72, 6, 6⤶            contextMain.rect 30, 72, 6, 6⤶            contextMain.rect 60, 78, 6, 6⤶            contextMain.rect 78, 78, 6, 6⤶            contextMain.rect 12, 84, 6, 6⤶            contextMain.rect 36, 84, 6, 6⤶            contextMain.rect 54, 84, 6, 6⤶            contextMain.rect 42, 90, 6, 6⤶            contextMain.rect 18, 6, 6, 6⤶            contextMain.rect 6, 24, 6, 6⤶            contextMain.rect 0, 42, 6, 6⤶            contextMain.fill()⤶⤶            contextMain.restore()⤶⤶        # you'd be tempted to initialise the queue⤶        # on mouseDown but it would be a bad idea⤶        # because the mouse could come ＂already-pressed＂⤶        # from outside the canvas⤶        initialiseQueueIfNeeded = ->⤶            if !@queue?⤶                @queue = [0..24].map -> nil⤶⤶        mouseUpLeft = ->⤶            if world.hand.isThisPointerDraggingSomething() then return⤶            if @queue?⤶                # draining the queue⤶                contextMain = @underlyingCanvasMorph.getContextForPainting()⤶                ⤶                until @queue.length == 0⤶                    previousPos = @queue[0]⤶                    @queue.shift()⤶                    if previousPos?⤶                        contextMain.save()⤶                        contextMain.translate previousPos.x, previousPos.y⤶                        contextMain.fillStyle = ＂white＂⤶                        @paintBrush contextMain⤶                        contextMain.restore()⤶                delete @queue⤶⤶        mouseMove = (pos, mouseButton) ->⤶            if world.hand.isThisPointerDraggingSomething() then return⤶            context = @backBufferContext⤶            context.setTransform 1, 0, 0, 1, 0, 0⤶            context.clearRect 0, 0, @width() * ceilPixelRatio, @height() * ceilPixelRatio⤶            context.useLogicalPixelsUntilRestore()⤶⤶            context.translate -@bounds.origin.x, -@bounds.origin.y⤶            context.translate pos.x, pos.y⤶⤶            context.beginPath()⤶            context.lineWidth=＂2＂⤶⤶            if mouseButton == 'left'⤶                @initialiseQueueIfNeeded()⤶                @queue.push pos⤶                context.fillStyle = ＂red＂⤶⤶                contextMain = @underlyingCanvasMorph.getContextForPainting()⤶                ⤶                contextMain.save()⤶                contextMain.translate pos.x, pos.y⤶                contextMain.fillStyle = ＂black＂⤶                #@paintBrush contextMain⤶                contextMain.beginPath()⤶                contextMain.arc 0,0,9,0,2*Math.PI⤶                contextMain.fill()⤶                contextMain.restore()⤶⤶⤶                previousPos = @queue[0]⤶                @queue.shift()⤶                if previousPos?⤶                    contextMain.save()⤶                    contextMain.translate previousPos.x, previousPos.y⤶                    contextMain.fillStyle = ＂white＂⤶                    @paintBrush contextMain⤶                    contextMain.restore()⤶⤶⤶                @underlyingCanvasMorph.changed()⤶⤶            else⤶                context.strokeStyle=＂green＂⤶            context.rect(-5,-5,10,10)⤶            context.stroke()⤶            @changed()⤶        ＂＂＂⤶⤶    toothpasteToolButtonOn = new CodeInjectingSimpleRectangularButtonMorph @, @overlayCanvas, new ToothpasteIconMorph @highlightedToolIconColor⤶    toothpasteToolButtonOn.alpha = 0.1⤶    toothpasteToolButtonOn.sourceCodeToBeInjected = ＂mouseMove = -> return＂⤶    @toothpasteToolButton = new ToggleButtonMorph toothpasteToolButtonOff, toothpasteToolButtonOn⤶⤶⤶    eraserToolButtonOff = new CodeInjectingSimpleRectangularButtonMorph @, @overlayCanvas, new EraserIconMorph⤶    eraserToolButtonOff.alpha = 0.1⤶⤶    eraserToolButtonOff.sourceCodeToBeInjected = ＂＂＂⤶        mouseMove = (pos, mouseButton) ->⤶            if world.hand.isThisPointerDraggingSomething() then return⤶            context = @backBufferContext⤶            context.setTransform 1, 0, 0, 1, 0, 0⤶            context.clearRect 0, 0, @width() * ceilPixelRatio, @height() * ceilPixelRatio⤶            context.useLogicalPixelsUntilRestore()⤶⤶            context.translate -@bounds.origin.x, -@bounds.origin.y⤶            context.translate pos.x, pos.y⤶⤶            context.beginPath()⤶            context.lineWidth=＂2＂⤶⤶            if mouseButton == 'left'⤶                context.fillStyle = ＂red＂⤶⤶                contextMain = @underlyingCanvasMorph.getContextForPainting()⤶                contextMain.translate pos.x, pos.y⤶⤶                contextMain.beginPath()⤶                contextMain.lineWidth=＂2＂⤶                contextMain.fillStyle = Color.WHITE.toString()⤶                contextMain.rect(-5,-5,10,10)⤶                contextMain.fill()⤶                @underlyingCanvasMorph.changed()⤶⤶            else⤶                context.strokeStyle=＂green＂⤶            context.rect(-5,-5,10,10)⤶            context.stroke()⤶            @changed()⤶        ＂＂＂⤶⤶    eraserToolButtonOn = new CodeInjectingSimpleRectangularButtonMorph @, @overlayCanvas, new EraserIconMorph @highlightedToolIconColor⤶    eraserToolButtonOn.alpha = 0.1⤶    eraserToolButtonOn.sourceCodeToBeInjected = ＂mouseMove = -> return＂⤶    @eraserToolButton = new ToggleButtonMorph eraserToolButtonOff, eraserToolButtonOn⤶⤶    # pencilAnnotation⤶    new EditableMarkMorph @pencilToolButton, pencilButtonOff, ＂editInjectableSource＂⤶    # brushAnnotation⤶    new EditableMarkMorph @brushToolButton, brushToolButtonOff, ＂editInjectableSource＂⤶    # toothpasteAnnotation⤶    new EditableMarkMorph @toothpasteToolButton, toothpasteToolButtonOff, ＂editInjectableSource＂⤶    # eraserAnnotation⤶    new EditableMarkMorph @eraserToolButton, eraserToolButtonOff, ＂editInjectableSource＂⤶⤶    @toolsPanel.add @pencilToolButton⤶    @toolsPanel.add @brushToolButton⤶    @toolsPanel.add @toothpasteToolButton⤶    @toolsPanel.add @eraserToolButton⤶⤶    @pencilToolButton.toggle()⤶    @invalidateLayout()⤶⤶  reLayout: ->⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    # label⤶    labelLeft = @left() + @externalPadding⤶    labelRight = @right() - @externalPadding⤶    labelBottom = @top() + @externalPadding⤶⤶    # tools -------------------------------⤶⤶    if @toolsPanel? and @toolsPanel.parent == @⤶        toolButtonSize = new Point 93, 55⤶    else⤶        toolButtonSize = new Point 0, 0⤶⤶    if @toolsPanel? and @toolsPanel.parent == @⤶      @toolsPanel.fullRawMoveTo new Point @left() + @externalPadding, labelBottom⤶      @toolsPanel.rawSetExtent new Point 2 * @internalPadding + toolButtonSize.width(), @height() - 2 * @externalPadding⤶⤶      if @pencilToolButton.parent == @toolsPanel⤶        buttonBounds = new Rectangle new Point @toolsPanel.left() + @internalPadding, labelBottom + @internalPadding⤶        buttonBounds = buttonBounds.setBoundsWidthAndHeight toolButtonSize⤶        @pencilToolButton.doLayout buttonBounds⤶⤶      if @brushToolButton.parent == @toolsPanel⤶        buttonBounds = new Rectangle new Point @toolsPanel.left() + @internalPadding, @pencilToolButton.bottom() + @internalPadding⤶        buttonBounds = buttonBounds.setBoundsWidthAndHeight toolButtonSize⤶        @brushToolButton.doLayout buttonBounds⤶⤶      if @toothpasteToolButton.parent == @toolsPanel⤶        buttonBounds = new Rectangle new Point @toolsPanel.left() + @internalPadding, @brushToolButton.bottom() + @internalPadding⤶        buttonBounds = buttonBounds.setBoundsWidthAndHeight toolButtonSize⤶        @toothpasteToolButton.doLayout buttonBounds⤶⤶      if @eraserToolButton.parent == @toolsPanel⤶        buttonBounds = new Rectangle new Point @toolsPanel.left() + @internalPadding, @toothpasteToolButton.bottom() + @internalPadding⤶        buttonBounds = buttonBounds.setBoundsWidthAndHeight toolButtonSize⤶        @eraserToolButton.doLayout buttonBounds ⤶⤶    # stretchableWidgetContainer --------------------------⤶    if @toolsPanel? and @toolsPanel.parent == @⤶      stretchableWidgetContainerWidth = @width() - @toolsPanel.width() - 2*@externalPadding - @internalPadding⤶    else⤶      stretchableWidgetContainerWidth = @width() - 2*@externalPadding⤶⤶    stretchableWidgetContainerHeight =  @height() - 2 * @externalPadding⤶⤶    if @toolsPanel? and @toolsPanel.parent == @⤶      stretchableWidgetContainerLeft = @toolsPanel.right() + @internalPadding⤶    else⤶      stretchableWidgetContainerLeft = @left() + @externalPadding⤶⤶    if @stretchableWidgetContainer.parent == @⤶      @stretchableWidgetContainer.fullRawMoveTo new Point stretchableWidgetContainerLeft, labelBottom⤶      @stretchableWidgetContainer.setExtent new Point stretchableWidgetContainerWidth, stretchableWidgetContainerHeight⤶⤶⤶    trackChanges.pop()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleDocumentWdgt_coffeSource = "# This simple-named widget is a user facing widget that⤶# provides viewing and editing capabilities for ＂documents＂...⤶# where documents are stacks of items that must stay within⤶# a certain width, but can stretch for any height.⤶⤶class SimpleDocumentWdgt extends Widget⤶⤶⤶  toolsPanel: nil⤶  defaultContents: nil⤶  textMorph: nil⤶⤶  simpleDocumentScrollPanel: nil⤶  simpleDocumentScrollPanelText: nil⤶⤶  # the external padding is the space between the edges⤶  # of the container and all of its internals. The reason⤶  # you often set this to zero is because windows already put⤶  # contents inside themselves with a little padding, so this⤶  # external padding is not needed. Useful to keep it⤶  # separate and know that it's working though.⤶  externalPadding: 0⤶  # the internal padding is the space between the internal⤶  # components. It doesn't necessarily need to be equal to the⤶  # external padding⤶  internalPadding: 5⤶⤶  providesAmenitiesForEditing: true⤶⤶  startingText: ＂Your text here.＂⤶⤶⤶  constructor: (@defaultContents = ＂＂) ->⤶    super new Point 368, 335⤶    @buildAndConnectChildren()⤶⤶  colloquialName: ->⤶    ＂Docs Maker＂⤶⤶  representativeIcon: ->⤶    new TypewriterIconWdgt⤶⤶  hasStartingContentBeenChangedByUser: ->⤶    !(⤶      @simpleDocumentScrollPanel.contents.children.length == 1 and⤶      @simpleDocumentScrollPanel.contents.children[0] instanceof SimplePlainTextWdgt and⤶      @simpleDocumentScrollPanel.contents.children[0].text == @startingText⤶    )⤶⤶  closeFromContainerWindow: (containerWindow) ->⤶⤶    if !@hasStartingContentBeenChangedByUser() and !world.anyReferenceToWdgt containerWindow⤶      # there is no real contents to save⤶      containerWindow.fullDestroy()⤶    else if !world.anyReferenceToWdgt containerWindow⤶      prompt = new SaveShortcutPromptWdgt @, containerWindow⤶      prompt.popUpAtHand()⤶    else⤶      containerWindow.close()⤶⤶⤶  buildAndConnectChildren: ->⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶⤶    @createToolsPanel()⤶    @simpleDocumentScrollPanel = new SimpleDocumentScrollPanelWdgt⤶⤶    startingContent = new SimplePlainTextWdgt(⤶      @startingText,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    @simpleDocumentScrollPanel.setContents startingContent, 5⤶    startingContent.isEditable = true⤶    startingContent.enableSelecting()⤶⤶    @add @simpleDocumentScrollPanel⤶⤶    @invalidateLayout()⤶⤶  createToolsPanel: ->⤶    @toolsPanel = new HorizontalMenuPanelWdgt⤶    @toolsPanel.strokeColor = nil⤶    @toolsPanel.rawSetExtent new Point 300,10⤶⤶⤶    @toolsPanel.add new ChangeFontButtonWdgt @⤶    @toolsPanel.add new BoldButtonWdgt⤶    @toolsPanel.add new ItalicButtonWdgt⤶    @toolsPanel.add new FormatAsCodeButtonWdgt⤶    @toolsPanel.add new IncreaseFontSizeButtonWdgt⤶    @toolsPanel.add new DecreaseFontSizeButtonWdgt⤶⤶    @toolsPanel.add new AlignLeftButtonWdgt⤶    @toolsPanel.add new AlignCenterButtonWdgt⤶    @toolsPanel.add new AlignRightButtonWdgt⤶⤶    @toolsPanel.add new TemplatesButtonWdgt⤶⤶    @add @toolsPanel⤶    @toolsPanel.disableDragsDropsAndEditing()⤶⤶    @dragsDropsAndEditingEnabled = true⤶    @invalidateLayout()⤶⤶  editButtonPressedFromWindowBar: ->⤶    if @dragsDropsAndEditingEnabled⤶      @disableDragsDropsAndEditing @⤶    else⤶      @enableDragsDropsAndEditing @⤶⤶  enableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if @dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilYellow?()⤶    @dragsDropsAndEditingEnabled = true⤶    @createToolsPanel()⤶    @simpleDocumentScrollPanel.enableDragsDropsAndEditing @⤶⤶  disableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if !@dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilClear?()⤶    @toolsPanel.destroy()⤶    @toolsPanel = nil⤶    @dragsDropsAndEditingEnabled = false⤶    @simpleDocumentScrollPanel.disableDragsDropsAndEditing @⤶    @invalidateLayout()⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts⤶    #  debugger⤶⤶    if @isCollapsed()⤶      @layoutIsValid = true⤶      @notifyChildrenThatParentHasReLayouted()⤶      return⤶⤶    super⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    availableHeight = @height() - 2 * @externalPadding⤶    simpleDocumentScrollPanelTop = @top() + @externalPadding⤶    toolsPanelHeight = 0⤶⤶    if @dragsDropsAndEditingEnabled⤶      toolsPanelHeight = 35⤶      availableHeight -= @internalPadding⤶      simpleDocumentScrollPanelTop += toolsPanelHeight + @internalPadding⤶⤶    simpleDocumentScrollPanelHeight = availableHeight - toolsPanelHeight⤶⤶⤶    if @toolsPanel?.parent == @⤶      @toolsPanel.fullRawMoveTo new Point @left() + @externalPadding, @top() + @externalPadding⤶      @toolsPanel.rawSetExtent new Point @width() - 2 * @externalPadding, toolsPanelHeight⤶⤶    if @simpleDocumentScrollPanel.parent == @⤶      @simpleDocumentScrollPanel.fullRawMoveTo new Point @left() + @externalPadding, simpleDocumentScrollPanelTop⤶      @simpleDocumentScrollPanel.rawSetExtent new Point @width() - 2 * @externalPadding, simpleDocumentScrollPanelHeight⤶⤶⤶    trackChanges.pop()⤶    @fullChanged()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶  # same as simpledocumentscrollpanel, you can lock the contents.⤶  # worth factoring it out as a mixin?⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶    if childrenNotHandlesNorCarets? and childrenNotHandlesNorCarets.length > 0⤶      menu.addLine()⤶      if !@dragsDropsAndEditingEnabled⤶        menu.addMenuItem ＂enable editing＂, true, @, ＂enableDragsDropsAndEditing＂, ＂lets you drag content in and out＂⤶      else⤶        menu.addMenuItem ＂disable editing＂, true, @, ＂disableDragsDropsAndEditing＂, ＂prevents dragging content in and out＂⤶⤶    menu.removeConsecutiveLines()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleSlideWdgt_coffeSource = "class SimpleSlideWdgt extends StretchableEditableWdgt⤶⤶  colloquialName: ->   ⤶    ＂Slides Maker＂⤶⤶  representativeIcon: ->⤶    new SimpleSlideIconWdgt⤶⤶⤶  createToolsPanel: ->⤶    # tools -------------------------------⤶    @toolsPanel = new ScrollPanelWdgt new ToolPanelWdgt⤶⤶    if false⤶      console.time 'createToolsPanel'⤶      @toolsPanel.add new TextBoxCreatorButtonWdgt⤶      @toolsPanel.add new ExternalLinkCreatorButtonWdgt⤶      @toolsPanel.add new VideoPlayCreatorButtonWdgt⤶⤶      @toolsPanel.add new WorldMapCreatorButtonWdgt⤶      @toolsPanel.add new USAMapCreatorButtonWdgt⤶⤶      @toolsPanel.add new RectangleMorph⤶⤶      @toolsPanel.add new MapPinIconWdgt⤶⤶      @toolsPanel.add new SpeechBubbleWdgt⤶⤶      @toolsPanel.add new DestroyIconMorph⤶      @toolsPanel.add new ScratchAreaIconMorph⤶      @toolsPanel.add new FloraIconMorph⤶      @toolsPanel.add new ScooterIconMorph⤶      @toolsPanel.add new HeartIconMorph⤶⤶      @toolsPanel.add new FizzygumLogoIconWdgt⤶      @toolsPanel.add new FizzygumLogoWithTextIconWdgt⤶      @toolsPanel.add new VaporwaveBackgroundIconWdgt⤶      @toolsPanel.add new VaporwaveSunIconWdgt⤶⤶      @toolsPanel.add new ArrowNIconWdgt⤶      @toolsPanel.add new ArrowSIconWdgt⤶      @toolsPanel.add new ArrowWIconWdgt⤶      @toolsPanel.add new ArrowEIconWdgt⤶      @toolsPanel.add new ArrowNWIconWdgt⤶      @toolsPanel.add new ArrowNEIconWdgt⤶      @toolsPanel.add new ArrowSWIconWdgt⤶      @toolsPanel.add new ArrowSEIconWdgt⤶      console.timeEnd 'createToolsPanel'⤶⤶    # from some measuring (30 measurements or so)⤶    # the batched approach seems twice as fast⤶    # (average of 5.4 ms on my machine instead of 10 ms), and⤶    # also variance is lower (3.1 vs 9.5).⤶    #console.time 'createToolsPanel'⤶    @toolsPanel.addMany [⤶      new TextBoxCreatorButtonWdgt⤶      new ExternalLinkCreatorButtonWdgt⤶      new VideoPlayCreatorButtonWdgt⤶⤶      new WorldMapCreatorButtonWdgt⤶      new USAMapCreatorButtonWdgt⤶⤶      new RectangleMorph⤶⤶      new MapPinIconWdgt⤶⤶      new SpeechBubbleWdgt⤶⤶      new DestroyIconMorph⤶      new ScratchAreaIconMorph⤶      new FloraIconMorph⤶      new ScooterIconMorph⤶      new HeartIconMorph⤶⤶      new FizzygumLogoIconWdgt⤶      new FizzygumLogoWithTextIconWdgt⤶      new VaporwaveBackgroundIconWdgt⤶      new VaporwaveSunIconWdgt⤶⤶      new ArrowNIconWdgt⤶      new ArrowSIconWdgt⤶      new ArrowWIconWdgt⤶      new ArrowEIconWdgt⤶      new ArrowNWIconWdgt⤶      new ArrowNEIconWdgt⤶      new ArrowSWIconWdgt⤶      new ArrowSEIconWdgt⤶    ]⤶    #console.timeEnd 'createToolsPanel'⤶⤶⤶⤶    @toolsPanel.disableDragsDropsAndEditing()⤶    @add @toolsPanel⤶    @dragsDropsAndEditingEnabled = true⤶    @invalidateLayout()⤶⤶  createNewStretchablePanel: ->⤶    @stretchableWidgetContainer = new StretchableWidgetContainerWdgt⤶    @add @stretchableWidgetContainer⤶⤶⤶  reLayout: ->⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    # label⤶    labelLeft = @left() + @externalPadding⤶    labelRight = @right() - @externalPadding⤶    labelBottom = @top() + @externalPadding⤶⤶    # tools -------------------------------⤶⤶    if @toolsPanel?.parent == @⤶      @toolsPanel.fullRawMoveTo new Point @left() + @externalPadding, labelBottom⤶      @toolsPanel.rawSetExtent new Point 95, @height() - 2 * @externalPadding⤶⤶⤶    # stretchableWidgetContainer --------------------------⤶⤶    stretchableWidgetContainerWidth = @width() - 2*@externalPadding⤶    ⤶    if @dragsDropsAndEditingEnabled⤶      stretchableWidgetContainerWidth -= @toolsPanel.width() + @internalPadding⤶⤶    stretchableWidgetContainerHeight =  @height() - 2 * @externalPadding⤶    if @dragsDropsAndEditingEnabled⤶      stretchableWidgetContainerLeft = @toolsPanel.right() + @internalPadding⤶    else⤶      stretchableWidgetContainerLeft = @left() + @externalPadding⤶⤶    if @stretchableWidgetContainer.parent == @⤶      @stretchableWidgetContainer.fullRawMoveTo new Point stretchableWidgetContainerLeft, labelBottom⤶      @stretchableWidgetContainer.setExtent new Point stretchableWidgetContainerWidth, stretchableWidgetContainerHeight⤶⤶    # ----------------------------------------------⤶⤶⤶    trackChanges.pop()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.Color_coffeSource = "# IMMUTABLE⤶⤶class Color⤶⤶  @augmentWith DeepCopierMixin⤶⤶  # if you want values like these instead: aliceblue: ＂0xfff0f8ff＂⤶  # then search for CoulourLiterals in LiveCodeLab repo⤶⤶  @_literalsData:[⤶    [＂ALICEBLUE＂,0xf0,0xf8,0xff]⤶    [＂ANTIQUEWHITE＂,0xfa,0xeb,0xd7]⤶    [＂AQUA＂,0x00,0xff,0xff]⤶    [＂AQUAMARINE＂,0x7f,0xff,0xd4]⤶    [＂AZURE＂,0xf0,0xff,0xff]⤶    [＂BEIGE＂,0xf5,0xf5,0xdc]⤶    [＂BISQUE＂,0xff,0xe4,0xc4]⤶    [＂BLACK＂,0x00,0x00,0x00]⤶    [＂BLANCHEDALMOND＂,0xff,0xeb,0xcd]⤶    [＂BLUE＂,0x00,0x00,0xff]⤶    [＂BLUEVIOLET＂,0x8a,0x2b,0xe2]⤶    [＂BROWN＂,0xa5,0x2a,0x2a]⤶    [＂BURLYWOOD＂,0xde,0xb8,0x87]⤶    [＂CADETBLUE＂,0x5f,0x9e,0xa0]⤶    [＂CHARTREUSE＂,0x7f,0xff,0x00]⤶    [＂CHOCOLATE＂,0xd2,0x69,0x1e]⤶    [＂CORAL＂,0xff,0x7f,0x50]⤶    [＂CORNFLOWERBLUE＂,0x64,0x95,0xed]⤶    [＂CORNSILK＂,0xff,0xf8,0xdc]⤶    [＂CRIMSON＂,0xdc,0x14,0x3c]⤶    [＂CYAN＂,0x00,0xff,0xff]⤶    [＂DARKBLUE＂,0x00,0x00,0x8b]⤶    [＂DARKCYAN＂,0x00,0x8b,0x8b]⤶    [＂DARKGOLDENROD＂,0xb8,0x86,0x0b]⤶    [＂DARKGRAY＂,0xa9,0xa9,0xa9]⤶    [＂DARKGREY＂,0xa9,0xa9,0xa9]⤶    [＂DARKGREEN＂,0x00,0x64,0x00]⤶    [＂DARKKHAKI＂,0xbd,0xb7,0x6b]⤶    [＂DARKMAGENTA＂,0x8b,0x00,0x8b]⤶    [＂DARKOLIVEGREEN＂,0x55,0x6b,0x2f]⤶    [＂DARKORANGE＂,0xff,0x8c,0x00]⤶    [＂DARKORCHID＂,0x99,0x32,0xcc]⤶    [＂DARKRED＂,0x8b,0x00,0x00]⤶    [＂DARKSALMON＂,0xe9,0x96,0x7a]⤶    [＂DARKSEAGREEN＂,0x8f,0xbc,0x8f]⤶    [＂DARKSLATEBLUE＂,0x48,0x3d,0x8b]⤶    [＂DARKSLATEGRAY＂,0x2f,0x4f,0x4f]⤶    [＂DARKSLATEGREY＂,0x2f,0x4f,0x4f]⤶    [＂DARKTURQUOISE＂,0x00,0xce,0xd1]⤶    [＂DARKVIOLET＂,0x94,0x00,0xd3]⤶    [＂DEEPPINK＂,0xff,0x14,0x93]⤶    [＂DEEPSKYBLUE＂,0x00,0xbf,0xff]⤶    [＂DIMGRAY＂,0x69,0x69,0x69]⤶    [＂DIMGREY＂,0x69,0x69,0x69]⤶    [＂DODGERBLUE＂,0x1e,0x90,0xff]⤶    [＂FIREBRICK＂,0xb2,0x22,0x22]⤶    [＂FLORALWHITE＂,0xff,0xfa,0xf0]⤶    [＂FORESTGREEN＂,0x22,0x8b,0x22]⤶    [＂FUCHSIA＂,0xff,0x00,0xff]⤶    [＂GAINSBORO＂,0xdc,0xdc,0xdc]⤶    [＂GHOSTWHITE＂,0xf8,0xf8,0xff]⤶    [＂GOLD＂,0xff,0xd7,0x00]⤶    [＂GOLDENROD＂,0xda,0xa5,0x20]⤶    [＂GRAY＂,0x80,0x80,0x80]⤶    [＂GREY＂,0x80,0x80,0x80]⤶    [＂GREEN＂,0x00,0x80,0x00]⤶    [＂GREENYELLOW＂,0xad,0xff,0x2f]⤶    [＂HONEYDEW＂,0xf0,0xff,0xf0]⤶    [＂HOTPINK＂,0xff,0x69,0xb4]⤶    [＂INDIANRED＂,0xcd,0x5c,0x5c]⤶    [＂INDIGO＂,0x4b,0x00,0x82]⤶    [＂IVORY＂,0xff,0xff,0xf0]⤶    [＂KHAKI＂,0xf0,0xe6,0x8c]⤶    [＂LAVENDER＂,0xe6,0xe6,0xfa]⤶    [＂LAVENDERBLUSH＂,0xff,0xf0,0xf5]⤶    [＂LAWNGREEN＂,0x7c,0xfc,0x00]⤶    [＂LEMONCHIFFON＂,0xff,0xfa,0xcd]⤶    [＂LIGHTBLUE＂,0xad,0xd8,0xe6]⤶    [＂LIGHTCORAL＂,0xf0,0x80,0x80]⤶    [＂LIGHTCYAN＂,0xe0,0xff,0xff]⤶    [＂LIGHTGOLDENRODYELLOW＂,0xfa,0xfa,0xd2]⤶    [＂LIGHTGREY＂,0xd3,0xd3,0xd3]⤶    [＂LIGHTGRAY＂,0xd3,0xd3,0xd3]⤶    [＂LIGHTGREEN＂,0x90,0xee,0x90]⤶    [＂LIGHTPINK＂,0xff,0xb6,0xc1]⤶    [＂LIGHTSALMON＂,0xff,0xa0,0x7a]⤶    [＂LIGHTSEAGREEN＂,0x20,0xb2,0xaa]⤶    [＂LIGHTSKYBLUE＂,0x87,0xce,0xfa]⤶    [＂LIGHTSLATEGRAY＂,0x77,0x88,0x99]⤶    [＂LIGHTSLATEGREY＂,0x77,0x88,0x99]⤶    [＂LIGHTSTEELBLUE＂,0xb0,0xc4,0xde]⤶    [＂LIGHTYELLOW＂,0xff,0xff,0xe0]⤶    [＂LIME＂,0x00,0xff,0x00]⤶    [＂LIMEGREEN＂,0x32,0xcd,0x32]⤶    [＂LINEN＂,0xfa,0xf0,0xe6]⤶    [＂MINTCREAM＂,0xf5,0xff,0xfa]⤶    [＂MISTYROSE＂,0xff,0xe4,0xe1]⤶    [＂MOCCASIN＂,0xff,0xe4,0xb5]⤶    [＂NAVAJOWHITE＂,0xff,0xde,0xad]⤶    [＂NAVY＂,0x00,0x00,0x80]⤶    [＂OLDLACE＂,0xfd,0xf5,0xe6]⤶    [＂OLIVE＂,0x80,0x80,0x00]⤶    [＂OLIVEDRAB＂,0x6b,0x8e,0x23]⤶    [＂ORANGE＂,0xff,0xa5,0x00]⤶    [＂ORANGERED＂,0xff,0x45,0x00]⤶    [＂ORCHID＂,0xda,0x70,0xd6]⤶    [＂PALEGOLDENROD＂,0xee,0xe8,0xaa]⤶    [＂PALEGREEN＂,0x98,0xfb,0x98]⤶    [＂PALETURQUOISE＂,0xaf,0xee,0xee]⤶    [＂PALEVIOLETRED＂,0xd8,0x70,0x93]⤶    [＂PAPAYAWHIP＂,0xff,0xef,0xd5]⤶    [＂PEACHPUFF＂,0xff,0xda,0xb9]⤶    [＂PERU＂,0xcd,0x85,0x3f]⤶    [＂PINK＂,0xff,0xc0,0xcb]⤶    [＂PLUM＂,0xdd,0xa0,0xdd]⤶    [＂POWDERBLUE＂,0xb0,0xe0,0xe6]⤶    [＂PURPLE＂,0x80,0x00,0x80]⤶    [＂RED＂,0xff,0x00,0x00]⤶    [＂ROSYBROWN＂,0xbc,0x8f,0x8f]⤶    [＂ROYALBLUE＂,0x41,0x69,0xe1]⤶    [＂SADDLEBROWN＂,0x8b,0x45,0x13]⤶    [＂SALMON＂,0xfa,0x80,0x72]⤶    [＂SANDYBROWN＂,0xf4,0xa4,0x60]⤶    [＂SEAGREEN＂,0x2e,0x8b,0x57]⤶    [＂SEASHELL＂,0xff,0xf5,0xee]⤶    [＂SIENNA＂,0xa0,0x52,0x2d]⤶    [＂SILVER＂,0xc0,0xc0,0xc0]⤶    [＂SKYBLUE＂,0x87,0xce,0xeb]⤶    [＂SLATEBLUE＂,0x6a,0x5a,0xcd]⤶    [＂SLATEGRAY＂,0x70,0x80,0x90]⤶    [＂SLATEGREY＂,0x70,0x80,0x90]⤶    [＂SNOW＂,0xff,0xfa,0xfa]⤶    [＂SPRINGGREEN＂,0x00,0xff,0x7f]⤶    [＂STEELBLUE＂,0x46,0x82,0xb4]⤶    [＂TAN＂,0xd2,0xb4,0x8c]⤶    [＂TEAL＂,0x00,0x80,0x80]⤶    [＂THISTLE＂,0xd8,0xbf,0xd8]⤶    [＂TOMATO＂,0xff,0x63,0x47]⤶    [＂TURQUOISE＂,0x40,0xe0,0xd0]⤶    [＂VIOLET＂,0xee,0x82,0xee]⤶    [＂WHEAT＂,0xf5,0xde,0xb3]⤶    [＂WHITE＂,0xff,0xff,0xff]⤶    [＂WHITESMOKE＂,0xf5,0xf5,0xf5]⤶    [＂YELLOW＂,0xff,0xff,0x00]⤶    [＂YELLOWGREEN＂,0x9a,0xcd,0x32]⤶  ]⤶⤶  @AVAILABLE_LITERALS_NAMES: []⤶⤶  _r: nil⤶  _g: nil⤶  _b: nil⤶  _a: nil⤶⤶  constructor: (@_r = 0, @_g = 0, @_b = 0, @_a=1) ->⤶    # all values are optional, just (r, g, b) is fine⤶⤶  bluerBy: (howMuchMoreBlue) ->⤶    new @constructor @_r, @_g, (@_b+howMuchMoreBlue), @_a⤶  ⤶  # Color string representation: e.g. 'rgba(255,165,0,1)'⤶  toString: ->⤶    ＂rgba(＂ + Math.round(@_r) + ＂,＂ + Math.round(@_g) + ＂,＂ + Math.round(@_b) + ＂,＂ + @_a + ＂)＂⤶⤶⤶⤶  ⤶  # Color comparison:⤶  equals: (aColor) ->⤶    # ==⤶    @==aColor or (aColor and @_r == aColor._r and @_g == aColor._g and @_b == aColor._b and @_a == aColor._a)⤶  ⤶  ⤶⤶⤶  # static method to initialise static constants. Will be called⤶  # immediately after the Class is defined⤶  # Note that this puts a spanner in the source management system⤶  # i.e. the source doesn't show these colors. Whatever solution you⤶  # put in place, remember that you should be able to re-generate valid⤶  # sources from whatever source code is loaded. I.e. the roundtrip⤶  # should be source -> parsed sources -> regen sources and the 1st step == last step⤶  @initStaticConstsAfterClassDefinition: ->⤶    for eachLiteral in @_literalsData⤶      @[eachLiteral[0]] = new @ eachLiteral[1], eachLiteral[2], eachLiteral[3]⤶      @AVAILABLE_LITERALS_NAMES.push eachLiteral[0]⤶⤶    # release this chunk of memory since we only use it here to initialise⤶    # the static constants⤶    @_literalsData = null⤶⤶    # there are two more constants that don't fit the⤶    # rgb pattern description, let's initialise them here⤶    @TRANSPARENT = new @ 0,0,0,0⤶    @AVAILABLE_LITERALS_NAMES.push ＂TRANSPARENT＂⤶⤶    # anglecolor is a special⤶    # color that tells the engine to use the⤶    # normal material.⤶    # It would be tempting to set it to a numeric value such as⤶    # 1 unit higher than then any max 32 bit integer, but it's such a special⤶    # case that it's OK to use a non-integer.⤶    # note that this is not an actual Color!⤶    @ANGLECOLOR = ＂angleColor＂⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.DoubleLinkedList_coffeSource = "## from https://github.com/viruschidai/lru-cache⤶## used for LRU cache⤶⤶class DoubleLinkedList⤶  constructor:  ->⤶    @headNode = @tailNode = nil⤶⤶  # removes the last element. Since⤶  # we move used elements to head, the last⤶  # element is *probably* a relatively⤶  # unused one.⤶  remove: (node) ->⤶    if node.pre⤶      node.pre.next = node.next⤶    else⤶      @headNode = node.next⤶⤶    if node.next⤶      node.next.pre = node.pre⤶    else⤶      @tailNode = node.pre⤶⤶  insertBeginning: (node) ->⤶    if @headNode⤶      node.next = @headNode⤶      @headNode.pre = node⤶      @headNode = node⤶    else⤶      @headNode = @tailNode = node⤶⤶  moveToHead: (node) ->⤶    @remove node⤶    @insertBeginning node⤶⤶  clear: ->⤶    @headNode = @tailNode = nil".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.LRUCache_coffeSource = "## LRU cache⤶## from https://github.com/viruschidai/lru-cache⤶⤶class LRUCache⤶  constructor: (@capacity = 10, @maxAge = 60000) ->⤶    @_linkList = new DoubleLinkedList⤶    @reset()⤶⤶  keys: ->⤶    return Object.keys @_hash⤶⤶⤶⤶  remove: (key) ->⤶    if @_hash[key]?⤶      node = @_hash[key]⤶      @_linkList.remove node⤶      delete @_hash[key]⤶      if node.data.onDispose then node.data.onDispose.call this, node.data.key, node.data.value⤶      @size--⤶⤶  reset: ->⤶    @_hash = {}⤶    @size = 0⤶    @_linkList.clear()⤶⤶  set: (key, value, onDispose) ->⤶    node = @_hash[key]⤶    if node⤶      node.data.value = value⤶      node.data.onDispose = onDispose⤶      @_refreshNode node⤶    else⤶      if @size is @capacity then @remove @_linkList.tailNode.data.key⤶⤶      createNode = (data, pre, next) -> {data, pre, next}⤶⤶      node = createNode {key, value, onDispose}⤶      node.data.lastVisitTime = Date.now()⤶      @_linkList.insertBeginning node⤶      @_hash[key] = node⤶      @size++⤶      return⤶⤶  get: (key) ->⤶    node = @_hash[key]⤶    if !node then return undefined⤶    if @_isExpiredNode node⤶      @remove key⤶      return undefined⤶    @_refreshNode node⤶    return node.data.value⤶⤶  _refreshNode: (node) ->⤶    node.data.lastVisitTime = Date.now()⤶    @_linkList.moveToHead node⤶⤶  _isExpiredNode: (node) ->⤶    return Date.now() - node.data.lastVisitTime > @maxAge⤶⤶  has: (key) -> return @_hash[key]?".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.Point_coffeSource = "# See the Rectangle class about the ＂copy on change＂ policy⤶# of this class.⤶⤶class Point⤶⤶  @augmentWith DeepCopierMixin⤶⤶  x: nil⤶  y: nil⤶   ⤶  constructor: (@x = 0, @y = 0) ->⤶⤶⤶⤶⤶  debugIfFloats: ->⤶    return⤶    #if !@onlyContainingIntegers()⤶    #  debugger⤶  ⤶  # Point string representation: e.g. '12@68'⤶  toString: ->⤶    Math.round(@x) + ＂@＂ + Math.round(@y)⤶⤶⤶  ⤶  # Point copying:⤶  copy: ->⤶    new @constructor @x, @y⤶⤶  # Point comparison:⤶  isZero: (aPoint) ->⤶    # ==⤶    @x is 0 and @y is 0⤶  ⤶  # Point comparison:⤶  equals: (aPoint) ->⤶    # ==⤶    @x is aPoint.x and @y is aPoint.y⤶  ⤶  lt: (aPoint) ->⤶    # <⤶    @x < aPoint.x and @y < aPoint.y⤶  ⤶  gt: (aPoint) ->⤶    # >⤶    @x > aPoint.x and @y > aPoint.y⤶  ⤶  ge: (aPoint) ->⤶    # >=⤶    @x >= aPoint.x and @y >= aPoint.y⤶  ⤶  le: (aPoint) ->⤶    # <=⤶    @x <= aPoint.x and @y <= aPoint.y⤶  ⤶  max: (aPoint) ->⤶    @debugIfFloats()⤶    new @constructor Math.max(@x, aPoint.x), Math.max(@y, aPoint.y)⤶  ⤶  min: (aPoint) ->⤶    @debugIfFloats()⤶    new @constructor Math.min(@x, aPoint.x), Math.min(@y, aPoint.y)  ⤶  ⤶  # Point conversion:⤶  round: ->⤶    new @constructor Math.round(@x), Math.round(@y)⤶  ⤶  abs: ->⤶    @debugIfFloats()⤶    new @constructor Math.abs(@x), Math.abs(@y)⤶  ⤶  neg: ->⤶    @debugIfFloats()⤶    new @constructor -@x, -@y⤶  ⤶  mirror: ->⤶    @debugIfFloats()⤶    new @constructor @y, @x ⤶  ⤶  floor: ->⤶    new @constructor Math.max(Math.floor(@x), 0), Math.max(Math.floor(@y), 0)⤶  ⤶  ceil: ->⤶    new @constructor Math.ceil(@x), Math.ceil(@y)⤶  ⤶⤶  # these two in theory don't make sense⤶  # for a Point BUT it's handy because sometimes⤶  # we store dimensions in Points⤶  width: ->⤶    return @x⤶⤶  height: ->⤶    return @y⤶⤶  ⤶  # Point arithmetic:⤶  add: (other) ->⤶    @debugIfFloats()⤶    return new @constructor @x + other.x, @y + other.y  if other instanceof Point⤶    new @constructor @x + other, @y + other⤶  ⤶  subtract: (other) ->⤶    @debugIfFloats()⤶    return new @constructor @x - other.x, @y - other.y  if other instanceof Point⤶    new @constructor @x - other, @y - other⤶  ⤶  multiplyBy: (other) ->⤶    @debugIfFloats()⤶    return new @constructor @x * other.x, @y * other.y  if other instanceof Point⤶    new @constructor @x * other, @y * other⤶  ⤶  divideBy: (other) ->⤶    @debugIfFloats()⤶    return new @constructor @x / other.x, @y / other.y  if other instanceof Point⤶    new @constructor @x / other, @y / other⤶  ⤶  floorDivideBy: (other) ->⤶    @debugIfFloats()⤶    if other instanceof Point⤶      return new @constructor Math.floor(@x / other.x), Math.floor(@y / other.y)⤶    new @constructor Math.floor(@x / other), Math.floor(@y / other)⤶  ⤶  toLocalCoordinatesOf: (aWdgt) ->⤶    new @constructor @x - aWdgt.left(), @y - aWdgt.top()⤶  ⤶  # Point polar coordinates:⤶  r: ->⤶    t = @multiplyBy @⤶    Math.sqrt t.x + t.y⤶  ⤶  degrees: ->⤶    #⤶    #    answer the angle I make with origin in degrees.⤶    #    Right is 0, down is 90⤶    #⤶    if @x is 0⤶      return 90  if @y >= 0⤶      return 270⤶    tan = @y / @x⤶    theta = Math.atan tan⤶    if @x >= 0⤶      return radiansToDegrees theta  if @y >= 0⤶      return 360 + radiansToDegrees theta⤶    180 + radiansToDegrees theta⤶  ⤶  theta: ->⤶    #⤶    #    answer the angle I make with origin in radians.⤶    #    Right is 0, down is 90⤶    #⤶    if @x is 0⤶      return degreesToRadians 90  if @y >= 0⤶      return degreesToRadians 270⤶    tan = @y / @x⤶    theta = Math.atan(tan)⤶    if @x >= 0⤶      return theta  if @y >= 0⤶      return degreesToRadians(360) + theta⤶    degreesToRadians(180) + theta⤶  ⤶  ⤶  # Point functions:⤶  distanceTo: (aPoint) ->⤶    aPoint.subtract(@).r()⤶  ⤶  rotate: (direction, center) ->⤶    # direction must be 'right', 'left' or 'pi'⤶    offset = @subtract center⤶    return new @constructor(-offset.y, offset.y).add(center)  if direction is ＂right＂⤶    return new @constructor(offset.y, -offset.y).add(center)  if direction is ＂left＂⤶⤶    # direction === 'pi'⤶    center.subtract offset⤶  ⤶  flip: (direction, center) ->⤶    # direction must be 'vertical' or 'horizontal'⤶    return new @constructor @x, center.y * 2 - @y  if direction is ＂vertical＂⤶⤶    # direction === 'horizontal'⤶    new @constructor center.x * 2 - @x, @y⤶  ⤶  distanceAngle: (dist, angle) ->⤶    deg = angle⤶    if deg > 270⤶      deg = deg - 360⤶    else deg = deg + 360  if deg < -270⤶    if -90 <= deg and deg <= 90⤶      x = Math.sin(degreesToRadians(deg)) * dist⤶      y = Math.sqrt((dist * dist) - (x * x))⤶      return new @constructor x + @x, @y - y⤶    x = Math.sin(degreesToRadians(180 - deg)) * dist⤶    y = Math.sqrt((dist * dist) - (x * x))⤶    new @constructor x + @x, @y + y⤶  ⤶  ⤶  # Point transforming:⤶  scaleBy: (scalePoint) ->⤶    @multiplyBy scalePoint⤶  ⤶  translateBy: (deltaPoint) ->⤶    @add deltaPoint⤶  ⤶  rotateBy: (⤶    angle,⤶    center = (new @constructor 0, 0)⤶    ) ->⤶    p = @subtract center⤶    r = p.r()⤶    theta = angle - p.theta()⤶    new @constructor center.x + (r * Math.cos(theta)), center.y - (r * Math.sin(theta))⤶  ⤶  ⤶  # Point conversion:⤶  asArray: ->⤶    [@x, @y]⤶  ⤶  # creating Rectangle instances from Points:⤶  corner: (cornerPoint) ->⤶    # answer a new Rectangle⤶    new Rectangle @x, @y, cornerPoint.x, cornerPoint.y⤶  ⤶  rectangle: (aPoint) ->⤶    # answer a new Rectangle⤶    org = @min aPoint⤶    crn = @max aPoint⤶    new Rectangle org.x, org.y, crn.x, crn.y⤶  ⤶  extent: (aPoint) ->⤶    #answer a new Rectangle⤶    crn = @add aPoint⤶    new Rectangle @x, @y, crn.x, crn.y⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.Rectangle_coffeSource = "# Just like the Point class, this class has a ＂new on change＂⤶# policy (also often called ＂immutable data structures＂).⤶# This means that any time you change any part of a⤶# Rectangle, a *new* Rectangle is created, the old one is⤶# left unchanged.⤶# The reason for this is that as manipulation and assignments⤶# of (parts of) Rectangles is done a lot, it gets⤶# difficult otherwise to understand how one change to⤶# (part of) a Rectangle propagates because of the⤶# assignments that may have happened.⤶# In this ＂new on change＂ policy things are easier - a change⤶# doesn't affect any other Rectangle ever apart from the⤶# new one.⤶# So for example you never change the @bounds property of⤶# a Widget in-place ever, rather⤶# you rather replace it with a new Rectangle.⤶# Also this means that as you create a Rectangle from another,⤶# you can have the new Rectangle pointing directly at the old⤶# origin and corner, because we are guaranteed that *those*⤶# will never change.⤶# Also another effect is that you never need to copy() a⤶# Rectangle. This is because the one you have will never change⤶# and the new operations you put it through will just create⤶# new ones.⤶# The drawback is that ＂new on change＂ policy means that a bunch⤶# of Rectangles are created for potentially a great⤶# number of transient transformations which would⤶# otherwise be cheaper to just do⤶# in place. The problem with mixing the two approaches⤶# is that using in-place changes poisons the other approach,⤶# so the two approaches can only be mixed with great care, so⤶# it should probably only be done in ＂optimisation＂ phase⤶# if profiling shows it's actually a problem.⤶⤶class Rectangle⤶⤶  @augmentWith DeepCopierMixin⤶⤶  origin: nil # a Point⤶  corner: nil # a Point⤶  @EMPTY: new Rectangle⤶  ⤶  constructor: (left = 0, top = 0, right = 0, bottom = 0) ->⤶    ⤶    if (typeof(left) is ＂number＂) and (typeof(top) is ＂number＂) and (typeof(right) is ＂number＂) and (typeof(bottom) is ＂number＂)⤶      @origin = new Point left, top⤶      @corner = new Point right, bottom⤶    else if (left instanceof Point) and (typeof(top) is ＂number＂) and (typeof(right) is ＂number＂)⤶      @origin = left⤶      @corner = new Point top, right⤶    else if (typeof(left) is ＂number＂) and (typeof(top) is ＂number＂) and (right instanceof Point)⤶      @origin = new Point left, top⤶      @corner = right⤶    else if (left instanceof Point) and (top instanceof Point)⤶      @origin = left⤶      @corner = top⤶    else if left instanceof Point⤶      @origin = left⤶      @corner = new Point 0, 0⤶    else if left instanceof Rectangle⤶      @origin = left.origin⤶      @corner = top.origin⤶  ⤶  ⤶  # Rectangle string representation: e.g. '[0@0 | 160@80]'⤶  toString: ->⤶    ＂[＂ + @origin + ＂ | ＂ + @extent() + ＂]＂⤶⤶  onlyContainingIntegers: ->⤶    if Math.floor(@origin.x) == @origin.x and⤶      Math.floor(@origin.y) == @origin.y and⤶      Math.floor(@corner.x) == @corner.x and⤶      Math.floor(@corner.y) == @corner.y⤶        return true⤶    else⤶      return false⤶⤶  debugIfFloats: ->⤶    #if !@onlyContainingIntegers()⤶    #  debugger⤶⤶⤶  ⤶  # Rectangle copying:⤶  copy: ->⤶    @debugIfFloats()⤶    new @constructor @left(), @top(), @right(), @bottom()⤶  ⤶  # Rectangle accessing - setting:⤶  setTo: (left, top, right, bottom) ->⤶    @debugIfFloats()⤶    # note: all inputs are optional and can be omitted⤶    @origin = new Point(⤶      left or ((if (left is 0) then 0 else @left())),⤶      top or ((if (top is 0) then 0 else @top())))⤶    @corner = new Point(⤶      right or ((if (right is 0) then 0 else @right())),⤶      bottom or ((if (bottom is 0) then 0 else @bottom())))⤶⤶  # Rectangle accessing - setting⤶  # This is used to create a bound with the specified⤶  # width and height: the corner needs to be displaced⤶  # of (width, bound) in respect to the origin ⤶  setBoundsWidthAndHeight: (width, height) ->⤶    copy = @copy()⤶    if (typeof(width) is ＂number＂) and (typeof(height) is ＂number＂)⤶      copy.corner = new Point(⤶        width + copy.origin.x,⤶        height + copy.origin.y⤶      )⤶    else if (width instanceof Point)⤶      copy.corner = new Point(⤶        width.x + copy.origin.x,⤶        width.y + copy.origin.y⤶      )⤶    return copy⤶  ⤶  # Rectangle accessing - getting:⤶  area: ->⤶    @debugIfFloats()⤶    #requires width() and height() to be defined⤶    w = @width()⤶    return 0  if w < 0⤶    Math.max w * @height(), 0⤶  ⤶  bottom: ->⤶    @debugIfFloats()⤶    @corner.y⤶  ⤶  bottomCenter: ->⤶    @debugIfFloats()⤶    new Point @center().x, @bottom()⤶  ⤶  bottomLeft: ->⤶    @debugIfFloats()⤶    new Point @origin.x, @corner.y⤶  ⤶  bottomRight: ->⤶    @debugIfFloats()⤶    @corner.copy()⤶  ⤶  boundingBox: ->⤶    @debugIfFloats()⤶    @⤶  ⤶  center: ->⤶    @debugIfFloats()⤶    @origin.add @corner.subtract(@origin).floorDivideBy(2)⤶  ⤶⤶  ⤶  extent: ->⤶    @debugIfFloats()⤶    @corner.subtract @origin⤶  ⤶  isEmpty: ->⤶    @debugIfFloats()⤶    return ((@width() <= 0) or (@height() <= 0))⤶⤶  isNotEmpty: ->⤶    !@isEmpty()⤶  ⤶  height: ->⤶    @debugIfFloats()⤶    @corner.y - @origin.y⤶  ⤶  left: ->⤶    @debugIfFloats()⤶    @origin.x⤶  ⤶  leftCenter: ->⤶    @debugIfFloats()⤶    new Point @left(), @center().y⤶  ⤶  right: ->⤶    @debugIfFloats()⤶    @corner.x⤶  ⤶  rightCenter: ->⤶    @debugIfFloats()⤶    new Point @right(), @center().y⤶  ⤶  top: ->⤶    @debugIfFloats()⤶    @origin.y⤶  ⤶  topCenter: ->⤶    @debugIfFloats()⤶    new Point @center().x, @top()⤶  ⤶  topLeft: ->⤶    @debugIfFloats()⤶    @origin⤶  ⤶  topRight: ->⤶    @debugIfFloats()⤶    new Point @corner.x, @origin.y⤶  ⤶  width: ->⤶    @debugIfFloats()⤶    @corner.x - @origin.x⤶  ⤶  position: ->⤶    @debugIfFloats()⤶    @origin⤶  ⤶  # Rectangle comparison:⤶  equals: (aRect) ->⤶    if !aRect? then return false⤶    @debugIfFloats()⤶    @origin.equals(aRect.origin) and @corner.equals(aRect.corner)⤶  ⤶  abs: ->⤶    @debugIfFloats()⤶    newOrigin = @origin.abs()⤶    newCorner = @corner.max newOrigin⤶    newOrigin.corner newCorner⤶  ⤶  # Rectangle functions:⤶  insetBy: (delta) ->⤶    @debugIfFloats()⤶    # delta can be either a Point or a Number⤶    result = new @constructor()⤶    result.origin = @origin.add delta⤶    result.corner = @corner.subtract delta⤶    result.debugIfFloats()⤶    result⤶⤶  rightHalf: ->⤶    @debugIfFloats()⤶    result = new @constructor()⤶    result.origin = @origin.add new Point Math.round(@width()/2),0⤶    result.corner = @corner.copy()⤶    result.debugIfFloats()⤶    result⤶  ⤶  expandBy: (delta) ->⤶    @debugIfFloats()⤶    # delta can be either a Point or a Number⤶    result = new @constructor()⤶    result.origin = @origin.subtract delta⤶    result.corner = @corner.add delta⤶    result.debugIfFloats()⤶    result⤶  ⤶  growBy: (delta) ->⤶    @debugIfFloats()⤶    # delta can be either a Point or a Number⤶    result = new @constructor()⤶    result.origin = @origin.copy()⤶    result.corner = @corner.add delta⤶    result.debugIfFloats()⤶    result⤶  ⤶  # Note that ＂negative＂ rectangles can come⤶  # out of this operation. E.g.⤶  # new Rectangle(10,10,20,20).intersect(new Rectangle(15,25,19,25))⤶  # gives a rectangle with the corner above the origin.⤶  intersect: (aRect) ->⤶    @debugIfFloats()⤶    a = @zeroIfNegative()⤶    b = aRect.zeroIfNegative()⤶    if a.isEmpty() or b.isEmpty()⤶      return @constructor.EMPTY⤶    result = new @constructor()⤶    result.origin = a.origin.max b.origin⤶    result.corner = a.corner.min b.corner⤶    result = result.zeroIfNegative()⤶    result.debugIfFloats()⤶    result⤶⤶  zeroIfNegative: () ->⤶    @debugIfFloats()⤶    if @isEmpty()⤶      return @constructor.EMPTY⤶    return @⤶  ⤶  merge: (aRect) ->⤶    @debugIfFloats()⤶    a = @zeroIfNegative()⤶    b = aRect.zeroIfNegative()⤶    if a.isEmpty()⤶      return b⤶    if b.isEmpty()⤶      return a⤶    result = new @constructor()⤶    result.origin = a.origin.min b.origin⤶    result.corner = a.corner.max aRect.corner⤶    result.debugIfFloats()⤶    result⤶  ⤶  round: ->⤶    @origin.round().corner @corner.round()⤶⤶  floor: ->⤶    @origin.floor().corner @corner.floor()⤶⤶  ceil: ->⤶    @origin.ceil().corner @corner.ceil()⤶  ⤶  spread: ->⤶    @debugIfFloats()⤶    # round me by applying floor() to my origin and ceil() to my corner⤶    @origin.floor().corner @corner.ceil()⤶  ⤶⤶  ⤶  toLocalCoordinatesOf: (aWdgt) ->⤶    new @constructor @origin.x - aWdgt.left(),@origin.y - aWdgt.top(),@corner.x - aWdgt.left(),@corner.y - aWdgt.top()⤶  ⤶  # Rectangle testing:⤶  containsPoint: (aPoint) ->⤶    @debugIfFloats()⤶    @origin.le(aPoint) and aPoint.lt(@corner)⤶  ⤶  containsRectangle: (aRect) ->⤶    @debugIfFloats()⤶    aRect.origin.ge(@origin) and aRect.corner.le(@corner)⤶⤶  isIntersecting: (aRect) ->⤶    @debugIfFloats()⤶    ro = aRect.origin⤶    rc = aRect.corner⤶    rc.x >= @origin.x and⤶      rc.y >= @origin.y and⤶      ro.x <= @corner.x and⤶      ro.y <= @corner.y⤶  ⤶  ⤶  # Rectangle transforming:⤶  scaleBy: (scale) ->⤶    @debugIfFloats()⤶    # scale can be either a Point or a scalar⤶    o = @origin.multiplyBy scale⤶    c = @corner.multiplyBy scale⤶    new @constructor o.x, o.y, c.x, c.y⤶  ⤶  translateBy: (factor) ->⤶    @debugIfFloats()⤶    # factor can be either a Point or a scalar⤶    o = @origin.add factor⤶    c = @corner.add factor⤶    new @constructor o.x, o.y, c.x, c.y⤶  ⤶  translateTo: (aPoint) ->⤶    @debugIfFloats()⤶    c = @corner⤶    new @constructor aPoint.x, aPoint.y, c.x, c.y⤶  ⤶  ⤶  # Rectangle converting:⤶  asArray: ->⤶    @debugIfFloats()⤶    [@left(), @top(), @right(), @bottom()]⤶  ⤶  asArray_xywh: ->⤶    @debugIfFloats()⤶    [@left(), @top(), @width(), @height()]⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.TreeNode_coffeSource = "# Widgetic node class only cares about the⤶# parent/child connection between⤶# morphs. It's good to connect/disconnect⤶# morphs and to find parents or children⤶# who satisfy particular properties.⤶# OUT OF SCOPE:⤶# It's important to note that this layer⤶# knows nothing about visibility, targets,⤶# image buffers, dirty rectangles, events,⤶# position and extent (and hence bounds).⤶# Please no invocations to changed or fullChanged⤶# or updateBackBuffer in here, and no⤶# touching of any of the out-of-scope properties⤶# mentioned.⤶⤶class TreeNode⤶⤶  parent: nil⤶  # ＂children＂ is an ordered list of the immediate⤶  # children of this node. First child is at the⤶  # back relative to other children, last child is at the⤶  # top.⤶  #⤶  # The repaint mechanism in Fizzygum is back-to-front,⤶  # so first the ＂parent＂ morph is drawn, then the children,⤶  # where first child is re-painted first.⤶  #⤶  # The slight exception is the shadow, which, when it exists,⤶  # is the first⤶  # child, but includes the shadow of the parent morph.⤶  # So, the shadow is drawn AFTER the parent morph, but it's⤶  # drawn with a special blending mode, such that it can be⤶  # painted over and it still looks like it's at the back.⤶  #⤶  # This makes intuitive sense if you think for example⤶  # at a textMorph being added to a box morph: it is⤶  # added to the children list of the box morph, at the end,⤶  # and it's painted on top (otherwise it wouldn't be visible).⤶  #⤶  # Note that when you add a morph A to a morph B, it doesn't⤶  # mean that A is cointained in B. The two potentially might⤶  # not even overlap.⤶  children: nil⤶⤶  rootCache: nil⤶  rootCacheChecker: nil⤶⤶  checkFirstParentClippingAtBoundsCache: nil⤶  cachedFirstParentClippingAtBounds: nil⤶⤶  gcSessionIdMark: 0⤶  gcReferenceExaminedSessionIdMark: 0⤶⤶  constructor: (@parent = nil, @children = []) ->⤶⤶  ⤶  # TreeNode string representation: e.g. 'a TreeNode[3]'⤶  toString: ->⤶    if @children?⤶      childrenLength = @children.length⤶    else⤶      childrenLength = ＂-＂⤶    ＂a TreeNode＂ + ＂[＂ + childrenLength + ＂]＂⤶⤶⤶  ⤶  # TreeNode accessing:⤶  addChild: (node, position = nil) ->⤶    WorldMorph.numberOfAddsAndRemoves++⤶    @invalidateFullBoundsCache @⤶    @invalidateFullClippedBoundsCache @⤶    if !position?⤶      @children.push node⤶    else⤶      @children.splice position, 0, node⤶    node.parent = @⤶  ⤶⤶⤶  # used from bringToForeground method⤶  # for example when you⤶  # click morphs around... they⤶  # pop to the foreground⤶  moveAsLastChild: ->⤶    return unless @parent?⤶    idx = @parent.children.indexOf @⤶    if idx == -1⤶      return⤶    # check if already last child⤶    # i.e. topmost⤶    if idx == @parent.children.length - 1⤶      return⤶    @parent.children.splice idx, 1⤶    @parent.children.push @⤶    @parent.childMovedInFrontOfOthers? @⤶    # whoever invoked this should probably⤶    # do a fullChanged() we don't do it⤶    # here because it seems like a lower-level⤶    # function calling a higher-level one.⤶  ⤶  removeChild: (node) ->⤶    # remove the array element from the⤶    # array⤶    WorldMorph.numberOfAddsAndRemoves++⤶    @invalidateFullBoundsCache @⤶    @invalidateFullClippedBoundsCache @⤶    @children.remove node⤶    node.parent = nil⤶⤶  markReferenceAsVisited: (newGcSessionId) ->⤶    @gcReferenceExaminedSessionIdMark = newGcSessionId⤶⤶  wasReferenceVisited: (newGcSessionId) ->⤶    @gcReferenceExaminedSessionIdMark == newGcSessionId⤶⤶  markItAndItsParentsAsReachable: (newGcSessionId) ->⤶    @gcSessionId = newGcSessionId⤶    if @parent?⤶      if @parent.gcSessionId == newGcSessionId⤶        return⤶      if @isDirectlyInBasement()⤶        return⤶      @parent.markItAndItsParentsAsReachable newGcSessionId⤶  ⤶  # is this Widget attached to neither the world nor to⤶  # the hand?⤶  isOrphan: ->⤶    root = @root()⤶    if root == world or root == world.hand⤶      return false⤶    return true⤶⤶  # check if the widget is on its own in the basement⤶  # (rather than being part of a widget that is in the⤶  # basement)⤶  isDirectlyInBasement: ->⤶    @parent?.parent?.parent instanceof BasementWdgt⤶⤶  # check if it's in the basement on its own or⤶  # as part of another widget.⤶  isInBasement: ->⤶    thereCouldBeOne = @allParentsBottomToTopSuchThat (eachWdgt) ->⤶      eachWdgt instanceof BasementWdgt ⤶    return thereCouldBeOne.length == 1⤶⤶  isInBasementButReachable: (newGcSessionId) ->⤶    if @gcSessionId == newGcSessionId⤶      return true⤶    if @parent.gcSessionId == newGcSessionId⤶      return true⤶    if @parent instanceof BasementWdgt⤶      return false⤶    return @parent.isInBasementButReachable newGcSessionId⤶⤶⤶  # TreeNode functions:⤶  SLOWroot: ->⤶    if @parent?⤶      return @parent.SLOWroot()⤶    else⤶      return @⤶⤶  # TreeNode functions:⤶  root: ->⤶    if @rootCacheChecker == WorldMorph.numberOfAddsAndRemoves⤶      #console.log ＂cache hit root＂⤶      result = @rootCache⤶    else⤶  ⤶      theRoot = @⤶      if @parent?⤶        theRoot = @parent.root()⤶⤶      @rootCacheChecker = WorldMorph.numberOfAddsAndRemoves⤶      @rootCache = theRoot⤶      result = @rootCache⤶⤶    if world.doubleCheckCachedMethodsResults⤶      if result != @SLOWroot()⤶        debugger⤶        alert ＂root is broken＂⤶⤶    return result⤶⤶  # returns the path of this morph in terms⤶  # of children positions relative to the world.⤶  # Meaning that if the morph is not attached to the⤶  # world or if it's attached to the hand, then⤶  # nil is returned.⤶  # Example: [0, 2, 1] means that this morph is⤶  # at⤶  #  world.children[0].children[2].children[1]⤶  pathOfChildrenPositionsRelativeToWorld: (pathSoFar) ->⤶    if !pathSoFar?⤶      pathSoFar = ⤶        actualPath: []⤶        lengthOfChildrenArrays: []⤶⤶    if @parent?⤶      pathSoFar.actualPath.push @parent.children.indexOf @⤶      pathSoFar.lengthOfChildrenArrays.push @parent.children.length⤶      @parent.pathOfChildrenPositionsRelativeToWorld pathSoFar⤶    else⤶      if @ == world⤶        pathSoFar.actualPath.reverse()⤶        pathSoFar.lengthOfChildrenArrays.reverse()⤶        return pathSoFar⤶      else⤶        return nil⤶⤶  ⤶⤶  ⤶  # Returns all the internal AND terminal nodes in the subtree starting⤶  # at this node - including this node.⤶  # Remember that the @children property already sorts morphs⤶  # from bottom to top⤶⤶  allChildrenBottomToTop: ->⤶    result = [@] # includes myself⤶    @children.forEach (child) ->⤶      result = result.concat child.allChildrenBottomToTop()⤶    result⤶⤶  ⤶⤶⤶  # the easiest way here would be to just return⤶  #   @allChildrenBottomToTop().shallowCopy().reverse()⤶  # but that's slower.⤶  # So we do the proper visit here instead.⤶  allChildrenTopToBottomSuchThat: (predicate) ->⤶    collected = []⤶⤶⤶    # if I have children, then start from the top⤶    # one (i.e. the last in the array) towards the bottom⤶    # one and concatenate their respective⤶    # top-to-bottom lists⤶    for morphNumber in [@children.length-1..0] by -1⤶      morph = @children[morphNumber]⤶      collected = collected.concat morph.allChildrenTopToBottomSuchThat predicate⤶⤶    # base case: after we checked all the⤶    # children, we add ourselves to the last position⤶    # of the list since this node is at the bottom of all of⤶    # its children...⤶    if predicate.call nil, @⤶      collected.push @ # include myself⤶⤶    return collected⤶⤶⤶  # A shorthand to run a function on all the internal/terminal nodes in the subtree⤶  # starting at this node - including this node.⤶  # Note that the function first runs on this node⤶  # (which is, when painted, the very bottom-est morph of them all)⤶  # and the proceeds by visiting the first child⤶  # which is the most ＂bottom＂ of the children⤶  # (i.e. when painted, the first child in the ＂children＂ array⤶  # and its children are painted just above the parent node)⤶  # and then recursively depht-first all its children⤶  # and then the second - bottomest child and children etc.⤶  # Also note that there is a more elegant implementation where⤶  # we just use @allChildrenBottomToTop() but that would mean to create⤶  # all the intermediary arrays with also all the unneeded node elements,⤶  # there is no need for that.⤶  # This is the simplest and cheapest way to visit all Widgets in⤶  # a tree of morphs.⤶  forAllChildrenBottomToTop: (aFunction) ->⤶    aFunction.call nil, @⤶    if @children.length⤶      @children.forEach (child) ->⤶        child.forAllChildrenBottomToTop aFunction⤶  ⤶⤶⤶  # Return all ＂parent＂ nodes from the root down to this node (including both)⤶  allParentsBottomToTop: ->⤶    if @parent?⤶      someParents = @parent.allParentsBottomToTop()⤶      someParents.push @⤶      return someParents⤶    else⤶      return [@]⤶  ⤶  # Return all ＂parent＂ nodes from this node up to the root (including both)⤶  # Implementation commented-out below works but it's probably⤶  # slower than the one given, because concat is slower than pushing just⤶  # an array element, since concat does a shallow copy of both parts of⤶  # the array...⤶  #   allParentsTopToBottom: ->⤶  #    # includes myself⤶  #    result = [@]⤶  #    if @parent?⤶  #      result = result.concat(@parent.allParentsTopToBottom())⤶  #    result⤶⤶  # Return all ＂parent＂ nodes from this note up to the root (including both)⤶  allParentsTopToBottom: ->⤶    return @allParentsBottomToTop().reverse()⤶⤶  # this should be quicker than allParentsTopToBottomSuchThat⤶  # cause there are no concats making shallow copies.⤶  allParentsBottomToTopSuchThat: (predicate) ->⤶    result = []⤶    if @parent?⤶      result = @parent.allParentsBottomToTopSuchThat predicate⤶    if predicate.call(nil, @)⤶      result.push @⤶    result⤶⤶  allParentsTopToBottomSuchThat: (predicate) ->⤶    collected = []⤶    if predicate.call nil, @⤶      collected = [@] # include myself⤶    if @parent?⤶      collected = collected.concat @parent.allParentsTopToBottomSuchThat predicate⤶    return collected⤶⤶  # quicker version that doesn't need us⤶  # to create any intermediate arrays⤶  # but rather just loops up the chain⤶  # and lets us return as soon as⤶  # we find a match⤶  isAncestorOf: (morph) ->⤶    if !morph?⤶      # this happens when in a test, you select⤶      # a menu entry that doesn't exist.⤶      # so it's a good thing that we block the test⤶      # and let the user navigate through the world⤶      # to find the state of affairs that caused⤶      # the problem.⤶      if Automator?⤶        console.log ＂failed to find morph in test: ＂ + world.automator.name⤶        console.log ＂trying to find item with text label: ＂ +  world.automator.player.getCommandBeingPlayed().textLabelOfClickedItem⤶        console.log ＂...you can likely fix the test by correcting the label above in the test＂⤶        debugger⤶    # test the morph itself⤶    if morph is @⤶      return true⤶    examinedMorph = morph⤶    # could use recursion, but⤶    # a loop will do too⤶    while examinedMorph.parent?⤶      examinedMorph = examinedMorph.parent⤶      if examinedMorph is @⤶        return true⤶    return false⤶⤶⤶⤶  amITheFirstSibling: ->⤶    if @parent.children[0] == @⤶      return true⤶    return false⤶⤶  amITheLastSibling: ->⤶    if @parent.children[@parent.children.length - 1] == @⤶      return true⤶    return false⤶⤶  positionAmongSiblings: ->⤶    theCount = 0⤶    for eachSibling in @parent.children⤶      if eachSibling == @⤶        return theCount⤶      theCount++⤶⤶  siblingBeforeMeIsA: (theConstructor) ->⤶    if @amITheFirstSibling()⤶      return false⤶    if @parent.children[@positionAmongSiblings()-1] instanceof theConstructor⤶      return true⤶    return false⤶⤶  siblingAfterMeIsA: (theConstructor) ->⤶    if @amITheLastSibling()⤶      return false⤶    if @parent.children[@positionAmongSiblings()+1] instanceof theConstructor⤶      return true⤶    return false⤶⤶⤶  # find how many siblings before me⤶  # satisfy a property⤶  # This is used when figuring out⤶  # how many buttons before a particular button⤶  # are labeled in the same way,⤶  # in the test system.⤶  # (so that we can say: automatically⤶  # click on the nth button labelled ＂X＂)⤶  howManySiblingsBeforeMeSuchThat: (predicate) ->⤶    theCount = 0⤶    for eachSibling in @parent.children⤶      if eachSibling == @⤶        return theCount⤶      if predicate.call nil, eachSibling⤶        theCount++⤶    return theCount⤶⤶  lastSiblingBeforeMeSuchThat: (predicate) ->⤶    theCount = 0⤶    indexOfMorph = nil⤶    for eachSibling in @parent.children⤶      if eachSibling == @⤶        break⤶      if predicate.call nil, eachSibling⤶        indexOfMorph = theCount⤶      theCount++⤶⤶    if indexOfMorph?⤶      return @parent.children[indexOfMorph]⤶    else⤶      return nil⤶⤶  firstSiblingAfterMeSuchThat: (predicate) ->⤶    searchActuallyOngoing = false⤶    for eachSibling in @parent.children⤶      if searchActuallyOngoing⤶        if predicate.call nil, eachSibling⤶          return eachSibling⤶      if eachSibling == @⤶        searchActuallyOngoing = true⤶    return nil⤶⤶⤶  childrenNotHandlesNorCarets: (whereToAct = @) ->⤶    whereToAct.children.filter (w) ->⤶      !((w instanceof HandleMorph) or (w instanceof CaretMorph))⤶⤶  # find the nth child satisfying⤶  # a property.⤶  # This is used when finding⤶  # the nth buttons of a menu⤶  # having a particular label.⤶  # (so that we can say: automatically⤶  # click on the nth button labelled ＂X＂)⤶  nthChildSuchThat: (n, predicate) ->⤶    theCount = 0⤶    for w in @children⤶      if predicate.call nil, w⤶        theCount++⤶        if theCount is n⤶          return w⤶    return nil⤶⤶  firstChildSuchThat: (predicate) ->⤶    @nthChildSuchThat 1, predicate⤶⤶  SLOWfirstParentClippingAtBounds: (morphToStartFrom = @) ->⤶    if morphToStartFrom.parent?⤶      if morphToStartFrom.parent.clipsAtRectangularBounds⤶        return morphToStartFrom.parent⤶      else⤶        return morphToStartFrom.parent.SLOWfirstParentClippingAtBounds()⤶    else⤶      return nil⤶⤶  firstParentClippingAtBounds: (morphToStartFrom = @) ->⤶    if @checkFirstParentClippingAtBoundsCache == WorldMorph.numberOfAddsAndRemoves⤶      if world.doubleCheckCachedMethodsResults⤶        if @cachedFirstParentClippingAtBounds != @SLOWfirstParentClippingAtBounds morphToStartFrom⤶          debugger⤶          alert ＂firstParentClippingAtBounds is broken (cached)＂⤶⤶    if morphToStartFrom.parent?⤶      if morphToStartFrom.parent.clipsAtRectangularBounds⤶        result = morphToStartFrom.parent⤶      else⤶        result = morphToStartFrom.parent.firstParentClippingAtBounds()⤶    else⤶      result =  nil⤶⤶    if world.doubleCheckCachedMethodsResults⤶      if result != @SLOWfirstParentClippingAtBounds morphToStartFrom⤶        debugger⤶        alert ＂firstParentClippingAtBounds is broken (uncached)＂⤶⤶    @checkFirstParentClippingAtBoundsCache = WorldMorph.numberOfAddsAndRemoves⤶    @cachedFirstParentClippingAtBounds = result⤶⤶⤶  ⤶  # returns the first parent (going up from this node) that is of a particular class⤶  # (includes this particular node)⤶  # This is a subcase of ＂parentThatIsAnyOf＂.⤶  parentThatIsA: (constructors...) ->⤶    # including myself⤶    for eachConstructor in constructors⤶      if @ instanceof eachConstructor⤶        return [@, eachConstructor]⤶    return nil  unless @parent⤶    @parent.parentThatIsA constructors...⤶⤶⤶  ⤶⤶  # There would be another, simpler, implementation⤶  # which is also slower, where you first collect all⤶  # the children from top to bottom and then do the⤶  # test on each. But this is more efficient - we don't⤶  # need to create that entire list to start with, we⤶  # just navigate through the children arrays depth-first⤶  # (in reverse order though, see below)⤶  # and stop at the first morph that satisfies the test.⤶  topWdgtSuchThat: (predicate) ->⤶    # base case - I am a leaf child, so I just test⤶    # the predicate on myself and return myself⤶    # if I satisfy, else I return nil⤶    if @children.length == 0⤶      if predicate.call nil, @⤶        return @⤶      else⤶        return nil⤶    # if I have children, then start to test from⤶    # the top one (the last one in the array)⤶    # and proceed to test ＂towards the back＂ i.e.⤶    # testing elements of the array towards 0⤶    # If you find any morph satisfying, the search is⤶    # over.⤶    for morphNumber in [@children.length-1..0] by -1⤶      morph = @children[morphNumber]⤶      foundMorph = morph.topWdgtSuchThat predicate⤶      if foundMorph?⤶        return foundMorph⤶    # now that all children are tested, test myself⤶    if predicate.call nil, @⤶      return @⤶⤶    # ok none of my children nor me test positive,⤶    # so return nil.⤶    return nil⤶⤶  topmostChildSuchThat: (predicate) ->⤶    # start to test from⤶    # the top one (the last one in the array)⤶    # and proceed to test ＂towards the back＂ i.e.⤶    # testing elements of the array towards 0⤶    # If you find any child that satisfies, the search is⤶    # over.⤶    for morphNumber in [@children.length-1..0] by -1⤶      morph = @children[morphNumber]⤶      if predicate.call nil, morph⤶        return morph⤶    # ok none of my children test positive,⤶    # so return nil.⤶    return nil⤶⤶  collectAllChildrenBottomToTopSuchThat: (predicate) ->⤶    collected = []⤶    if predicate.call(nil, @)⤶      collected = [@] # include myself⤶    @children.forEach (child) ->⤶      collected = collected.concat(child.collectAllChildrenBottomToTopSuchThat(predicate))⤶    return collected⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BlinkerMorph_coffeSource = "# can be used for text caret⤶⤶class BlinkerMorph extends Widget⤶⤶  constructor: (@fps = 2) ->⤶    world.steppingWdgts.add @⤶    super()⤶    @appearance = new RectangularAppearance @⤶    @color = Color.BLACK⤶  ⤶  # BlinkerMorph stepping:⤶  step: ->⤶    # if we are recording or playing a test⤶    # then there is a flag we need to check that allows⤶    # the world to control all the animations.⤶    # This is so there is a consistent check⤶    # when taking/comparing⤶    # screenshots.⤶    # So we check here that flag, and make the⤶    # caret is always going to be visible.⤶    if Automator? and⤶     Automator.animationsPacingControl and⤶     Automator.state != Automator.IDLE⤶      return⤶ ⤶    # in all other cases just⤶    # do like usual, i.e. toggle⤶    # visibility at the fps⤶    # specified in the constructor.⤶    @toggleVisibility()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BoxMorph_coffeSource = "# I can have an optionally rounded border⤶⤶class BoxMorph extends Widget⤶⤶  cornerRadius: nil⤶⤶  constructor: (@cornerRadius = 4) ->⤶    super()⤶    @appearance = new BoxyAppearance @⤶⤶  colloquialName: ->⤶    ＂box＂⤶⤶  insetPosition: ->⤶    return @position().add(@cornerRadius - Math.round(@cornerRadius/Math.sqrt(2)))⤶⤶  insetSpaceExtent: ->⤶    return @extent().subtract(2*(@cornerRadius - Math.round(@cornerRadius/Math.sqrt(2))))⤶⤶  extentBasedOnInsetExtent: (insetMorph) ->⤶    return insetMorph.extent().add(2*(@cornerRadius - Math.round(@cornerRadius/Math.sqrt(2))))⤶⤶  # there is another method almost equal to this⤶  # todo refactor⤶  choiceOfMorphToBePicked: (ignored, morphPickingUp) ->⤶    # this is what happens when ＂each＂ is⤶    # selected: we attach the selected morph⤶    morphPickingUp.addInset @⤶    if @ instanceof ScrollPanelWdgt⤶      @adjustContentsBounds()⤶      @adjustScrollBars()⤶⤶⤶  setCornerRadius: (radiusOrMorphGivingRadius, morphGivingRadius) ->⤶    if morphGivingRadius?.getValue?⤶      radius = morphGivingRadius.getValue()⤶    else⤶      radius = radiusOrMorphGivingRadius⤶⤶    if typeof radius is ＂number＂⤶      @cornerRadius = Math.max radius, 0⤶    else⤶      newRadius = parseFloat radius⤶      if !isNaN newRadius⤶        @cornerRadius = Math.max newRadius, 0⤶    @layoutInset()⤶    @changed()⤶⤶  ⤶  # there is another method almost equal to this⤶  # todo refactor⤶  pickInset: ->⤶    choices = world.plausibleTargetAndDestinationMorphs @⤶⤶    # my direct parent might be in the⤶    # options which is silly, leave that one out⤶    choicesExcludingParent = []⤶    choices.forEach (each) =>⤶      if each != @parent⤶        choicesExcludingParent.push each⤶⤶    if choicesExcludingParent.length > 0⤶      menu = new MenuMorph @, false, @, true, true, ＂choose Widget to put as inset:＂⤶      choicesExcludingParent.forEach (each) =>⤶        menu.addMenuItem each.toString().slice(0, 50), true, each, ＂choiceOfMorphToBePicked＂⤶    else⤶      # the ideal would be to not show the⤶      # ＂attach＂ menu entry at all but for the⤶      # time being it's quite costly to⤶      # find the eligible morphs to attach⤶      # to, so for now let's just calculate⤶      # this list if the user invokes the⤶      # command, and if there are no good⤶      # morphs then show some kind of message.⤶      menu = new MenuMorph @, false, @, true, true, ＂no morphs to pick＂⤶    menu.popUpAtHand()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BoxyAppearance_coffeSource = "class BoxyAppearance extends Appearance⤶⤶  getCornerRadius: ->⤶    if @morph.cornerRadius?⤶      return @morph.cornerRadius⤶    else⤶      return 4⤶⤶  constructor: (morph) ->⤶    super morph⤶⤶  isTransparentAt: (aPoint) ->⤶    # first quickly check if the point is even⤶    # within the bounding box⤶    if !@morph.boundsContainPoint aPoint⤶      return true⤶ ⤶    thisMorphPosition = @morph.position()⤶    radius = Math.max @getCornerRadius(), 0⤶ ⤶    relativePoint = new Point aPoint.x - thisMorphPosition.x, aPoint.y - thisMorphPosition.y⤶⤶    # top left corner⤶    if relativePoint.x < radius and relativePoint.y < radius⤶      if relativePoint.distanceTo(new Point radius,radius) > radius⤶        return true⤶⤶    # top right corner⤶    else if relativePoint.x > @morph.width() - radius and relativePoint.y < radius⤶      if relativePoint.distanceTo(new Point @morph.width() - radius,radius) > radius⤶        return true⤶⤶    # bottom left corner⤶    else if relativePoint.x < radius and relativePoint.y > @morph.height() - radius⤶      if relativePoint.distanceTo(new Point radius, @morph.height() - radius) > radius⤶        return true⤶⤶    # bottom right corner⤶    else if relativePoint.x > @morph.width() - radius and relativePoint.y > @morph.height() - radius⤶      if relativePoint.distanceTo(new Point @morph.width() - radius, @morph.height() - radius) > radius⤶        return true⤶⤶⤶    return false⤶  ⤶  # This method only paints this very morph's ＂image＂,⤶  # it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which⤶  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if @morph.preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return nil⤶⤶    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    aContext.save()⤶⤶    # clip out the dirty rectangle as we are⤶    # going to paint the whole of the box⤶    aContext.clipToRectangle al,at,w,h⤶⤶    aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @morph.alpha⤶⤶    aContext.useLogicalPixelsUntilRestore()⤶    morphPosition = @morph.position()⤶    aContext.translate morphPosition.x, morphPosition.y⤶    if !@morph.color? then debugger⤶    aContext.fillStyle = @morph.color.toString()⤶    ⤶    if appliedShadow?⤶      aContext.fillStyle = ＂black＂⤶⤶    aContext.beginPath()⤶    @outlinePath aContext, @getCornerRadius(), false⤶    aContext.closePath()⤶    aContext.fill()⤶⤶    if @morph.strokeColor? and !appliedShadow?⤶      aContext.lineWidth = 1 # TODO might look better if * ceilPixelRatio⤶      aContext.strokeStyle = @morph.strokeColor.toString()⤶      aContext.beginPath()⤶      @outlinePath aContext, @getCornerRadius(), true⤶      aContext.closePath()⤶      aContext.stroke()⤶⤶    aContext.restore()⤶⤶    # paintHighlight is usually made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, so it's generally used⤶    # outside the effect of the scaling because⤶    # of the ceilPixelRatio (i.e. after the restore)⤶    @paintHighlight aContext, al, at, w, h⤶⤶  ⤶  outlinePath: (context, radius, isStroke) ->⤶    offset = radius⤶    # in order to be crisp, strokes have to be displaced a bit⤶    # (while fills don't, they'd look fuzzy instead).⤶    # Note that the curved corners will be drawn with antialiasing,⤶    # which for small dimensions and/or for small curvatures looks messy.⤶    # There is really no way to disable antialiasing when drawing⤶    # vector graphics (see:⤶    # https://stackoverflow.com/questions/195262/can-i-turn-off-antialiasing-on-an-html-canvas-element⤶    # ). A possible solution is to detect when you are⤶    # drawing small components (somehow track the scale that it's drawn at)⤶    # and small radius, and in those cases avoid to paint the arc, but⤶    # rather fiddle with pixels individually (following the equation of the⤶    # circle or just manually pixel-painting the curve).⤶    if isStroke⤶      offset += 0.5⤶    w = @morph.width()⤶    h = @morph.height()⤶    # top left (from -180 to -90 degrees):⤶    context.arc offset, offset, radius, -Math.PI, -Math.PI/2⤶    # top right (from -90 to 0 degrees):⤶    context.arc w - offset, offset, radius, -Math.PI/2, 0⤶    # bottom right (from 0 to 90 degrees):⤶    context.arc w - offset, h - offset, radius, 0, Math.PI/2⤶    # bottom left (from 90 to 180 degrees):⤶    context.arc offset, h - offset, radius, Math.PI/2, Math.PI⤶⤶  cornerRadiusPopout: (menuItem)->⤶    @morph.prompt menuItem.parent.title + ＂⧹ncorner⧹nradius:＂,⤶      @morph,⤶      ＂setCornerRadius＂,⤶      @morph.cornerRadius.toString(),⤶      nil,⤶      0,⤶      100,⤶      true⤶  ⤶  # Boxy menus:⤶  addShapeSpecificMenuItems: (menu) ->⤶    menu.addLine()⤶    menu.addMenuItem ＂corner radius...＂, true, @, ＂cornerRadiusPopout＂, ＂set the corner's⧹nradius＂⤶    menu.addMenuItem ＂pick inset...＂, true, @morph, ＂pickInset＂, ＂put a morph as inset＂⤶    menu⤶  ⤶  addShapeSpecificNumericalSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    if !menuEntriesStrings? ⤶      menuEntriesStrings = []⤶      functionNamesStrings = []⤶    menuEntriesStrings.push ＂corner radius＂⤶    functionNamesStrings.push ＂setCornerRadius＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CanvasGlassTopWdgt_coffeSource = "class CanvasGlassTopWdgt extends CanvasMorph⤶⤶  underlyingCanvasMorph: nil⤶  defaultRejectDrags: true⤶⤶  constructor: ->⤶    super⤶    @color = nil⤶    # the overlay canvas is usually attached to a Canvas⤶    # which unfortunately is a Frame (it shouldn't, it should⤶    # just clip at its bounds via a mixin TODO ). So, usually⤶    # things inside a Panel can be dragged-out of it, so we have⤶    # to avoid that here⤶    @isLockingToPanels = true⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CanvasMorph_coffeSource = "# I clip my submorphs at my bounds. Which potentially saves a lot of redrawing⤶# and event handling. ⤶# Also I always use a canvas to retain my graphical representation and respond⤶# to the HTML5 commands.⤶# ⤶# ＂container＂/＂contained＂ scenario going on.⤶⤶class CanvasMorph extends PanelWdgt⤶  @augmentWith BackBufferMixin⤶⤶  constructor: ->⤶    super⤶    @color = Color.WHITE⤶  ⤶  iHaveBeenAddedTo: (whereTo, beingDropped) ->⤶⤶  # No changes of position or extent should be⤶  # performed in here.⤶  # There is really little hope to cache this buffer⤶  # cross-morph, unless you key the buffer with the⤶  # order of all the primitives and their⤶  # parameters. So if user wants a cache it will have to specify⤶  # a dedicated one in here. See textMorph for an example.⤶  createRefreshOrGetBackBuffer: ->⤶⤶    extent = @extent()⤶⤶    if @backBuffer?⤶      # @backBuffer.width and @backBuffer.height are already in⤶      # physical coordinates so no need to adjust for pixelratio⤶      backBufferExtent = new Point @backBuffer.width, @backBuffer.height⤶      if backBufferExtent.equals extent.scaleBy ceilPixelRatio⤶        return [@backBuffer, @backBufferContext]⤶      else⤶⤶        original_backBuffer = @backBuffer⤶⤶        # make a new canvas of the new size⤶        @backBuffer = newCanvas extent.scaleBy ceilPixelRatio⤶        @backBufferContext = @backBuffer.getContext ＂2d＂⤶⤶        # paint the background over it all so there are⤶        # no holes in the new area (if the canvas is being⤶        # enlarged).⤶        if @color?⤶          @backBufferContext.fillStyle = @color.toString()⤶          @backBufferContext.fillRect 0, 0, extent.x * ceilPixelRatio, extent.y * ceilPixelRatio⤶⤶        # copy back the original canvas in the new one.⤶        @backBufferContext.drawImage original_backBuffer, 0, 0⤶        ⤶        # we leave the context with the correct pixel scaling.⤶        # ALWAYS leave the context with the correct pixel scaling.⤶        @backBufferContext.useLogicalPixelsUntilRestore()⤶        return [@backBuffer, @backBufferContext]⤶⤶    @backBuffer = newCanvas extent.scaleBy ceilPixelRatio⤶    @backBufferContext = @backBuffer.getContext ＂2d＂⤶⤶    if @color?⤶      @backBufferContext.fillStyle = @color.toString()⤶      @backBufferContext.fillRect 0, 0, extent.x * ceilPixelRatio, extent.y * ceilPixelRatio⤶⤶    # we leave the context with the correct scaling.⤶    # ALWAYS leave the context with the correct pixel scaling.⤶    @backBufferContext.useLogicalPixelsUntilRestore()⤶    return [@backBuffer, @backBufferContext]⤶⤶⤶  clear: (color = @color) ->⤶    if !@backBuffer? then @createRefreshOrGetBackBuffer()⤶    # @backBuffer.width and @backBuffer.height are already in⤶    # physical coordinates so no need to adjust for pixelratio⤶    backBufferExtent = new Point @backBuffer.width, @backBuffer.height⤶    ⤶    # just in case we get a dirty transformation matrix:⤶    # set it to the identity.⤶    @backBufferContext.setTransform(1, 0, 0, 1, 0, 0)⤶    # no need to scale here because we get the physical pixels⤶    # in backBufferExtent ⤶    #@backBufferContext.useLogicalPixelsUntilRestore()⤶    ⤶    @backBufferContext.fillStyle = color.toString()⤶    @backBufferContext.fillRect 0, 0, backBufferExtent.x, backBufferExtent.y⤶⤶    # we leave the context with the correct scaling.⤶    # ALWAYS leave the context with the correct pixel scaling.⤶    @backBufferContext.useLogicalPixelsUntilRestore()⤶    @changed()⤶⤶  drawLine: (start, dest, lineWidth, color) ->⤶    if !@backBuffer? then @createRefreshOrGetBackBuffer()⤶⤶    context = @backBufferContext⤶⤶    from = start⤶    to = dest⤶    context.lineWidth = lineWidth⤶    context.strokeStyle = color.toString()⤶    context.lineCap = ＂round＂⤶    context.lineJoin = ＂round＂⤶    context.beginPath()⤶    context.moveTo from.x, from.y⤶    context.lineTo to.x, to.y⤶    context.stroke()⤶    @changed()⤶  ⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CaretMorph_coffeSource = "# I mark where the caret is in a String/Text while editing⤶⤶class CaretMorph extends BlinkerMorph⤶⤶  keyDownEventUsed: false⤶  target: nil⤶  slot: nil⤶  viewPadding: 1⤶  currentCaretFontSize: nil⤶⤶  constructor: (@target) ->⤶    # additional properties:⤶    @slot = @target.text.length⤶    super()⤶⤶    # if the only thing in the undo history is the⤶    # first positioning of the caret via click, we can clear⤶    # that because we are going to set out own with⤶    # the first click⤶    if @target.undoHistory?.length == 1⤶      onlyUndo = @target.undoHistory[@target.undoHistory.length - 1]⤶      if onlyUndo.isJustFirstClickToPositionCursor⤶        @target.undoHistory = []⤶⤶    # font could be really small I guess?⤶    @minimumExtent = new Point 1,1⤶⤶    if (@target instanceof TextMorph) and (@target.alignment != 'left')⤶      @target.setAlignmentToLeft()⤶    @adjustAccordingToTargetText()⤶⤶  adjustAccordingToTargetText: ->⤶    @updateDimension()⤶    @gotoSlot @slot⤶⤶  justBeforeBeingPainted: ->⤶    @adjustAccordingToTargetText()⤶⤶  updateDimension: ->⤶    ls = fontHeight @target.actualFontSizeUsedInRendering()⤶    if ls != @currentCaretFontSize⤶      @currentCaretFontSize = ls⤶      @rawSetExtent new Point Math.max(Math.floor(ls / 20), 1), ls⤶  ⤶  # CaretMorph event processing:⤶  processKeyPress: (charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->⤶    # @inspectKeyEvent event⤶    if @keyDownEventUsed⤶      @keyDownEventUsed = false⤶      @updateDimension()⤶      return nil⤶    if ctrlKey⤶      @ctrl charCode, shiftKey⤶    # in Chrome/OSX cmd-a and cmd-z⤶    # don't trigger a keypress so this⤶    # function invocation here does⤶    # nothing.⤶    else if metaKey⤶      @cmd charCode, shiftKey⤶    else⤶      @insert symbol, shiftKey⤶    # notify target's parent of key event⤶    @target.escalateEvent ＂reactToKeystroke＂, charCode, symbol, shiftKey, ctrlKey, altKey, metaKey⤶    @updateDimension()⤶  ⤶  # Some ＂keys＂ don't produce a keypress,⤶  # they just produce a keydown/keyup,⤶  # (see https://stackoverflow.com/q/1367700 )⤶  # so we handle those here.⤶  # Note that we use the keyDownEventUsed flag⤶  # to absolutely make sure that we don't process⤶  # the same thing twice just in case in some⤶  # platforms some unexpected keys DO produce⤶  # both the keydown + keypress ...⤶  processKeyDown: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->⤶    # @inspectKeyEvent event⤶    @keyDownEventUsed = false⤶    if ctrlKey⤶      @ctrl scanCode, shiftKey⤶      # notify target's parent of key event⤶      @target.escalateEvent ＂reactToKeystroke＂, scanCode, nil, shiftKey, ctrlKey, altKey, metaKey⤶      @updateDimension()⤶      return⤶    else if metaKey⤶      @cmd scanCode, shiftKey⤶      # notify target's parent of key event⤶      @target.escalateEvent ＂reactToKeystroke＂, scanCode, nil, shiftKey, ctrlKey, altKey, metaKey⤶      @updateDimension()⤶      return⤶    switch scanCode⤶      when 32⤶        # when you do a preventDefault() on the spacebar,⤶        # (to avoid the page to scroll), then the⤶        # keypress event for the space doesn't happen⤶        # (at least in Chrome/OSX),⤶        # so we must process it in the keydown here instead!⤶        @insert ＂ ＂⤶        @keyDownEventUsed = true⤶      when 37⤶        @goLeft shiftKey⤶        @keyDownEventUsed = true⤶      when 39⤶        @goRight shiftKey⤶        @keyDownEventUsed = true⤶      when 38⤶        @goUp shiftKey⤶        @keyDownEventUsed = true⤶      when 40⤶        @goDown shiftKey⤶        @keyDownEventUsed = true⤶      when 36⤶        @goHome shiftKey⤶        @keyDownEventUsed = true⤶      when 35⤶        @goEnd shiftKey⤶        @keyDownEventUsed = true⤶      when 46⤶        @deleteRight()⤶        @keyDownEventUsed = true⤶      when 8⤶        @deleteLeft()⤶        @keyDownEventUsed = true⤶      when 9⤶        # TAB is another key that doesn't⤶        # produce a keypress in all browsers/OSs⤶        @keyDownEventUsed = true⤶        if @target?⤶          if shiftKey⤶            return @target.backTab @target⤶          else⤶            if @target instanceof SimplePlainTextWdgt⤶              @insert ＂  ＂⤶              @keyDownEventUsed = true⤶            else⤶              return @target.tab @target⤶⤶      when 13⤶        # we can't check the class using instanceof⤶        # because TextMorphs are instances of StringMorphs⤶        # but they want the enter to insert a carriage return.⤶        if @target.constructor.name == ＂StringMorph＂ or @target.constructor.name == ＂StringMorph2＂⤶          @accept()⤶        else⤶          @insert ＂⧹n＂⤶        @keyDownEventUsed = true⤶      when 27⤶        @cancel()⤶        @keyDownEventUsed = true⤶      else⤶    # @inspectKeyEvent event⤶    # notify target's parent of key event⤶    @target.escalateEvent ＂reactToKeystroke＂, scanCode, nil, shiftKey, ctrlKey, altKey, metaKey⤶    @updateDimension()⤶  ⤶  processCut: (selectedText) ->⤶    #console.log ＂processing cut＂⤶    # see comment on outstandingTimerTriggeredOperationsCounter⤶    # above where the property is declared and initialised.⤶    world.outstandingTimerTriggeredOperationsCounter.push true⤶    window.setTimeout ( =>⤶     @deleteLeft()⤶     world.outstandingTimerTriggeredOperationsCounter.pop()⤶    ), 50, true⤶⤶⤶  processCopy: (selectedText) ->⤶    #console.log ＂processing copy＂⤶⤶  processPaste: (clipboardText) ->⤶    # Needs a few msec to execute paste⤶    #console.log ＂about to insert text: ＂ + clipboardText⤶⤶    # see comment on outstandingTimerTriggeredOperationsCounter⤶    # above where the property is declared and initialised.⤶    world.outstandingTimerTriggeredOperationsCounter.push true⤶    window.setTimeout ( =>⤶     @insert clipboardText⤶     world.outstandingTimerTriggeredOperationsCounter.pop()⤶    ), 50, true⤶⤶  ⤶  gotoSlot: (slot, becauseOfMouseClick) ->⤶    # check that slot is within the allowed boundaries of⤶    # of zero and text length.⤶    length = @target.text.length⤶    @slot = (if slot < 0 then 0 else (if slot > length then length else slot))⤶⤶    pos = @target.slotCoordinates @slot⤶    if pos?⤶      if @parent and @target.isScrollable⤶        right = @parent.right() - @viewPadding⤶        left = @parent.left() + @viewPadding⤶        if pos.x > right⤶          @target.fullRawMoveLeftSideTo @target.left() + right - pos.x⤶          pos.x = right⤶        if pos.x < left⤶          left = Math.min @parent.left(), left⤶          @target.fullRawMoveLeftSideTo @target.left() + left - pos.x⤶          pos.x = left⤶        if @target.right() < right and right - @target.width() < left⤶          pos.x += right - @target.right()⤶          @target.fullRawMoveRightSideTo right⤶      #console.log ＂moving caret to: ＂ + pos⤶      @show()⤶      @fullRawMoveTo pos.floor()⤶⤶      if @amIDirectlyInsideScrollPanelWdgt() and @target.isScrollable⤶        @parent.parent.scrollCaretIntoView @⤶⤶    if becauseOfMouseClick and @target.undoHistory?.length == 0⤶      @target.pushUndoState? @slot, true⤶⤶  ⤶  goLeft: (shift) ->⤶    if !shift and @target.firstSelectedSlot()?⤶      @gotoSlot @target.firstSelectedSlot()⤶      @updateSelection shift⤶    else⤶      @updateSelection shift⤶      @gotoSlot @slot - 1⤶      @updateSelection shift⤶      @clearSelectionIfStartAndEndMeet shift⤶    @target.caretHorizPositionForVertMovement = @slot⤶  ⤶  goRight: (shift, howMany) ->⤶    if !shift and @target.lastSelectedSlot()?⤶      @gotoSlot @target.lastSelectedSlot()⤶      @updateSelection shift⤶    else⤶      @updateSelection shift⤶      @gotoSlot @slot + (howMany || 1)⤶      @updateSelection shift⤶      @clearSelectionIfStartAndEndMeet shift⤶    @target.caretHorizPositionForVertMovement = @slot⤶  ⤶  goUp: (shift) ->⤶    if !shift and @target.lastSelectedSlot()?⤶      @gotoSlot @target.firstSelectedSlot()⤶      @updateSelection shift⤶    else⤶      @updateSelection shift⤶      @gotoSlot @target.upFrom @slot⤶      @updateSelection shift⤶      @clearSelectionIfStartAndEndMeet shift⤶  ⤶  goDown: (shift) ->⤶    if !shift and @target.lastSelectedSlot()?⤶      @gotoSlot @target.lastSelectedSlot()⤶      @updateSelection shift⤶    else⤶      @updateSelection shift⤶      @gotoSlot @target.downFrom @slot⤶      @updateSelection shift⤶      @clearSelectionIfStartAndEndMeet shift⤶  ⤶  goHome: (shift) ->⤶    @updateSelection shift⤶    @gotoSlot @target.startOfLine @slot⤶    @updateSelection shift⤶    @clearSelectionIfStartAndEndMeet shift⤶  ⤶  goEnd: (shift) ->⤶    @updateSelection shift⤶    @gotoSlot @target.endOfLine @slot⤶    @updateSelection shift⤶    @clearSelectionIfStartAndEndMeet shift⤶  ⤶  gotoPos: (aPoint) ->⤶    slotToGoTo = @target.slotAt aPoint⤶    @gotoSlot slotToGoTo⤶    @show()⤶    return slotToGoTo⤶⤶  clearSelectionIfStartAndEndMeet: (shift) ->⤶    if shift⤶      #console.log ＂@target.startMark: ＂ + @target.startMark + ＂ @target.endMark: ＂ + @target.endMark⤶      if @target.startMark == @target.endMark⤶        #console.log ＂clearSelectionIfStartAndEndMeet clearing selection＂⤶        @target.clearSelection()⤶⤶  updateSelection: (shift) ->⤶    if shift⤶      if (!@target.endMark?) and (!@target.startMark?)⤶        @target.selectBetween @slot, @slot⤶      else if @target.endMark isnt @slot⤶        @target.setEndMark @slot⤶    else⤶      @target.clearSelection()⤶  ⤶  # CaretMorph editing.⤶⤶  # User presses enter on a stringMorph⤶  accept: ->⤶    world.stopEditing()⤶    @escalateEvent ＂accept＂, nil⤶  ⤶  # User presses ESC⤶  cancel: ->⤶    world.stopEditing()⤶    @escalateEvent 'cancel', nil⤶⤶  # User presses CTRL-Z or CMD-Z, potentially with shift⤶  undo: (shiftKey) ->⤶    if !@target.undoHistory?⤶      return⤶⤶    if !shiftKey⤶      if @target.undoHistory.length > 1⤶        @target.popUndoState()⤶        undoState = @target.undoHistory[@target.undoHistory.length - 1]⤶        @bringTextAndCaretToState undoState⤶    else⤶      redoState = @target.popRedoState()⤶      if redoState?⤶        @bringTextAndCaretToState redoState⤶⤶  bringTextAndCaretToState: (state) ->⤶    @target.setText state.textContent, nil, nil⤶    @gotoSlot state.cursorPos⤶    if state.selectionStart? and state.selectionEnd?⤶      @target.selectBetween state.selectionStart, state.selectionEnd⤶    else⤶      @target.clearSelection()⤶  ⤶  insert: (symbol, shiftKey) ->    ⤶    # if the target ＂isNumeric＂, then only accept⤶    # numbers and ＂-＂ and ＂.＂ as input⤶    if not @target.isNumeric or not isNaN(parseFloat(symbol)) or symbol in [＂-＂, ＂.＂]⤶      ⤶      # we push the state here before the change, then again⤶      # after the change. This seems redundant, however⤶      # it's needed because:⤶      #⤶      # 1) in case we are about to insert something that⤶      #    replaces a selection, then it's actually⤶      #    important to save the state before the selection⤶      #    is touched so that the user can go back to it⤶      # 2) in case of edit ＂far＂ from the previous edit,⤶      #    this is going to be very very useful because⤶      #    it's much *much* more natural⤶      #    for the user to undo up to the position BEFORE an⤶      #    edit. If you don't save that position before the⤶      #    edit, you jump directly to the end of the edit before,⤶      #    it's actually quite puzzling.⤶      #    It's nominally ＂functional＂ to only jump to text changes,⤶      #    but it's quite unnatural, it's not how undos work⤶      #    in real editors.⤶      # ⤶      # In the ＂normal＂ case of continuous typing this⤶      # would be indeed redundant, HOWEVER we avoid such⤶      # redundancy, because the sequences of:⤶      #⤶      #         position, text, position, text, ...⤶      #⤶      # actually are saved without the ＂position＂⤶      # changes (these is a check in ＂pushUndoState＂ that if there⤶      # is only a change position of one then that state is not⤶      # pushed)⤶⤶      @target.pushUndoState? @slot⤶⤶      if @target.selection() isnt ＂＂⤶        @gotoSlot @target.firstSelectedSlot()⤶        @target.deleteSelection()⤶      text = @target.text⤶      text = text.slice(0, @slot) + symbol + text.slice(@slot)⤶      # this is a setText that will trigger the text⤶      # connections ＂from within＂, starting a new connections⤶      # update round⤶      @target.setText text, nil, nil⤶      @goRight false, symbol.length⤶      @updateDimension()⤶      @target.pushUndoState? @slot⤶  ⤶  ctrl: (scanCodeOrCharCode, shiftKey) ->⤶    # ctrl-a apparently can come from either⤶    # keypress or keydown⤶    # 64 is for keydown⤶    # 97 is for keypress⤶    # in Chrome on OSX there is no keypress⤶    switch scanCodeOrCharCode⤶      when 97, 65⤶        @target.selectAll()⤶      # ctrl-z arrives both via keypress and⤶      # keydown but 90 here matches the keydown only⤶      when 90⤶        @undo shiftKey⤶      # unclear which keyboard needs ctrl⤶      # to be pressed to give a keypressed⤶      # event for {}[]@⤶      # but this is what this catches⤶      when 123⤶        @insert ＂{＂⤶      when 125⤶        @insert ＂}＂⤶      when 91⤶        @insert ＂[＂⤶      when 93⤶        @insert ＂]＂⤶      when 64⤶        @insert ＂@＂⤶  ⤶  # these two arrive only from⤶  # keypressed, at least in Chrome/OSX⤶  # 65 and 90 are both scan codes.⤶  cmd: (scanCode, shiftKey) ->⤶    # CMD-A⤶    switch scanCode⤶      when 65⤶        @target.selectAll()⤶      # CMD-Z⤶      when 90⤶        @undo shiftKey⤶  ⤶  deleteRight: ->⤶    if @target.selection() isnt ＂＂⤶      @gotoSlot @target.firstSelectedSlot()⤶      @target.deleteSelection()⤶    else⤶      text = @target.text⤶      text = text.slice(0, @slot) + text.slice(@slot + 1)⤶      @target.setText text, nil, nil⤶  ⤶  deleteLeft: ->⤶    if @target.selection()⤶      @gotoSlot @target.firstSelectedSlot()⤶      @target.deleteSelection()⤶    else⤶      text = @target.text⤶      @target.setText text.substring(0, @slot - 1) + text.substr(@slot), nil, nil⤶      @goLeft()⤶⤶    @updateSelection false⤶    @gotoSlot @slot⤶    @updateSelection false⤶    @clearSelectionIfStartAndEndMeet false⤶  ⤶  # CaretMorph utilities:⤶  inspectKeyEvent: (event) ->⤶    # private⤶    @inform ＂Key pressed: ＂ + String.fromCharCode(event.charCode) + ＂⧹n------------------------＂ + ＂⧹ncharCode: ＂ + event.charCode + ＂⧹nkeyCode: ＂ + event.keyCode + ＂⧹naltKey: ＂ + event.altKey + ＂⧹nctrlKey: ＂ + event.ctrlKey  + ＂⧹ncmdKey: ＂ + event.metaKey⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CircleBoxMorph_coffeSource = "# I can be used for sliders⤶⤶class CircleBoxMorph extends Widget⤶⤶⤶  constructor: ->⤶    super()⤶    @appearance = new CircleBoxyAppearance(@)⤶    @silentRawSetExtent new Point 20, 100⤶⤶  colloquialName: ->⤶    return ＂circle-box＂⤶  ⤶  autoOrientation: ->⤶    if @height() > @width()⤶      return ＂vertical＂⤶    else⤶      return ＂horizontal＂⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CircleBoxyAppearance_coffeSource = "class CircleBoxyAppearance extends Appearance⤶⤶  constructor: (morph) ->⤶    super morph⤶⤶  autoOrientation: ->⤶    if @morph.height() > @morph.width()⤶      return ＂vertical＂⤶    else⤶      return ＂horizontal＂⤶⤶⤶  calculateKeyPoints: ->⤶    orientation = @autoOrientation()⤶    if orientation is ＂vertical＂⤶      radius = @morph.width() / 2⤶      x = @morph.center().x⤶      center1 = new Point(x, @morph.top() + radius).round()⤶      center2 = new Point(x, @morph.bottom() - radius).round()⤶      rect = @morph.topLeft().add(⤶        new Point(0, radius)).corner(@morph.bottomRight().subtract(new Point(0, radius)))⤶    else⤶      radius = @morph.height() / 2⤶      y = @morph.center().y⤶      center1 = new Point(@morph.left() + radius, y).round()⤶      center2 = new Point(@morph.right() - radius, y).round()⤶      rect = @morph.topLeft().add(⤶        new Point(radius, 0)).corner(@morph.bottomRight().subtract(new Point(radius, 0)))⤶    return [radius,center1,center2,rect]⤶⤶  isTransparentAt: (aPoint) ->⤶    # first quickly check if the point is even⤶    # within the bounding box⤶    if !@morph.boundsContainPoint aPoint⤶      return true⤶⤶    [radius,center1,center2,rect] = @calculateKeyPoints()⤶⤶    if center1.distanceTo(aPoint) < radius or⤶    center2.distanceTo(aPoint) < radius or⤶    rect.containsPoint aPoint⤶      return false⤶⤶    return true⤶  ⤶  # This method only paints this very morph's ＂image＂,⤶  # it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which⤶  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if @morph.preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return nil⤶⤶    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    aContext.save()⤶⤶    # clip out the dirty rectangle as we are⤶    # going to paint the whole of the box⤶    aContext.clipToRectangle al,at,w,h⤶⤶    aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @morph.alpha⤶⤶    aContext.useLogicalPixelsUntilRestore()⤶    morphPosition = @morph.position()⤶    aContext.translate morphPosition.x, morphPosition.y⤶⤶    [radius,center1,center2,rect] = @calculateKeyPoints()⤶⤶    # the centers of two circles⤶    points = [center1.toLocalCoordinatesOf(@morph), center2.toLocalCoordinatesOf(@morph)]⤶⤶    color = @morph.color⤶⤶    if appliedShadow?⤶      aContext.fillStyle = ＂black＂⤶    else⤶      aContext.fillStyle = color.toString()⤶⤶    aContext.beginPath()⤶⤶    # the two circles (one at each end)⤶    aContext.arc points[0].x, points[0].y, radius, 0, 2 * Math.PI⤶    aContext.arc points[1].x, points[1].y, radius, 0, 2 * Math.PI⤶    # the rectangle⤶    rect = rect.floor()⤶    rect = rect.toLocalCoordinatesOf @morph⤶    aContext.moveTo rect.origin.x, rect.origin.y⤶    aContext.lineTo rect.origin.x + rect.width(), rect.origin.y⤶    aContext.lineTo rect.origin.x + rect.width(), rect.origin.y + rect.height()⤶    aContext.lineTo rect.origin.x, rect.origin.y + rect.height()⤶⤶    aContext.closePath()⤶    aContext.fill()⤶⤶    aContext.restore()⤶⤶    # paintHighlight is usually made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, so it's generally used⤶    # outside the effect of the scaling because⤶    # of the ceilPixelRatio (i.e. after the restore)⤶    @paintHighlight aContext, al, at, w, ⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ClippingBoxMorph_coffeSource = "# I can have an optionally rounded border⤶⤶class ClippingBoxMorph extends BoxMorph⤶⤶  @augmentWith ClippingAtRectangularBoundsMixin⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.PanelWdgt_coffeSource = "# I clip my submorphs at my bounds. Which potentially saves a lot of redrawing⤶# and event handling. ⤶# It's a good idea to use me whenever it's clear that there is a  ⤶# ＂container＂/＂contained＂ scenario going on.⤶⤶class PanelWdgt extends Widget⤶⤶  @augmentWith ClippingAtRectangularBoundsMixin, @name⤶⤶  scrollPanel: nil⤶  extraPadding: 0⤶  _acceptsDrops: true⤶  providesAmenitiesForEditing: true⤶⤶  # if this Panel belongs to a ScrollPanel, then⤶  # the @scrollPanel points to it⤶  constructor: (@scrollPanel = nil) ->⤶    super()⤶    @dragsDropsAndEditingEnabled = true⤶    @appearance = new RectangularAppearance @⤶⤶    @color = WorldMorph.preferencesAndSettings.defaultPanelsBackgroundColor⤶    @strokeColor = WorldMorph.preferencesAndSettings.defaultPanelsStrokeColor⤶⤶    if @scrollPanel⤶      @noticesTransparentClick = false⤶⤶  colloquialName: ->⤶    ＂panel＂⤶⤶  # only the desktop and folder panels have menu entries⤶  # to invoke this⤶  makeFolder: (ignored, ignored2, name) ->⤶    newFolderWindow = new FolderWindowWdgt⤶    newFolderWindow.close()⤶    newFolderWindow.createReference (name or world.getNextUntitledFolderShortcutName()), @⤶    world.howManyUntitledShortcuts++⤶    return newFolderWindow⤶⤶  setColor: (aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @connectionsCalculationToken = connectionsCalculationToken⤶⤶    aColor = super aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken, true⤶    # keep in synch the value of the container scrollPanel⤶    # if there is one. Note that the container scrollPanel⤶    # is actually not painted.⤶    if @scrollPanel⤶      # if the color is set using the color string literal⤶      # e.g. ＂red＂ then we can't check equality using .equals⤶      # so just skip the check and set the color⤶      # TODO either all colors should be set as Color instead⤶      # of strings, or this check should be smarter⤶      if @scrollPanel.color?.equals?⤶        if @scrollPanel.color.equals aColor⤶          return⤶      @scrollPanel.color = aColor⤶      @scrollPanel.changed()⤶⤶    return aColor⤶⤶⤶  setAlphaScaled: (alphaOrMorphGivingAlpha, morphGivingAlpha) ->⤶    alpha = super(alphaOrMorphGivingAlpha, morphGivingAlpha)⤶    if @scrollPanel⤶      unless @scrollPanel.alpha == alpha⤶        @scrollPanel.alpha = alpha⤶    return alpha⤶⤶⤶  mouseClickLeft: (pos, ignored_button, ignored_buttons, ignored_ctrlKey, shiftKey, ignored_altKey, ignored_metaKey) ->⤶    @bringToForeground()⤶⤶    # when you click on an ＂empty＂ part of a Panel that contains⤶    # a piece of text, we pass the click on to the text to it⤶    # puts the caret at the end of the text.⤶    # TODO the focusing and placing of the caret at the end of⤶    # the text should happen via API rather than via spoofing⤶    # a mouse event?⤶    if @parent? and @parent instanceof ScrollPanelWdgt⤶      childrenNotCarets = @children.filter (m) ->⤶        !(m instanceof CaretMorph)⤶      if childrenNotCarets.length == 1⤶        item = @firstChildSuchThat (m) ->⤶          ((m instanceof TextMorph) or⤶          (m instanceof SimplePlainTextWdgt)) and m.isEditable⤶        item?.mouseClickLeft item.bottomRight(), ignored_button, ignored_buttons, ignored_ctrlKey, shiftKey, ignored_altKey, ignored_metaKey⤶⤶⤶  reactToDropOf: ->⤶    if @parent?⤶      if @parent.adjustContentsBounds?⤶        @parent.adjustContentsBounds()⤶        @parent.adjustScrollBars?()⤶⤶  childRemoved: (child) ->⤶    if @parent?⤶      @parent.grandChildRemoved?()  ⤶      if @parent.adjustContentsBounds?⤶        @parent.adjustContentsBounds()⤶        @parent.adjustScrollBars?()  ⤶⤶  childAdded: (child) ->⤶    # the BasementWdgt has a filter that can⤶    # show/hide the contents of this pane⤶    # based on whether they are reachable or⤶    # not. So let's notify it.⤶    if @parent?⤶      @parent.grandChildAdded?()⤶      if @parent.parent?⤶        if @parent.parent.childAddedInScrollPanel?⤶          @parent.parent.childAddedInScrollPanel child⤶⤶  # puts the morph in the ScrollPanel⤶  # in some sparse manner and keeping it⤶  # ＂in view＂⤶  addInPseudoRandomPosition: (aWdgt) ->⤶    width = @width()⤶    height = @height()⤶⤶    posx = Math.abs(hashCode(aWdgt.toString())) % width⤶    posy = Math.abs(hashCode(aWdgt.toString() + ＂x＂)) % height⤶    position = @position().add new Point posx, posy⤶⤶    @add aWdgt⤶    aWdgt.fullRawMoveTo position⤶⤶    if @parent?⤶      if @parent.adjustContentsBounds?⤶        @parent.adjustContentsBounds()⤶        @parent.adjustScrollBars()⤶⤶⤶  detachesWhenDragged: ->⤶    if @parent?⤶⤶      # otherwise you could detach a Frame contained in a⤶      # ScrollPanelWdgt which is very strange⤶      if @parent instanceof ScrollPanelWdgt⤶        return false⤶⤶      return super⤶⤶  grabsToParentWhenDragged: ->⤶    if @parent?⤶⤶      # otherwise you could detach a Frame contained in a⤶      # ScrollPanelWdgt which is very strange⤶      if @parent instanceof ScrollPanelWdgt⤶        if @parent.canScrollByDraggingBackground and @parent.anyScrollBarShowing()⤶          return false⤶        else⤶          return true⤶⤶      return super⤶⤶    # doesn't have a parent⤶    return false⤶  ⤶  reactToGrabOf: ->⤶    if @parent?⤶      if @parent.adjustContentsBounds?⤶        @parent.adjustContentsBounds()⤶        @parent.adjustScrollBars?()⤶⤶  # PanelWdgt menus:⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    if @children.length⤶      menu.addLine()⤶      menu.addMenuItem ＂move all inside＂, true, @, ＂keepAllSubmorphsWithin＂, ＂keep all submorphs⧹nwithin and visible＂⤶  ⤶  keepAllSubmorphsWithin: ->⤶    @children.forEach (m) =>⤶      m.fullRawMoveWithin @⤶⤶  editButtonPressedFromWindowBar: ->⤶    if @dragsDropsAndEditingEnabled⤶      @disableDragsDropsAndEditing @⤶    else⤶      @enableDragsDropsAndEditing @⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.RectangleMorph_coffeSource = "# a plain rectangular Widget. Because it's so basic, it's the building⤶# block of many more complex constructions, for example containers⤶# , clipping windows, and clipping windows which allow content to be⤶# scrolled (clipping is particularly easy to do along a rectangular⤶# path and it allows many optimisations and it's a very common case)⤶# It's important that the basic unadulterated version of⤶# rectangle doesn't draw a border, to keep this basic⤶# and versatile, so for example there is no case where the children⤶# are painted over the border, which would look bad.⤶⤶⤶class RectangleMorph extends Widget⤶⤶  constructor: (extent, color) ->⤶    super()⤶    @appearance = new RectangularAppearance @⤶    @silentRawSetExtent(extent) if extent?⤶    @color = color if color?⤶    @toolTipMessage = ＂rectangle＂⤶⤶  colloquialName: ->⤶    ＂rectangle＂⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.RectangularAppearance_coffeSource = "class RectangularAppearance extends Appearance⤶⤶  isTransparentAt: (aPoint) ->⤶    if @morph.boundingBoxTight().containsPoint aPoint⤶      return false⤶    if @morph.backgroundTransparency? and @morph.backgroundColor?⤶      if @morph.backgroundTransparency > 0⤶        if @morph.boundsContainPoint aPoint⤶          return false⤶    return true⤶⤶  # paintHighlight can work in two patterns:⤶  #  * passing actual pixels, when used⤶  #    outside the effect of the scope of⤶  #    ＂useLogicalPixelsUntilRestore()＂, or⤶  #  * passing logical pixels, when used⤶  #    inside the effect of the scope of⤶  #    ＂useLogicalPixelsUntilRestore()＂, or⤶  # Mostly, the first pattern is used.⤶  #⤶  # useful for example when hovering over references⤶  # to morphs. Can only modify the rendering of a morph,⤶  # so any highlighting is only visible in the measure that⤶  # the morph is visible (as opposed to HighlighterMorph being⤶  # used to highlight a morph)⤶  paintHighlight: (aContext, al, at, w, h) ->⤶    return⤶    ⤶    #if !@morph.highlighted⤶    #  return⤶    #⤶    # paintRectangle here is usually made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels.⤶    #@morph.paintRectangle ⧹⤶    #  aContext,⤶    #  al, at, w, h,⤶    #  ＂orange＂,⤶    #  0.5,⤶    #  true # push and pop the context⤶⤶⤶  # This method only paints this very morph⤶  # i.e. it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer,⤶  # which eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if @morph.preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return nil⤶⤶    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    @morph.justBeforeBeingPainted?()⤶⤶    aContext.save()⤶    aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @morph.alpha⤶    if !@morph.color? then debugger⤶    aContext.fillStyle = @morph.color.toString()⤶⤶    # paintRectangle is usually made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, so it's generally used⤶    # outside the effect of the scaling because⤶    # of the ceilPixelRatio⤶⤶    # paint the background⤶    toBePainted = new Rectangle al, at, al + w, at + h⤶⤶    if @morph.backgroundColor?⤶      color = @morph.backgroundColor⤶      if appliedShadow?⤶        color = ＂black＂⤶      @morph.paintRectangle aContext, toBePainted.left(), toBePainted.top(), toBePainted.width(), toBePainted.height(), color⤶⤶⤶    # now paint the actual morph, which is a rectangle⤶    # (potentially inset because of the padding)⤶    toBePainted = toBePainted.intersect @morph.boundingBoxTight().scaleBy ceilPixelRatio⤶⤶    color = @morph.color⤶    if appliedShadow?⤶      color = ＂black＂⤶⤶    @morph.paintRectangle aContext, toBePainted.left(), toBePainted.top(), toBePainted.width(), toBePainted.height(), color⤶⤶    @drawAdditionalPartsOnBaseShape? false, false, appliedShadow, aContext, al, at, w, h⤶⤶    if !appliedShadow?⤶      @paintStroke aContext, clippingRectangle⤶⤶    aContext.restore()⤶⤶    # paintHighlight is usually made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, so it's generally used⤶    # outside the effect of the scaling because⤶    # of the ceilPixelRatio⤶    @paintHighlight aContext, al, at, w, h⤶⤶  paintStroke: (aContext, clippingRectangle) ->⤶⤶    if @morph.preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return nil⤶⤶    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    @morph.justBeforeBeingPainted?()⤶⤶    aContext.save()⤶⤶    toBePainted = new Rectangle al, at, al + w, at + h⤶    toBePainted = toBePainted.intersect @morph.boundingBoxTight().scaleBy ceilPixelRatio⤶⤶    if @morph.strokeColor?⤶⤶      aContext.beginPath()⤶      aContext.rect Math.round(toBePainted.left()),⤶        Math.round(toBePainted.top()),⤶        Math.round(toBePainted.width()),⤶        Math.round(toBePainted.height())⤶      aContext.clip()⤶⤶      aContext.globalAlpha = @morph.alpha⤶      aContext.lineWidth = 1 # TODO might look better if * ceilPixelRatio⤶      aContext.strokeStyle = @morph.strokeColor.toString()⤶      # half-pixel adjustments are needed in HTML5 Canvas to draw⤶      # pixel-perfect lines. Also note how we have to multiply the⤶      # morph metrics to bring them to physical pixels coords.⤶      aContext.strokeRect  (Math.round(@morph.left() * ceilPixelRatio)+0.5),⤶          (Math.round(@morph.top() * ceilPixelRatio)+0.5),⤶          (Math.round(@morph.width() * ceilPixelRatio)-1),⤶          (Math.round(@morph.height() * ceilPixelRatio)-1)⤶⤶    aContext.restore()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ScrollPanelWdgt_coffeSource = "class ScrollPanelWdgt extends PanelWdgt⤶⤶  autoScrollTrigger: nil⤶  hasVelocity: true # dto.⤶  padding: 0 # around the scrollable area⤶  growth: 0 # pixels or Point to grow right/left when near edge⤶  isTextLineWrapping: false⤶  isScrollingByfloatDragging: true⤶  scrollBarsThickness: nil⤶  contents: nil⤶  vBar: nil⤶  hBar: nil⤶  # used to avoid recursively re-entering the⤶  # adjustContentsBounds function⤶  _adjustingContentsBounds: false⤶⤶  # there are several ways in which we allow⤶  # scrolling when a ScrollPanel is scrollable⤶  # (i.e. the scrollbars are showing).⤶  # You can choose to scroll it by dragging the⤶  # contents or by dragging the background,⤶  # independently. Which could be useful for⤶  # example when showing a geographic map.⤶  canScrollByDraggingBackground: false⤶  canScrollByDraggingForeground: false⤶⤶  constructor: (⤶    @contents,⤶    @scrollBarsThickness = (WorldMorph.preferencesAndSettings.scrollBarsThickness),⤶    @sliderColor⤶    ) ->⤶    # super() paints the ScrollPanel, which we don't want,⤶    # so we set 0 opacity here.⤶    @alpha = 0⤶    super()⤶⤶    @contents = new PanelWdgt @ unless @contents?⤶    @addRaw @contents⤶⤶    # the ScrollPanel is never going to paint itself,⤶    # but its values are going to mimick the values of the⤶    # contained Panel⤶    @color = @contents.color⤶    @alpha = @contents.alpha⤶    ⤶    #@setColor = @contents.setColor⤶    #@setAlphaScaled = @contents.setAlphaScaled⤶⤶    @hBar = new SliderMorph nil, nil, nil, nil, @sliderColor⤶    @hBar.rawSetHeight @scrollBarsThickness⤶⤶    @hBar.target = @⤶    @addRaw @hBar⤶⤶    @vBar = new SliderMorph nil, nil, nil, nil, @sliderColor⤶    @vBar.rawSetWidth @scrollBarsThickness⤶    @vBar.target = @⤶    @addRaw @vBar⤶⤶    @hBar.target = @⤶    @hBar.action = ＂adjustContentsBasedOnHBar＂⤶    @vBar.target = @⤶    @vBar.action = ＂adjustContentsBasedOnVBar＂⤶⤶    @adjustScrollBars()⤶⤶  wantsDropOf: (aWdgt) ->⤶    if @contents instanceof FolderPanelWdgt⤶      return false⤶    return @_acceptsDrops⤶⤶  colloquialName: ->⤶    if @contents instanceof FolderPanelWdgt⤶      ＂folder＂⤶    else if @contents instanceof ToolPanelWdgt⤶      ＂toolbar＂⤶    else⤶      ＂scrollable panel＂⤶⤶  adjustContentsBasedOnHBar: (num) ->⤶    @contents.fullRawMoveTo new Point @left() - num, @contents.position().y⤶    @adjustContentsBounds()⤶    @adjustScrollBars()⤶⤶  adjustContentsBasedOnVBar: (num) ->⤶    @contents.fullRawMoveTo new Point @contents.position().x, @top() - num⤶    @adjustContentsBounds()⤶    @adjustScrollBars()⤶⤶  setColor: (aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @connectionsCalculationToken = connectionsCalculationToken⤶⤶    aColor = super aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken, true⤶    # keep in synch the color of the content.⤶    # Note that the container ScrollPanel.⤶    # is actually not painted.⤶    @contents.setColor aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken⤶    return aColor⤶⤶  setAlphaScaled: (alphaOrMorphGivingAlpha, morphGivingAlpha) ->⤶    alpha = super⤶    # update the alpha of the ScrollPanel - note⤶    # that we are never going to paint the ScrollPanel⤶    # we are updating the alpha so that its value is the same as the⤶    # contained Panel⤶    @contents.setAlphaScaled alphaOrMorphGivingAlpha, morphGivingAlpha⤶    return alpha⤶⤶  anyScrollBarShowing: ->⤶    if (@hBar.visibleBasedOnIsVisibleProperty() and !@hBar.isCollapsed()) or⤶    (@vBar.visibleBasedOnIsVisibleProperty() and !@vBar.isCollapsed())⤶      return true⤶    return false⤶⤶  adjustScrollBars: ->⤶    # one typically has both scrollbars in view, plus a resizer⤶    # in buttom right corner, so adjust the width/height of the⤶    # scrollbars so that there is no overlap between the three things⤶    spaceToLeaveOnOneSide = Math.max(@scrollBarsThickness, WorldMorph.preferencesAndSettings.handleSize) + 2 * @padding⤶    hWidth = @width() - spaceToLeaveOnOneSide⤶    vHeight = @height() - spaceToLeaveOnOneSide⤶⤶    unless @parent instanceof ListMorph⤶      @changed()⤶⤶    # this check is to see whether the bar actually belongs to this⤶    # ScrollPanel. The reason why the bar could belong to another⤶    # ScrollPanel is the following: the bar could have been detached⤶    # from a ScrollPanel A. The ScrollPanel A (which is still fully⤶    # working albeit detached) is then duplicated into⤶    # a ScrollPanel B. What happens is that because the bar is not⤶    # a child of A (rather, it's only referenced as a property),⤶    # the duplication mechanism does not duplicate the bar and it does⤶    # not update the reference to it. This is correct because one cannot⤶    # just change all the references to other objects that are not children⤶    # , a good example being the targets, i.e. if you duplicate a colorPicker⤶    # which targets a Widget you want the duplication of the colorPicker to⤶    # still change color of that same Widget.⤶    # So: the ScrollPanel B could still reference the scrollbar⤶    # detached from A and that causes a problem because changes to B would⤶    # change the dimensions and hiding/unhiding of the scrollbar.⤶    # So here we avoid that by actually checking what the scrollbar is⤶    # attached to.⤶    if @hBar.target == @ ⤶      if @contents.width() >= @width() + 1⤶        @hBar.show()⤶        @hBar.rawSetWidth hWidth  if @hBar.width() isnt hWidth⤶        # we check whether the bar has been detached. If it's still⤶        # attached then we possibly move it, together with the⤶        # ScrollPanel, otherwise we don't move it.⤶        if @hBar.parent == @⤶          @hBar.fullRawMoveTo new Point @left(), @bottom() - @hBar.height()⤶        stopValue = @contents.width() - @width()⤶        @hBar.updateSpecs(⤶          0, # start⤶          stopValue, # stop⤶          @left() - @contents.left(), # value⤶          @width() / @contents.width() * stopValue # size⤶        )⤶      else⤶        @hBar.hide()⤶⤶    # see comment on equivalent if line above.⤶    if @vBar.target == @⤶      if @contents.height() >= @height() + 1⤶        @vBar.show()⤶        @vBar.rawSetHeight vHeight  if @vBar.height() isnt vHeight⤶        # we check whether the bar has been detached. If it's still⤶        # attached then we possibly move it, together with the⤶        # ScrollPanel, otherwise we don't move it.⤶        if @vBar.parent == @⤶          @vBar.fullRawMoveTo new Point @right() - @vBar.width(), @top()⤶        stopValue = @contents.height() - @height()⤶        @vBar.updateSpecs(⤶          0, # start⤶          stopValue, # stop⤶          @top() - @contents.top(), # value⤶          @height() / @contents.height() * stopValue # size⤶        )⤶      else⤶        @vBar.hide()⤶  ⤶  # when you add things to the ScrollPanelWdgt they actually⤶  # end up in the Panel inside it. This also applies to⤶  # resizing handles!⤶  add: (aWdgt, position = nil, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING, beingDropped, unused, positionOnScreen) ->⤶    if aWdgt instanceof ModifiedTextTriangleAnnotationWdgt⤶      super⤶    else⤶      @contents.add aWdgt, position, layoutSpec, beingDropped, nil, positionOnScreen⤶      @adjustContentsBounds()⤶      @adjustScrollBars()⤶⤶  # see SimpleSlideWdgt for performance improvements⤶  # of this over the non-⤶  addMany: (widgetsToBeAdded) ->⤶    @contents.addMany widgetsToBeAdded⤶    @adjustContentsBounds()⤶    @adjustScrollBars()⤶⤶⤶  showResizeAndMoveHandlesAndLayoutAdjusters: ->⤶    super⤶    @adjustContentsBounds()⤶    @adjustScrollBars()⤶⤶  ⤶  setContents: (aWdgt, extraPadding) ->⤶    @extraPadding = extraPadding⤶    # there should never be a shadow but one never knows...⤶    @contents.closeChildren()⤶    @contents.fullRawMoveTo @position()⤶⤶    aWdgt.fullRawMoveTo @position().add @padding + @extraPadding⤶⤶    @add aWdgt⤶⤶⤶  rawSetExtent: (aPoint) ->⤶    unless aPoint.equals @extent()⤶      #console.log ＂move 15＂⤶      @breakNumberOfRawMovesAndResizesCaches()⤶      if @isTextLineWrapping and !(@contents instanceof SimpleVerticalStackPanelWdgt)⤶        @contents.fullRawMoveTo @position()⤶      super aPoint⤶      @contents.rawSetExtent aPoint⤶      @adjustContentsBounds()⤶      @adjustScrollBars()⤶⤶⤶  reactToDropOf: ->⤶    @adjustContentsBounds()⤶    @adjustScrollBars()⤶  ⤶  reactToGrabOf: ->⤶    @adjustContentsBounds()⤶    @adjustScrollBars()⤶⤶  adjustContentsBounds: ->⤶    # avoid recursively re-entering this function⤶    if @_adjustingContentsBounds then return else @_adjustingContentsBounds = true⤶⤶    # if PanelWdgt is of type isTextLineWrapping⤶    # it means that you don't want the TextMorph to⤶    # extend indefinitely as you are typing. Rather,⤶    # the width will be constrained and the text will⤶    # wrap.⤶    padding = Math.floor @extraPadding + @padding⤶    totalPadding = 2*padding⤶⤶    if @contents instanceof SimpleVerticalStackPanelWdgt⤶      @contents.adjustContentsBounds()⤶    else if @isTextLineWrapping and @contents instanceof PanelWdgt⤶      @contents.children.forEach (morph) =>⤶        if (morph instanceof TextMorph) or (morph instanceof SimplePlainTextWdgt)⤶          # this re-layouts the text to fit the width.⤶          # The new height of the TextMorph will then be used⤶          # to redraw the vertical slider.⤶          morph.rawSetWidth @contents.width() - totalPadding⤶          # the SimplePlainTextWdgt just needs this to be different from null⤶          # while the TextMorph actually uses this number⤶          morph.maxTextWidth = @contents.width() - totalPadding⤶          @contents.rawSetHeight (Math.max morph.height(), @height()) - totalPadding⤶⤶    subBounds = @contents.subMorphsMergedFullBounds()?.ceil()⤶    if subBounds⤶⤶      # add-in the content's own external padding⤶      if @contents.externalPadding?⤶        subBounds = subBounds.expandBy @contents.externalPadding⤶⤶      # in case of a SimpleVerticalStackScrollPanelWdgt then we really⤶      # want to make sure that we don't stretch the view and the stack⤶      # after the end of the contents (this can happen for example⤶      # when you are completely scrolled to the bottom and remove a long⤶      # chunk of text at the bottom: you don't want the extra vacant space⤶      # to be in view, you want to shrink all that part up and reposition the⤶      # stack so you actually see a bottom that has something in it)⤶      # So we first size the stack according to the minimum area of the⤶      # components in it, then we add the minimum space needed to fill⤶      # the viewport, so we never end up with empty space filling the stack⤶      # beyond the height of the viewport.⤶      if @isTextLineWrapping or⤶       (@ instanceof SimplePlainTextScrollPanelWdgt) or⤶       (@ instanceof SimpleVerticalStackScrollPanelWdgt)⤶        newBounds = subBounds.expandBy(padding).ceil()⤶⤶        # ok so this is tricky: say that you have a document with⤶        # ONLY a centered icon in it.⤶        # If you don't add this line, the subBounds will start at the⤶        # origin of the icon, which is NOT aligned to the left of the⤶        # viewport. So what will happen is that the panel will be moved⤶        # so its left will coincide with the left of the viewport.⤶        # So the icon will appear non-centered.⤶        newBounds = newBounds.merge new Rectangle @contents.left(), @contents.top(), @contents.left() + @width(), @contents.top() + 1⤶⤶        if newBounds.height() < @height()⤶          newBounds = newBounds.growBy new Point 0, @height() - newBounds.height()⤶        # I don't think this check below is needed anymore,⤶        # TODO verify when there are a healthy number of tests around⤶        # vertical stack and text scroll panels⤶        if newBounds.width() < @width()⤶          newBounds = newBounds.growBy new Point @width() - newBounds.width(), 0⤶      else⤶        newBounds = subBounds.expandBy(padding).merge @boundingBox()?.ceil()⤶    else⤶      newBounds = @boundingBox()?.ceil()⤶⤶    unless @contents.boundingBox().equals newBounds⤶      @contents.silentRawSetBounds newBounds⤶      @contents.reLayout()⤶    ⤶    # you'd think that if @contents.boundingBox().equals newBounds⤶    # then we don't need to check if the contents are ＂in good view＂⤶    # but actually for example a stack resizes itself automatically when the⤶    # elements are resized (in the foreach loop above),⤶    # so we need anyways to do this check and fix the view if the⤶    # case. The good news is that it's a cheap check to do in case⤶    # there is nothing to do.⤶    @keepContentsInScrollPanelWdgt()⤶    @_adjustingContentsBounds = false⤶⤶  keepContentsInScrollPanelWdgt: ->⤶    if @contents.left() > @left()⤶      @contents.fullRawMoveBy new Point @left() - @contents.left(), 0⤶    if @contents.right() < @right()⤶      @contents.fullRawMoveBy new Point @right() - @contents.right(), 0⤶    if @contents.top() > @top()⤶      @contents.fullRawMoveBy new Point 0, @top() - @contents.top()⤶    if @contents.bottom() < @bottom()⤶      @contents.fullRawMoveBy new Point 0, @bottom() - @contents.bottom()⤶  ⤶  # ScrollPanelWdgt scrolling by floatDragging:⤶  scrollX: (steps) ->⤶    cl = @contents.left()⤶    l = @left()⤶    cw = @contents.width()⤶    r = @right()⤶    newX = cl + steps⤶    newX = r - cw  if newX + cw < r⤶    newX = l  if newX > l⤶    # return true if any movement of⤶    # the scrollbar button is⤶    # actually happening, otherwise⤶    # false. We use this to figure⤶    # out in some places whether⤶    # we need to trigger a bunch of⤶    # updates of the content and scrollbars⤶    # or not.⤶    if newX isnt cl⤶      @contents.fullRawMoveLeftSideTo newX⤶      return true⤶    else⤶      return false⤶⤶  scrollTo: (whereTo) ->⤶    @contents.fullRawMoveLeftSideTo -whereTo.x⤶    @contents.fullRawMoveTopSideTo -whereTo.y⤶    @adjustScrollBars()    ⤶⤶⤶  scrollToBottom: ->⤶    @scrollY -100000⤶    @adjustScrollBars()    ⤶  ⤶  scrollY: (steps) ->⤶    ct = @contents.top()⤶    t = @top()⤶    ch = @contents.height()⤶    b = @bottom()⤶    newY = ct + steps⤶    if newY + ch < b⤶      newY = b - ch⤶    # prevents content to be scrolled to the Panel's⤶    # bottom if the content is otherwise empty⤶    newY = t  if newY > t⤶    # return true if any movement of⤶    # the scrollbar button is⤶    # actually happening, otherwise⤶    # false. We use this to figure⤶    # out in some places whether⤶    # we need to trigger a bunch of⤶    # updates of the content and scrollbars⤶    # or not.⤶    if newY isnt ct⤶      @contents.fullRawMoveTopSideTo newY⤶      return true⤶    else⤶      return false⤶  ⤶  # sometimes you can scroll the contents of a ScrollPanel⤶  # by floatDragging its contents. This is particularly⤶  # useful in touch devices.⤶  # You can test this also in non-touch mode⤶  # by anchoring a ScrollPanel to something⤶  # non-draggable such as a color palette (can't drag it⤶  # because user can drag on it to pick a color)⤶  # Ten you chuck a long text into the ScrollPanel and⤶  # drag the Panel (on the side of the text, where there is no⤶  # text) and you should see the ScrollPanel scrolling.⤶  mouseDownLeft: (pos) ->⤶⤶    return nil  unless @isScrollingByfloatDragging⤶⤶    oldPos = pos⤶    deltaX = 0⤶    deltaY = 0⤶    friction = 0.8⤶    world.steppingWdgts.add @⤶    @step = =>⤶      scrollbarJustChanged = false⤶      if world.hand.mouseButton and⤶        !world.hand.isThisPointerFloatDraggingSomething() and⤶        # if the Widget at hand is float draggable then⤶        # we are probably about to detach it, so⤶        # we shouldn't move anything, because user might⤶        # just float-drag the morph as soon as the threshold is⤶        # reached, and we don't want to scroll until that happens⤶        # that would be strange because it would be giving the⤶        # wrong cue to the user, we just want to hold steady⤶        !world.hand.wdgtToGrab?.detachesWhenDragged() and⤶        @boundsContainPoint(world.hand.position())⤶          newPos = world.hand.position()⤶          if @hBar.visibleBasedOnIsVisibleProperty() and⤶          !@hBar.isCollapsed()⤶            deltaX = newPos.x - oldPos.x⤶            if deltaX isnt 0⤶              scrollbarJustChanged ||= @scrollX deltaX⤶          if @vBar.visibleBasedOnIsVisibleProperty() and⤶          !@vBar.isCollapsed()⤶            deltaY = newPos.y - oldPos.y⤶            if deltaY isnt 0⤶              scrollbarJustChanged ||= @scrollY deltaY⤶          oldPos = newPos⤶      else⤶        unless @hasVelocity⤶          @step = noOperation⤶          world.steppingWdgts.delete @⤶        else⤶          if (Math.abs(deltaX) < 0.5) and (Math.abs(deltaY) < 0.5)⤶            @step = noOperation⤶            world.steppingWdgts.delete @⤶          else⤶            if @hBar.visibleBasedOnIsVisibleProperty() and⤶            !@hBar.isCollapsed()⤶              deltaX = deltaX * friction⤶              if deltaX isnt 0⤶                scrollbarJustChanged ||= @scrollX Math.round deltaX⤶            if @vBar.visibleBasedOnIsVisibleProperty() and⤶            !@vBar.isCollapsed()⤶              deltaY = deltaY * friction⤶              if deltaY isnt 0⤶                scrollbarJustChanged ||= @scrollY Math.round deltaY⤶      if scrollbarJustChanged⤶        @adjustContentsBounds()⤶        @adjustScrollBars()⤶    super⤶  ⤶  startAutoScrolling: ->⤶    inset = WorldMorph.preferencesAndSettings.scrollBarsThickness * 3⤶    if @isOrphan() then return nil⤶    hand = world.hand⤶    @autoScrollTrigger = Date.now()  unless @autoScrollTrigger⤶    world.steppingWdgts.add @⤶    @step = =>⤶      pos = hand.position()⤶      inner = @boundingBox().insetBy inset⤶      if @boundsContainPoint(pos) and⤶        !inner.containsPoint(pos) and⤶        hand.isThisPointerFloatDraggingSomething()⤶          @autoScroll pos⤶      else⤶        @step = noOperation⤶        world.steppingWdgts.delete @⤶        @autoScrollTrigger = nil⤶  ⤶  autoScroll: (pos) ->⤶    return nil  if Date.now() - @autoScrollTrigger < 500⤶    inset = WorldMorph.preferencesAndSettings.scrollBarsThickness * 3⤶    area = @topLeft().extent new Point @width(), inset⤶    scrollbarJustChanged = false⤶    if area.containsPoint(pos)⤶      scrollbarJustChanged ||= @scrollY inset - (pos.y - @top())⤶    area = @topLeft().extent new Point inset, @height()⤶    if area.containsPoint(pos)⤶      scrollbarJustChanged ||= @scrollX inset - (pos.x - @left())⤶    area = (new Point(@right() - inset, @top())).extent new Point inset, @height()⤶    if area.containsPoint(pos)⤶      scrollbarJustChanged ||= @scrollX -(inset - (@right() - pos.x))⤶    area = (new Point(@left(), @bottom() - inset)).extent new Point @width(), inset⤶    if area.containsPoint(pos)⤶      scrollbarJustChanged ||= @scrollY -(inset - (@bottom() - pos.y))⤶    if scrollbarJustChanged⤶      @adjustContentsBounds()⤶      @adjustScrollBars()  ⤶  ⤶  # ScrollPanelWdgt scrolling when editing text⤶  # so to bring the caret fully into view.⤶  scrollCaretIntoView: (caretMorph) ->⤶    txt = caretMorph.target⤶    ft = @top() + @padding⤶    fb = @bottom() - @padding⤶    fl = @left() + @padding⤶    fr = @right() - @padding⤶    @adjustContentsBounds()⤶    marginAroundCaret = @padding⤶    if @extraPadding?⤶      marginAroundCaret += @extraPadding⤶    if caretMorph.top() < ft⤶      newT = @contents.top() + ft - caretMorph.top()⤶      @contents.fullRawMoveTopSideTo newT + marginAroundCaret⤶      caretMorph.fullRawMoveTopSideTo ft⤶    else if caretMorph.bottom() > fb⤶      newB = @contents.bottom() + fb - caretMorph.bottom()⤶      @contents.fullRawMoveBottomSideTo newB - marginAroundCaret⤶      caretMorph.fullRawMoveBottomSideTo fb⤶    if caretMorph.left() < fl⤶      newL = @contents.left() + fl - caretMorph.left()⤶      @contents.fullRawMoveLeftSideTo newL + marginAroundCaret⤶      caretMorph.fullRawMoveLeftSideTo fl⤶    else if caretMorph.right() > fr⤶      newR = @contents.right() + fr - caretMorph.right()⤶      @contents.fullRawMoveRightSideTo newR - marginAroundCaret⤶      caretMorph.fullRawMoveRightSideTo fr⤶    @adjustContentsBounds()⤶    @adjustScrollBars()⤶⤶  # ScrollPanelWdgt events.⤶  wheel: (xArg, yArg, zArg, altKeyArg, buttonArg, buttonsArg) ->⤶⤶    x = xArg⤶    y = yArg⤶    z = zArg⤶⤶    # if we don't destroy the resizing handles,⤶    # they'll follow the contents being moved!⤶    world.hand.destroyTemporaryHandlesAndLayoutAdjustersIfHandHasNotActionedThem @⤶⤶    scrollbarJustChanged = false⤶⤶    # this paragraph prevents too much⤶    # diagonal movement when the intention⤶    # is clearly to just move vertically or⤶    # horizontally. Doesn't need to be always⤶    # the case though.⤶    if Math.abs(y) < Math.abs(x)⤶      y = 0⤶    if Math.abs(x) < Math.abs(y)⤶      x = 0⤶⤶    if WorldMorph.preferencesAndSettings.invertWheelX⤶      x *= -1⤶    if WorldMorph.preferencesAndSettings.invertWheelY⤶      y *= -1⤶    # unused⤶    if WorldMorph.preferencesAndSettings.invertWheelZ⤶      z *= -1⤶⤶    if y != 0⤶      # TODO this escalation should also⤶      # be implemented in the touch case... user could scroll⤶      # WITHOUT wheel, by just touch-dragging the contents...⤶      #⤶      # Escalate the scroll in case we are in a nested⤶      # ScrollPanel situation and we already⤶      # scrolled this inner one ＂up/down to the end＂.⤶      # In such case, the outer one has to scroll...⤶      #⤶      # if scrolling up and the content top is already below the top (or just a little above the top)⤶      #  OR⤶      # if scrolling down and the content bottom is already above the bottom (or just a little below the bottom)⤶      #  THEN⤶      # escalate the method up, since there might be another scrollbar catching it⤶      #⤶      # The ＂just a little＂ caveats are because sometimes dimensions are non-integer⤶      # (TODO ...which shouldn't really happen)⤶      #⤶      if (y > 0 and @contents.top() >= (@top() - 1)) or⤶       (y < 0 and @contents.bottom() <= (@bottom() + 1))⤶        @escalateEvent 'wheel', xArg, yArg, zArg, altKeyArg, buttonArg, buttonsArg⤶      else⤶        scrollbarJustChanged = true⤶        @scrollY y * WorldMorph.preferencesAndSettings.wheelScaleY⤶    if x != 0⤶      # similar to the vertical case, escalate the scroll in case⤶      # we are in a nested ScrollPanel situation⤶      if (x > 0 and @contents.left() >= (@left()-1)) or⤶       (x < 0 and @contents.right() <= (@right()+1) )⤶        @escalateEvent 'wheel', xArg, yArg, zArg, altKeyArg, buttonArg, buttonsArg⤶      else⤶        scrollbarJustChanged = true⤶        @scrollX x * WorldMorph.preferencesAndSettings.wheelScaleX⤶⤶    if scrollbarJustChanged⤶      @adjustContentsBounds()⤶      @adjustScrollBars()⤶  ⤶⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    if @takesOverAndCoalescesChildrensMenus⤶      if @contents⤶        childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets @contents⤶      if childrenNotHandlesNorCarets? and childrenNotHandlesNorCarets.length == 1⤶        childrenNotHandlesNorCarets[0].addMorphSpecificMenuEntries morphOpeningThePopUp, menu⤶    else⤶      super⤶  ⤶⤶⤶  enableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if @dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilYellow?()⤶⤶    @enableDrops()⤶    @dragsDropsAndEditingEnabled = true⤶⤶    @contents.enableDragsDropsAndEditing @⤶⤶  disableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if !@dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilClear?()⤶⤶    @disableDrops()⤶    @dragsDropsAndEditingEnabled = false⤶⤶    @contents.disableDragsDropsAndEditing @⤶    @invalidateLayout()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");