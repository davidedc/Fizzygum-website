

window.ActivePointerWdgt_coffeSource = "# The mouse cursor. Note that it's not a child of the WorldMorph, this widget⤶# is never added to any other widget. [TODO] Find out why and write explanation.⤶# Not to be confused with the HandleMorph⤶⤶class ActivePointerWdgt extends Widget⤶⤶  mouseButton: nil⤶  # used for example to check that⤶  # mouseDown and mouseUp happen on the⤶  # same Widget (otherwise clicks happen for⤶  # example when resizing a button via the⤶  # handle)⤶  mouseDownWdgt: nil⤶  mouseDownPosition: nil⤶  wdgtToGrab: nil⤶  grabOrigin: nil⤶  mouseOverList: nil⤶  doubleClickWdgt: nil⤶  tripleClickWdgt: nil⤶  nonFloatDraggedWdgt: nil⤶  nonFloatDragPositionWithinWdgtAtStart: nil⤶  # this is useful during nonFloatDrags to pass the widget⤶  # the delta position since the last invokation⤶  previousNonFloatDraggingPos: nil⤶⤶  constructor: ->⤶    @mouseOverList = new Set⤶    super()⤶    @minimumExtent = new Point 0,0⤶    @silentRawSetBounds Rectangle.EMPTY⤶⤶  clippedThroughBounds: ->⤶    @checkClippedThroughBoundsCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶    @clippedThroughBoundsCache = @boundingBox()⤶    return @clippedThroughBoundsCache⤶⤶  clipThrough: ->⤶    @checkClipThroughCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶    @clipThroughCache = @boundingBox()⤶    return @clipThroughCache⤶  ⤶  # ActivePointerWdgt navigation:⤶  topWdgtUnderPointer: ->⤶    result = world.topWdgtSuchThat (m) =>⤶      m.clippedThroughBounds().containsPoint(@position()) and⤶        m.visibleBasedOnIsVisibleProperty() and⤶        !m.isCollapsed() and⤶        (m.noticesTransparentClick or (not m.isTransparentAt(@position()))) and⤶        # we exclude the Caret here because⤶        #  a) it messes up things on double-click as it appears under⤶        #     the mouse after the first clicks⤶        #  b) the caret disappears as soon as a menu appears, so it⤶        #     would be confusing to select a caret.⤶        # I drafted an alternative implementation where we manage⤶        # those situations without being radical in this filtering-out⤶        # but it was quite a bit more complicated.⤶        (m not instanceof CaretMorph) and⤶        # exclude widgets we use for highlighting⤶        # other widgets⤶        !m.wdgtThisWdgtIsHighlighting? and⤶        !m.wdgtThisWdgtIsPinouting?⤶    if result?⤶      return result⤶    else⤶      return world⤶⤶⤶⤶⤶⤶  openContextMenuAtPointer: (wdgtTheMenuIsAbout) ->⤶    # note that the widgets that the menu⤶    # belongs to might not be under the mouse.⤶    # It usually is, but in cases⤶    # where a system test is playing against⤶    # a world setup that has varied since the⤶    # recording, this could be the case.⤶⤶    # these three are checks and actions that normally⤶    # would happen on MouseDown event, but we⤶    # removed that event as we collapsed the down and up⤶    # into this coalesced higher-level event,⤶    # but we still need to make these checks and actions⤶    @destroyTemporaryHandlesAndLayoutAdjustersIfHandHasNotActionedThem wdgtTheMenuIsAbout⤶    @stopEditingIfWidgetDoesntNeedCaretOrActionIsElsewhere wdgtTheMenuIsAbout⤶⤶    if Automator? and⤶     Automator.state == Automator.PLAYING⤶      Automator.fade 'rightMouseButtonIndicator', 0, 1, 10, new Date().getTime()⤶      setTimeout ⧹⤶        =>⤶          Automator.fade 'rightMouseButtonIndicator', 1, 0, 500, new Date().getTime()⤶        , 100⤶    ⤶    contextMenu = wdgtTheMenuIsAbout.buildContextMenu()⤶    while !contextMenu and wdgtTheMenuIsAbout.parent⤶      wdgtTheMenuIsAbout = wdgtTheMenuIsAbout.parent⤶      contextMenu = wdgtTheMenuIsAbout.buildContextMenu()⤶⤶    if contextMenu⤶      contextMenu.popUpAtHand()⤶⤶⤶⤶  ⤶  ⤶  ⤶  # ActivePointerWdgt floatDragging and dropping:⤶  #⤶  # floatDrag 'n' drop events, method(arg) -> receiver:⤶  #⤶  #   prepareToBeGrabbed() -> grabTarget⤶  #   reactToGrabOf(grabbedWdgt) -> oldParent⤶  #   wantsDropOf(wdgtToDrop) ->  newParent⤶  #   justDropped(activePointerWdgt) -> droppedWdgt⤶  #   reactToDropOf(droppedWdgt, activePointerWdgt) -> newParent⤶  #⤶  dropTargetFor: (aWdgt) ->⤶    target = @topWdgtUnderPointer()⤶    until target.wantsDropOf aWdgt⤶      target = target.parent⤶    target⤶  ⤶  grab: (aWdgt, displacementDueToGrabDragThreshold,  switcherooHappened) ->⤶    return nil  if aWdgt instanceof WorldMorph⤶    oldParent = aWdgt.parent⤶    if !@isThisPointerFloatDraggingSomething()⤶⤶      if Automator?⤶        world.automator.recorder.addGrabCommand()⤶        if Automator.state == Automator.RECORDING⤶          action = ＂grab＂⤶          arr = world.automator.tagsCollectedWhileRecordingTest⤶          if action not in arr⤶            arr.push action⤶⤶⤶      world.stopEditing()⤶⤶      # this paragraph deals with how to resize/reposition the widget⤶      # that we are grabbing in respect to the hand⤶      if switcherooHappened⤶        # in this case the widget being grabbed is created on the fly⤶        # so just like the next case it's OK to center it under the pointer⤶        aWdgt.fullMoveTo @position().subtract aWdgt.extent().floorDivideBy 2⤶        aWdgt.fullRawMoveWithin world # TODO no fullMoveWithin ?⤶      else if aWdgt.extentToGetWhenDraggedFromGlassBox? and (oldParent instanceof GlassBoxBottomWdgt)⤶        # in this case the widget is ＂inflating＂. So, all⤶        # visual references that the user might have around the⤶        # position of the grab go out of the window: just center⤶        # the widget under the pointer and fit it within the⤶        # desktop bounds since we are at it (useful in case the⤶        # widget is inflating near the screen edges)⤶        aWdgt.setExtent aWdgt.extentToGetWhenDraggedFromGlassBox⤶        aWdgt.fullMoveTo @position().subtract aWdgt.extent().floorDivideBy 2⤶        aWdgt.fullRawMoveWithin world⤶      else if displacementDueToGrabDragThreshold?⤶        # in this case keep some visual consistency and move⤶        # the widget accordingly to where the grab started⤶        # (remember: we actually grab a while after the user has⤶        # pressed, because we want to see an actual significant move⤶        # before we resolve that this is a grab)⤶        # Don't fit the widget within the world because it often⤶        # happens to pick up a widget that is partially outside the⤶        # screen and it's no good to make it jump within the screen⤶        # - I tried and it looks really strange -⤶        aWdgt.fullMoveTo aWdgt.position().add displacementDueToGrabDragThreshold⤶⤶      @grabOrigin = aWdgt.situation()⤶      aWdgt.prepareToBeGrabbed?()⤶⤶      @add aWdgt⤶      aWdgt.justBeenGrabbed? oldParent⤶      # you must add the shadow⤶      # after the widget has been added⤶      # because ＂@add aWdgt＂ causes⤶      # the widget to be painted potentially⤶      # for the first time.⤶      # The shadow needs the image of the⤶      # widget to make the shadow, so⤶      # this is why we add the shadow after⤶      # the widget has been added.⤶      # Note that Widgets can specify the look⤶      # (i.e. offset blur and color)⤶      # of their shadow (e.g. Menus have a particular one⤶      # so they all seem to float at a particular height)⤶      # but here when we grab widgets we⤶      # specify a particular look for the shadow.⤶      # This is a particularly ＂floaty＂ shadow⤶      # which illustrates how things being dragged⤶      # are above anything else.⤶⤶      aWdgt.addShadow new Point(6, 6), 0.1⤶      ⤶      #debugger⤶      @fullChanged()⤶      # this gives an occasion to the old parent⤶      # widget to adjust itself e.g. the ScrollPanelWdgt⤶      # readjusts itself if you take some widgets⤶      # out of it.⤶      oldParent?.reactToGrabOf? aWdgt⤶⤶  isThisPointerDraggingSomething: ->⤶    @isThisPointerFloatDraggingSomething() or @isThisPointerNonFloatDraggingSomething()⤶⤶  isThisPointerFloatDraggingSomething: ->⤶    if @children.length > 0 then true else false⤶⤶  isThisPointerNonFloatDraggingSomething: ->⤶    return @nonFloatDraggedWdgt?⤶⤶⤶  drop: ->⤶    if @isThisPointerFloatDraggingSomething()⤶⤶      if Automator?⤶        world.automator.recorder.addDropCommand()⤶        if Automator.state == Automator.RECORDING⤶          action = ＂drop＂⤶          arr = world.automator.tagsCollectedWhileRecordingTest⤶          if action not in arr⤶            arr.push action⤶⤶      wdgtToDrop = @children[0]⤶⤶      if wdgtToDrop.rejectsBeingDropped?()⤶        target = world⤶      else⤶        target = @dropTargetFor wdgtToDrop⤶⤶      @fullChanged()⤶      wdgtToDrop.aboutToBeDropped? target⤶      target.aboutToDrop? wdgtToDrop⤶      target.add wdgtToDrop, nil, nil, true, nil, @position()⤶      wdgtToDrop.fullChanged()⤶⤶      # when you click the buttons, sometimes you end up⤶      # clicking between the buttons, and so the ＂proper＂⤶      # widget ＂loses focus＂ so to speak. So avoiding that here.⤶      if !(wdgtToDrop instanceof HorizontalMenuPanelWdgt)⤶        world.lastNonTextPropertyChangerButtonClickedOrDropped = wdgtToDrop⤶⤶      @children = []⤶      @rawSetExtent new Point⤶⤶      # first we notify the recipient of the drop⤶      # this gives the chance to the recipient to⤶      # initialise a layout spec for the dropped widget⤶      target.reactToDropOf? wdgtToDrop, @⤶⤶      # then we notify the dropped widget. This currently⤶      # is used to let the dropped widget tweak the layout⤶      # spec (some widgets suddenly become constrained by ratio⤶      # when they are dropped into a document)⤶      wdgtToDrop.justDropped? target⤶⤶    #else⤶    #  alert ＂if you never see this alert then you can delete the test＂⤶  ⤶  # ActivePointerWdgt event dispatching:⤶  #⤶  #    mouse events:⤶  #⤶  #   mouseDownLeft⤶  #   mouseDownRight⤶  #   mouseClickLeft⤶  #   mouseClickRight⤶  #   mouseDoubleClick⤶  #   mouseEnter⤶  #   mouseLeave⤶  #   mouseEnterfloatDragging⤶  #   mouseLeavefloatDragging⤶  #   mouseMove⤶  #   wheel⤶  #⤶  # Note that some handlers don't want the event but the⤶  # interesting parameters of the event. This is because⤶  # the testing harness only stores the interesting parameters⤶  # rather than a multifaceted and sometimes browser-specific⤶  # event object.⤶⤶  destroyTemporaryHandlesAndLayoutAdjustersIfHandHasNotActionedThem: (actionedWdgt) ->⤶    if world.temporaryHandlesAndLayoutAdjusters.size > 0⤶      unless world.temporaryHandlesAndLayoutAdjusters.has actionedWdgt⤶        world.temporaryHandlesAndLayoutAdjusters.forEach (eachTemporaryHandlesAndLayoutAdjusters) =>⤶          eachTemporaryHandlesAndLayoutAdjusters.fullDestroy()⤶        world.temporaryHandlesAndLayoutAdjusters.clear()⤶⤶  stopEditingIfWidgetDoesntNeedCaretOrActionIsElsewhere: (actionedWdgt) ->⤶    if world.caret?⤶⤶      # some actioning widgets rely on the⤶      # caret, for example to change the properties⤶      # of text (e.g. make it bold)⤶      if actionedWdgt.editorContentPropertyChangerButton? and actionedWdgt.editorContentPropertyChangerButton⤶        return⤶⤶      # if you click anything directly inside a button that has⤶      # ＂editorContentPropertyChangerButton＂ set, then do nothing⤶      # This is needed because you might ＂down＂ on the label of the⤶      # button and you don't want to stopEditing in that case⤶      # either...⤶      if actionedWdgt.parent? and⤶       (actionedWdgt.parent instanceof SimpleButtonMorph) and⤶       actionedWdgt.parent.editorContentPropertyChangerButton? and⤶       actionedWdgt.parent.editorContentPropertyChangerButton⤶        return⤶⤶      # there is a caret on the screen⤶      # depending on what the user is clicking on,⤶      # we might need to close an ongoing edit⤶      # operation, which means deleting the⤶      # caret and un-selecting anything that was selected.⤶      #⤶      # This check is because we don't want to interrupt⤶      # an edit if the user is invoking/clicking on anything⤶      # inside a menu regarding text that is being edited⤶      # because the invoked function⤶      # might do something with the selection⤶      # (for example doSelection takes the current selection).⤶      #⤶      # In other words, if we are actioning on something that has⤶      # the text as an ancestor, then don't stop the⤶      # editing.⤶      if actionedWdgt isnt world.caret.target⤶        # user clicked on something other than what the⤶        # caret is attached to⤶        mostRecentlyCreatedPopUp = world.mostRecentlyCreatedPopUp()⤶        if mostRecentlyCreatedPopUp?⤶          unless mostRecentlyCreatedPopUp.isAncestorOf actionedWdgt⤶            # only dismiss editing if the actionedWdgt the user⤶            # clicked on is not part of a menu.⤶            world.stopEditing()⤶        # there is no menu at all, in which case⤶        # we know there was an editing operation going⤶        # on that we need to stop⤶        else⤶          world.stopEditing()⤶⤶⤶  processMouseDown: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->⤶    world.destroyToolTips()⤶    @wdgtToGrab = nil⤶⤶    if Automator? and Automator.state == Automator.PLAYING⤶      if button is 2 or ctrlKey⤶        Automator.fade 'rightMouseButtonIndicator', 0, 1, 10, new Date().getTime()⤶      else⤶        Automator.fade 'leftMouseButtonIndicator', 0, 1, 10, new Date().getTime()⤶⤶⤶    @mouseDownPosition = @position()⤶⤶    # check whether we are in the middle⤶    # of a floatDrag/drop operation⤶    if @isThisPointerFloatDraggingSomething()⤶      @drop()⤶      @mouseButton = nil⤶    else⤶      w = @topWdgtUnderPointer()⤶⤶      @destroyTemporaryHandlesAndLayoutAdjustersIfHandHasNotActionedThem w⤶      # TODO it seems a little aggressive to stop any editing⤶      # just on the ＂down＂, probably something higher level⤶      # would be better? Like if any other object is brought to the⤶      # foreground?⤶      @stopEditingIfWidgetDoesntNeedCaretOrActionIsElsewhere w⤶⤶      # if we are doing a mousedown on anything outside a menu⤶      # then all the menus must go, whether or not they have⤶      # been freshly created or not. This came about because⤶      # small movements of the mouse while clicking on the⤶      # desktop would not dismiss menus.⤶      if !(w.firstParentThatIsAPopUp() instanceof MenuMorph)⤶        @cleanupMenuWdgts nil, w, true⤶⤶      @wdgtToGrab = w.findRootForGrab()⤶      if button is 2 or ctrlKey⤶        @mouseButton = ＂right＂⤶        actualClick = ＂mouseDownRight＂⤶        expectedClick = ＂mouseClickRight＂⤶      else⤶        @mouseButton = ＂left＂⤶        actualClick = ＂mouseDownLeft＂⤶        expectedClick = ＂mouseClickLeft＂⤶⤶      @mouseDownWdgt = w⤶      @mouseDownWdgt = @mouseDownWdgt.parent  until @mouseDownWdgt[expectedClick]⤶⤶      ⤶      while !w[actualClick]?⤶        if w.parent?⤶          w = w.parent⤶        else⤶          break⤶⤶      if w[actualClick]?⤶        w[actualClick] @position()⤶      #w = w.parent  until w[actualClick]⤶      #w[actualClick] @position()⤶  ⤶  ⤶   # note that the button param is not used,⤶   # but adding it for consistency...⤶  processMouseUp: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->⤶    if Automator? and Automator.state == Automator.PLAYING⤶      if button is 2⤶        Automator.fade 'rightMouseButtonIndicator', 1, 0, 500, new Date().getTime()⤶      else⤶        Automator.fade 'leftMouseButtonIndicator', 1, 0, 500, new Date().getTime()⤶⤶    w = @topWdgtUnderPointer()⤶⤶    alreadyRecordedLeftOrRightClickOnMenuItem = false⤶    world.destroyToolTips()⤶    world.freshlyCreatedPopUps.clear()⤶⤶⤶    if @isThisPointerFloatDraggingSomething()⤶      @drop()⤶    else⤶⤶      # used right now for the slider button:⤶      # it's likely that the non-float drag will end⤶      # up outside of its bounds, and yet we need to⤶      # notify the button that the drag is over so it⤶      # can repaint itself of another color.⤶      if @isThisPointerNonFloatDraggingSomething()⤶        @nonFloatDraggedWdgt.endOfNonFloatDrag?()⤶⤶      @previousNonFloatDraggingPos = nil⤶      # let's check if the user clicked on a menu item,⤶      # in which case we add a special dedicated command⤶      # [TODO] you need to do some of this only if you⤶      # are recording a test, it's worth saving⤶      # these steps...⤶      #debugger⤶      ignored = nil⤶      toDestructure = w.parentThatIsA MenuItemMorph⤶      if toDestructure?⤶        [menuItemMorph, ignored]= toDestructure⤶        if menuItemMorph⤶          # we check whether the menuitem is actually part⤶          # of an activeMenu. Keep in mind you could have⤶          # detached a menuItem and placed it on any other⤶          # widget so you need to ascertain that you'll⤶          # find it in the activeMenu later on...⤶          mostRecentlyCreatedPopUp = world.mostRecentlyCreatedPopUp()⤶          if mostRecentlyCreatedPopUp == menuItemMorph.parent⤶            labelString = menuItemMorph.labelString⤶            occurrenceNumber = menuItemMorph.howManySiblingsBeforeMeSuchThat (m) ->⤶              m.labelString == labelString⤶            # this method below is also going to remove⤶            # the mouse down/up commands that have⤶            # recently/just been added.⤶            if Automator?⤶              world.automator.recorder.addCommandLeftOrRightClickOnMenuItem(@mouseButton, labelString, occurrenceNumber + 1)⤶            alreadyRecordedLeftOrRightClickOnMenuItem = true⤶⤶      # TODO check if there is any other⤶      # possibility other than mouseButton being ＂left＂⤶      # or ＂right＂. If it can only be one of those⤶      # that you can simplify this nested if below⤶      # and avoid using actionAlreadyProcessed⤶      if @mouseButton is ＂left＂⤶        expectedClick = ＂mouseClickLeft＂⤶      else⤶        expectedClick = ＂mouseClickRight＂⤶        if @mouseButton⤶          if !alreadyRecordedLeftOrRightClickOnMenuItem⤶            # this being a right click, pop⤶            # up a menu as needed.⤶            if Automator?⤶              world.automator.recorder.addOpenContextMenuCommand w.uniqueIDString()⤶⤶      # trigger the action⤶      until w[expectedClick]⤶        w = w.parent⤶        if not w?⤶          break⤶      if w?⤶        if w == @mouseDownWdgt⤶⤶          switch expectedClick⤶            when ＂mouseClickLeft＂⤶              pointerAndWdgtInfo = world.getPointerAndWdgtInfo()⤶              if Automator?⤶                world.automator.recorder.addMouseClickCommand 0, nil, pointerAndWdgtInfo...⤶              w.mouseUpLeft? @position(), button, buttons, ctrlKey, shiftKey, altKey, metaKey⤶            when ＂mouseClickRight＂⤶              pointerAndWdgtInfo = world.getPointerAndWdgtInfo()⤶              if Automator?⤶                world.automator.recorder.addMouseClickCommand 2, nil, pointerAndWdgtInfo...⤶              w.mouseUpRight? @position(), button, buttons, ctrlKey, shiftKey, altKey, metaKey⤶⤶          # also send doubleclick if the⤶          # two clicks happen on the same widget⤶          doubleClickInvocation = false⤶⤶          if @doubleClickWdgt?⤶            # three conditions:⤶            #  - both clicks are left-button clicks⤶            #  - both clicks on same widget⤶            #  - both clicks nearby⤶            if @mouseButton == ＂left＂ and⤶             @doubleClickWdgt == w and⤶             ((@doubleClickPosition.distanceTo @position()) < WorldMorph.preferencesAndSettings.grabDragThreshold)⤶              #console.log ＂@doubleClickPosition.distanceTo @position():＂ + @doubleClickPosition.distanceTo @position()⤶              #console.log ＂WorldMorph.preferencesAndSettings.grabDragThreshold:＂ + WorldMorph.preferencesAndSettings.grabDragThreshold⤶              @doubleClickWdgt = nil⤶              disableConsecutiveClicksFromSingleClicksDueToFastTests = false⤶              if Automator? and Automator.state == Automator.PLAYING⤶                if !world.automator.player.runningInSlowMode()⤶                  disableConsecutiveClicksFromSingleClicksDueToFastTests = true⤶              if !disableConsecutiveClicksFromSingleClicksDueToFastTests⤶                # remember we are going to send a double click⤶                # but let's do it after. That's because we first⤶                # want to send the normal click AND we want to tell⤶                # in the normal click that that normal click is part⤶                # of a double click⤶                doubleClickInvocation = true⤶                # triple-click detection starts here, it's just⤶                # like chaining a second double-click detection⤶                # once this double-click has just been detected⤶                # right here.⤶                @rememberTripleClickWdgtsForAWhile w⤶            else⤶              @forgetDoubleClickWdgts()⤶          else⤶            @rememberDoubleClickWdgtsForAWhile w⤶⤶          tripleClickInvocation = false⤶⤶          # also send tripleclick if the⤶          # three clicks happen on the same widget⤶          # Don't do anything if a double-click has⤶          # just been invoked because you'd immediately⤶          # fire a tripleClick⤶          # This pargraph of code is basically the same⤶          # as the previous one.⤶          if !doubleClickInvocation⤶            # same three conditions as double click⤶            if @mouseButton == ＂left＂ and⤶             @tripleClickWdgt == w and⤶             ((@tripleClickPosition.distanceTo @position()) < WorldMorph.preferencesAndSettings.grabDragThreshold)⤶              #debugger⤶              if @tripleClickWdgt == w⤶                @tripleClickWdgt = nil⤶                disableConsecutiveClicksFromSingleClicksDueToFastTests = false⤶                if Automator? and Automator.state == Automator.PLAYING⤶                  if !world.automator.player.runningInSlowMode()⤶                    disableConsecutiveClicksFromSingleClicksDueToFastTests = true⤶                if !disableConsecutiveClicksFromSingleClicksDueToFastTests⤶                  # remember we are going to send a triple click⤶                  # but let's do it after. That's because we first⤶                  # want to send the normal click AND we want to tell⤶                  # in the normal click that that normal click is part⤶                  # of a triple click⤶                  tripleClickInvocation = true⤶              else⤶                @forgetTripleClickWdgts()⤶⤶          # fire the click, sending info on whether this was part⤶          # of a double/triple click⤶          if !w.editorContentPropertyChangerButton and !(w instanceof HorizontalMenuPanelWdgt)⤶            world.lastNonTextPropertyChangerButtonClickedOrDropped = w⤶          w[expectedClick] @position(), button, buttons, ctrlKey, shiftKey, altKey, metaKey, doubleClickInvocation, tripleClickInvocation⤶          #console.log ＂>>> sent event ＂ + expectedClick + ＂ to: ＂ + w⤶⤶          # now send the double/triple clicks⤶          if doubleClickInvocation⤶            @processDoubleClick w⤶          if tripleClickInvocation⤶            @processTripleClick w⤶⤶⤶      # some pop-overs can contain horizontal sliders⤶      # and when the user interacts with them, it's easy⤶      # that she can ＂drag＂ them outside the range and⤶      # do the mouse-up outside the boundaries⤶      # of the pop-over. So we avoid that here, if there⤶      # is a non-float drag ongoing then we avoid⤶      # cleaning-up the pop-overs⤶      if !@nonFloatDraggedWdgt?⤶        @cleanupMenuWdgts expectedClick, w⤶⤶    @mouseButton = nil⤶    @nonFloatDraggedWdgt = nil⤶⤶⤶  forgetDoubleClickWdgts: ->⤶    @doubleClickWdgt = nil⤶    @doubleClickPosition = nil⤶⤶  rememberDoubleClickWdgtsForAWhile: (w) ->⤶    @doubleClickWdgt = w⤶    @doubleClickPosition = @position()⤶    setTimeout (=>⤶      #if @doubleClickWdgt?⤶      #  console.log ＂single click＂⤶      @forgetDoubleClickWdgts()⤶      return false⤶    ), 300⤶⤶  # basically the same as rememberDoubleClickWdgtsForAWhile⤶  forgetTripleClickWdgts: ->⤶    @tripleClickWdgt = nil⤶    @tripleClickPosition = nil⤶⤶  rememberTripleClickWdgtsForAWhile: (w) ->⤶    @tripleClickWdgt = w⤶    @tripleClickPosition = @position()⤶    setTimeout (=>⤶      #if @tripleClickWdgt?⤶      #  console.log ＂not a triple click, just a double click＂⤶      @forgetTripleClickWdgts()⤶      return false⤶    ), 300⤶⤶  cleanupMenuWdgts: (expectedClick, w, alsoKillFreshMenus)->⤶⤶    world.hierarchyOfClickedWdgts.clear()⤶    world.hierarchyOfClickedMenus.clear()⤶⤶    # note that all the actions due to the clicked⤶    # widgets have been performed, now we can destroy⤶    # widgets queued up for closure⤶    # which might include menus...⤶    # if we destroyed menus earlier, the⤶    # actions that come from the click⤶    # might be mangled, e.g. adding a menu⤶    # to a destroyed menu, etc.⤶    world.closePopUpsMarkedForClosure()⤶⤶    # remove menus that have requested⤶    # to be removed when a click happens outside⤶    # of their bounds OR the bounds of their⤶    # children⤶    #if expectedClick == ＂mouseClickLeft＂⤶    # collect all widgets up the hierarchy of⤶    # the one the user clicked on.⤶    # (including the one the user clicked on)⤶    ascendingWdgts = w⤶    world.hierarchyOfClickedWdgts.clear()⤶    world.hierarchyOfClickedWdgts.add ascendingWdgts⤶    while ascendingWdgts.parent?⤶      ascendingWdgts = ascendingWdgts.parent⤶      world.hierarchyOfClickedWdgts.add ascendingWdgts⤶⤶    # remove menus that have requested⤶    # to be removed when a click happens outside⤶    # of their bounds OR the bounds of their⤶    # children⤶    #if expectedClick == ＂mouseClickLeft＂⤶    # collect all the menus up the hierarchy of⤶    # the one the user clicked on.⤶    # (including the one the user clicked on)⤶    # note that the hierarchy of the menus is actually⤶    # via the getParentPopUp method⤶    firstParentThatIsAPopUp = w.firstParentThatIsAPopUp()⤶    if firstParentThatIsAPopUp?.hierarchyOfPopUps?⤶      world.hierarchyOfClickedMenus = firstParentThatIsAPopUp.hierarchyOfPopUps()⤶    ⤶    # go through the widgets that wanted a notification⤶    # in case there is a click outside of them or any⤶    # of their children.⤶    # i.e. check from the notification list which ones are not⤶    # in the hierarchy of the clicked widgets⤶    # and call their callback.⤶    #console.log ＂widgets wanting to be notified: ＂ + world.wdgtsDetectingClickOutsideMeOrAnyOfMeChildren⤶    #console.log ＂hierarchy of clicked widgets: ＂ + world.hierarchyOfClickedWdgts⤶    #console.log ＂hierarchy of clicked menus: ＂ + world.hierarchyOfClickedMenus⤶    ⤶⤶    # because we might remove elements of the set while we⤶    # iterate on it (as we destroy menus that want to be destroyed⤶    # when the user clicks outside of them or their children)⤶    world.wdgtsDetectingClickOutsideMeOrAnyOfMeChildren.forEach (eachWdgtWantingToBeNotifiedIfClickOutsideThemOrTheirChildren) =>⤶      if (!world.hierarchyOfClickedMenus.has eachWdgtWantingToBeNotifiedIfClickOutsideThemOrTheirChildren) and⤶         (!world.hierarchyOfClickedWdgts.has eachWdgtWantingToBeNotifiedIfClickOutsideThemOrTheirChildren)⤶        # skip the freshly created menus as otherwise we might⤶        # destroy them immediately⤶        if alsoKillFreshMenus or !world.freshlyCreatedPopUps.has eachWdgtWantingToBeNotifiedIfClickOutsideThemOrTheirChildren⤶          if eachWdgtWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[0]?⤶            eachWdgtWantingToBeNotifiedIfClickOutsideThemOrTheirChildren[eachWdgtWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[0]].call eachWdgtWantingToBeNotifiedIfClickOutsideThemOrTheirChildren, eachWdgtWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[1], eachWdgtWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[2], eachWdgtWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[3]⤶⤶  processDoubleClick: (w = @topWdgtUnderPointer()) ->⤶    pointerAndWdgtInfo = world.getPointerAndWdgtInfo w⤶    if Automator?⤶      world.automator.recorder.addMouseDoubleClickCommand nil, pointerAndWdgtInfo...⤶⤶    world.destroyToolTips()⤶    if @isThisPointerFloatDraggingSomething()⤶      @drop()⤶    else⤶      w = w.parent  while w and not w.mouseDoubleClick⤶      w.mouseDoubleClick @position() if w⤶    @mouseButton = nil⤶⤶  processTripleClick: (w = @topWdgtUnderPointer()) ->⤶    pointerAndWdgtInfo = world.getPointerAndWdgtInfo w⤶    if Automator?⤶      world.automator.recorder.addMouseTripleClickCommand nil, pointerAndWdgtInfo...⤶⤶    world.destroyToolTips()⤶    if @isThisPointerFloatDraggingSomething()⤶      @drop()⤶    else⤶      w = w.parent  while w and not w.mouseTripleClick⤶      w.mouseTripleClick @position() if w⤶    @mouseButton = nil⤶  ⤶  # see https://developer.mozilla.org/en-US/docs/Web/Events/wheel⤶  processWheel: (deltaX, deltaY, deltaZ, altKey, button, buttons) ->⤶    w = @topWdgtUnderPointer()⤶    w = w.parent  while w and not w.wheel⤶⤶    if w?⤶      w.wheel deltaX, deltaY, deltaZ, altKey, button, buttons⤶  ⤶  ⤶⤶  ⤶  ⤶  # ActivePointerWdgt tools⤶  ⤶  # ActivePointerWdgt floatDragging optimization⤶  fullRawMoveBy: (delta) ->⤶    if delta.isZero() then return⤶    world.disableTrackChanges()⤶    #console.log ＂move 2＂⤶    @breakNumberOfRawMovesAndResizesCaches()⤶    super delta⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶⤶  processMouseMove: (worldX, worldY, button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->⤶    #startProcessMouseMove = new Date().getTime()⤶    pos = new Point worldX, worldY⤶    @fullRawMoveTo pos⤶⤶    if Automator? and Automator.state == Automator.PLAYING⤶      mousePointerIndicator = document.getElementById ＂mousePointerIndicator＂⤶      mousePointerIndicator.style.display = 'block'⤶      posInDocument = world.getCanvasPosition()⤶      mousePointerIndicator.style.left = (posInDocument.x + worldX - (mousePointerIndicator.clientWidth/2)) + 'px'⤶      mousePointerIndicator.style.top = (posInDocument.y + worldY - (mousePointerIndicator.clientHeight/2)) + 'px'⤶⤶    # determine the new mouse-over-list.⤶    # Spacial multiplexing⤶    # (search ＂multiplexing＂ for the other parts of⤶    # code where this matters)⤶    # There are two interpretations of what this⤶    # list should be:⤶    #   1) all widgets ＂pierced through＂ by the pointer⤶    #   2) all widgets parents of the topmost widgets under the pointer⤶    # 2 is what is used in Cuis⤶    ⤶    # commented-out implementation of 1):⤶    # mouseOverNew = @allWdgtsAtPointer().reverse()⤶    topWdgt = @topWdgtUnderPointer()⤶    # allParentsTopToButton makes more logical sense but⤶    # allParentsBottomToTop is cheaper and it all ends up in a set anyways⤶    mouseOverNew = new Set topWdgt.allParentsBottomToTop()⤶⤶    @determineGrabs pos, topWdgt, mouseOverNew⤶⤶    @dispatchEventsFollowingMouseMove mouseOverNew⤶⤶  checkDraggingTreshold: ->⤶    # UNFORTUNATELY OLD tests didn't take the correction into account,⤶    # pointers inevitably have some ＂noise＂, so to avoid that⤶    # a simple clicking (which could be done for example for⤶    # selection purposes or to pick a position for a cursor)⤶    # turns into a drag, so we add⤶    # a grab/drag distance threshold.⤶    # Note that even if the mouse moves a bit, we are still⤶    # picking up the correct widget that was under the mouse when⤶    # the mouse down happened.⤶    # Also we correct for the initial displacement⤶    # due to the threshold, so really when user starts dragging⤶    # it should pick up the EXACT point where the click happened,⤶    # not a ＂later＂ point once the threshold is passed.⤶⤶    # so we have to bypass this mechanism for those.⤶    displacementDueToGrabDragThreshold = nil⤶    skipGrabDragThreshold = false⤶    ⤶    if Automator? and Automator.state == Automator.PLAYING⤶      if !window[＂#{world.automator.player.currentlyPlayingTestName()}＂].grabDragThreshold?⤶        skipGrabDragThreshold = true⤶⤶    if !skipGrabDragThreshold⤶      if @wdgtToGrab.parent != world or (!@wdgtToGrab.isEditable? or @wdgtToGrab.isEditable )⤶        if (@mouseDownPosition.distanceTo @position()) < WorldMorph.preferencesAndSettings.grabDragThreshold⤶          return [true,nil]⤶      displacementDueToGrabDragThreshold = @position().subtract @mouseDownPosition⤶⤶    return [false, displacementDueToGrabDragThreshold]⤶⤶  determineGrabs: (pos, topWdgt, mouseOverNew) ->⤶    if !@isThisPointerDraggingSomething() and (@mouseButton is ＂left＂)⤶      w = topWdgt.findRootForGrab()⤶      topWdgt.mouseMove pos  if topWdgt.mouseMove⤶⤶      # if a widget is marked for grabbing, grab it⤶      if @wdgtToGrab⤶        ⤶        # these first two cases are for float dragging⤶        # the third case is non-float drag⤶        if @wdgtToGrab.isTemplate⤶          [skipDragging, displacementDueToGrabDragThreshold] = @checkDraggingTreshold()⤶          if skipDragging then return⤶⤶          w = @wdgtToGrab.fullCopy()⤶          w.isTemplate = false⤶          @grab w, displacementDueToGrabDragThreshold⤶          @grabOrigin = @wdgtToGrab.situation()⤶⤶        else if @wdgtToGrab.detachesWhenDragged()⤶          [skipDragging, displacementDueToGrabDragThreshold] = @checkDraggingTreshold()⤶          if skipDragging then return⤶⤶          originalWdgtToGrab = @wdgtToGrab⤶          @wdgtToGrab = @wdgtToGrab.grabbedWidgetSwitcheroo()⤶          w = @wdgtToGrab⤶          @grab w, displacementDueToGrabDragThreshold, (originalWdgtToGrab != w)⤶⤶        else⤶          # non-float drags are for things such as sliders⤶          # and resize handles.⤶          # you could have the concept of de-noising, but⤶          # actually it seems nicer to have a ＂springy＂⤶          # reaction to a slider with some noise.⤶          # Users don't seem to click on a slider for any other⤶          # reason than to move it (as opposed to selecting them⤶          # or picking a position for a cursor), so it's OK.⤶          @nonFloatDraggedWdgt = @wdgtToGrab⤶          @nonFloatDragPositionWithinWdgtAtStart =⤶            # if we ever will need to compensate for the grab/drag⤶            # treshold here, just add .subtract displacementDueToGrabDragThreshold⤶            (pos.subtract @nonFloatDraggedWdgt.position())⤶⤶⤶        # if the mouse has left its fullBounds, center it⤶        if w⤶          fb = w.fullBounds()⤶          unless fb.containsPoint pos⤶            @rawSetExtent @extent().subtract fb.extent().floorDivideBy 2⤶            @grab w⤶            @fullRawMoveTo pos⤶    #endProcessMouseMove = new Date().getTime()⤶    #timeProcessMouseMove = endProcessMouseMove - startProcessMouseMove⤶    #console.log('Execution time ProcessMouseMove: ' + timeProcessMouseMove)⤶⤶⤶    if @isThisPointerNonFloatDraggingSomething()⤶      #console.log ＂nonFloatDraggedWdgt: ＂ + @nonFloatDraggedWdgt⤶⤶      # OK so this is an interesting choice. You can avoid⤶      # this next line and have Fizzygum to behave like OSX where you⤶      # can scroll on a panel without bringing its window in the⤶      # foreground. OR you can have the window to automatically⤶      # pop into the foreground. I'm liking the OSX style⤶      # so I'm leaving this commented-out, but it's there.⤶      # TODO this could be a setting somewhere in Fizzygum.⤶      # @nonFloatDraggedWdgt.bringToForeground()⤶⤶      if @mouseButton⤶        if @previousNonFloatDraggingPos?⤶          deltaDragFromPreviousCall = pos.subtract @previousNonFloatDraggingPos⤶        else⤶          deltaDragFromPreviousCall = nil⤶        @previousNonFloatDraggingPos = pos.copy()⤶        @nonFloatDraggedWdgt.nonFloatDragging?(@nonFloatDragPositionWithinWdgtAtStart, pos, deltaDragFromPreviousCall)⤶    ⤶⤶  # this is used by the ScrollMorph: clicking on the slider⤶  # (but OUTSIDE of the button), the (center of the) button⤶  # is immediately non-float dragged to where clicked.⤶  nonFloatDragWdgtFarAwayToHere: (wdgtFarAway, pos) ->⤶    # allParentsTopToButton makes more logical sense but⤶    # allParentsBottomToTop is cheaper and it all ends up in a set anyways⤶    mouseOverNew = new Set wdgtFarAway.allParentsBottomToTop()⤶    @previousNonFloatDraggingPos = wdgtFarAway.center()⤶    @nonFloatDragPositionWithinWdgtAtStart = (new Point wdgtFarAway.width()/2, wdgtFarAway.height()/2).round()⤶    @nonFloatDraggedWdgt = wdgtFarAway⤶    # this one calls the wdgtFarAway's nonFloatDragging method,⤶    # for example in case of a SliderMorph invoking this on its⤶    # button, this causes the movement of the button⤶    # and adjusting of the Slider values and potentially⤶    # adjusting scrollpanel etc.⤶    @determineGrabs pos, wdgtFarAway, mouseOverNew⤶⤶  reCheckMouseEntersAndMouseLeavesAfterPotentialGeometryChanges: ->⤶    topWdgt = @topWdgtUnderPointer()⤶    # allParentsTopToButton makes more logical sense but⤶    # allParentsBottomToTop is cheaper and it all ends up in a set anyways⤶    mouseOverNew = new Set topWdgt.allParentsBottomToTop()⤶    @dispatchEventsFollowingMouseMove mouseOverNew⤶⤶  dispatchEventsFollowingMouseMove: (mouseOverNew) ->⤶⤶    @mouseOverList.forEach (old) =>⤶      unless mouseOverNew.has old⤶        old.mouseLeave?()⤶        old.mouseLeavefloatDragging?()  if @mouseButton⤶⤶    mouseOverNew.forEach (newWdgt) =>⤶      ⤶      # send mouseMove only if mouse actually moved,⤶      # otherwise it will fire also when the user⤶      # simply clicks⤶      if !@mouseDownPosition? or !@mouseDownPosition.equals @position()⤶        newWdgt.mouseMove?(@position(), @mouseButton)⤶      ⤶      unless @mouseOverList.has newWdgt⤶        newWdgt.mouseEnter?()⤶        newWdgt.mouseEnterfloatDragging?()  if @mouseButton⤶⤶      # autoScrolling support:⤶      if @isThisPointerFloatDraggingSomething()⤶        widgetBeingFloatDragged = @children[0]⤶        # if we are dragging stuff that can't be dropped⤶        # (e.g. external windows) then nothing happens⤶        if !widgetBeingFloatDragged.rejectsBeingDropped? or !widgetBeingFloatDragged.rejectsBeingDropped()⤶          if newWdgt instanceof ScrollPanelWdgt⤶            if newWdgt.wantsDropOf widgetBeingFloatDragged⤶              if !newWdgt.boundingBox().insetBy(⤶                WorldMorph.preferencesAndSettings.scrollBarsThickness * 3⤶                ).containsPoint @position()⤶                  newWdgt.startAutoScrolling()⤶⤶    @mouseOverList = mouseOverNew⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AlignmentSpecHorizontal_coffeSource = "# AlignmentSpecHorizontal⤶⤶⤶class AlignmentSpecHorizontal⤶  @LEFT: 0⤶  @CENTER: 1⤶  @RIGHT: 2⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AlignmentSpecVertical_coffeSource = "# AlignmentSpecVertical⤶⤶⤶class AlignmentSpecVertical⤶  @TOP: 3⤶  @MIDDLE: 4⤶  @BOTTOM: 5⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.Appearance_coffeSource = "class Appearance⤶⤶  @augmentWith DeepCopierMixin⤶⤶  morph: nil⤶  # the ownColorInsteadOfWidgetColor is used for buttons⤶  # with icons on a glass bottom: the glass bottom has⤶  # to change the color on hover, so the icon_button on it⤶  # stain it, but they have to retain their color otherwise⤶  # they are not visible anymore.⤶  ownColorInsteadOfWidgetColor: nil⤶⤶  constructor: (@morph, @ownColorInsteadOfWidgetColor) ->⤶⤶  isTransparentAt: (aPoint) ->⤶⤶  # paintHighlight can work in two patterns:⤶  #  * passing actual pixels, when used⤶  #    outside the effect of the scope of⤶  #    ＂useLogicalPixelsUntilRestore()＂, or⤶  #  * passing logical pixels, when used⤶  #    inside the effect of the scope of⤶  #    ＂useLogicalPixelsUntilRestore()＂, or⤶  # Mostly, the first pattern is used.⤶  #⤶  # useful for example when hovering over references⤶  # to morphs. Can only modify the rendering of a morph,⤶  # so any highlighting is only visible in the measure that⤶  # the morph is visible (as opposed to HighlighterMorph being⤶  # used to highlight a morph)⤶  paintHighlight: (aContext, al, at, w, h) ->⤶⤶⤶  # This method only paints this very morph⤶  # i.e. it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer,⤶  # which eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BasementOpenerWdgt_coffeSource = "class BasementOpenerWdgt extends IconicDesktopSystemLinkWdgt⤶⤶  @augmentWith HighlightableMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.BLACK⤶⤶  _acceptsDrops: true⤶⤶  constructor: ->⤶    super ＂Basement＂, new GenericShortcutIconWdgt new BasementIconWdgt⤶    @target = world.basementWdgt⤶    @rawSetExtent new Point 75, 75⤶⤶  iHaveBeenAddedTo: (whereTo, beingDropped) ->⤶    super⤶    if whereTo == world and !@userMovedThisFromComputedPosition⤶      @fullMoveTo world.bottomRight().subtract @extent().add world.desktopSidesPadding⤶⤶  justDropped: (whereIn) ->⤶    super⤶    if whereIn == world⤶      @userMovedThisFromComputedPosition = true⤶⤶⤶  mouseClickLeft: (arg1, arg2, arg3, arg4, arg5, arg6, arg7, doubleClickInvocation, arg9) ->⤶    if doubleClickInvocation⤶      return⤶⤶    if @target.isOrphan()⤶      @target.unCollapse()⤶      windowedBasementWdgt = new WindowWdgt nil, nil, @target⤶      world.add windowedBasementWdgt⤶      windowedBasementWdgt.rawSetExtent new Point 460, 400⤶      windowedBasementWdgt.fullRawMoveTo new Point 140, 90⤶      windowedBasementWdgt.rememberFractionalSituationInHoldingPanel()⤶      menusHelper.createBasementOneOffInfoWindowNextTo windowedBasementWdgt⤶    else⤶      # if the basement is not an orphan, then it's⤶      # visible somewhere and it's in a window⤶      @target.parent.spawnNextTo @⤶      @target.parent.rememberFractionalSituationInHoldingPanel()⤶⤶⤶  reactToDropOf: (droppedWidget) ->⤶    @target.scrollPanel.contents.addInPseudoRandomPosition droppedWidget⤶⤶  rejectsBeingDropped: ->⤶    true".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BasementWdgt_coffeSource = "class BasementWdgt extends BoxMorph⤶⤶  # panes:⤶  scrollPanel: nil⤶  resizer: nil⤶⤶  hideUsedWdgtsOnButton: nil⤶  hideUsedWdgtsOffButton: nil⤶  hideUsedWdgtsToggle: nil⤶⤶  showingLostItemsOnly: false⤶⤶  constructor: ->⤶    super()⤶⤶    @silentRawSetExtent new Point 340, 270⤶    @color = Color.create 60, 60, 60⤶    @padding = 5⤶    @buildAndConnectChildren()⤶⤶  colloquialName: ->⤶    ＂Basement＂⤶⤶  closeFromContainerWindow: (containerWindow) ->⤶    # remove ourselves from⤶    # the window⤶    @removeFromTree()⤶    # here we are just removing the empty window⤶    # there is nothing in it⤶    containerWindow.fullDestroy()⤶  ⤶⤶  ⤶  buildAndConnectChildren: ->⤶⤶    @scrollPanel = new ScrollPanelWdgt⤶    @add @scrollPanel⤶⤶    @hideUsedWdgtsOnButton = new SimpleButtonMorph true, @, ＂showAllWidgets＂, ＂☒ only show lost items＂⤶    @hideUsedWdgtsOffButton = new SimpleButtonMorph true, @, ＂hideUsedWidgets＂, ＂☐ only show lost items＂⤶    @hideUsedWdgtsToggle = new ToggleButtonMorph @hideUsedWdgtsOffButton, @hideUsedWdgtsOnButton, 0⤶    @add @hideUsedWdgtsToggle⤶⤶⤶    # resizer⤶    @resizer = new HandleMorph @⤶⤶    @invalidateLayout()⤶⤶⤶  # this is a very basic garbage collection mechanism⤶  # we basically try to find out which items in the basement⤶  # are still referenced somehow and which aren't⤶  # it's based on the idea that ＂referencing＂ widgets⤶  # are kept in a list, and we can just scan those and mark⤶  # everything they reference as ＂reachable＂.⤶  doGC: ->⤶    world.incrementalGcSessionId++⤶    newGcSessionId = world.incrementalGcSessionId⤶⤶    # precondition: the BasementWdgt is on the desktop.⤶    # first, take all orphan references and mark them as visited so we⤶    # get them out of the way immediately. They are unreachable by⤶    # definition (remember, the BasementWdgt is on screen, so they⤶    # are not even in the basement!) and⤶    # so they don't make their target reacheable.⤶    for eachReferencingWdgt from world.widgetsReferencingOtherWidgets⤶      if eachReferencingWdgt.isOrphan()⤶        eachReferencingWdgt.markReferenceAsVisited newGcSessionId⤶⤶    # then, take all remaining references, filter OUT the ones in the⤶    # basement (so: get the non-orphan non-basement references, which means⤶    # they are reachable from the desktop without going via the basement)⤶    # and for each:⤶    #  - mark what they reach (and their parents) as reachable⤶    #     (note that what they reach MIGHT be in the basement)⤶    #  - mark them as visited so we don't visit again⤶    for eachReferencingWdgt from world.widgetsReferencingOtherWidgets⤶      if !eachReferencingWdgt.wasReferenceVisited newGcSessionId⤶        if !eachReferencingWdgt.isInBasement()⤶          eachReferencingWdgt.target.markItAndItsParentsAsReachable newGcSessionId⤶          eachReferencingWdgt.markReferenceAsVisited newGcSessionId⤶⤶    # then, take all remaining references (which by exclusion at this point⤶    # must be the references the basement) and,⤶    # if they are reachable, then we have to mark what they reference⤶    # as reachable.⤶    # How do we know if they are reachable?⤶    # They are reachable if one of their parents is reachable.⤶    # Then:⤶    #   - mark what it references (and parents) as reacheable⤶    #   - mark it as visited so we don't visit again⤶    # Note that this a progressive search, because a reference might⤶    # make another reference reacheable, which might make another⤶    # reference reachable... in those chains we have to keep⤶    # searching until we find no new references⤶    newReachableReferencesUncovered = true⤶    while newReachableReferencesUncovered⤶      newReachableReferencesUncovered = false⤶      for eachReferencingWdgt from world.widgetsReferencingOtherWidgets⤶        if !eachReferencingWdgt.wasReferenceVisited newGcSessionId⤶          if eachReferencingWdgt.isInBasementButReachable newGcSessionId⤶            newReachableReferencesUncovered = true⤶            eachReferencingWdgt.target.markItAndItsParentsAsReachable newGcSessionId⤶            eachReferencingWdgt.markReferenceAsVisited newGcSessionId⤶⤶    return newGcSessionId⤶⤶  hideUsedWidgets: ->⤶    @showingLostItemsOnly = true⤶⤶    newGcSessionId = @doGC()⤶⤶    # now we have an idea of which children in the basement⤶    # are reachable and which aren't⤶    referencedChildren = new Set⤶⤶    for w in @scrollPanel.contents.children⤶      if w.isInBasementButReachable newGcSessionId⤶        referencedChildren.add w⤶⤶    referencedChildren.forEach (w) =>⤶      w.hide()⤶⤶  showAllWidgets: ->⤶    @showingLostItemsOnly = false⤶    for w in @scrollPanel.contents.children⤶      w.show()⤶⤶  # if a child has been added to the scrollPanel,⤶  # the scrollPanel checks its parent to see if it⤶  # has this callback. We use this callback because⤶  # we want to make⤶  # sure that the ＂only show lost items＂⤶  # filter is respected. Just re-invoke the⤶  # methods that calculate the visibility⤶  childAddedInScrollPanel: ->⤶    if @showingLostItemsOnly⤶      @hideUsedWidgets()⤶    else⤶      @showAllWidgets()⤶⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    newBoundsForThisLayout = @__calculateNewBoundsWhenDoingLayout newBoundsForThisLayout⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # TODO should'be calling this rawSetBounds from here,⤶    # rather use super⤶    @rawSetBounds newBoundsForThisLayout⤶⤶    world.disableTrackChanges()⤶⤶    x = @left() + @cornerRadius⤶⤶    # scrollPanel⤶    y = @top() + 2⤶    w = @width() - @cornerRadius⤶    w -= @cornerRadius⤶    b = @bottom() - (2 * @cornerRadius) - WorldMorph.preferencesAndSettings.handleSize⤶    h = b - y⤶    @scrollPanel.fullRawMoveTo new Point x, y⤶    @scrollPanel.rawSetExtent new Point w, h⤶⤶    # hideUsedWdgts toggle button⤶    x = @scrollPanel.left()⤶    y = @scrollPanel.bottom() + @cornerRadius⤶    h = WorldMorph.preferencesAndSettings.handleSize⤶    w = @scrollPanel.width() - h - @cornerRadius⤶    @hideUsedWdgtsToggle.doLayout (new Rectangle  0,0,w,h).translateBy new Point x, y⤶    world.maybeEnableTrackChanges()⤶⤶    super⤶    @markLayoutAsFixed()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BubblyAppearance_coffeSource = "class BubblyAppearance extends BoxyAppearance⤶⤶  constructor: (morph) ->⤶    super morph⤶⤶  outlinePath: (context, radius) ->⤶    # console.log ＂bubble outlinePath＂⤶⤶    padding = radius⤶    w = @morph.width()⤶    h = @morph.height()⤶⤶    spikeHeight = h/5⤶    spikeDistanceFromClosestSide = h/5⤶⤶    # outline drawn from top left corner, clockwise⤶⤶    # top left:⤶    context.arc padding, padding, radius, (-180).toRadians(), (-90).toRadians()⤶⤶    # top right:⤶    context.arc w - padding, padding, radius, (-90).toRadians(), (-0).toRadians()⤶⤶    # bottom right:⤶    context.arc w - padding, h - spikeHeight - radius, radius, (0).toRadians(), (90).toRadians()⤶⤶    # line from bottom right corner to the edge of the spike going down⤶    context.lineTo padding + radius + spikeDistanceFromClosestSide, h - spikeHeight⤶⤶    # spike line going down⤶    context.lineTo padding, h⤶⤶    # bottom left:⤶    context.arc padding, h - spikeHeight - radius, radius, (90).toRadians(), (180).toRadians()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CodeInjectingSimpleRectangularButtonMorph_coffeSource = "# like a SimpleRectangularButtonMorph but it contains code that can be⤶# injected into another morph⤶⤶class CodeInjectingSimpleRectangularButtonMorph extends SimpleRectangularButtonMorph⤶⤶  # Why don't we store just a Function, why are we dealing with strings here?⤶  # 1) because the user inputs a string⤶  # 2) because we NEED to keep the Coffeescript source code around, if⤶  #    we just hold the Function then we lose the CS source⤶⤶  sourceCodeToBeInjected: ＂＂⤶  wdgtWhereToInject: nil⤶  wdgtToBeNotifiedForNewCode: nil⤶⤶  constructor: (@wdgtToBeNotifiedForNewCode, @wdgtWhereToInject, face) ->⤶    super true, @, 'injectCodeIntoTarget', face⤶    @strokeColor = Color.BLACK⤶    @setColor Color.create 150, 150, 150⤶    @toolTipMessage = face.toolTipMessage⤶⤶  editInjectableSource: ->⤶    @textPrompt ＂Code＂, @, ＂modifyCodeToBeInjected＂, @sourceCodeToBeInjected⤶⤶  # this happens when pressed, the source code is injected⤶  injectCodeIntoTarget: ->⤶    @wdgtWhereToInject.injectProperties @sourceCodeToBeInjected⤶⤶  modifyCodeToBeInjected: (unused,textMorph) ->⤶    @sourceCodeToBeInjected = textMorph.text⤶    @wdgtToBeNotifiedForNewCode.newCodeToInjectFromButton? @⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CodePromptMorph_coffeSource = "class CodePromptMorph extends Widget⤶⤶  tempPromptEntryField: nil⤶  defaultContents: ＂＂⤶  textMorph: nil⤶⤶  cancelButton: nil⤶  saveButton: nil⤶  okButton: nil⤶  saveTextWdgt: nil⤶⤶  # the external padding is the space between the edges⤶  # of the container and all of its internals. The reason⤶  # you often set this to zero is because windows already put⤶  # contents inside themselves with a little padding, so this⤶  # external padding is not needed. Useful to keep it⤶  # separate and know that it's working though.⤶  externalPadding: 0⤶  # the internal padding is the space between the internal⤶  # components. It doesn't necessarily need to be equal to the⤶  # external padding⤶  internalPadding: 5⤶⤶  constructor: (@msg, @target, @callback, @defaultContents) ->⤶    super new Point 200,400⤶    @buildAndConnectChildren()⤶⤶  colloquialName: ->⤶    ＂Edit tool code＂⤶⤶  buildAndConnectChildren: ->⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @tempPromptEntryField = new SimplePlainTextScrollPanelWdgt @defaultContents, false, 5⤶    @tempPromptEntryField.disableDrops()⤶    @tempPromptEntryField.contents.disableDrops()⤶    @tempPromptEntryField.color = Color.WHITE⤶    @tempPromptEntryField.addModifiedContentIndicator()⤶⤶    # register this wdgt as one to be notified when the text⤶    # changes/unchanges from ＂reference＂ content⤶    # so we can enable/disable the ＂save＂ button⤶    @tempPromptEntryField.widgetToBeNotifiedOfTextModificationChange = @⤶⤶    @textMorph = @tempPromptEntryField.textWdgt⤶    @textMorph.backgroundColor = Color.TRANSPARENT⤶    @textMorph.setFontName nil, nil, @textMorph.monoFontStack⤶    @textMorph.isEditable = true⤶    @textMorph.enableSelecting()⤶⤶    @add @tempPromptEntryField⤶⤶    # buttons -------------------------------⤶    @cancelButton = new SimpleButtonMorph true, @, ＂close＂, ＂cancel＂⤶    @add @cancelButton⤶⤶    ⤶    @saveTextWdgt = new StringMorph2 ＂save＂, WorldMorph.preferencesAndSettings.textInButtonsFontSize⤶    @saveTextWdgt.alignCenter()⤶    @saveButton = new SimpleButtonMorph true, @, ＂informTarget＂, @saveTextWdgt⤶    @add @saveButton⤶⤶    @okButton = new SimpleButtonMorph true, @, ＂notifyTargetAndClose＂, ＂ok＂⤶    @add @okButton⤶    # ---------------------------------------⤶⤶    # now that we added the buttons there is a ＂save＂ button⤶    # to disable (because the reference text has not been⤶    # changed yet), so trigger the content check now⤶    @tempPromptEntryField.checkIfTextContentWasModifiedFromTextAtStart()⤶⤶    @invalidateLayout()⤶⤶  textContentModified: ->⤶    @saveTextWdgt.setColor Color.BLACK⤶⤶  textContentUnmodified: ->⤶    @saveTextWdgt.setColor Color.create 200, 200, 200⤶⤶⤶  informTarget: ->⤶    @target[@callback].call @target, nil, @textMorph⤶    @textMorph.considerCurrentTextAsReferenceText()⤶    @tempPromptEntryField.checkIfTextContentWasModifiedFromTextAtStart()⤶⤶  notifyTargetAndClose: ->⤶    @informTarget()⤶    @close()⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶    textHeight = @height() - 2 * @externalPadding - @internalPadding - 15⤶    textBottom = @top() + @externalPadding + textHeight⤶⤶    if @tempPromptEntryField.parent == @⤶      @tempPromptEntryField.fullRawMoveTo new Point @left() + @externalPadding, @top() + @externalPadding⤶      @tempPromptEntryField.rawSetExtent new Point @width() - 2 * @externalPadding, textHeight⤶⤶⤶    # buttons -------------------------------⤶    ⤶⤶    eachButtonWidth = (@width() - 2 * @externalPadding - 3 * @internalPadding - WorldMorph.preferencesAndSettings.handleSize) / 3⤶⤶    if @cancelButton.parent == @⤶      buttonBounds = new Rectangle new Point @left() + @externalPadding + 0*(eachButtonWidth + @internalPadding), textBottom + @internalPadding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight eachButtonWidth, 15⤶      @cancelButton.doLayout buttonBounds⤶⤶    if @saveButton.parent == @⤶      buttonBounds = new Rectangle new Point @left() + @externalPadding + 1*(eachButtonWidth + @internalPadding), textBottom + @internalPadding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight eachButtonWidth, 15⤶      @saveButton.doLayout buttonBounds⤶⤶    if @okButton.parent == @⤶      buttonBounds = new Rectangle new Point @left() + @externalPadding + 2*(eachButtonWidth + @internalPadding), textBottom + @internalPadding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight eachButtonWidth, 15⤶      @okButton.doLayout buttonBounds⤶⤶    # ----------------------------------------------⤶⤶⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    super⤶    @markLayoutAsFixed()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ColorPaletteMorph_coffeSource = "class ColorPaletteMorph extends Widget⤶⤶  @augmentWith ControllerMixin⤶  @augmentWith BackBufferMixin⤶⤶  target: nil⤶  action: nil⤶  argumentToAction: nil⤶  choice: nil⤶⤶  constructor: (@target = nil, sizePoint) ->⤶    super()⤶    @silentRawSetExtent sizePoint or new Point 80, 50⤶⤶  colloquialName: ->⤶    ＂color palette＂⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    @layoutSpecDetails = new WindowContentLayoutSpec PreferredSize.DONT_MIND , PreferredSize.DONT_MIND, 1⤶  ⤶  detachesWhenDragged: ->⤶    false⤶⤶  # no changes of position or extent should be⤶  # performed in here⤶  createRefreshOrGetBackBuffer: ->⤶    cacheKey =⤶      @constructor.name + ＂-＂ + @extent().toString()⤶⤶    cacheHit = world.cacheForImmutableBackBuffers.get cacheKey⤶    if cacheHit? then return cacheHit⤶⤶    extent = @extent()⤶    backBuffer = HTMLCanvasElement.createOfPhysicalDimensions extent.scaleBy ceilPixelRatio⤶    backBufferContext = backBuffer.getContext ＂2d＂⤶    backBufferContext.useLogicalPixelsUntilRestore()⤶    @choice = Color.BLACK⤶    for x in [0..extent.x]⤶      h = 360 * x / extent.x⤶      y = 0⤶      for y in [0..extent.y]⤶        l = 100 - (y / extent.y * 100)⤶        # see link below for alternatives on how to set a single⤶        # pixel color.⤶        # You should really be using putImageData of the whole buffer⤶        # here anyways. But this is clearer.⤶        # http://stackoverflow.com/questions/4899799/whats-the-best-way-to-set-a-single-pixel-in-an-html5-canvas⤶        backBufferContext.fillStyle = ＂hsl(＂ + h + ＂,100%,＂ + l + ＂%)＂⤶        backBufferContext.fillRect x, y, 1, 1⤶⤶    cacheEntry = [backBuffer, backBufferContext]⤶    world.cacheForImmutableBackBuffers.set cacheKey, cacheEntry⤶    return cacheEntry⤶  ⤶  nonFloatDragging: (nonFloatDragPositionWithinWdgtAtStart, pos, deltaDragFromPreviousCall) ->⤶    @choice = @getPixelColor pos.add (deltaDragFromPreviousCall or new Point 0, 0)⤶    @connectionsCalculationToken = world.makeNewConnectionsCalculationToken()⤶    @updateTarget()⤶  ⤶  mouseDownLeft: (pos) ->⤶    @choice = @getPixelColor pos⤶    @connectionsCalculationToken = world.makeNewConnectionsCalculationToken()⤶    @updateTarget()⤶⤶  stringSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂bang!＂⤶    functionNamesStrings.push ＂bang＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂bang!＂⤶    functionNamesStrings.push ＂bang＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  colorSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂bang!＂⤶    functionNamesStrings.push ＂bang＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶⤶  # the bang makes the node fire the current output value⤶  bang: (newvalue, ignored, connectionsCalculationToken, superCall) ->⤶    if !@choice? then return⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @connectionsCalculationToken = connectionsCalculationToken⤶    @updateTarget()⤶  ⤶  updateTarget: ->⤶    if !@target? then return⤶⤶    if !@action?⤶      @action = ＂setColor＂⤶⤶    @target[@action].call @target, @choice, nil, @connectionsCalculationToken⤶    return⤶⤶  reactToTargetConnection: ->⤶⤶  # ColorPaletteMorph menu:⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    menu.addLine()⤶    if world.isIndexPage⤶      menu.addMenuItem ＂connect to ➜＂, true, @, ＂openTargetSelector＂, ＂connect to⧹nanother widget＂⤶    else⤶      menu.addMenuItem ＂set target＂, true, @, ＂openTargetSelector＂, ＂choose another morph⧹nwhose color property⧹n will be＂ + ＂ controlled by this one＂⤶  ⤶  # openTargetSelector: -> taken form the ControllerMixin⤶⤶  openTargetPropertySelector: (ignored, ignored2, theTarget) ->⤶    [menuEntriesStrings, functionNamesStrings] = theTarget.colorSetters()⤶    menu = new MenuMorph @, false, @, true, true, ＂choose target property:＂⤶    for i in [0...menuEntriesStrings.length]⤶      menu.addMenuItem menuEntriesStrings[i], true, @, ＂setTargetAndActionWithOnesPickedFromMenu＂, nil, nil, nil, nil, nil, theTarget, functionNamesStrings[i]⤶    if menuEntriesStrings.length == 0⤶      menu = new MenuMorph @, false, @, true, true, ＂no target properties available＂⤶    menu.popUpAtHand()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ColorPickerMorph_coffeSource = "# Note that the ColorPicker has no ＂set target...＂ from⤶# the menu.⤶⤶class ColorPickerMorph extends Widget⤶⤶  # pattern: all the children should be declared here⤶  # the reason is that when you duplicate a morph⤶  # , the duplicated morph needs to have the handles⤶  # that will be duplicated. If you don't list them⤶  # here, then they need to be initialised in the⤶  # constructor. But actually they might not be⤶  # initialised in the constructor if a ＂lazy initialisation＂⤶  # approach is taken. So it's good practice⤶  # to list them here so they can be duplicated either way.⤶  feedback: nil⤶  choice: nil⤶  colorPalette: nil⤶  grayPalette: nil⤶⤶  constructor: ( @choice = Color.WHITE ) ->⤶    super()⤶    @appearance = new RectangularAppearance @⤶    @color = Color.WHITE⤶    @rawSetExtent new Point 80, 80⤶    @buildSubmorphs()⤶⤶  colloquialName: ->⤶    ＂color picker＂⤶⤶  buildSubmorphs: ->⤶    @feedback = new RectangleMorph new Point(20, 20), @choice⤶    @colorPalette = new ColorPaletteMorph @feedback, new Point @width(), 50⤶    @grayPalette = new GrayPaletteMorph @feedback, new Point @width(), 5⤶    @add @colorPalette⤶    @add @grayPalette⤶    @add @feedback⤶    @invalidateLayout()⤶⤶  iHaveBeenAddedTo: (whereTo, beingDropped) ->⤶  ⤶  getColor: ->⤶    @feedback.color⤶  ⤶⤶  rawSetExtent: (aPoint) ->⤶    super⤶    @invalidateLayout()⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    newBoundsForThisLayout = @__calculateNewBoundsWhenDoingLayout newBoundsForThisLayout⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶    # TODO should'be calling this rawSetBounds from here,⤶    # rather use super⤶    @rawSetBounds newBoundsForThisLayout⤶    @colorPalette.fullRawMoveTo @position()⤶    @colorPalette.rawSetExtent new Point @width(), Math.round(@height() * 0.625)⤶⤶    @grayPalette.fullRawMoveTo @colorPalette.bottomLeft()⤶    @grayPalette.rawSetExtent new Point @width(), Math.round(@height() * 0.0625)⤶⤶    x = @grayPalette.left() + Math.floor((@grayPalette.width() - @feedback.width()) / 2)⤶    y = @grayPalette.bottom() + Math.floor((@bottom() - @grayPalette.bottom() - @feedback.height()) / 2)⤶    @feedback.fullRawMoveTo new Point x, y⤶    @feedback.rawSetExtent new Point Math.min(@width(), Math.round(@height() * 0.25)), Math.round(@height() * 0.25)⤶⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶⤶    super⤶    @markLayoutAsFixed()⤶⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.DesktopAppearance_coffeSource = "class DesktopAppearance extends RectangularAppearance⤶⤶⤶  currentPattern: nil⤶⤶  # This method only paints this very morph⤶  # i.e. it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer,⤶  # which eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if @morph.preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return nil⤶⤶⤶    # set up a pattern⤶    if @morph.patternName? && @morph.patternName == @morph.pattern1⤶      @currentPattern = @morph.patternName⤶      @pattern = nil⤶⤶    if @morph.patternName? && @morph.patternName != @currentPattern⤶      @currentPattern = @morph.patternName⤶      @pattern = document.createElement ＂canvas＂⤶      @pattern.width = 5 * ceilPixelRatio⤶      @pattern.height = 5 * ceilPixelRatio⤶      pctx = @pattern.getContext ＂2d＂⤶      pctx.useLogicalPixelsUntilRestore()⤶⤶      switch @morph.patternName⤶        when @morph.pattern2⤶          pctx.fillStyle = 'rgb(244, 243, 244)'⤶          pctx.fillRect 0,0,5,5⤶          pctx.lineWidth = 0.25⤶          pctx.beginPath()⤶          pctx.arc 2,2,2,0,2*Math.PI⤶          pctx.fillStyle = 'rgb(220, 219, 220)'⤶          pctx.fill()⤶        when @morph.pattern3⤶          pctx.fillStyle = 'rgb(244, 243, 244)'⤶          pctx.fillRect 0,0,5,5⤶          pctx.moveTo 1,0⤶          pctx.lineTo 1,5⤶          pctx.strokeStyle = 'rgb(225, 224, 225)'⤶          pctx.stroke()⤶        when @morph.pattern4⤶          pctx.fillStyle = 'rgb(244, 243, 244)'⤶          pctx.fillRect 0,0,5,5⤶          pctx.moveTo 0,5⤶          pctx.lineTo 5,0⤶          pctx.strokeStyle = 'rgb(225, 224, 225)'⤶          pctx.stroke()⤶        when @morph.pattern5⤶          pctx.fillStyle = 'rgb(244, 243, 244)'⤶          pctx.fillRect 0,0,5,5⤶          pctx.moveTo 2,2⤶          pctx.lineTo 4,4⤶          pctx.strokeStyle = 'rgb(225, 224, 225)'⤶          pctx.stroke()⤶        when @morph.pattern6⤶          pctx.fillStyle = 'rgb(244, 243, 244)'⤶          pctx.fillRect 0,0,5,5⤶          pctx.moveTo 0,0⤶          pctx.lineTo 3,3⤶          pctx.lineTo 5,0⤶          pctx.strokeStyle = 'rgb(225, 224, 225)'⤶          pctx.stroke()⤶        when @morph.pattern7⤶          pctx.fillStyle = 'rgb(244, 243, 244)'⤶          pctx.fillRect 0,0,5,5⤶          pctx.moveTo 0,5⤶          pctx.lineTo 5,0⤶          pctx.moveTo 2.5,2.5⤶          pctx.lineTo 0,0⤶          pctx.strokeStyle = 'rgb(225, 224, 225)'⤶          pctx.stroke()⤶⤶⤶      @pattern = aContext.createPattern(@pattern, 'repeat')⤶⤶⤶⤶    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    @morph.justBeforeBeingPainted?()⤶⤶    aContext.save()⤶    aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @morph.alpha⤶    if !@morph.color? then debugger⤶    aContext.fillStyle = @morph.color.toString()⤶⤶    # paintRectangle is usually made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, so it's generally used⤶    # outside the effect of the scaling because⤶    # of the ceilPixelRatio⤶⤶    # paint the background⤶    toBePainted = new Rectangle al, at, al + w, at + h⤶⤶    if @morph.backgroundColor?⤶      color = @morph.backgroundColor⤶      if appliedShadow?⤶        color = Color.BLACK⤶      @morph.paintRectangle aContext, toBePainted.left(), toBePainted.top(), toBePainted.width(), toBePainted.height(), color⤶⤶⤶    # now paint the actual morph, which is a rectangle⤶    # (potentially inset because of the padding)⤶    toBePainted = toBePainted.intersect @morph.boundingBoxTight().scaleBy ceilPixelRatio⤶⤶    color = @morph.color⤶    if appliedShadow?⤶      color = Color.BLACK⤶⤶    @morph.paintRectangle aContext, toBePainted.left(), toBePainted.top(), toBePainted.width(), toBePainted.height(), color⤶⤶    @drawAdditionalPartsOnBaseShape? false, false, appliedShadow, aContext, al, at, w, h⤶⤶    if !appliedShadow?⤶      @paintStroke aContext, clippingRectangle⤶⤶    if @pattern?⤶      aContext.fillStyle = @pattern⤶      aContext.fillRect toBePainted.left(), toBePainted.top(), toBePainted.width(), toBePainted.height()⤶⤶    aContext.restore()⤶⤶    # paintHighlight is usually made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, so it's generally used⤶    # outside the effect of the scaling because⤶    # of the ceilPixelRatio⤶    @paintHighlight aContext, al, at, w, h⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.EditableMarkMorph_coffeSource = "class EditableMarkMorph extends UpperRightTriangleIconicButton⤶⤶  editObject: nil⤶  editMethodAsString: ＂＂⤶⤶  constructor: (parent = nil, @editObject, @editMethodAsString) ->⤶    super parent⤶    @toolTipMessage = ＂edit code for the tool＂⤶⤶  mouseClickLeft: ->⤶    @editObject[@editMethodAsString].call @editObject⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.EmptyButtonMorph_coffeSource = "# sends a message to a target object when pressed.⤶# Doesn't have any particular shape, but can host⤶# a morph to be used as ＂face＂⤶⤶# TODO it's unclear to me why we pass a number of targets⤶# and actions in the constructor when what we could simply⤶# do is to extend this button and override the mouse events?⤶⤶class EmptyButtonMorph extends Widget⤶⤶  @augmentWith HighlightableMixin, @name⤶⤶  target: nil⤶  action: nil⤶  dataSourceMorphForTarget: nil⤶  morphEnv: nil⤶ ⤶ ⤶  doubleClickAction: nil⤶  argumentToAction1: nil⤶  argumentToAction2: nil⤶ ⤶  toolTipMessage: nil⤶ ⤶  ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked: true⤶  ⤶  # tells if the button represents a morph, in which⤶  # case we are going to highlight the Widget on hover⤶  representsAMorph: false⤶⤶  padding: 0⤶⤶⤶  # overrides to superclass⤶  color: Color.WHITE⤶⤶  constructor: (⤶      @ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked = true,⤶      @target = nil,⤶      @action = nil,⤶⤶      @faceMorph = nil,⤶⤶      @dataSourceMorphForTarget = nil,⤶      @morphEnv,⤶      @toolTipMessage = nil,⤶⤶      @doubleClickAction = nil,⤶      @argumentToAction1 = nil,⤶      @argumentToAction2 = nil,⤶      @representsAMorph = false,⤶      @padding = 0⤶      ) ->⤶⤶    # additional properties:⤶⤶    super()⤶    @defaultRejectDrags = true⤶⤶    #@color = Color.create 255, 152, 152⤶    #@color = Color.WHITE⤶    if @faceMorph?⤶⤶      if (typeof @faceMorph) == ＂string＂⤶        @faceMorph = (new StringMorph2 @faceMorph, WorldMorph.preferencesAndSettings.textInButtonsFontSize).alignCenter()⤶      @add @faceMorph⤶      @invalidateLayout()⤶  ⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    newBoundsForThisLayout = @__calculateNewBoundsWhenDoingLayout newBoundsForThisLayout⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # TODO should'be calling this rawSetBounds from here,⤶    # rather use super⤶    @rawSetBounds newBoundsForThisLayout⤶⤶    if @faceMorph?.parent == @⤶      @faceMorph.rawSetBounds newBoundsForThisLayout.insetBy @padding⤶⤶    super⤶    @markLayoutAsFixed()⤶⤶  # TODO⤶  getTextDescription: ->⤶⤶    ⤶  # TriggerMorph action:⤶  trigger: ->⤶    if @action? and @action != ＂＂⤶      #console.log ＂@target: ＂ + @target + ＂ @morphEnv: ＂ + @morphEnv⤶      @target[@action].call @target, @dataSourceMorphForTarget, @morphEnv, @argumentToAction1, @argumentToAction2⤶    return⤶⤶  triggerDoubleClick: ->⤶    # same as trigger() but use doubleClickAction instead of action property⤶    # note that specifying a doubleClickAction is optional⤶    return  unless @doubleClickAction⤶    @target[@doubleClickAction]()⤶⤶  ⤶  mouseClickLeft: (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) ->⤶    if @ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked⤶      @propagateKillPopUps()⤶    @trigger()⤶    @escalateEvent ＂mouseClickLeft＂, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9⤶⤶  mouseDoubleClick: ->⤶    @triggerDoubleClick()⤶⤶  # you shouldn't be able to drag a compound⤶  # morphs containing a button by dragging the button⤶  # (because you expect buttons attached to anything but the⤶  # world to be ＂slippery＂, i.e.⤶  # you can ＂skid＂ your drag over it in case you change⤶  # your mind on pressing it)⤶  # and you shouldn't be able to drag the button away either⤶  # so the drag is entirely rejected⤶  rejectDrags: ->⤶    if @parent instanceof WorldMorph⤶      return false⤶    else⤶      return @defaultRejectDrags⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ErrorsLogViewerMorph_coffeSource = "# to make this error log viewer come up, edit any code⤶# in the inspector so to get a compilation error⤶# (e.g. unmatched parens) and click ＂save＂⤶⤶class ErrorsLogViewerMorph extends Widget⤶⤶  tempPromptEntryField: nil⤶  defaultContents: ＂＂⤶  textMorph: nil⤶⤶  clearButton: nil⤶  pauseToggle: nil⤶  okButton: nil⤶⤶  externalPadding: 0⤶  internalPadding: 5⤶⤶  paused: false⤶⤶  constructor: (@msg, @target, @callback, @defaultContents) ->⤶    super new Point 200,400⤶    @buildAndConnectChildren()⤶⤶  colloquialName: ->⤶    ＂Error log＂⤶⤶  closeFromContainerWindow: (containerWindow) ->⤶    @parent.hide()⤶⤶  addText: (newLog) ->⤶    if @textMorph.text.length != 0⤶      existingLog = @textMorph.text⤶    else⤶      existingLog = ＂＂⤶⤶    @textMorph.setText existingLog + ＂⧹n⧹n-----------------------------------------⧹n⧹n＂ + newLog⤶⤶⤶  showUpWithError: (err) ->⤶    unless @paused⤶      toBeAddedToLog = ＂＂⤶⤶      if world.widgetsGivingErrorWhileRepainting.length != 0⤶        toBeAddedToLog += ＂Some widgets crashed while painting themselves and⧹n＂⤶        toBeAddedToLog += ＂hence have been banned from re-painting themseves.⧹n＂⤶        toBeAddedToLog += ＂Edit/save any source code to give them another chance.⧹n⧹n＂⤶⤶      toBeAddedToLog += err⤶      if err.stack?⤶        toBeAddedToLog += ＂⧹n⧹nStack:⧹n＂ + err.stack⤶      @addText toBeAddedToLog⤶⤶    if !@parent.isVisible⤶      @parent.show()⤶      @parent.bringToForeground()⤶⤶⤶  buildAndConnectChildren: ->⤶    if Automator? and⤶     Automator.state != Automator.IDLE and⤶     Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @tempPromptEntryField = new SimplePlainTextScrollPanelWdgt @defaultContents, false, 5⤶    @tempPromptEntryField.disableDrops()⤶    @tempPromptEntryField.contents.disableDrops()⤶    @tempPromptEntryField.color = Color.WHITE⤶⤶    @textMorph = @tempPromptEntryField.textWdgt⤶    @textMorph.backgroundColor = Color.TRANSPARENT⤶    @textMorph.setFontName nil, nil, @textMorph.monoFontStack⤶    @textMorph.isEditable = true⤶    @textMorph.enableSelecting()⤶⤶    @add @tempPromptEntryField⤶⤶    # buttons -------------------------------⤶    @clearButton = new SimpleButtonMorph true, @, ＂clearTextPane＂, ＂clear＂⤶    @add @clearButton⤶⤶⤶    pauseButton = new SimpleButtonMorph true, @, ＂pauseErrors＂, ＂pause＂⤶    unpauseButton = new SimpleButtonMorph true, @, ＂unpauseErrors＂, ＂un-pause＂⤶    @pauseToggle = new ToggleButtonMorph pauseButton, unpauseButton, if @paused then 1 else 0⤶    @add @pauseToggle⤶⤶    @okButton = new SimpleButtonMorph true, @, ＂closeFromContainerWindow＂, ＂ok＂⤶    @add @okButton⤶⤶    @invalidateLayout()⤶⤶  pauseErrors: ->⤶    @paused = true⤶⤶  unpauseErrors: ->⤶    @paused = false⤶⤶  clearTextPane: ->⤶    @textMorph.setText ＂＂⤶⤶  informTarget: ->⤶    @target[@callback].call @target, nil, @textMorph⤶⤶  notifyTargetAndClose: ->⤶    @informTarget()⤶    @close()⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    newBoundsForThisLayout = @__calculateNewBoundsWhenDoingLayout newBoundsForThisLayout⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # TODO should'be calling this rawSetBounds from here,⤶    # rather use super⤶    @rawSetBounds newBoundsForThisLayout⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶⤶    mainCanvasHeight = @height() - 2 * @externalPadding - @internalPadding - WorldMorph.preferencesAndSettings.handleSize⤶    mainCanvasBottom = @top() + @externalPadding + mainCanvasHeight⤶⤶    if @tempPromptEntryField.parent == @⤶      @tempPromptEntryField.fullRawMoveTo new Point @left() + @externalPadding, @top() + @externalPadding⤶      @tempPromptEntryField.rawSetExtent new Point @width() - 2 * @externalPadding, mainCanvasHeight⤶⤶⤶    # buttons -------------------------------⤶    ⤶⤶    eachButtonWidth = (@width() - 2* @externalPadding - 3 * @internalPadding - WorldMorph.preferencesAndSettings.handleSize) / 3⤶⤶    if @clearButton.parent == @⤶      buttonBounds = new Rectangle new Point @left() + @externalPadding + 0*(eachButtonWidth + @internalPadding), mainCanvasBottom + @internalPadding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight eachButtonWidth, 15⤶      @clearButton.doLayout buttonBounds⤶⤶    if @pauseToggle.parent == @⤶      buttonBounds = new Rectangle new Point @left() + @externalPadding + 1*(eachButtonWidth + @internalPadding), mainCanvasBottom + @internalPadding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight eachButtonWidth, 15⤶      @pauseToggle.doLayout buttonBounds⤶⤶    if @okButton.parent == @⤶      buttonBounds = new Rectangle new Point @left() + @externalPadding + 2*(eachButtonWidth + @internalPadding), mainCanvasBottom + @internalPadding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight eachButtonWidth, 15⤶      @okButton.doLayout buttonBounds⤶⤶    # ----------------------------------------------⤶⤶⤶    world.maybeEnableTrackChanges()⤶    if Automator? and⤶     Automator.state != Automator.IDLE and⤶     Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶⤶    super⤶    @markLayoutAsFixed()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.FittingSpecTextInLargerBounds_coffeSource = "# FittingSpecTextInLargerBounds⤶⤶⤶class FittingSpecTextInLargerBounds⤶  @FLOAT: false⤶  @SCALEUP: true⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.FittingSpecTextInSmallerBounds_coffeSource = "# FittingSpecTextInSmallerBounds⤶⤶⤶class FittingSpecTextInSmallerBounds⤶  @CROP: true⤶  @SCALEDOWN: false⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.FolderPanelWdgt_coffeSource = "# a FolderPanelWdgt is a Panel that:⤶#⤶# 1) lets user create new folders in them⤶# 2) holds neatly any desktop system links in a grid⤶#    (including, but not limited to, other desktop system links that refer⤶#    to widgets and folders).⤶# 3) has extra logic such that any widget dropped in it ＂becomes＂⤶#    a reference to such widget, and the widget is moved to the basement.⤶#    The reason for this is that the actual ＂rest＂ place where⤶#    general widgets should be is in the basement.⤶#    The simulated ＂file system＂ (i.e. shortcuts and folders) is just a⤶#    network of pointers to stuff that ＂rests＂ in the basement and is⤶#    pulled in/out of it as the user works with them.⤶#⤶# Note that the panel of the Basement IS NOT a FolderPanelWdgt⤶# because it doesn't need any of these behaviours.⤶#⤶# Also, the desktop IS NOT a FolderPanelWdgt because it⤶# doesn't need 3)⤶⤶class FolderPanelWdgt extends PanelWdgt⤶⤶  @augmentWith GridPositioningOfAddedShortcutsMixin, @name⤶  @augmentWith KeepIconicDesktopSystemLinksBackMixin, @name⤶  @augmentWith CreateShortcutOfDroppedItemsMixin, @name⤶⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    menu.addLine()⤶    menu.addMenuItem ＂new folder＂, true, @, ＂makeFolder＂, ＂make a new folder＂⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.FolderWindowWdgt_coffeSource = "class FolderWindowWdgt extends WindowWdgt⤶⤶⤶  constructor: (@labelContent, @closeButton, @contents, @internal = false) ->⤶    @contents = new ScrollPanelWdgt new FolderPanelWdgt⤶    super ＂＂, @closeButton, @contents, @internal⤶⤶⤶  representativeIcon: ->⤶    new GenericShortcutIconWdgt new FolderIconWdgt⤶⤶  closeFromWindowBar: ->⤶    if !world.anyReferenceToWdgt @⤶      prompt = new SaveShortcutPromptWdgt @, @⤶      prompt.popUpAtHand()⤶    else⤶      @close()⤶⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    @contents.contents.addMorphSpecificMenuEntries morphOpeningThePopUp, menu⤶⤶  createReference: (referenceName, whichFolderPanelToAddTo) ->⤶    # this function can also be called as a callback⤶    # of a trigger, in which case the first parameter⤶    # here is a menuItem. We take that parameter away⤶    # in that case.⤶    if referenceName? and typeof(referenceName) != ＂string＂⤶      referenceName = nil⤶⤶    morphToAdd = new IconicDesktopSystemFolderShortcutWdgt @, referenceName⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    whichFolderPanelToAddTo.add morphToAdd⤶    morphToAdd.setExtent new Point 75, 75⤶    morphToAdd.fullChanged()⤶    @bringToForeground()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.GlassBoxBottomWdgt_coffeSource = "# the glassbox bottom goes UNDER a thumbnail, it provides⤶# support for both a widget that would go on top of⤶# it, and potentially for the glass box top that⤶# might be at the top of everything.⤶# This helps with the following: it provides a⤶# visually contrasting background and it gives⤶# a larger target to grab the widget.⤶⤶class GlassBoxBottomWdgt extends BoxMorph⤶⤶  constructor: ->⤶    super⤶    @setColor Color.create 230,230,230⤶    @strokeColor = Color.create 196,195,196⤶    @setAlphaScaled 50⤶⤶  reLayout: ->⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶    thumbnailSize = @width()⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶    for w in childrenNotHandlesNorCarets⤶⤶      if (w instanceof MenuItemMorph)⤶        w.fullRawMoveTo @topLeft().add((new Point 0 ,(@height() - w.height())/2 ).round())⤶      else⤶        if w.idealRatioWidthToHeight?⤶          ratio = w.idealRatioWidthToHeight⤶          if ratio > 1⤶            # more wide than tall⤶            w.rawSetExtent new Point thumbnailSize, thumbnailSize / ratio⤶          else⤶            # more tall than wide⤶            w.rawSetExtent new Point thumbnailSize * ratio, thumbnailSize⤶        else⤶          w.rawSetExtent new Point thumbnailSize, thumbnailSize⤶⤶        w.fullRawMoveTo @topLeft().add((new Point (thumbnailSize - w.width())/2 ,(thumbnailSize - w.height())/2 ).round())⤶⤶⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.GlassBoxTopWdgt_coffeSource = "# If the widget in the tool panel doesn't⤶# need to be interactive (i.e. it's just there⤶# to be dragged out, then we should put⤶# this glass top on it, so that it prevents⤶# mouse actions to reach the widget, and it⤶# provides a larger target area to grab the⤶# widget)⤶⤶class GlassBoxTopWdgt extends Widget⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith WidgetCreatorAndSmartPlacerOnClickMixin, @name⤶⤶  createWidgetToBeHandled: ->⤶    widgetToBeHandled = @parent.children[0].fullCopy()⤶    widgetToBeHandled.isTemplate = false⤶    return widgetToBeHandled⤶⤶  # grab the widget inside the glass box⤶  # i.e. the first child of my parent⤶  # i.e. the first child of the glass box bottom⤶  findRootForGrab: ->⤶    return @parent.children[0]⤶⤶  setColor: (theColor, ignored, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @connectionsCalculationToken = connectionsCalculationToken⤶    @parent?.setColor theColor, ignored, connectionsCalculationToken⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.GrayPaletteMorph_coffeSource = "class GrayPaletteMorph extends ColorPaletteMorph⤶⤶  constructor: (@target = nil, sizePoint) ->⤶    super @target, sizePoint or new Point 80, 10⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    @layoutSpecDetails = new WindowContentLayoutSpec PreferredSize.DONT_MIND , PreferredSize.DONT_MIND, 1⤶⤶  colloquialName: ->⤶    ＂shades of gray＂⤶  ⤶  # no changes of position or extent should be⤶  # performed in here⤶  createRefreshOrGetBackBuffer: ->⤶⤶    cacheKey =⤶      @constructor.name + ＂-＂ + @extent().toString()⤶⤶    cacheHit = world.cacheForImmutableBackBuffers.get cacheKey⤶    if cacheHit? then return cacheHit⤶⤶    extent = @extent()⤶    backBuffer = HTMLCanvasElement.createOfPhysicalDimensions extent.scaleBy ceilPixelRatio⤶    backBufferContext = backBuffer.getContext ＂2d＂⤶    backBufferContext.useLogicalPixelsUntilRestore()⤶    @choice = Color.BLACK⤶    gradient = backBufferContext.createLinearGradient 0, extent.y, extent.x, extent.y⤶    gradient.addColorStop 0, Color.BLACK.toString()⤶    gradient.addColorStop 1, Color.WHITE.toString()⤶    backBufferContext.fillStyle = gradient⤶    backBufferContext.fillRect 0, 0, extent.x, extent.y⤶⤶    cacheEntry = [backBuffer, backBufferContext]⤶    world.cacheForImmutableBackBuffers.set cacheKey, cacheEntry⤶    return cacheEntry⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.HandleMorph_coffeSource = "# not to be confused with the ActivePointerWdgt⤶# I am a resize / move handle that can be attached to any Widget⤶⤶class HandleMorph extends Widget⤶⤶  target: nil⤶  inset: nil⤶  type: nil⤶⤶  state: 0⤶  STATE_NORMAL: 0⤶  STATE_HIGHLIGHTED: 1⤶⤶  constructor: (@target = nil, @type = ＂resizeBothDimensionsHandle＂) ->⤶⤶    # some minimum padding with whatever edge we⤶    # end up against, it looks better⤶    minimumPadding = 2⤶⤶    if @target?.padding?⤶      @inset = new Point Math.max(@target.padding, minimumPadding), Math.max(@target.padding, minimumPadding)⤶    else⤶      @inset = new Point minimumPadding, minimumPadding⤶    super()⤶    @color = Color.WHITE⤶    @noticesTransparentClick = true⤶⤶    @layoutSpec_cornerInternal_proportionOfParent = 0⤶    @layoutSpec_cornerInternal_fixedSize = WorldMorph.preferencesAndSettings.handleSize⤶    @layoutSpec_cornerInternal_inset = @inset⤶⤶    @makeHandleSolidWithParentMorph nil, nil, @target⤶⤶  detachesWhenDragged: ->⤶    if (@parent instanceof WorldMorph)⤶      return true⤶    else⤶      return false⤶⤶  # HandleMorphs are one of the few morphs that⤶  # by default don't stick to their parents.⤶  # Also SliderButtonMorphs tend do the same (if⤶  # they are attached to a SliderMorph)⤶  # The ＂move＂ HandleMorph COULD grab to its⤶  # parent, in fact it would be easier, however for⤶  # uniformity we don't do that⤶  grabsToParentWhenDragged: ->⤶    return false⤶⤶⤶  iHaveBeenAddedTo: (whereTo, beingDropped) ->⤶    @moveInFrontOfSiblings()⤶⤶  updateVisibility: ->⤶    # TODO rather than updating the visibility, we could⤶    # just make it ＂inactive＂ and by drawing it gray, which⤶    # would also look better (rather than a hole with⤶    # nothing)⤶    if @parent.layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING⤶      @show()⤶    else⤶      @hide()⤶⤶⤶  # This method only paints this very morph's ＂image＂,⤶  # it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which⤶  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if @preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return⤶⤶    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    aContext.save()⤶⤶    # clip out the dirty rectangle as we are⤶    # going to paint the whole of the box⤶    aContext.clipToRectangle al,at,w,h⤶⤶    aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @alpha⤶⤶    aContext.useLogicalPixelsUntilRestore()⤶    morphPosition = @position()⤶    aContext.translate morphPosition.x, morphPosition.y⤶⤶    if @state == @STATE_NORMAL⤶      @handleMorphRenderingHelper aContext, @color, Color.create 150, 150, 150⤶    if @state == @STATE_HIGHLIGHTED⤶      @handleMorphRenderingHelper aContext, Color.WHITE, Color.create 200, 200, 255⤶⤶    aContext.restore()⤶⤶    # paintHighlight is usually made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, so it's generally used⤶    # outside the effect of the scaling because⤶    # of the ceilPixelRatio (i.e. after the restore)⤶    @paintHighlight aContext, al, at, w, h⤶⤶  drawArrow: (context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown) ->⤶    context.beginPath()⤶    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y⤶    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftUp.x, 0.5 + leftArrowPoint.y + arrowPieceLeftUp.y⤶    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y⤶    context.lineTo 0.5 + leftArrowPoint.x + arrowPieceLeftDown.x, 0.5 + leftArrowPoint.y + arrowPieceLeftDown.y⤶⤶    context.moveTo 0.5 + leftArrowPoint.x, 0.5 + leftArrowPoint.y⤶    context.lineTo 0.5 + rightArrowPoint.x, 0.5 + rightArrowPoint.y⤶⤶    context.lineTo 0.5 + rightArrowPoint.x + arrowPieceRightUp.x, 0.5 + rightArrowPoint.y + arrowPieceRightUp.y⤶    context.moveTo 0.5 + rightArrowPoint.x, 0.5 + rightArrowPoint.y⤶    context.lineTo 0.5 + rightArrowPoint.x + arrowPieceRightDown.x, 0.5 + rightArrowPoint.y + arrowPieceRightDown.y⤶⤶    context.closePath()⤶    context.stroke()⤶⤶  # from Chrome code coverage - it doesn't seem tha this is used?⤶  # TODO check and remove if not needed⤶  drawHandle: (context) ->⤶⤶    # horizontal arrow⤶    if @type is ＂resizeHorizontalHandle＂ or @type is ＂moveHandle＂⤶      p0 = @bottomLeft().subtract(@position())⤶      p0 = p0.subtract new Point 0, Math.ceil(@height()/2)⤶      ⤶      leftArrowPoint = p0.add new Point Math.ceil(@width()/15), 0⤶⤶      rightArrowPoint = p0.add new Point @width() - Math.ceil(@width()/14), 0⤶      arrowPieceLeftUp = new Point Math.ceil(@width()/5),-Math.ceil(@height()/5)⤶      arrowPieceLeftDown = new Point Math.ceil(@width()/5),Math.ceil(@height()/5)⤶      arrowPieceRightUp = new Point -Math.ceil(@width()/5),-Math.ceil(@height()/5)⤶      arrowPieceRightDown = new Point -Math.ceil(@width()/5),Math.ceil(@height()/5)⤶      @drawArrow context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown⤶⤶    # vertical arrow⤶    if @type is ＂resizeVerticalHandle＂ or @type is ＂moveHandle＂⤶      p0 = @bottomCenter().subtract @position()⤶      ⤶      leftArrowPoint = p0.add new Point 0, -Math.ceil(@height()/14)⤶⤶      rightArrowPoint = p0.add new Point 0, -@height() + Math.ceil(@height()/15)⤶      arrowPieceLeftUp = new Point -Math.ceil(@width()/5), -Math.ceil(@height()/5)⤶      arrowPieceLeftDown = new Point Math.ceil(@width()/5), -Math.ceil(@height()/5)⤶      arrowPieceRightUp = new Point -Math.ceil(@width()/5), Math.ceil(@height()/5)⤶      arrowPieceRightDown = new Point Math.ceil(@width()/5), Math.ceil(@height()/5)⤶      @drawArrow context, leftArrowPoint, rightArrowPoint, arrowPieceLeftUp, arrowPieceLeftDown, arrowPieceRightUp, arrowPieceRightDown⤶⤶⤶    # draw the traditional ＂striped triangle＂ resizer⤶    if @type is ＂resizeBothDimensionsHandle＂⤶      bottomLeft = @bottomLeft().subtract(@position())⤶      topRight = @topRight().subtract(@position())⤶⤶      bottomLeftSweep = bottomLeft.copy()⤶      topRightSweep = topRight.copy()⤶⤶      # draw the lines sweeping from long lines⤶      # down to the short ones at the corner⤶      for i in [0..@height()] by 6⤶        # bottomLeftSweep moves right⤶        bottomLeftSweep.x = bottomLeft.x + i⤶        # topRightSweep moves down⤶        topRightSweep.y = topRight.y + i⤶        context.beginPath()⤶        context.moveTo bottomLeftSweep.x, bottomLeftSweep.y⤶        context.lineTo topRightSweep.x, topRightSweep.y⤶        context.closePath()⤶        context.stroke()⤶⤶⤶  handleMorphRenderingHelper: (context, color, shadowColor) ->⤶    context.lineWidth = 0.5⤶    context.lineCap = ＂round＂⤶⤶    # give it a good shadow so that⤶    # it's visible also when on light⤶    # background. Do that by painting it⤶    # twice, slightly translated, in⤶    # darker color.⤶    context.save()⤶    context.strokeStyle = shadowColor.toString()⤶    context.translate 1,1⤶    @drawHandle context⤶    context.translate 1,0⤶    @drawHandle context⤶    context.restore()⤶⤶    context.strokeStyle = color.toString()⤶    @drawHandle context⤶⤶⤶  ⤶⤶  # implement dummy methods in here⤶  # so the handle catches the clicks and⤶  # prevents the parent from doing anything.⤶  mouseClickLeft: ->⤶  mouseUpLeft: ->⤶  ⤶  # same here, the handle doesn't want to propagate⤶  # anything, otherwise the handle on a button⤶  # will trigger the button when resizing.⤶  mouseDownLeft: (pos) ->⤶    return nil  unless @target⤶    @target.bringToForeground()⤶⤶  nonFloatDragging: (nonFloatDragPositionWithinWdgtAtStart, pos, deltaDragFromPreviousCall) ->⤶    newPos = pos.subtract nonFloatDragPositionWithinWdgtAtStart⤶    switch @type⤶      # 1. all these changes applied to the target are all deferred⤶      # 2. the position of this handle will be changed when the⤶      # doLayout method of the parent of the handle will be called⤶      # ...i.e. *after* the parent has re-layouted (in the deferred layout phase).⤶      when ＂resizeBothDimensionsHandle＂⤶        newExt = newPos.add(@extent().add(@inset)).subtract @target.position()⤶        @target.setExtent newExt, @⤶      when ＂moveHandle＂⤶        @target.fullMoveTo (newPos.subtract @inset), @⤶      when ＂resizeHorizontalHandle＂⤶        newWidth = newPos.x + @extent().x + @inset.x - @target.left()⤶        @target.setWidth newWidth⤶      when ＂resizeVerticalHandle＂⤶        newHeight = newPos.y + @extent().y + @inset.y - @target.top()⤶        @target.setHeight newHeight⤶  ⤶  ⤶  # HandleMorph events:⤶  mouseEnter: ->⤶    #console.log ＂<<<<<< handle mousenter＂⤶    @state = @STATE_HIGHLIGHTED⤶    @changed()⤶  ⤶  mouseLeave: ->⤶    #console.log ＂<<<<<< handle mouseleave＂⤶    @state = @STATE_NORMAL⤶    @changed()⤶⤶  makeHandleSolidWithParentMorph: (ignored, ignored2, morphAttachedTo)->⤶    if morphAttachedTo?⤶      @target = morphAttachedTo⤶      switch @type⤶        when ＂resizeBothDimensionsHandle＂⤶          @target.add @, nil, LayoutSpec.ATTACHEDAS_CORNER_INTERNAL_BOTTOMRIGHT⤶        when ＂moveHandle＂⤶          @target.add @, nil, LayoutSpec.ATTACHEDAS_CORNER_INTERNAL_TOPLEFT⤶        when ＂resizeHorizontalHandle＂⤶          @target.add @, nil, LayoutSpec.ATTACHEDAS_CORNER_INTERNAL_RIGHT⤶        when ＂resizeVerticalHandle＂⤶          @target.add @, nil, LayoutSpec.ATTACHEDAS_CORNER_INTERNAL_BOTTOM⤶      @noticesTransparentClick = true⤶⤶    ⤶  # HandleMorph menu:⤶  attach: ->⤶    choices = world.plausibleTargetAndDestinationMorphs @⤶    menu = new MenuMorph @, false, @, true, true, ＂choose target:＂⤶    if choices.length > 0⤶      choices.forEach (each) =>⤶        menu.addMenuItem (each.toString().replace ＂Wdgt＂, ＂＂).slice(0, 50) + ＂ ➜＂, true, @, 'makeHandleSolidWithParentMorph', nil, nil, nil, nil, nil, each, nil, true⤶    else⤶      # the ideal would be to not show the⤶      # ＂attach＂ menu entry at all but for the⤶      # time being it's quite costly to⤶      # find the eligible morphs to attach⤶      # to, so for now let's just calculate⤶      # this list if the user invokes the⤶      # command, and if there are no good⤶      # morphs then show some kind of message.⤶      menu = new MenuMorph @, false, @, true, true, ＂no morphs to attach to＂⤶    menu.popUpAtHand() if choices.length⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.HighlighterMorph_coffeSource = "# Used to temporarily highlight morphs e.g. when you hover over⤶# a morph entry in a menu, the corresponding morph is highlighted.⤶#⤶# Doesn't cast a shadow (that would be too much, this is simple⤶# highlighting, it's not anything material that the user is⤶# supposed to click/drag/interact with).⤶#⤶# These morphs are transparently/automatically added/removed by the⤶# addHighlightingMorphs function in doOneCycle⤶# just before the @updateBroken() call.⤶#⤶# That addHighlightingMorphs function tries to be smart so to just⤶# add/modify/remove the HighlighterMorphs that⤶# are new or that need to change position or that need to go away.⤶# (i.e. HighlighterMorph are not just blindly created anew each frame)⤶# (TODO is this optimisation needed/worth it? probably not?)⤶#⤶# These morphs are always at the top, so you can always see a morph being⤶# highlighted even if it's (partially) occluded by other morphs.⤶⤶class HighlighterMorph extends RectangleMorph⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.HorizontalMenuPanelWdgt_coffeSource = "⤶# This is meant to be used as a horizontal menu bar at the top or⤶# bottom of widgets. As such, it doesn't scroll its contents and⤶# it just hides entries that are ＂beyond＂ its width, tough⤶# luck for the content that doesn't fit...⤶⤶class HorizontalMenuPanelWdgt extends PanelWdgt⤶⤶  # TODO pretty sure that we don't need numberOfIconsOnPanel⤶  numberOfIconsOnPanel: 0⤶  internalPadding: 5⤶  thumbnailSize: 30⤶⤶  constructor: ->⤶    super⤶    @rawSetExtent new Point 300,15⤶⤶  add: (aWdgt, position = nil, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING, beingDropped, unused, positionOnScreen) ->⤶⤶    if (aWdgt instanceof ModifiedTextTriangleAnnotationWdgt) or⤶     (aWdgt instanceof HandleMorph)⤶      super⤶    else⤶      aWdgt.isTemplate = true⤶      if !aWdgt.extentToGetWhenDraggedFromGlassBox?⤶        aWdgt.extentToGetWhenDraggedFromGlassBox = aWdgt.extent()⤶⤶      if !(aWdgt instanceof GlassBoxBottomWdgt)⤶        glassBoxBottom = new GlassBoxBottomWdgt⤶        glassBoxBottom.add aWdgt⤶⤶        if !aWdgt.actionableAsThumbnail⤶          glassBoxTop = new GlassBoxTopWdgt⤶          glassBoxBottom.add glassBoxTop⤶          glassBoxTop.toolTipMessage = aWdgt.toolTipMessage⤶⤶        glassBoxBottom.fullRawMoveTo @topLeft().add new Point @internalPadding, @internalPadding⤶        if (aWdgt instanceof MenuItemMorph)⤶          aWdgt.shrinkToTextSize()⤶          glassBoxBottom.rawSetExtent new Point aWdgt.width(), @thumbnailSize⤶        else⤶          glassBoxBottom.rawSetExtent new Point @thumbnailSize, @thumbnailSize⤶⤶        aWdgt = glassBoxBottom⤶⤶⤶      childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶      foundDrop = false⤶⤶      if positionOnScreen? and childrenNotHandlesNorCarets.length > 0⤶        positionNumberAmongSiblings = 0⤶⤶        for w in childrenNotHandlesNorCarets⤶          if w.bounds.growBy(@internalPadding).containsPoint positionOnScreen⤶            foundDrop = true⤶            if w.bounds.growBy(@internalPadding).rightHalf().containsPoint positionOnScreen⤶              positionNumberAmongSiblings++⤶            break⤶          positionNumberAmongSiblings++⤶      ⤶      if foundDrop⤶        super aWdgt, positionNumberAmongSiblings, layoutSpec, beingDropped⤶      else⤶        super aWdgt, @numberOfIconsOnPanel, layoutSpec, beingDropped⤶⤶      @numberOfIconsOnPanel++⤶      @reLayout()⤶⤶⤶  reLayout: ->⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶    widthOfContentsSoFar = @internalPadding⤶    countOfItems = 0⤶⤶    for w in childrenNotHandlesNorCarets⤶      if widthOfContentsSoFar + @internalPadding  + w.width() > @width()⤶        break⤶⤶      widthOfContentsSoFar += @internalPadding  + w.width()⤶      countOfItems++⤶⤶    widthLayingDown = @internalPadding⤶    for i in [0...countOfItems]⤶      childrenNotHandlesNorCarets[i].unCollapse()⤶      startingPoint = @position().add new Point (@width() - widthOfContentsSoFar)/2, 0⤶      childrenNotHandlesNorCarets[i].fullRawMoveTo (startingPoint.add new Point widthLayingDown, (@height()-childrenNotHandlesNorCarets[i].height())/2).round()⤶      widthLayingDown += childrenNotHandlesNorCarets[i].width() + @internalPadding⤶⤶    for i in [countOfItems...childrenNotHandlesNorCarets.length]⤶      childrenNotHandlesNorCarets[i].collapse()⤶⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.IconMorph_coffeSource = "class IconMorph extends Widget⤶⤶  @augmentWith KeepsRatioWhenInVerticalStackMixin, @name⤶⤶  constructor: (@color = WorldMorph.preferencesAndSettings.iconDarkLineColor) ->⤶    super()⤶    @appearance = new IconAppearance @⤶⤶  widthWithoutSpacing: ->⤶    @appearance.widthWithoutSpacing()⤶⤶  rawResizeToWithoutSpacing: ->⤶    @rawSetExtent @appearance.calculateRectangleOfIcon().extent()⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    super⤶    @layoutSpecDetails.canSetHeightFreely = false⤶⤶   ".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.IconicDesktopSystemDocumentShortcutWdgt_coffeSource = "# This is a reference to any type of document, be it a script, or an image⤶# or a slide or a note etc. etc.⤶⤶class IconicDesktopSystemDocumentShortcutWdgt extends IconicDesktopSystemShortcutWdgt⤶⤶  reactToDropOf: (droppedWidget) ->⤶⤶  constructor: (@target, @title, @icon) ->⤶    if !@icon?⤶      @icon = new GenericShortcutIconWdgt new GenericObjectIconWdgt @target.representativeIcon()⤶⤶    super @target, @title, @icon⤶⤶  mouseClickLeft: (arg1, arg2, arg3, arg4, arg5, arg6, arg7, doubleClickInvocation, arg9) ->⤶    if doubleClickInvocation⤶      return⤶⤶    if @target.destroyed⤶      @inform ＂The referenced item⧹nis dead!＂⤶      return⤶⤶    if @target.isAncestorOf @⤶      @inform ＂The referenced item is⧹nalready open and containing⧹nwhat you just clicked on!＂⤶      return⤶⤶    # the target could be hidden if it's been hidden in the⤶    # basement view ＂only show lost items＂⤶    @target.show()⤶⤶    whatToBringUp = @target.findRootForGrab()⤶    # things like draggable graphs have no root for grab,⤶    # however since they are in the basement ＂directly＂ on their own⤶    # it's OK to bring those up (as opposed to things⤶    # that are part of other widgets that are in the basement,⤶    # in that case you'd tear it off an existing widget and it⤶    # would probably be a bad thing)⤶    if !whatToBringUp? and @target.isDirectlyInBasement()⤶      whatToBringUp = @target⤶    if !whatToBringUp?⤶      @inform ＂The referenced item does exist⧹nhowever it's part of something⧹nthat can't be grabbed!＂⤶    else⤶      # let's make SURE what we are bringing up is⤶      # visible⤶      whatToBringUp.show()⤶      whatToBringUp.spawnNextTo @, world⤶      whatToBringUp.rememberFractionalSituationInHoldingPanel()⤶      whatToBringUp.setTitle? @label.text⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.IconicDesktopSystemFolderShortcutWdgt_coffeSource = "class IconicDesktopSystemFolderShortcutWdgt extends IconicDesktopSystemShortcutWdgt⤶⤶  _acceptsDrops: true⤶⤶  reactToDropOf: (droppedWidget) ->⤶    if droppedWidget instanceof IconicDesktopSystemLinkWdgt⤶      @target.contents.contents.add droppedWidget⤶    else⤶      droppedWidget.createReferenceAndClose nil, @target.contents.contents⤶⤶  constructor: (@target, @title) ->⤶    super @target, @title, new GenericShortcutIconWdgt new FolderIconWdgt⤶⤶  mouseClickLeft: (arg1, arg2, arg3, arg4, arg5, arg6, arg7, doubleClickInvocation, arg9) ->⤶    if doubleClickInvocation⤶      return⤶⤶    if @target.destroyed⤶      @inform ＂The referenced item⧹nis dead!＂⤶      return⤶⤶    if @target.isAncestorOf @⤶      @inform ＂The referenced item is⧹nalready open and containing⧹nwhat you just clicked on!＂⤶      return⤶⤶    # the target could be hidden if it's been hidden in the⤶    # basement view ＂only show lost items＂⤶    @target.show()⤶⤶    whatToBringUp = @target.findRootForGrab()⤶    # things like draggable graphs have no root for grab,⤶    # however since they are in the basement ＂directly＂ on their own⤶    # it's OK to bring those up (as opposed to things⤶    # that are part of other widgets that are in the basement,⤶    # in that case you'd tear it off an existing widget and it⤶    # would probably be a bad thing)⤶    if !whatToBringUp? and @target.isDirectlyInBasement()⤶      whatToBringUp = @target⤶    if !whatToBringUp?⤶      @inform ＂The referenced item does exist⧹nhowever it's part of something⧹nthat can't be grabbed!＂⤶    else⤶      # let's make SURE what we are bringing up is⤶      # visible⤶      whatToBringUp.show()⤶      whatToBringUp.spawnNextTo @, world⤶      whatToBringUp.rememberFractionalSituationInHoldingPanel()⤶      whatToBringUp.setTitle? @label.text⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.IconicDesktopSystemLinkWdgt_coffeSource = "# This is an icon, with a caption below, AND it has some logic⤶# to be shown ＂in its own layer＂ together with the⤶# other desktop system links. I.e. you never see a desktop system link⤶# on top of a window (unless during a drag), so in that sense⤶# the desktop system links live in their own ＂layer＂⤶⤶class IconicDesktopSystemLinkWdgt extends WidgetHolderWithCaptionWdgt⤶⤶  moveOnTopOfTopReference: ->⤶    topMostReference = @parent.topmostChildSuchThat (c) =>⤶      c != @ and (c instanceof WidgetHolderWithCaptionWdgt)⤶    if topMostReference?⤶      @parent.children.remove @⤶      index = @parent.children.indexOf topMostReference⤶      @parent.children.splice (index + 1), 0, @⤶    else⤶      @parent.children.remove @⤶      @parent.children.unshift @⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.IconicDesktopSystemScriptShortcutWdgt_coffeSource = "# Normally a shortcut just brings up another widget⤶# so normally a Script Shortcut would bring up... a ScriptWdgt⤶# However here we make an exception and insted of doing that,⤶# we actually ask the referred ScriptWdgt to run the its code.⤶⤶# TODO I don't think this should be extending IconicDesktopSystemShortcutWdgt but⤶# but rather IconicDesktopSystemLinkWdgt⤶⤶class IconicDesktopSystemScriptShortcutWdgt extends IconicDesktopSystemShortcutWdgt⤶⤶  constructor: (@target, @title, @icon) ->⤶    if !@icon?⤶      @icon = new GenericShortcutIconWdgt new ScriptIconWdgt⤶    ⤶    super @target, @title, @icon⤶⤶  mouseClickLeft: (arg1, arg2, arg3, arg4, arg5, arg6, arg7, doubleClickInvocation, arg9) ->⤶    if doubleClickInvocation⤶      return⤶⤶    if @target.destroyed⤶      @inform ＂The referenced item⧹nis dead!＂⤶      return⤶⤶    @target.contents.doAll()⤶⤶⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    menu.addLine()⤶    menu.addMenuItem ＂edit script...＂, true, @, ＂editScript＂⤶    menu⤶⤶  editScript: ->⤶    if @target.destroyed⤶      @inform ＂The referenced item⧹nis dead!＂⤶      return⤶⤶    if @target.isAncestorOf @⤶      @inform ＂The referenced item is⧹nalready open and containing⧹nwhat you just clicked on!＂⤶      return⤶⤶    # the target could be hidden if it's been hidden in the⤶    # basement view ＂only show lost items＂⤶    @target.show()⤶⤶    whatToBringUp = @target.findRootForGrab()⤶    # things like draggable graphs have no root for grab,⤶    # however since they are in the basement ＂directly＂ on their own⤶    # it's OK to bring those up (as opposed to things⤶    # that are part of other widgets that are in the basement,⤶    # in that case you'd tear it off an existing widget and it⤶    # would probably be a bad thing)⤶    if !whatToBringUp? and @target.isDirectlyInBasement()⤶      whatToBringUp = @target⤶    if !whatToBringUp?⤶      @inform ＂The referenced item does exist⧹nhowever it's part of something⧹nthat can't be grabbed!＂⤶    else⤶      # let's make SURE what we are bringing up is⤶      # visible⤶      whatToBringUp.show()⤶      whatToBringUp.spawnNextTo @, world⤶      whatToBringUp.rememberFractionalSituationInHoldingPanel()⤶      whatToBringUp.setTitle? @label.text⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.IconicDesktopSystemShortcutWdgt_coffeSource = "# a ＂shortcut＂ (for friends) is a reference to something else.⤶# What does it mean? That if you duplicate the shortcut you just⤶# duplicate a reference, and opening either one will open the⤶# SAME referenced widget. Note that you can't show TWO⤶# ＂SAME widget＂s at the same time, so opening a shortcut is likely⤶# to move the referenced widget from a location to another.⤶#⤶# If you want to duplicate the referencED widget instead, just⤶# duplicate that one, and create a reference FOR THE COPY.⤶#⤶# So, for example, is the Fizzypaint launcher icon a reference?⤶# NO, because if you duplicate the launcher, and open both of the⤶# launchers, you don't get to the SAME widget, you get to two entirely⤶# separate Fizzypaint instances that have different lifes and can be⤶# shown both at the same time on the screen.⤶⤶class IconicDesktopSystemShortcutWdgt extends IconicDesktopSystemLinkWdgt⤶⤶  @augmentWith HighlightableMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.BLACK⤶⤶  reactToDropOf: (droppedWidget) ->⤶⤶  constructor: (@target, @title, @icon) ->⤶    if !@title?⤶      @title = @target.colloquialName()⤶⤶    super @title, @icon⤶    world.widgetsReferencingOtherWidgets.add @⤶⤶  destroy: ->⤶    super⤶    world.widgetsReferencingOtherWidgets.delete @⤶⤶  alignCopiedMorphToReferenceTracker: (cloneOfMe) ->⤶    world.widgetsReferencingOtherWidgets.add cloneOfMe⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.IconicDesktopSystemWindowedAppLauncherWdgt_coffeSource = "class IconicDesktopSystemWindowedAppLauncherWdgt extends IconicDesktopSystemLinkWdgt⤶⤶  @augmentWith HighlightableMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.BLACK⤶⤶⤶  constructor: (@title, @icon, @target, @callback) ->⤶    if !@title?⤶      @title = @target.colloquialName()⤶⤶    super @title, @icon⤶⤶  mouseClickLeft: (arg1, arg2, arg3, arg4, arg5, arg6, arg7, doubleClickInvocation, arg9) ->⤶    if doubleClickInvocation⤶      return⤶⤶    @target[@callback].call @target⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.LayoutSpec_coffeSource = "# LayoutSpec⤶# ...just giving some convenient names to constants/singletons⤶⤶class LayoutSpec⤶⤶  @ATTACHEDAS_FREEFLOATING: 100000⤶  # @ATTACHEDAS_INSET: 100001⤶  @ATTACHEDAS_VERTICAL_STACK_ELEMENT: 100002⤶  @ATTACHEDAS_WINDOW_CONTENT: 100003⤶⤶  @ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED: 100004⤶  #@ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_STRETCH: 100005⤶  #@ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_TOP: 100006⤶  #@ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_CENTER: 100007⤶  #@ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_BOTTOM: 100008⤶⤶  ⤶  # @STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED: 100009⤶  # @STACK_HORIZONTAL_VERTICALALIGNMENTS_STRETCH: 100010⤶  # @STACK_HORIZONTAL_VERTICALALIGNMENTS_TOP: 100011⤶  # @STACK_HORIZONTAL_VERTICALALIGNMENTS_CENTER: 100012⤶  # @STACK_HORIZONTAL_VERTICALALIGNMENTS_BOTTOM: 100013⤶⤶⤶  @ATTACHEDAS_CORNER_INTERNAL_TOPRIGHT: 100014⤶  @ATTACHEDAS_CORNER_INTERNAL_TOPLEFT: 100015⤶  @ATTACHEDAS_CORNER_INTERNAL_BOTTOMRIGHT: 100016⤶  @ATTACHEDAS_CORNER_INTERNAL_RIGHT: 100017⤶  @ATTACHEDAS_CORNER_INTERNAL_BOTTOM: 100018⤶⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ListMorph_coffeSource = "class ListMorph extends ScrollPanelWdgt⤶  ⤶  elements: nil⤶  labelGetter: nil⤶  format: nil⤶  listContents: nil # a MenuMorph with the contents of the list⤶  selected: nil # actual element currently selected⤶  active: nil # menu item representing the selected element⤶  action: nil⤶  target: nil⤶  doubleClickAction: nil⤶⤶  constructor: (⤶    @target,⤶    @action,⤶    @elements = [],⤶    @labelGetter = (element) ->⤶        return element  if Utils.isString element⤶        return element.toSource()  if element.toSource⤶        element.toString()⤶    ,⤶⤶    @format = [],⤶    @doubleClickAction = nil⤶    ) ->⤶    #⤶    #    passing a format is optional. If the format parameter is specified⤶    #    it has to be of the following pattern:⤶    #⤶    #        [⤶    #            [<color>, <single-argument predicate>],⤶    #            ['bold', <single-argument predicate>],⤶    #            ['italic', <single-argument predicate>],⤶    #            ...⤶    #        ]⤶    #⤶    #    multiple conditions can be passed in such a format list, the⤶    #    last predicate to evaluate true when given the list element sets⤶    #    the given format category (color, bold, italic).⤶    #    If no condition is met, the default format (color black, non-bold,⤶    #    non-italic) will be assigned.⤶    #    ⤶    #    An example of how to use formats can be found in the InspectorMorph's⤶    #    ＂markOwnProperties＂ mechanism.⤶    #⤶    #debugger⤶    super()⤶    @contents.disableDrops()⤶    @color = Color.WHITE⤶    @buildAndConnectChildren() # builds the list contents⤶    # it's important to leave the step as the default noOperation⤶    # instead of nil because the scrollbars (inherited from ScrollPanel)⤶    # need the step function to react to mouse floatDrag.⤶  ⤶  # builds the list contents⤶  buildAndConnectChildren: ->⤶    @listContents = new MenuMorph @, true, @, false, false, nil, nil⤶    @listContents.isLockingToPanels = true⤶    @elements = [＂(empty)＂]  if !@elements.length⤶    world.disableTrackChanges()⤶    @elements.forEach (element) =>⤶      color = nil⤶      bold = false⤶      italic = false⤶      @format.forEach (pair) ->⤶        if pair[1].call nil, element⤶          switch pair[0]⤶            when 'bold'⤶              bold = true⤶            when 'italic'⤶              italic = true⤶            else # assume it's a color⤶              color = pair[0]⤶⤶      #labelString,⤶      #action,⤶      #toolTipMessage,⤶      #color,⤶      #bold = false,⤶      #italic = false,⤶      #doubleClickAction # optional, when used as list contents⤶⤶      #console.log ＂@labelGetter(element): ＂ + @labelGetter(element)⤶      @listContents.addMenuItem(⤶        @labelGetter(element), # labelString⤶        true,⤶        @, # target⤶        ＂select＂, # action⤶        nil, # toolTipMessage⤶        color, # color⤶        bold, # bold⤶        italic, # italic⤶        @doubleClickAction # doubleClickAction⤶      )⤶⤶    world.maybeEnableTrackChanges()⤶    @listContents.silentFullRawMoveTo @contents.position()⤶    @listContents.reLayout()⤶    ⤶    @add @listContents⤶  ⤶  select: (item, trigger) ->⤶    @selected = item⤶    @active = trigger⤶    if @action? and @action != ＂＂⤶      @target[@action].call @target, item.labelString⤶    return⤶⤶  ⤶  rawSetExtent: (aPoint) ->⤶    unless aPoint.equals @extent()⤶      #console.log ＂move 3＂⤶      @breakNumberOfRawMovesAndResizesCaches()⤶      lb = @listContents.boundingBox()⤶      nb = @bounds.origin.corner @bounds.origin.add aPoint⤶      if nb.right() > lb.right() and nb.width() <= lb.width()⤶        @listContents.fullRawMoveRightSideTo nb.right()⤶      if nb.bottom() > lb.bottom() and nb.height() <= lb.height()⤶        @listContents.fullRawMoveBottomSideTo nb.bottom()⤶      super aPoint⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ModifiedTextTriangleAnnotationWdgt_coffeSource = "class ModifiedTextTriangleAnnotationWdgt extends Widget⤶⤶  @augmentWith CornerInternalHaloMixin, @name⤶  positionWithinParent: ＂topLeft＂⤶⤶  constructor: (parent = nil, @layoutSpec_cornerInternal_proportionOfParent = 0, @layoutSpec_cornerInternal_fixedSize = 10) ->⤶    super()⤶    @appearance = new UpperRightTriangleAppearance @, @positionWithinParent⤶⤶    # this morph has triangular shape and we want it⤶    # to only react to pointer events happening⤶    # within tha shape⤶    @noticesTransparentClick = false⤶⤶    size = WorldMorph.preferencesAndSettings.handleSize⤶    @silentRawSetExtent new Point size, size⤶    parent?.add @, nil, LayoutSpec.ATTACHEDAS_CORNER_INTERNAL_TOPLEFT⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.PopUpWdgt_coffeSource = "# PopUp widgets are special Widgets that have quite complex logic for⤶# opening themselves, closing themseves when users click outside,⤶# popping up, opening sub-widgets, and pinning them down.⤶# They don't specify their own ＂look＂ (apart from shadowsn, see below),⤶# nor the contents or the look of the contents.⤶#⤶# PopUps have 3 different shadows: ＂normal＂, ＂when dragged＂ and⤶# ＂pinned on desktop＂, plus no shadow when pinned on anything⤶# else other than the desktop.⤶⤶class PopUpWdgt extends Widget⤶⤶  killThisPopUpIfClickOnDescendantsTriggers: true⤶  killThisPopUpIfClickOutsideDescendants: true⤶  isPopUpMarkedForClosure: false⤶  # the morphOpeningThePopUp is only useful to get the ＂parent＂ pop-up.⤶  # the ＂parent＂ pop-up is the menu that this menu is attached to,⤶  # but we need this extra property because it's not the⤶  # actual parent. The reason is that menus are actually attached⤶  # to the world morph. This is for a couple of reasons:⤶  # 1) they can still appear at the top even if the ＂parent menu＂⤶  #    or the parent object are not in the foreground. This is⤶  #    what happens for example in OSX, you can right-click on a⤶  #    morph that is not in the background but the menu that comes up⤶  #    will be in the foreground.⤶  # 2) they can appear unoccluded if the ＂parent morph＂ or ＂parent object＂⤶  #    are in a morph that clips at its boundaries.⤶  morphOpeningThePopUp: nil⤶⤶  constructor: (@morphOpeningThePopUp, @killThisPopUpIfClickOutsideDescendants = true, @killThisPopUpIfClickOnDescendantsTriggers = true) ->⤶    super()⤶    @isLockingToPanels = false⤶    world.freshlyCreatedPopUps.add @⤶    world.openPopUps.add @⤶⤶  hierarchyOfPopUps: ->⤶    ascendingWdgts = @⤶    hierarchy = new Set [ascendingWdgts]⤶    while ascendingWdgts?.getParentPopUp?⤶      ascendingWdgts = ascendingWdgts.getParentPopUp()⤶      if ascendingWdgts?⤶        hierarchy.add ascendingWdgts⤶    return hierarchy⤶⤶  # for pop ups, the propagation happens through the getParentPopUp method⤶  # rather than the parent property, but for other normal widgets it goes⤶  # up the parent property⤶  propagateKillPopUps: ->⤶    if @killThisPopUpIfClickOnDescendantsTriggers⤶      @getParentPopUp()?.propagateKillPopUps()⤶      @markPopUpForClosure()⤶⤶  markPopUpForClosure: ->⤶    world.popUpsMarkedForClosure.add @⤶    @isPopUpMarkedForClosure = true⤶⤶  # why introduce a new flag when you can calculate⤶  # from existing flags?⤶  isPopUpPinned: ->⤶    return !(@killThisPopUpIfClickOnDescendantsTriggers or @killThisPopUpIfClickOutsideDescendants)⤶⤶  getParentPopUp: ->⤶    if @isPopUpPinned()⤶      return @parent⤶    else⤶      if @morphOpeningThePopUp?⤶        return @morphOpeningThePopUp.firstParentThatIsAPopUp()⤶    return nil⤶⤶  firstParentThatIsAPopUp: ->⤶    if !@isPopUpMarkedForClosure or !@parent? then return @⤶    return @parent.firstParentThatIsAPopUp()⤶⤶  # this is invoked on the menu morph to be⤶  # pinned. The triggering menu item is the first⤶  # parameter.⤶  pinPopUp: (pinMenuItem)->⤶    @killThisPopUpIfClickOnDescendantsTriggers = false⤶    @killThisPopUpIfClickOutsideDescendants = false⤶    @onClickOutsideMeOrAnyOfMyChildren nil⤶    if pinMenuItem?⤶      pinMenuItem.firstParentThatIsAPopUp().propagateKillPopUps()⤶    else⤶      @getParentPopUp()?.propagateKillPopUps()⤶    world.closePopUpsMarkedForClosure()⤶    ⤶    # leave the menu attached to whatever it's attached,⤶    # just change the shadow.⤶    @updatePopUpShadow()⤶⤶⤶  fullCopy: ->⤶    copiedMorph = super⤶    copiedMorph.onClickOutsideMeOrAnyOfMyChildren nil⤶    copiedMorph.killThisPopUpIfClickOnDescendantsTriggers = false⤶    copiedMorph.killThisPopUpIfClickOutsideDescendants = false⤶    return copiedMorph⤶⤶⤶  addMorphSpecificMenuEntries: (unused_morphOpeningThePopUp, menu) ->⤶    super⤶    menu.addLine()⤶    menu.addMenuItem ＂pin＂, false, @, ＂pin＂⤶ ⤶  justDropped: (whereIn) ->⤶    super⤶    if whereIn != world⤶      @pinPopUp()⤶⤶    @updatePopUpShadow()⤶⤶  updatePopUpShadow: ->⤶    if @isPopUpPinned()⤶      if @parent == world⤶        @addShadow()⤶      else⤶        @removeShadow()⤶    else⤶      @addShadow()⤶⤶  # shadow is added to a morph by⤶  # the ActivePointerWdgt while floatDragging⤶  addShadow: (offset = new Point(5, 5), alpha = 0.2, color) ->⤶⤶    if @isPopUpPinned() and @parent == world⤶      super new Point(3, 3), 0.3⤶      return⤶⤶    super offset, alpha⤶  ⤶  popUpCenteredAtHand: (world) ->⤶    @popUp (world.hand.position().subtract @extent().floorDivideBy 2), world⤶  ⤶⤶⤶  popUpAtHand: ->⤶    @popUp world.hand.position(), world⤶⤶  popUp: (pos, morphToAttachTo) ->⤶    # console.log ＂menu popup＂⤶    @silentFullRawMoveTo pos⤶    morphToAttachTo.add @⤶    # the @fullRawMoveWithin method⤶    # needs to know the extent of the morph⤶    # so it must be called after the morphToAttachTo.add⤶    # method. If you call before, there is⤶    # nopainting happening and the morph doesn't⤶    # know its extent.⤶    @fullRawMoveWithin world⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶    # shadow must be added after the morph⤶    # has been placed somewhere because⤶    # otherwise there is no visible image⤶    # to base the shadow on⤶    # P.S. this is the thing that causes the MenuMorph buffer⤶    # to be painted after the creation.⤶    @addShadow()⤶    @fullChanged()⤶⤶  destroy: ->⤶    super()⤶    world.openPopUps.delete @⤶⤶  close: ->⤶    super()⤶    world.openPopUps.delete @⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.PreferencesAndSettings_coffeSource = "# World-wide preferences and settings ///////////////////////////////////⤶⤶# Contains all possible preferences and settings for a World.⤶# So it's World-wide values.⤶# It belongs to a world, each world may have different settings.⤶⤶class PreferencesAndSettings⤶⤶  @augmentWith DeepCopierMixin⤶⤶  @INPUT_MODE_MOUSE: 0⤶  @INPUT_MODE_TOUCH: 1⤶⤶  # all these properties can be modified⤶  # by the input mode.⤶  inputMode: nil⤶  minimumFontHeight: nil⤶  shortcutsFontSize: nil⤶  menuFontName: nil⤶  menuFontSize: nil⤶  menuHeaderFontSize: nil⤶  menuHeaderColor: nil⤶  menuHeaderBold: nil⤶  menuStrokeColor: nil⤶  menuBackgroundColor: nil⤶  menuButtonsLabelColor: nil⤶  normalTextFontSize: nil⤶  textInButtonsFontSize: nil⤶  titleBarTextFontSize: nil⤶  titleBarBoldText: nil⤶  titleBarTextHeight: nil⤶  bubbleHelpFontSize: nil⤶  prompterFontName: nil⤶  prompterFontSize: nil⤶  prompterSliderSize: nil⤶  handleSize: nil⤶  scrollBarsThickness: nil⤶⤶  outlineColor: nil⤶  outlineColorString: nil⤶⤶  wheelScaleX: 1⤶  wheelScaleY: 1⤶  wheelScaleZ: 1⤶  invertWheelX: true⤶  invertWheelY: true⤶  invertWheelZ: true⤶⤶  useSliderForInput: nil⤶  useVirtualKeyboard: nil⤶  isTouchDevice: nil⤶  rasterizeSVGs: nil⤶  isFlat: nil⤶  grabDragThreshold: 7⤶⤶  # decimalFloatFiguresOfFontSizeGranularity allows you to go into sub-points⤶  # in the font size. This is so the resizing of the⤶  # text is less ＂jumpy＂.⤶  # ＂1＂ seems to be perfect in terms of jumpiness,⤶  # but obviously this routine gets quite a bit more⤶  # expensive.⤶  @decimalFloatFiguresOfFontSizeGranularity: 0⤶⤶  constructor: ->⤶    @setMouseInputMode()⤶⤶⤶⤶⤶  # answer the height of the smallest font renderable in pixels⤶  getMinimumFontHeight: ->⤶    str = ＂I＂⤶    size = 50⤶    canvas = document.createElement ＂canvas＂⤶    canvas.width = size⤶    canvas.height = size⤶    ctx = canvas.getContext ＂2d＂⤶    ctx.font = ＂1px serif＂⤶    maxX = Math.ceil ctx.measureText(str).width⤶    ctx.fillStyle = Color.BLACK.toString()⤶    ctx.textBaseline = ＂bottom＂⤶    ctx.fillText str, 0, size⤶    for y in [0...size]⤶      for x in [0...maxX]⤶        data = ctx.getImageData x, y, 1, 1⤶        return size - y + 1  if data.data[3] isnt 0⤶    0⤶⤶  setMouseInputMode: ->⤶    @inputMode = PreferencesAndSettings.INPUT_MODE_MOUSE⤶    @minimumFontHeight = @getMinimumFontHeight() # browser settings⤶    @menuFontName = ＂sans-serif＂⤶    @menuFontSize = 12 # 14⤶    @menuHeaderFontSize = 12 # 13⤶    @menuHeaderColor = Color.create 77,77,77 # Color.create 125, 125, 125⤶    @menuHeaderBold = true # false⤶    @menuStrokeColor = Color.create 210, 210, 210 # Color.create 186, 186, 186⤶    @menuBackgroundColor = Color.create 249, 249, 249 # Color.create 244, 244, 244⤶    @menuButtonsLabelColor = Color.BLACK # Color.create 50, 50, 50⤶⤶    @externalWindowBarBackgroundColor = Color.create 125, 125, 125⤶    @externalWindowBarStrokeColor = Color.create 100,100,100⤶    @internalWindowBarBackgroundColor = Color.create 172, 172, 172⤶    @internalWindowBarStrokeColor = Color.create 150,150,150⤶⤶    @normalTextFontSize = 12 # 13⤶    @textInButtonsFontSize = 12 # 13⤶⤶    @titleBarTextFontSize = 12 # 13⤶    @titleBarTextHeight = 15 # 16⤶    @titleBarBoldText = true # false⤶    @bubbleHelpFontSize = 10 # 12⤶    @prompterFontName = ＂sans-serif＂⤶    @prompterFontSize = 12⤶    @prompterSliderSize = 10⤶⤶    @defaultPanelsBackgroundColor = Color.create 255, 250, 245⤶    @defaultPanelsStrokeColor = Color.create 100, 100, 100⤶    @editableItemBackgroundColor = Color.create 240, 240, 240⤶⤶    @outlineColor = Color.create 244,243,244⤶    # let's create this shortcut just because⤶    # we use this string so many times⤶    @outlineColorString = @outlineColor.toString()⤶⤶    @iconDarkLineColor = Color.BLACK⤶⤶    @shortcutsFontSize = 12⤶⤶    # handle and scrollbar should ideally be the⤶    # same size because they often show next to⤶    # each other⤶    @handleSize = 15⤶    @scrollBarsThickness = 10⤶⤶    @wheelScaleX = 1⤶    @wheelScaleY = 1⤶    @wheelScaleZ = 1⤶    @invertWheelX = true⤶    @invertWheelY = true⤶    @invertWheelZ = true⤶⤶    @useSliderForInput = false⤶    @useVirtualKeyboard = true⤶    @isTouchDevice = false # turned on by touch events, don't set⤶    @rasterizeSVGs = false⤶    @isFlat = false⤶⤶  setTouchInputMode: ->⤶    @inputMode = PreferencesAndSettings.INPUT_MODE_TOUCH⤶    @minimumFontHeight = @getMinimumFontHeight()⤶    @menuFontName = ＂sans-serif＂⤶    @menuFontSize = 24⤶    @bubbleHelpFontSize = 18⤶    @prompterFontName = ＂sans-serif＂⤶    @prompterFontSize = 24⤶    @prompterSliderSize = 20⤶⤶    # handle and scrollbar should ideally be the⤶    # same size because they often show next to⤶    # each other⤶    @handleSize = 26⤶    @scrollBarsThickness = 24⤶⤶    @wheelScaleX = 1⤶    @wheelScaleY = 1⤶    @wheelScaleZ = 1⤶    @invertWheelX = true⤶    @invertWheelY = true⤶    @invertWheelZ = true⤶⤶    @useSliderForInput = true⤶    @useVirtualKeyboard = true⤶    @isTouchDevice = false⤶    @rasterizeSVGs = false⤶    @isFlat = false⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.PreferredSize_coffeSource = "# PreferredSize⤶# ...just giving some convenient names to constants/singletons⤶⤶class PreferredSize⤶⤶  @THIS_ONE_I_HAVE_NOW: -1⤶  @DONT_MIND: -2⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.PromptMorph_coffeSource = "class PromptMorph extends MenuMorph⤶⤶  # pattern: all the children should be declared here⤶  # the reason is that when you duplicate a morph⤶  # , the duplicated morph needs to have the handles⤶  # that will be duplicated. If you don't list them⤶  # here, then they need to be initialised in the⤶  # constructor. But actually they might not be⤶  # initialised in the constructor if a ＂lazy initialisation＂⤶  # approach is taken. So it's good practice⤶  # to list them here so they can be duplicated either way.⤶  #feedback: nil⤶  #choice: nil⤶  #colorPalette: nil⤶  #grayPalette: nil⤶⤶  tempPromptEntryField: nil⤶⤶  constructor: (morphOpeningThePopUp, @msg, @target, @callback, @defaultContents, @intendedWidth, @floorNum,⤶    @ceilingNum, @isRounded) ->⤶⤶    isNumeric = true  if @ceilingNum⤶    @tempPromptEntryField = new StringFieldMorph(⤶      @defaultContents or ＂＂,⤶      @intendedWidth or 100,⤶      WorldMorph.preferencesAndSettings.prompterFontSize,⤶      WorldMorph.preferencesAndSettings.prompterFontName,⤶      false,⤶      false,⤶      isNumeric)⤶⤶    super morphOpeningThePopUp, false, @target, true, true, @msg or ＂＂, @tempPromptEntryField⤶⤶⤶    @silentAdd @tempPromptEntryField⤶    if @ceilingNum or WorldMorph.preferencesAndSettings.useSliderForInput⤶      slider = new SliderMorph(⤶        @floorNum or 0,⤶        @ceilingNum,⤶        parseFloat(@defaultContents),⤶        Math.floor((@ceilingNum - @floorNum) / 4))⤶      slider.alpha = 1⤶      slider.color = Color.create 225, 225, 225⤶      slider.button.color = Color.create 60,60,60⤶      slider.button.highlightColor = slider.button.color.bluerBy 100⤶      slider.button.pressColor = slider.button.color.bluerBy 150⤶      slider.silentRawSetHeight WorldMorph.preferencesAndSettings.prompterSliderSize⤶      slider.target = @⤶      slider.argumentToAction = @⤶      slider.action = ＂reactToSliderAction＂⤶      @silentAdd slider⤶    @addLine 2⤶⤶    @addMenuItem ＂Ok＂, true, @target, @callback⤶    # we name the button ＂Close＂ instead of ＂Cancel＂⤶    # because we are not undoing any change we made⤶    # that would be rather difficult in case of⤶    # multiple prompts being pinned down and changing⤶    # the property concurrently⤶    @addMenuItem ＂Close＂, true, @, ＂close＂⤶⤶    @reLayout()⤶⤶  reactToSliderAction: (num) ->⤶    @tempPromptEntryField.changed()⤶    @tempPromptEntryField.text.text = Math.round(num).toString()⤶    @tempPromptEntryField.text.reLayout()⤶    ⤶    @tempPromptEntryField.text.changed()⤶    @tempPromptEntryField.text.edit()⤶⤶  reLayout: ->⤶    super()⤶    @buildSubmorphs()⤶⤶  buildSubmorphs: ->⤶⤶  iHaveBeenAddedTo: (whereTo, beingDropped) ->⤶  ⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.RadioButtonsHolderMorph_coffeSource = "class RadioButtonsHolderMorph extends Widget⤶⤶  wantsButtonsToBehaveLikeRadioButtons: true⤶  allowsRadioButtonsToBeAllDisabled: true⤶⤶  constructor: ->⤶    super()⤶    @appearance = new RectangularAppearance @⤶    @setColor Color.create 230, 230, 230⤶⤶⤶  # TODO gross pattern break - usually mouseClickLeft has 9 params⤶  # none of which is a widget⤶  mouseClickLeft: (morphThatFired) ->⤶    for w in @children⤶      if w != morphThatFired⤶        w.resetSwitchButton?()⤶⤶  whichButtonSelected: ->⤶    @firstChildSuchThat (w) =>⤶      w.isSelected()⤶⤶  unselectAll: ->⤶    if @allowsRadioButtonsToBeAllDisabled⤶      for w in @children⤶        if w.isSelected()⤶          w.toggle()⤶    return null⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SaveShortcutPromptWdgt_coffeSource = "class SaveShortcutPromptWdgt extends MenuMorph⤶⤶  # bad hack to set the prompt to a⤶  # decent width⤶  # TODO this widget has to be re-made using⤶  # vertical stack layout anyways⤶  msg: ＂ save as...         ＂⤶⤶  tempPromptEntryField: nil⤶⤶  constructor: (morphOpeningThePopUp, @target, @defaultContents, @intendedWidth = 100, @wdgtWhereReferenceWillGo) ->⤶    ⤶    if !@defaultContents⤶      @defaultContents = world.getNextUntitledShortcutName()⤶⤶    @tempPromptEntryField = new StringFieldWdgt2(⤶      @defaultContents,⤶      150,⤶      WorldMorph.preferencesAndSettings.prompterFontSize,⤶      WorldMorph.preferencesAndSettings.prompterFontName,⤶      false,⤶      false,⤶      false⤶    )⤶⤶    super morphOpeningThePopUp, false, @target, true, true, @msg, @tempPromptEntryField⤶⤶    @silentAdd @tempPromptEntryField⤶⤶    @addMenuItem ＂Don't save＂, true, @target, ＂destroy＂⤶    # ＂Cancel＂ here just dismisses this prompt, but the target⤶    # wdgt remains open⤶    @addMenuItem ＂Cancel＂, true, @, ＂close＂⤶    @addMenuItem ＂Ok＂, true, @, ＂createReferenceAndClose＂⤶⤶    @reLayout()⤶    @rawSetWidth 150⤶    @tempPromptEntryField.text.edit()⤶⤶  reLayout: ->⤶    super()⤶    @buildSubmorphs()⤶⤶  buildSubmorphs: ->⤶⤶  iHaveBeenAddedTo: (whereTo, beingDropped) ->⤶  ⤶  createReferenceAndClose: ->⤶    @target.createReferenceAndClose @tempPromptEntryField.text.text, @wdgtWhereReferenceWillGo⤶    @close()".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ScriptWdgt_coffeSource = "# As usual in Widgetic widgets are visual interactable things, and⤶# this widget embodies a script.⤶#⤶# A script is⤶#   * an easy-to modify piece of code⤶#     (i.e. it opens in its own panel, where you can edit and run it)⤶#   * it's standalone, i.e. it's independent i.e.⤶#     it's code that doesn't belong to any other widget⤶#     (i.e.: if this code should belong to a widget, add it to a widget)⤶#   * it's probably temporary ＂glue＂ or ＂scaffholding＂ or ＂utility＂⤶#     code that is not meant to be around for long (i.e.: this code,⤶#     if really useful, should really find its place in a proper class)⤶#⤶# When writing a script, consider the alternatives:⤶#   * a menu entry invoking a proper method from a widget⤶#   * a button invoking a proper method from a widget⤶#   * an iconic link on the desktop... invoking a proper method from a widget⤶⤶class ScriptWdgt extends Widget⤶⤶  tempPromptEntryField: nil⤶  textMorph: nil⤶⤶  runItButton: nil⤶  saveButton: nil⤶  saveTextWdgt: nil⤶⤶  savedScript: nil⤶  functionFromCompiledCode: nil⤶⤶  # the external padding is the space between the edges⤶  # of the container and all of its internals. The reason⤶  # you often set this to zero is because windows already put⤶  # contents inside themselves with a little padding, so this⤶  # external padding is not needed. Useful to keep it⤶  # separate and know that it's working though.⤶  externalPadding: 0⤶  # the internal padding is the space between the internal⤶  # components. It doesn't necessarily need to be equal to the⤶  # external padding⤶  internalPadding: 5⤶⤶  constructor: (@savedScript = ＂＂) ->⤶    super new Point 200,400⤶    @buildAndConnectChildren()⤶⤶  colloquialName: ->⤶    ＂script＂⤶⤶  representativeIcon: ->⤶    new ScriptIconWdgt⤶⤶  closeFromContainerWindow: (containerWindow) ->⤶    if !world.anyReferenceToWdgt containerWindow⤶      prompt = new SaveShortcutPromptWdgt @, containerWindow⤶      prompt.popUpAtHand()⤶    else⤶      containerWindow.close()⤶⤶  buildAndConnectChildren: ->⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @tempPromptEntryField = new SimplePlainTextScrollPanelWdgt @savedScript, false, 5⤶    @tempPromptEntryField.disableDrops()⤶    @tempPromptEntryField.contents.disableDrops()⤶    @tempPromptEntryField.color = Color.WHITE⤶    @tempPromptEntryField.addModifiedContentIndicator()⤶⤶    # register this wdgt as one to be notified when the text⤶    # changes/unchanges from ＂reference＂ content⤶    # so we can enable/disable the ＂save＂ button⤶    @tempPromptEntryField.widgetToBeNotifiedOfTextModificationChange = @⤶⤶    @textMorph = @tempPromptEntryField.textWdgt⤶    @textMorph.backgroundColor = Color.TRANSPARENT⤶    @textMorph.setFontName nil, nil, @textMorph.monoFontStack⤶    @textMorph.isEditable = true⤶    @textMorph.enableSelecting()⤶⤶    @add @tempPromptEntryField⤶⤶    # buttons -------------------------------⤶    @runItButton = new SimpleButtonMorph true, @, ＂tryIt＂, ＂try it＂⤶    @add @runItButton⤶⤶    @saveTextWdgt = new StringMorph2 ＂save + close＂, WorldMorph.preferencesAndSettings.textInButtonsFontSize⤶    @saveTextWdgt.alignCenter()⤶    @saveButton = new SimpleButtonMorph true, @, ＂saveScriptAndClose＂, @saveTextWdgt⤶    @add @saveButton⤶    # ---------------------------------------⤶⤶    # now that we added the buttons there is a ＂save＂ button⤶    # to disable (because the reference text has not been⤶    # changed yet), so trigger the content check now⤶    @tempPromptEntryField.checkIfTextContentWasModifiedFromTextAtStart()⤶⤶    @invalidateLayout()⤶⤶  saveScript: ->⤶    @savedScript = @textMorph.text⤶    compiled = compileFGCode @savedScript, true⤶    @functionFromCompiledCode = new Function compiled⤶⤶    @textMorph.considerCurrentTextAsReferenceText()⤶    @tempPromptEntryField.checkIfTextContentWasModifiedFromTextAtStart()⤶⤶  saveScriptAndClose: ->⤶    @saveScript()⤶    @closeFromContainerWindow @parent⤶⤶  doAll: ->⤶    @functionFromCompiledCode?.call world⤶⤶  tryIt: ->⤶    world.evaluateString @textMorph.text⤶⤶  textContentModified: ->⤶⤶  textContentUnmodified: ->⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶    textHeight = @height() - 2 * @externalPadding - @internalPadding - 15⤶    textBottom = @top() + @externalPadding + textHeight⤶    textWidth = @width() - 2 * @externalPadding⤶    buttonsWidth = Math.round((textWidth - 2 * @internalPadding - WorldMorph.preferencesAndSettings.handleSize)/2)⤶⤶    if @tempPromptEntryField.parent == @⤶      @tempPromptEntryField.fullRawMoveTo new Point @left() + @externalPadding, @top() + @externalPadding⤶      @tempPromptEntryField.rawSetExtent new Point textWidth, textHeight⤶⤶⤶    # buttons -------------------------------⤶    ⤶⤶    if @runItButton.parent == @⤶      buttonBounds = new Rectangle new Point @left() + @externalPadding, textBottom + @internalPadding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight buttonsWidth, 15⤶      @runItButton.doLayout buttonBounds⤶⤶    if @saveButton.parent == @⤶      buttonBounds = new Rectangle new Point buttonBounds.right() + @internalPadding, textBottom + @internalPadding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight buttonsWidth, 15⤶      @saveButton.doLayout buttonBounds⤶⤶⤶    # ----------------------------------------------⤶⤶⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    super⤶    @markLayoutAsFixed()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ShadowInfo_coffeSource = "class ShadowInfo⤶⤶  @augmentWith DeepCopierMixin⤶⤶  offset: nil⤶  alpha: 0⤶⤶  # alpha should be between zero (transparent)⤶  # and one (fully opaque)⤶  constructor: (@offset = new Point(7, 7), @alpha = 0.2) ->⤶    @offset.debugIfFloats()⤶⤶⤶  @noShadow: ->⤶    new ShadowInfo new Point(0, 0), 0⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleButtonMorph_coffeSource = "# sends a message to a target object when pressed.⤶# takes a rectangular shape, and can host⤶# a morph to be used as ＂face＂⤶⤶class SimpleButtonMorph extends EmptyButtonMorph⤶⤶  constructor: (⤶      @ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked = true,⤶      @target = nil,⤶      @action = nil,⤶⤶      @faceMorph = nil,⤶⤶      @dataSourceMorphForTarget = nil,⤶      @morphEnv,⤶      @toolTipMessage = nil,⤶⤶      @doubleClickAction = nil,⤶      @argumentToAction1 = nil,⤶      @argumentToAction2 = nil,⤶      @representsAMorph = false,⤶      @padding = 0⤶      ) ->⤶⤶    # additional properties:⤶⤶    super⤶⤶    @appearance = new BoxyAppearance @⤶    @strokeColor = Color.create 196,195,196⤶    @color = Color.create 245, 244, 245⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleDocumentPanelWdgt_coffeSource = "# this wraps the functionality of the⤶# SimpleVerticalStackPanelWdgt into something that has⤶# a more human name. Also provides additional document-oriented⤶# features such as ＂increase/decrease size＂ etc.⤶⤶class SimpleDocumentPanelWdgt extends SimpleVerticalStackPanelWdgt⤶⤶  colloquialName: ->⤶    ＂document＂⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleDocumentScrollPanelWdgt_coffeSource = "# this wraps the functionality of the⤶# SimpleVerticalStackScrollPanelWdgt into something that has⤶# a more human name. Also provides additional document-oriented⤶# features such as for addind divider lines, bullets etc.⤶⤶class SimpleDocumentScrollPanelWdgt extends SimpleVerticalStackScrollPanelWdgt⤶⤶  colloquialName: ->⤶    ＂document＂⤶⤶  getNormalParagraph: (text) ->⤶    paragraph = new SimplePlainTextWdgt(⤶      text,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    paragraph.isEditable = true⤶    paragraph.enableSelecting()⤶    return paragraph⤶⤶  makeAllContentIntoTemplates: ->⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets @contents⤶⤶    for w in childrenNotHandlesNorCarets⤶      w.isTemplate = true⤶⤶  addNormalParagraph: (text) ->⤶    paragraph = @getNormalParagraph text⤶    @add paragraph⤶    return paragraph⤶⤶  addDivider: ->⤶    divider = @getNormalParagraph ＂＂⤶    divider.toggleHeaderLine()⤶    @add divider⤶    return divider⤶⤶  addIndentedText: (text)->⤶    indentedText = @getNormalParagraph text⤶    indentedText.rawSetExtent new Point Math.round(92*@width()/100), 335⤶    @add indentedText⤶    indentedText.layoutSpecDetails.setAlignmentToRight()⤶    return indentedText⤶⤶  addBulletPoint: (text) ->⤶    bulletPoint = @addIndentedText ＂• ＂ + text⤶    return bulletPoint⤶⤶  addCodeBlock: (text) ->⤶    codeBlock = @addIndentedText ＂a code block with⧹n  some example⧹n    code in here＂⤶    codeBlock.setFontName nil, nil, codeBlock.monoFontStack⤶    @add codeBlock⤶    return codeBlock⤶⤶  addSpacer: (numberOfLines = 1) ->⤶⤶    # TODO it's 2018 now, if you see this in 2019⤶    # consider replacing this with ES6 repeat() method⤶    repeatStringNumTimes = (string, times) ->⤶      repeatedString = ''⤶      while times > 0⤶        repeatedString += string⤶        times--⤶      repeatedString⤶⤶    spacer = @getNormalParagraph repeatStringNumTimes(＂⧹n＂,numberOfLines-1)⤶    spacer.isEditable = true⤶    spacer.enableSelecting()⤶    @add spacer⤶    return spacer".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleLinkWdgt_coffeSource = "class SimpleLinkWdgt extends Widget⤶⤶⤶  tempPromptEntryField: nil⤶  textMorph: nil⤶⤶  outputTextArea: nil⤶  outputTextAreaText: nil⤶⤶  externalLinkIcon: nil⤶⤶  externalPadding: 5⤶  # the internal padding is the space between the internal⤶  # components. It doesn't necessarily need to be equal to the⤶  # external padding⤶  internalPadding: 5⤶⤶  descriptionString: nil⤶  linkString: nil⤶⤶  constructor: (@descriptionString = ＂insert link caption here＂, @linkString = ＂http://www.google.com＂) ->⤶    super new Point 405, 50⤶    @buildAndConnectChildren()⤶⤶  colloquialName: ->⤶    ＂Simple link＂⤶⤶  buildAndConnectChildren: ->⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @tempPromptEntryField = new StringMorph2 @descriptionString⤶    @tempPromptEntryField.isEditable = true⤶    @tempPromptEntryField.fittingSpecWhenBoundsTooLarge = FittingSpecTextInLargerBounds.SCALEUP⤶    @tempPromptEntryField.fittingSpecWhenBoundsTooSmall = FittingSpecTextInSmallerBounds.SCALEDOWN⤶    @tempPromptEntryField.alignMiddle()⤶    @tempPromptEntryField.alignRight()⤶    @add @tempPromptEntryField⤶⤶    @outputTextArea = new StringMorph2 @linkString⤶    @outputTextArea.isEditable = true⤶    @outputTextArea.fittingSpecWhenBoundsTooLarge = FittingSpecTextInLargerBounds.SCALEUP⤶    @outputTextArea.fittingSpecWhenBoundsTooSmall = FittingSpecTextInSmallerBounds.SCALEDOWN⤶    @outputTextArea.alignMiddle()⤶    @outputTextArea.alignRight()⤶    @add @outputTextArea⤶    @createLinkIcon()⤶    @add @externalLinkIcon⤶⤶    @invalidateLayout()⤶⤶  createLinkIcon: ->⤶    @externalLinkIcon = new ExternalLinkButtonWdgt⤶⤶  rawSetExtent: (aPoint) ->⤶    super⤶    @invalidateLayout()⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶    availableHeight = @height() - 2 * @externalPadding - @internalPadding⤶    text1Height = Math.round availableHeight * 50/100⤶    text2Height = availableHeight - text1Height - @externalPadding⤶⤶    squareSize = Math.min @width(), @height() - 2 * @externalPadding⤶⤶    if @tempPromptEntryField.parent == @⤶      @tempPromptEntryField.fullRawMoveTo new Point @left() + @externalPadding, @top() + @externalPadding⤶      @tempPromptEntryField.rawSetExtent new Point @width() - 2 * @externalPadding - @internalPadding - squareSize, text1Height⤶⤶    if @outputTextArea.parent == @⤶      @outputTextArea.fullRawMoveTo new Point @left() + @externalPadding, @tempPromptEntryField.bottom() + @internalPadding⤶      @outputTextArea.rawSetExtent new Point @width() - 2 * @externalPadding - @internalPadding - squareSize, text2Height⤶⤶    if @externalLinkIcon.parent == @⤶      @externalLinkIcon.fullRawMoveTo new Point @right() - @externalPadding - squareSize, @top() + @externalPadding⤶      @externalLinkIcon.rawSetExtent new Point squareSize, squareSize⤶⤶⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    super⤶    @markLayoutAsFixed()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimplePlainTextPanelWdgt_coffeSource = "# TODO the SimplePlainTextPanelWdgt can't quite stand on its own,⤶# it's really meant to be inside a ScrollPanel.⤶#⤶# The analogous VerticalStackPanel is better engineered,⤶# that one can indeed stand on its own.⤶#⤶# However, there really isn't a need for this widget⤶# because it doesn't provide anything more than what the⤶# SimplePlainText widget can already provide.⤶⤶class SimplePlainTextPanelWdgt extends PanelWdgt⤶⤶  constructor: (⤶    textAsString,⤶    wraps,⤶    padding⤶    ) ->⤶⤶    super()⤶    @takesOverAndCoalescesChildrensMenus = true⤶    @disableDrops()⤶    @disableDrops()⤶    @isTextLineWrapping = wraps⤶    @color = Color.WHITE⤶    ostmA = new SimplePlainTextWdgt(⤶      textAsString,nil,nil,nil,nil,nil,Color.create(230, 230, 130), 1)⤶    ostmA.isEditable = true⤶    if !wraps⤶      ostmA.maxTextWidth = 0⤶    ostmA.enableSelecting()⤶    @add ostmA⤶    ostmA.lockToPanels()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimplePlainTextScrollPanelWdgt_coffeSource = "# The SimplePlainTextScrollPanelWdgt allows you show/edit ONE⤶# text blurb only.⤶# It doesn't allow you to view/edit multiple text blurbs or⤶# other Widgets like the SimpleVerticalStackPanelWdgt/DocumentViewerOrEditor do.⤶#⤶# However, what the SimplePlainTextScrollPanelWdgt DOES⤶# in respect to the SimpleVerticalStackPanelWdgt/DocumentViewerOrEditor is to⤶# view/edit UNWRAPPED text, which is quite important for⤶# code, since really code must have the option of an⤶# unwrapped view.⤶⤶class SimplePlainTextScrollPanelWdgt extends ScrollPanelWdgt⤶⤶  textWdgt: nil⤶  modifiedTextTriangleAnnotation: nil⤶  widgetToBeNotifiedOfTextModificationChange: nil⤶⤶  constructor: (⤶    textAsString,⤶    wraps,⤶    padding⤶    ) ->⤶⤶    super()⤶    @takesOverAndCoalescesChildrensMenus = true⤶    @disableDrops()⤶    @contents.disableDrops()⤶    @isTextLineWrapping = wraps⤶    @color = Color.WHITE⤶    @textWdgt = new SimplePlainTextWdgt(⤶      textAsString,nil,nil,nil,nil,nil,Color.create(230, 230, 130), 1)⤶    @textWdgt.isEditable = true⤶    if !wraps⤶      @textWdgt.maxTextWidth = 0⤶    @textWdgt.enableSelecting()⤶    @setContents @textWdgt, padding⤶    @textWdgt.lockToPanels()⤶    ⤶⤶  colloquialName: ->⤶    return ＂text＂⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    @layoutSpecDetails = new WindowContentLayoutSpec PreferredSize.DONT_MIND , PreferredSize.DONT_MIND, 1⤶⤶  checkIfTextContentWasModifiedFromTextAtStart: ->⤶    @textWdgt.checkIfTextContentWasModifiedFromTextAtStart()⤶⤶  addModifiedContentIndicator: ->⤶    @modifiedTextTriangleAnnotation = new ModifiedTextTriangleAnnotationWdgt @⤶    @textWdgt.widgetToBeNotifiedOfTextModificationChange = @⤶⤶    # just because we add the modified content indicator it⤶    # doesn't mean that we automatically ＂save＂ the content,⤶    # so removing this.⤶    # @textWdgt.considerCurrentTextAsReferenceText()⤶⤶    @textWdgt.checkIfTextContentWasModifiedFromTextAtStart()⤶⤶  textContentModified: ->⤶    @modifiedTextTriangleAnnotation?.show()⤶    @widgetToBeNotifiedOfTextModificationChange?.textContentModified()⤶⤶  textContentUnmodified: ->⤶    @modifiedTextTriangleAnnotation?.hide()⤶    @widgetToBeNotifiedOfTextModificationChange?.textContentUnmodified()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");