

window.MenuAppearance_coffeSource = "class MenuAppearance extends BoxyAppearance⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.MenuHeader_coffeSource = "class MenuHeader extends BoxMorph⤶⤶  text: nil⤶⤶  constructor: (textContents) ->⤶    super 3⤶    @color = WorldMorph.preferencesAndSettings.menuHeaderColor⤶⤶    @text = new TextMorph(⤶      textContents,⤶      @fontSize or WorldMorph.preferencesAndSettings.menuHeaderFontSize,⤶      WorldMorph.preferencesAndSettings.menuFontName,⤶      WorldMorph.preferencesAndSettings.menuHeaderBold,⤶      false,⤶      ＂center＂)⤶    @text.alignment = ＂center＂⤶    @text.color = Color.WHITE⤶    @text.backgroundColor = @color⤶⤶    @add @text⤶    @rawSetExtent @text.extent().add 2⤶⤶  rawSetWidth: (theWidth) ->⤶    super⤶    @text.fullRawMoveTo @center().subtract @text.extent().floorDivideBy 2⤶⤶  mouseClickLeft: ->⤶    super⤶    if @parent?⤶      @firstParentThatIsAPopUp()?.pinPopUp @⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.MenuItemMorph_coffeSource = "# I automatically determine my bounds⤶⤶class MenuItemMorph extends TriggerMorph⤶⤶  # labelString can also be a Widget or a Canvas or a tuple: [icon, string]⤶  constructor: (ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, target, action, labelString, fontSize, fontStyle, centered, environment, morphEnv, toolTipMessage, color, bold, italic, doubleClickAction, argumentToAction1, argumentToAction2, representsAMorph) ->⤶    #console.log ＂menuitem constructing＂⤶    super ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, target, action, labelString, fontSize, fontStyle, centered, environment, morphEnv, toolTipMessage, color, bold, italic, doubleClickAction, argumentToAction1, argumentToAction2, representsAMorph⤶    @actionableAsThumbnail = true⤶⤶  getTextDescription: ->⤶    if @textDescription?⤶      return @textDescription + ＂ (adhoc description of menu item)＂⤶    if @labelString⤶      textWithoutLocationOrInstanceNo = @labelString.replace /#⧹d*/, ＂＂⤶      return textWithoutLocationOrInstanceNo + ＂ (text in button)＂⤶    else⤶      return super()⤶  ⤶  # in theory this would be the right thing to do⤶  # but a bunch of tests break and it's not worth it⤶  # as we are going to remake the whole layout system anyways⤶  #reLayout: ->⤶  #  @label.setExtent @extent().subtract (@label.bounds.origin.subtract @.bounds.origin)⤶⤶  isTicked: ->⤶    @label.text.isTicked()⤶⤶  toggleTick: ->⤶    if @label.text.isTicked()⤶      @label.text = @label.text.toggleTick()⤶      @label.reLayout()⤶      @label.changed()⤶    else if @label.text.isUnticked()⤶      @label.text = @label.text.toggleTick()⤶      @label.reLayout()⤶      @label.changed()⤶⤶⤶  createLabel: ->⤶    # console.log ＂menuitem createLabel＂⤶    @label = new TextMorph @labelString, @fontSize, @fontStyle⤶    @label.setColor @labelColor⤶⤶    @add @label⤶  ⤶    w = @width()⤶    @silentRawSetExtent @label.extent().add new Point 8, 0⤶    @silentRawSetWidth w⤶    np = @position().add new Point 4, 0⤶    @label.silentFullRawMoveTo np⤶  ⤶  shrinkToTextSize: ->⤶    # '5' is to add some padding between⤶    # the text and the button edge⤶    @rawSetWidth @widthOfLabel() + 5⤶⤶  widthOfLabel: ->⤶    @label.width()⤶⤶  # MenuItemMorph events:⤶  mouseEnter: ->⤶    #console.log ＂@target: ＂ + @target + ＂ @morphEnv: ＂ + @morphEnv⤶    ⤶    # this could be a way to catch menu entries that should cause⤶    # an highlighting but don't⤶    #if @labelString.startsWith(＂a ＂) and !@representsAMorph⤶    #  debugger⤶⤶    if @representsAMorph⤶      if @argumentToAction1?⤶        # this first case handles when you pick a morph⤶        # as a target⤶        morphToBeHighlighted = @argumentToAction1⤶      else⤶        # this second case handles when you attach to a morph⤶        morphToBeHighlighted = @target⤶      morphToBeHighlighted.turnOnHighlight()⤶    unless @isListItem()⤶      @state = @STATE_HIGHLIGHTED⤶      @changed()⤶    if @toolTipMessage⤶      @startCountdownForBubbleHelp @toolTipMessage⤶  ⤶  mouseLeave: ->⤶    if @representsAMorph⤶      if @argumentToAction1?⤶        # this first case handles when you pick a morph⤶        # as a target⤶        morphToBeHighlighted = @argumentToAction1⤶      else⤶        # this second case handles when you attach to a morph⤶        morphToBeHighlighted = @target⤶      morphToBeHighlighted.turnOffHighlight()⤶    unless @isListItem()⤶      @state = @STATE_NORMAL⤶      @changed()⤶    world.destroyToolTips()  if @toolTipMessage⤶  ⤶  mouseDownLeft: (pos) ->⤶    if @isListItem()⤶      @parent.unselectAllItems()⤶      @escalateEvent ＂mouseDownLeft＂, pos⤶    @state = @STATE_PRESSED⤶    @changed()⤶    super⤶  ⤶  isListItem: ->⤶    return @parent.isListContents  if @parent⤶    false⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.MenuMorph_coffeSource = "# MenuMorphs is a Pop-up with basically a vertical stack of buttons⤶⤶class MenuMorph extends PopUpWdgt⤶⤶  target: nil⤶  title: nil⤶  environment: nil⤶  fontSize: nil⤶  label: nil⤶  isListContents: false⤶⤶  constructor: (@morphOpeningThePopUp, @isListContents = false, @target, @killThisPopUpIfClickOutsideDescendants = true, @killThisPopUpIfClickOnDescendantsTriggers = true, @title = nil, @environment = nil, @fontSize = nil) ->⤶    # console.log ＂menu constructor＂⤶    # console.log ＂menu super＂⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶    if !@isListContents⤶      if @killThisPopUpIfClickOutsideDescendants⤶        @onClickOutsideMeOrAnyOfMyChildren ＂close＂⤶    super @morphOpeningThePopUp, @killThisPopUpIfClickOutsideDescendants, @killThisPopUpIfClickOnDescendantsTriggers⤶    @isLockingToPanels = false⤶    @appearance = new MenuAppearance @⤶    @strokeColor = WorldMorph.preferencesAndSettings.menuStrokeColor⤶⤶⤶    if @isListContents⤶      world.freshlyCreatedPopUps.delete @⤶      world.openPopUps.delete @⤶⤶    unless @isListContents⤶      if @title⤶        @createLabel()⤶        @silentAdd @label⤶⤶  colloquialName: ->⤶    if @title⤶      return ＂⧹＂＂ + @title + ＂⧹＂ menu＂⤶    else⤶      return ＂menu＂⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    @layoutSpecDetails = new WindowContentLayoutSpec PreferredSize.THIS_ONE_I_HAVE_NOW , PreferredSize.THIS_ONE_I_HAVE_NOW, 0⤶    @layoutSpecDetails.canSetHeightFreely = false⤶⤶⤶  createLine: (height = 1) ->⤶    item = new RectangleMorph⤶    item.setMinimumExtent new Point 5,1⤶    item.color = Color.create 230,230,230⤶    item.rawSetHeight height + 2⤶    item⤶⤶  addLine: (height) ->⤶    item = @createLine height⤶    @silentAdd item⤶⤶  prependLine: (height) ->⤶    item = @createLine height⤶    @silentAdd item,nil,0⤶  ⤶  createLabel: ->⤶    @label = new MenuHeader @title⤶⤶  createMenuItem: (label, ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked = true, target, action, toolTipMessage, color, bold = false, italic = false,doubleClickAction, arg1, arg2,representsAMorph = false)->⤶    # console.log ＂menu creating MenuItemMorph ＂⤶    item = new MenuItemMorph(⤶      ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, # closes unpinned menus⤶      target, # target⤶      action, # action⤶      (label or ＂close＂), # label⤶      @fontSize or WorldMorph.preferencesAndSettings.menuFontSize,⤶      WorldMorph.preferencesAndSettings.menuFontName,⤶      false,⤶      @target, # environment⤶      @environment, # environment2⤶      toolTipMessage, # bubble help toolTipMessage⤶      color, # color⤶      bold, # bold⤶      italic, # italic⤶      doubleClickAction,  # doubleclick action⤶      arg1,  # argument to action 1⤶      arg2,  # argument to action 2⤶      representsAMorph  # does it represent a Widget?⤶      )⤶    if !@environment?⤶      item.dataSourceMorphForTarget = item⤶      item.morphEnv = @target⤶⤶    item⤶⤶  removeMenuItem: (label) ->⤶    item = @firstChildSuchThat (m) ->⤶      m.label? and m.label.text == label⤶    if item?⤶      item.fullDestroy()⤶⤶  removeConsecutiveLines: ->⤶    # have to copy the array with slice()⤶    # because we are removing items from it⤶    # while looping over it⤶    destroyNextLines = false⤶    for item in @children.slice()⤶      if destroyNextLines and item instanceof RectangleMorph⤶        item.fullDestroy()⤶      if item instanceof RectangleMorph⤶        destroyNextLines = true⤶        continue⤶      else⤶        destroyNextLines = false⤶⤶  addMenuItem: (label, ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, target, action, toolTipMessage, color, bold, italic,doubleClickAction, arg1, arg2,representsAMorph)->⤶    # console.log ＂menu creating MenuItemMorph ＂⤶    item = @createMenuItem label, ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, target, action, toolTipMessage, color, bold, italic,doubleClickAction, arg1, arg2,representsAMorph⤶    @silentAdd item⤶⤶  prependMenuItem: (label, ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, target, action, toolTipMessage, color, bold, italic,doubleClickAction, arg1, arg2,representsAMorph)->⤶    # console.log ＂menu creating MenuItemMorph ＂⤶    item = @createMenuItem label, ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, target, action, toolTipMessage, color, bold, italic,doubleClickAction, arg1, arg2,representsAMorph⤶    @silentAdd item, nil, 0⤶⤶⤶⤶  reLayout: ->⤶    # console.log ＂menu update rendering＂⤶    super()⤶⤶    # no point in breaking a rectangle for each menu entry,⤶    # let's hold on the broken rects and then issue⤶    # a fullChanged() at the end.⤶    world.disableTrackChanges()⤶⤶⤶    # we are going to re-build the⤶    # children list from the @items.⤶    # If the list of @items has changed, we⤶    # make sure we destroy the children that⤶    # are going away.⤶    #for w in @children⤶    #  if !@items.includes(w)⤶    #    w.fullDestroy()⤶⤶    #@children = []⤶⤶    unless @isListContents⤶      @cornerRadius = if WorldMorph.preferencesAndSettings.isFlat then 0 else 5⤶    @color = Color.create 238, 238, 238⤶    @silentRawSetExtent new Point 0, 0⤶    y = @top()⤶    x = @left() + 2⤶⤶    unless @isListContents⤶      if @title⤶        @label.fullRawMoveTo @position().add 2⤶        y = @label.bottom()⤶      else⤶        y = @top()⤶    y += 1⤶⤶    @removeShadow()⤶⤶    # note that menus can contain:⤶    # strings, colorpickers,⤶    # sliders, menuItems (which are buttons)⤶    # and divider lines.⤶    # console.log ＂menu @items.length ＂ + @items.length⤶    for item in @children⤶      if item == @label then continue⤶      item.fullRawMoveTo new Point x, y⤶      #console.log ＂item added: ＂ + item.bounds⤶      y = y + item.height()⤶  ⤶    @adjustWidthsOfMenuEntries()⤶    fb = @fullBounds()⤶    #console.log ＂fb: ＂ + fb⤶    # add some padding to the right and bottom of the menu⤶    @silentRawSetExtent fb.extent().add 2⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶  ⤶  maxWidthOfMenuEntries: ->⤶    w = 0⤶    #if @parent instanceof PanelWdgt⤶    #  if @parent.scrollPanel instanceof ScrollPanelWdgt⤶    #    w = @parent.scrollPanel.width()⤶    @children.forEach (item) ->⤶      if item instanceof MenuItemMorph⤶        if !item.children[0]? then debugger⤶        w = Math.max(w, item.children[0].width() + 8)⤶      else if (item instanceof StringFieldMorph) or⤶        (item instanceof ColorPickerMorph) or⤶        (item instanceof SliderMorph)⤶          w = Math.max w, item.width()⤶      #console.log ＂maxWidthOfMenuEntries: width of item ＂ + item + ＂ : ＂ + w⤶⤶    if @label⤶      w = Math.max w, @label.width()⤶      #console.log ＂maxWidthOfMenuEntries: label width : ＂ + w⤶    w⤶  ⤶  # makes all the elements of this menu the⤶  # right width.⤶  adjustWidthsOfMenuEntries: ->⤶    w = @maxWidthOfMenuEntries()⤶    #console.log ＂maxWidthOfMenuEntries ＂ + w⤶    @children.forEach (item) =>⤶      world.disableTrackChanges()⤶      item.rawSetWidth w⤶      #console.log ＂new width of ＂ + item + ＂ : ＂ + item.width()⤶      world.maybeEnableTrackChanges()⤶⤶  ⤶  unselectAllItems: ->⤶    @children.forEach (item) ->⤶      if item instanceof MenuItemMorph⤶        item.state = item.STATE_NORMAL⤶⤶    @changed()⤶⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.MenusHelper_coffeSource = "# All ＂actions＂ functions for all accessory menu items should belong⤶# in here. Also helps so we don't pollute moprhs with a varying number⤶# of helper functions, which is problematic for visual diffing⤶# on inspectors (the number of methods keeps changing).⤶⤶class MenusHelper⤶⤶  @augmentWith DeepCopierMixin⤶⤶  popUpDevToolsMenu: (morphOpeningThePopUp, widgetThisMenuIsAbout) ->⤶    menu = new MenuMorph morphOpeningThePopUp,  false, @, true, true, ＂Dev Tools＂⤶    menu.addMenuItem ＂inspect＂, true, widgetThisMenuIsAbout, ＂inspect2＂, ＂open a window⧹non all properties＂⤶    menu.addMenuItem ＂console＂, true, widgetThisMenuIsAbout, ＂createConsole＂, ＂console＂⤶⤶    menu.popUpAtHand()⤶⤶⤶⤶⤶⤶  basementIconAndText: ->⤶    world.add new BasementOpenerWdgt⤶⤶⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchFizzyPaint: ->⤶    wm = new WindowWdgt nil, nil, new ReconfigurablePaintWdgt⤶    wm.setExtent new Point 460, 400⤶    wm.fullRawMoveTo new Point 174, 114⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶⤶    ReconfigurablePaintInfoWdgt.createNextTo wm⤶⤶  createFizzyPaintLauncher: ->⤶    fizzyPaintLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂Draw＂, new PaintBucketIconWdgt, @, ＂launchFizzyPaint＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    world.add fizzyPaintLauncher⤶    fizzyPaintLauncher.setExtent new Point 75, 75⤶    fizzyPaintLauncher.fullChanged()⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchSimpleDocument: ->⤶    wm = new WindowWdgt nil, nil, new SimpleDocumentWdgt⤶    wm.setExtent new Point 370, 395⤶    wm.fullRawMoveTo new Point 170, 88⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶⤶    SimpleDocumentInfoWdgt.createNextTo wm⤶⤶⤶  createSimpleDocumentLauncher: ->⤶    simpleDocumentLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂Docs Maker＂, new TypewriterIconWdgt, @, ＂launchSimpleDocument＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    world.add simpleDocumentLauncher⤶    simpleDocumentLauncher.setExtent new Point 75, 75⤶    simpleDocumentLauncher.fullChanged()⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchSimpleSlide: ->⤶    wm = new WindowWdgt nil, nil, new SimpleSlideWdgt⤶    wm.setExtent new Point 460, 400⤶    wm.fullRawMoveTo new Point 168, 134⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶⤶    SimpleSlideInfoWdgt.createNextTo wm⤶⤶  createSimpleSlideLauncher: ->⤶    simpleSlideLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂Slides Maker＂, new SimpleSlideIconWdgt, @, ＂launchSimpleSlide＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    world.add simpleSlideLauncher⤶    simpleSlideLauncher.setExtent new Point 75, 75⤶    simpleSlideLauncher.fullChanged()⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchDashboards: ->⤶    reconfPaint = new DashboardsWdgt⤶    wm = new WindowWdgt nil, nil, reconfPaint⤶    wm.setExtent new Point 460, 400⤶    wm.fullRawMoveTo world.hand.position()⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶⤶    DashboardsInfoWdgt.createNextTo wm⤶⤶  createDashboardsLauncher: ->⤶    simpleDashboardsLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂Dashboards＂, new DashboardsIconWdgt, @, ＂launchDashboards＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    world.add simpleDashboardsLauncher⤶    simpleDashboardsLauncher.setExtent new Point 75, 75⤶    simpleDashboardsLauncher.fullChanged()⤶⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchPatchProgramming: ->⤶    patchProgramming = new PatchProgrammingWdgt⤶    wm = new WindowWdgt nil, nil, patchProgramming⤶    wm.setExtent new Point 460, 400⤶    wm.fullRawMoveTo world.hand.position()⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶    ⤶    PatchProgrammingInfoWdgt.createNextTo wm⤶⤶  createPatchProgrammingLauncher: ->⤶    patchProgrammingLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂Patch progr.＂, new PatchProgrammingIconWdgt, @, ＂launchPatchProgramming＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    world.add patchProgrammingLauncher⤶    patchProgrammingLauncher.setExtent new Point 75, 75⤶    patchProgrammingLauncher.fullChanged()⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchGenericPanel: ->⤶    genericPanel = new StretchableEditableWdgt⤶    wm = new WindowWdgt nil, nil, genericPanel⤶    wm.setExtent new Point 460, 400⤶    wm.fullRawMoveTo world.hand.position()⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶⤶    GenericPanelInfoWdgt.createNextTo wm⤶⤶  createGenericPanelLauncher: ->⤶    genericPanelLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂Generic panel＂, new GenericPanelIconWdgt, @, ＂launchGenericPanel＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    world.add genericPanelLauncher⤶    genericPanelLauncher.setExtent new Point 75, 75⤶    genericPanelLauncher.fullChanged()⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchToolbars: ->⤶    # tools -------------------------------⤶    toolsPanel = new ScrollPanelWdgt new ToolPanelWdgt⤶⤶    toolsPanel.addMany [⤶      new TextToolbarCreatorButtonWdgt⤶      new UsefulTextSnippetsToolbarCreatorButtonWdgt⤶      new SlidesToolbarCreatorButtonWdgt⤶      new PlotsToolbarCreatorButtonWdgt⤶      new PatchProgrammingComponentsToolbarCreatorButtonWdgt⤶      new WindowsToolbarCreatorButtonWdgt⤶    ]⤶⤶    toolsPanel.disableDragsDropsAndEditing()⤶⤶    wm = new WindowWdgt nil, nil, toolsPanel⤶    wm.setExtent new Point 60, 261⤶    wm.fullRawMoveTo new Point 170, 170⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶⤶    ToolbarsInfoWdgt.createNextTo wm⤶⤶  createToolbarsOpener: ->⤶    toolbarsOpenerLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂Super Toolbar＂, new ToolbarsIconWdgt, @, ＂launchToolbars＂⤶    toolbarsOpenerLauncher.toolTipMessage = ＂a toolbar to rule them all＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    world.add toolbarsOpenerLauncher⤶    toolbarsOpenerLauncher.setExtent new Point 75, 75⤶    toolbarsOpenerLauncher.fullChanged()⤶⤶  # ------------------------------------------------------------------------⤶⤶  createNewTemplatesWindow: ->⤶    sdspw = new SimpleDocumentScrollPanelWdgt⤶⤶    sdspw.rawSetExtent new Point 365, 335⤶⤶    startingContent = new SimplePlainTextWdgt(⤶      ＂Simply drag the items below into your document＂,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    startingContent.alignCenter()⤶    startingContent.setFontSize 18⤶    startingContent.isEditable = true⤶    startingContent.enableSelecting()⤶⤶    sdspw.setContents startingContent, 5⤶⤶⤶    startingContent = new ArrowSIconWdgt⤶    startingContent.rawSetExtent new Point 25, 25⤶    sdspw.add startingContent⤶    startingContent.layoutSpecDetails.setAlignmentToCenter()⤶⤶    sdspw.addDivider()⤶⤶    startingContent = new SimplePlainTextWdgt(⤶      ＂Title＂,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    startingContent.alignCenter()⤶    startingContent.setFontName nil, nil, startingContent.georgiaFontStack⤶    startingContent.setFontSize 48⤶    startingContent.isEditable = true⤶    startingContent.enableSelecting()⤶    sdspw.add startingContent⤶⤶    startingContent = new SimplePlainTextWdgt(⤶      ＂Section X＂,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    startingContent.toggleWeight()⤶    startingContent.isEditable = true⤶    startingContent.enableSelecting()⤶    startingContent.setFontSize 28⤶    sdspw.add startingContent⤶⤶    startingContent = new SimplePlainTextWdgt(⤶      ＂Section X.X＂,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    startingContent.isEditable = true⤶    startingContent.enableSelecting()⤶    startingContent.setFontSize 24⤶    sdspw.add startingContent⤶⤶    sdspw.addNormalParagraph ＂Normal text.＂⤶⤶    startingContent = new SimplePlainTextWdgt(⤶      ＂“Be careful--with quotations, you can damn anything.”⧹n― André Malraux＂,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    startingContent.toggleItalic()⤶    startingContent.alignRight()⤶    startingContent.isEditable = true⤶    startingContent.enableSelecting()⤶    sdspw.add startingContent⤶⤶⤶    sdspw.addIndentedText ＂indentedText＂⤶    sdspw.addBulletPoint ＂bullet point＂⤶    sdspw.addCodeBlock ＂a code block with⧹n  some example⧹n    code in here＂⤶⤶⤶    startingContent = new SimplePlainTextWdgt(⤶      ＂Spacers:＂,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    startingContent.toggleWeight()⤶    startingContent.isEditable = true⤶    startingContent.enableSelecting()⤶    sdspw.add startingContent⤶⤶    sdspw.addSpacer()⤶    sdspw.addSpacer 2⤶    sdspw.addSpacer 3⤶⤶    startingContent = new SimplePlainTextWdgt(⤶      ＂Divider line:＂,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    startingContent.toggleWeight()⤶    startingContent.isEditable = true⤶    startingContent.enableSelecting()⤶    sdspw.add startingContent⤶⤶    sdspw.addDivider()⤶⤶    startingContent = new SimplePlainTextWdgt(⤶      ＂Links:＂,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    startingContent.toggleWeight()⤶    startingContent.isEditable = true⤶    startingContent.enableSelecting()⤶    sdspw.add startingContent⤶⤶    startingContent = new SimpleLinkWdgt⤶    startingContent.rawSetExtent new Point 405, 50⤶    sdspw.add startingContent⤶    startingContent.layoutSpecDetails.setAlignmentToRight()⤶⤶    startingContent = new SimpleVideoLinkWdgt⤶    startingContent.rawSetExtent new Point 405, 50⤶    sdspw.add startingContent⤶    startingContent.layoutSpecDetails.setAlignmentToRight()⤶⤶    startingContent = new SimplePlainTextWdgt(⤶      ＂Useful characters:＂,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    startingContent.toggleWeight()⤶    startingContent.isEditable = true⤶    startingContent.enableSelecting()⤶    sdspw.add startingContent⤶    # in March 2018, greek chars take a long time to paint on OSX/Chrome so⤶    # not adding those to the paragraph, however here they are:⤶    # αβγδεζηθικλμνξοπρστυφχψω ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ⤶    specialCharsParagraph = sdspw.addNormalParagraph ＂… †‡§ ↵⏎⇧␣ ☐☑☒✓X✗ •‣⁃◦ °±⁻¹²³µ×÷ℓΩ√∛∜∝∞∟∠∡∩∪∿≈⊂⋅⌀▫◽◻□⩽⩾ ¼½¾⅛⅜⅝⅞ ←↑→↓↔↕↵⇎⇏⇑⇒⇓⇔⇕ ©®™ $£€¥＂⤶    specialCharsParagraph.setFontSize 16⤶⤶⤶    sdspw.makeAllContentIntoTemplates()⤶⤶    wm = new WindowWdgt nil, nil, sdspw⤶    wm.setExtent new Point 370, 335⤶    wm.setTitleWithoutPrependedContentName ＂useful snippets＂⤶⤶    return wm⤶⤶⤶⤶⤶  createWelcomeMessageWindowAndShortcut: ->⤶    wm = WelcomeMessageInfoWdgt.create()⤶    readmeLauncher = new IconicDesktopSystemDocumentShortcutWdgt wm, ＂Welcome＂, new WelcomeIconWdgt⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    world.add readmeLauncher⤶    readmeLauncher.setExtent new Point 75, 75⤶    readmeLauncher.fullChanged()⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchDegreesConverter: ->⤶    @createDegreesConverterWindowOrBringItUpIfAlreadyCreated()⤶⤶  createDegreesConverterOpener: (inWhichFolder) ->⤶    degreesConverterOpenerLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂°C ↔ °F＂, new DegreesConverterIconWdgt, @, ＂launchDegreesConverter＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    ⤶    degreesConverterOpenerLauncher.setExtent new Point 75, 75⤶    if inWhichFolder?⤶      inWhichFolder.contents.contents.add degreesConverterOpenerLauncher⤶    else⤶      world.add degreesConverterOpenerLauncher⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchSampleDashboard: ->⤶    @createSampleDashboardWindowOrBringItUpIfAlreadyCreated()⤶⤶  createSampleDashboardOpener: (inWhichFolder) ->⤶    degreesConverterOpenerLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂sample dashb＂, (new GenericShortcutIconWdgt new DashboardsIconWdgt), @, ＂launchSampleDashboard＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    ⤶    degreesConverterOpenerLauncher.setExtent new Point 75, 75⤶    if inWhichFolder?⤶      inWhichFolder.contents.contents.add degreesConverterOpenerLauncher⤶    else⤶      world.add degreesConverterOpenerLauncher⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchSampleSlide: ->⤶    @createSampleSlideWindowOrBringItUpIfAlreadyCreated()⤶⤶  createSampleSlideOpener: (inWhichFolder) ->⤶    degreesConverterOpenerLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂sample slide＂, (new GenericShortcutIconWdgt new SimpleSlideIconWdgt), @, ＂launchSampleSlide＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    ⤶    degreesConverterOpenerLauncher.setExtent new Point 75, 75⤶    if inWhichFolder?⤶      inWhichFolder.contents.contents.add degreesConverterOpenerLauncher⤶    else⤶      world.add degreesConverterOpenerLauncher⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchSampleDoc: ->⤶    @createSampleDocWindowOrBringItUpIfAlreadyCreated()⤶⤶  createSampleDocOpener: (inWhichFolder) ->⤶    degreesConverterOpenerLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂sample doc＂, (new GenericShortcutIconWdgt new TypewriterIconWdgt), @, ＂launchSampleDoc＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    ⤶    degreesConverterOpenerLauncher.setExtent new Point 75, 75⤶    if inWhichFolder?⤶      inWhichFolder.contents.contents.add degreesConverterOpenerLauncher⤶    else⤶      world.add degreesConverterOpenerLauncher⤶⤶  # ------------------------------------------------------------------------⤶⤶  createSampleSlideWindowOrBringItUpIfAlreadyCreated: ->⤶    if world.sampleSlideWindow?⤶      if !world.sampleSlideWindow.destroyed and world.sampleSlideWindow.parent?⤶        world.add world.sampleSlideWindow⤶        world.sampleSlideWindow.bringToForeground()⤶        world.sampleSlideWindow.fullRawMoveTo world.hand.position().add new Point 100, -50⤶        world.sampleSlideWindow.fullRawMoveWithin world⤶        world.sampleSlideWindow.rememberFractionalSituationInHoldingPanel()⤶        return⤶⤶    slideWdgt = new SimpleSlideWdgt⤶⤶    container = slideWdgt.stretchableWidgetContainer.contents⤶    container.rawSetExtent new Point 575,454⤶⤶    windowWithScrollingPanel = new WindowWdgt nil, nil, new ScrollPanelWdgt, true, true⤶    windowWithScrollingPanel.setTitleWithoutPrependedContentName ＂New York City＂⤶    windowWithScrollingPanel.fullRawMoveTo container.position().add new Point 28, 43⤶    windowWithScrollingPanel.rawSetExtent new Point 322, 268⤶    container.add windowWithScrollingPanel⤶    windowWithScrollingPanel.rememberFractionalSituationInHoldingPanel()⤶⤶⤶    usaMap = new SimpleUSAMapIconWdgt Color.create 183, 183, 183⤶    usaMap.rawSetExtent new Point 1808, 1115⤶    windowWithScrollingPanel.contents.add usaMap⤶    windowWithScrollingPanel.contents.scrollTo new Point 1484, 246⤶    usaMap.rememberFractionalSituationInHoldingPanel()⤶⤶    mapPin = new MapPinIconWdgt⤶    windowWithScrollingPanel.contents.add mapPin⤶    mapPin.fullRawMoveTo windowWithScrollingPanel.contents.contents.position().add new Point 1606, 343⤶    mapPin.rememberFractionalSituationInHoldingPanel()⤶⤶    sampleBarPlot = new WindowWdgt nil, nil, new PlotWithAxesWdgt(new ExampleBarPlotWdgt), true, true⤶    sampleBarPlot.rawSetExtent new Point 240, 104⤶    windowWithScrollingPanel.contents.add sampleBarPlot⤶    sampleBarPlot.fullRawMoveTo windowWithScrollingPanel.contents.contents.position().add new Point 1566, 420⤶    sampleBarPlot.setTitleWithoutPrependedContentName ＂NYC: traffic＂⤶⤶⤶    windowWithScrollingPanel.contents.disableDragsDropsAndEditing()⤶⤶    mapCaption = new TextMorph2 ＂The City of New York, often called New York City or simply New York, is the most populous city in the United States. With an estimated 2017 population of 8,622,698 distributed over a land area of about 302.6 square miles (784 km2), New York City is also the most densely populated major city in the United States.＂⤶    mapCaption.fittingSpecWhenBoundsTooLarge = FittingSpecTextInLargerBounds.SCALEUP⤶    mapCaption.fittingSpecWhenBoundsTooSmall = FittingSpecTextInSmallerBounds.SCALEDOWN⤶⤶    mapCaption.fullRawMoveTo container.position().add new Point 366, 40⤶    mapCaption.rawSetExtent new Point 176, 387⤶    container.add mapCaption⤶    mapCaption.rememberFractionalSituationInHoldingPanel()⤶⤶    wikiLink = new SimpleLinkWdgt ＂New York City Wikipedia page＂, ＂https://en.wikipedia.org/wiki/New_York_City＂⤶    wikiLink.fullRawMoveTo container.position().add new Point 110, 348⤶    wikiLink.rawSetExtent new Point 250, 50⤶    container.add wikiLink⤶    wikiLink.rememberFractionalSituationInHoldingPanel()⤶⤶⤶    wm = new WindowWdgt nil, nil, slideWdgt⤶    wm.fullRawMoveTo new Point 114, 10⤶    wm.rawSetExtent new Point 596, 592⤶    world.add wm⤶    wm.setTitleWithoutPrependedContentName ＂Sample slide＂⤶⤶    slideWdgt.disableDragsDropsAndEditing()⤶    ⤶    # if we don't do this, the window would ask to save content⤶    # when closed. Just close it instead.⤶    # TODO: should be done using a flag, we don't like⤶    # to inject code like this: the source is not tracked⤶    slideWdgt.closeFromContainerWindow = (containerWindow) ->⤶      containerWindow.close()⤶⤶    world.sampleSlideWindow = wm⤶⤶  createSampleDocWindowOrBringItUpIfAlreadyCreated: ->⤶    if world.sampleDocWindow?⤶      if !world.sampleDocWindow.destroyed and world.sampleDocWindow.parent?⤶        world.add world.sampleDocWindow⤶        world.sampleDocWindow.bringToForeground()⤶        world.sampleDocWindow.fullRawMoveTo world.hand.position().add new Point 100, -50⤶        world.sampleDocWindow.fullRawMoveWithin world⤶        world.sampleDocWindow.rememberFractionalSituationInHoldingPanel()⤶        return⤶⤶    world.sampleDocWindow = SimpleDocumentSampleWdgt.create()⤶⤶  createSampleDashboardWindowOrBringItUpIfAlreadyCreated: ->⤶    if world.sampleDashboardWindow?⤶      if !world.sampleDashboardWindow.destroyed and world.sampleDashboardWindow.parent?⤶        world.add world.sampleDashboardWindow⤶        world.sampleDashboardWindow.bringToForeground()⤶        world.sampleDashboardWindow.fullRawMoveTo world.hand.position().add new Point 100, -50⤶        world.sampleDashboardWindow.fullRawMoveWithin world⤶        world.sampleDashboardWindow.rememberFractionalSituationInHoldingPanel()⤶        return⤶⤶    slideWdgt = new DashboardsWdgt⤶⤶    container = slideWdgt.stretchableWidgetContainer.contents⤶    container.rawSetExtent new Point 725,556⤶⤶    scatterPlot = new WindowWdgt nil, nil, new PlotWithAxesWdgt(new ExampleScatterPlotWdgt), true, true⤶    scatterPlot.fullRawMoveTo container.position().add new Point 19, 86⤶    scatterPlot.rawSetExtent new Point 200, 200⤶    container.add scatterPlot⤶    scatterPlot.rememberFractionalSituationInHoldingPanel()⤶⤶    functionPlot = new WindowWdgt nil, nil, new PlotWithAxesWdgt(new ExampleFunctionPlotWdgt), true, true⤶    functionPlot.fullRawMoveTo container.position().add new Point 251, 86⤶    functionPlot.rawSetExtent new Point 200, 200⤶    container.add functionPlot⤶    functionPlot.rememberFractionalSituationInHoldingPanel()⤶⤶    barPlot = new WindowWdgt nil, nil, new PlotWithAxesWdgt(new ExampleBarPlotWdgt), true, true⤶    barPlot.fullRawMoveTo container.position().add new Point 19, 327⤶    barPlot.rawSetExtent new Point 200, 200⤶    container.add barPlot⤶    barPlot.rememberFractionalSituationInHoldingPanel()⤶⤶    plot3D = new WindowWdgt nil, nil, new Example3DPlotWdgt, true, true⤶    plot3D.fullRawMoveTo container.position().add new Point 491, 327⤶    plot3D.rawSetExtent new Point 200, 150⤶    container.add plot3D⤶    plot3D.rememberFractionalSituationInHoldingPanel()⤶⤶    usaMap = new SimpleUSAMapIconWdgt Color.create 183, 183, 183⤶    usaMap.fullRawMoveTo container.position().add new Point 242, 355⤶    usaMap.rawSetExtent new Point 230, 145⤶    container.add usaMap⤶    usaMap.rememberFractionalSituationInHoldingPanel()⤶⤶    mapPin1 = new MapPinIconWdgt⤶    mapPin1.fullRawMoveTo container.position().add new Point 226, 376⤶    container.add mapPin1⤶    mapPin1.rememberFractionalSituationInHoldingPanel()⤶⤶    mapPin2 = new MapPinIconWdgt⤶    mapPin2.fullRawMoveTo container.position().add new Point 289, 363⤶    container.add mapPin2⤶    mapPin2.rememberFractionalSituationInHoldingPanel()⤶⤶    mapPin3 = new MapPinIconWdgt⤶    mapPin3.fullRawMoveTo container.position().add new Point 323, 397⤶    container.add mapPin3⤶    mapPin3.rememberFractionalSituationInHoldingPanel()⤶⤶    mapPin4 = new MapPinIconWdgt⤶    mapPin4.fullRawMoveTo container.position().add new Point 360, 421⤶    container.add mapPin4⤶    mapPin4.rememberFractionalSituationInHoldingPanel()⤶⤶    mapPin5 = new MapPinIconWdgt⤶    mapPin5.fullRawMoveTo container.position().add new Point 417, 374⤶    container.add mapPin5⤶    mapPin5.rememberFractionalSituationInHoldingPanel()⤶⤶    worldMap = new SimpleWorldMapIconWdgt Color.create 183, 183, 183⤶    worldMap.fullRawMoveTo container.position().add new Point 464, 128⤶    worldMap.rawSetExtent new Point 240, 125⤶    container.add worldMap⤶    worldMap.rememberFractionalSituationInHoldingPanel()⤶⤶    speechBubble1 = new SpeechBubbleWdgt ＂online＂⤶    speechBubble1.fullRawMoveTo container.position().add new Point 506, 123⤶    speechBubble1.rawSetExtent new Point 66, 42⤶    container.add speechBubble1⤶    speechBubble1.rememberFractionalSituationInHoldingPanel()⤶⤶    speechBubble2 = new SpeechBubbleWdgt ＂offline＂⤶    speechBubble2.fullRawMoveTo container.position().add new Point 590, 105⤶    speechBubble2.rawSetExtent new Point 66, 42⤶    container.add speechBubble2⤶    speechBubble2.rememberFractionalSituationInHoldingPanel()⤶⤶    dashboardTitle = new TextMorph2 ＂Example dashboard with interactive 3D plot＂⤶    dashboardTitle.alignCenter()⤶    dashboardTitle.alignMiddle()⤶    dashboardTitle.fullRawMoveTo container.position().add new Point 161, 6⤶    dashboardTitle.rawSetExtent new Point 403, 50⤶    container.add dashboardTitle⤶    dashboardTitle.rememberFractionalSituationInHoldingPanel()⤶⤶⤶    slider1 = new SliderMorph nil, nil, nil, nil, nil, true⤶    slider1.fullRawMoveTo container.position().add new Point 491, 484⤶    slider1.rawSetExtent new Point 201, 24⤶    container.add slider1⤶    slider1.rememberFractionalSituationInHoldingPanel()⤶⤶    slider1.setTargetAndActionWithOnesPickedFromMenu nil, nil, plot3D.contents, ＂setParameter＂⤶⤶    wm = new WindowWdgt nil, nil, slideWdgt⤶    wm.fullRawMoveTo new Point 114, 10⤶    wm.rawSetExtent new Point 596, 592⤶    world.add wm⤶    wm.setTitleWithoutPrependedContentName ＂Sample dashboard＂⤶⤶⤶    slideWdgt.disableDragsDropsAndEditing()⤶    ⤶    # if we don't do this, the window would ask to save content⤶    # when closed. Just close it instead.⤶    # TODO: should be done using a flag, we don't like⤶    # to inject code like this: the source is not tracked⤶    slideWdgt.closeFromContainerWindow = (containerWindow) ->⤶      containerWindow.close()⤶⤶    world.sampleDashboardWindow = wm⤶⤶⤶⤶  createDegreesConverterWindowOrBringItUpIfAlreadyCreated: ->⤶    if world.degreesConverterWindow?⤶      if !world.degreesConverterWindow.destroyed and world.degreesConverterWindow.parent?⤶        world.add world.degreesConverterWindow⤶        world.degreesConverterWindow.bringToForeground()⤶        world.degreesConverterWindow.fullRawMoveTo world.hand.position().add new Point 100, -50⤶        world.degreesConverterWindow.fullRawMoveWithin world⤶        world.degreesConverterWindow.rememberFractionalSituationInHoldingPanel()⤶        return⤶⤶    xCorrection = 32⤶    yCorrection = 50⤶    patchProgrammingWdgt = new PatchProgrammingWdgt⤶⤶    container = patchProgrammingWdgt.stretchableWidgetContainer.contents⤶    container.rawSetExtent new Point 584,552⤶⤶    slider1 = new SliderMorph nil, nil, nil, nil, nil, true⤶    slider1.fullRawMoveTo container.position().add new Point 43+xCorrection, 195+yCorrection⤶    slider1.rawSetExtent new Point 20, 100⤶    container.add slider1⤶    slider1.rememberFractionalSituationInHoldingPanel()⤶⤶    slider2 = new SliderMorph nil, nil, nil, nil, nil, true⤶    slider2.fullRawMoveTo container.position().add new Point 472+xCorrection, 203+yCorrection⤶    slider2.rawSetExtent new Point 20, 100⤶    container.add slider2⤶    slider2.rememberFractionalSituationInHoldingPanel()⤶⤶    cText = new TextMorph2 ＂0＂⤶    cText.fullRawMoveTo container.position().add new Point 104, 253⤶    cText.rawSetExtent new Point 150, 75⤶    container.add cText⤶    cText.rememberFractionalSituationInHoldingPanel()⤶⤶    fText = new TextMorph2 ＂0＂⤶    fText.fullRawMoveTo container.position().add new Point 344, 255⤶    fText.alignRight()⤶    fText.rawSetExtent new Point 150, 75⤶    container.add fText⤶    fText.rememberFractionalSituationInHoldingPanel()⤶⤶    calc1 = new WindowWdgt nil, nil, new CalculatingPatchNodeWdgt(＂# °C → °F formula⧹n(in1)->Math.round in1*9/5+32＂), true⤶    calc1.fullRawMoveTo container.position().add new Point 148+xCorrection/2, 19⤶    calc1.rawSetExtent new Point 241, 167⤶    container.add calc1⤶    calc1.rememberFractionalSituationInHoldingPanel()⤶⤶    calc2 = new WindowWdgt nil, nil, new CalculatingPatchNodeWdgt(＂# °F → °C formula⧹n(in1)->Math.round (in1-32)*5/9＂), true⤶    calc2.fullRawMoveTo container.position().add new Point 148+xCorrection/2, 365⤶    calc2.rawSetExtent new Point 241, 167⤶    container.add calc2⤶    calc2.rememberFractionalSituationInHoldingPanel()⤶⤶⤶    slider1.setTargetAndActionWithOnesPickedFromMenu nil, nil, cText, ＂setText＂⤶    cText.setTargetAndActionWithOnesPickedFromMenu nil, nil, calc1.contents, ＂setInput1＂⤶    calc1.contents.setTargetAndActionWithOnesPickedFromMenu nil, nil, fText, ＂setText＂⤶    fText.setTargetAndActionWithOnesPickedFromMenu nil, nil, slider2, ＂setValue＂⤶    slider2.setTargetAndActionWithOnesPickedFromMenu nil, nil, calc2.contents, ＂setInput1＂⤶    calc2.contents.setTargetAndActionWithOnesPickedFromMenu nil, nil, slider1, ＂setValue＂⤶⤶⤶⤶    cLabel = new TextMorph2 ＂°C＂⤶    cLabel.fullRawMoveTo container.position().add new Point 0+xCorrection, 102+yCorrection⤶    cLabel.rawSetExtent new Point 90, 90⤶    container.add cLabel⤶    cLabel.rememberFractionalSituationInHoldingPanel()⤶⤶    fLabel = new TextMorph2 ＂°F＂⤶    fLabel.fullRawMoveTo container.position().add new Point 422+xCorrection, 102+yCorrection⤶    fLabel.rawSetExtent new Point 90, 90⤶    container.add fLabel⤶    fLabel.rememberFractionalSituationInHoldingPanel()⤶⤶    #@inform (@position().subtract @parent.position()) + ＂ ＂ +  @extent()⤶⤶    wm = new WindowWdgt nil, nil, patchProgrammingWdgt⤶    wm.fullRawMoveTo new Point 114, 10⤶    wm.rawSetExtent new Point 596, 592⤶    world.add wm⤶    wm.setTitleWithoutPrependedContentName ＂°C ↔ °F converter＂⤶⤶⤶    patchProgrammingWdgt.disableDragsDropsAndEditing()⤶    ⤶    cText.isEditable = true⤶    fText.isEditable = true⤶⤶    # if we don't do this, the window would ask to save content⤶    # when closed. Just close it instead.⤶    # TODO: should be done using a flag, we don't like⤶    # to inject code like this: the source is not tracked⤶    patchProgrammingWdgt.closeFromContainerWindow = (containerWindow) ->⤶      containerWindow.close()⤶⤶    world.degreesConverterWindow = wm⤶⤶  # ------------------------------------------------------------------------⤶⤶  launchHowToSaveMessage: ->⤶    @createHowToSaveMessageWindowOrBringItUpIfAlreadyCreated()⤶⤶  createHowToSaveMessageOpener: ->⤶    toolbarsOpenerLauncher = new IconicDesktopSystemWindowedAppLauncherWdgt ＂How to save?＂, new FloppyDiskIconWdgt, @, ＂launchHowToSaveMessage＂⤶    # this ＂add＂ is going to try to position the reference⤶    # in some smart way (i.e. according to a grid)⤶    world.add toolbarsOpenerLauncher⤶    toolbarsOpenerLauncher.setExtent new Point 75, 75⤶    toolbarsOpenerLauncher.fullChanged()⤶⤶  # ------------------------------------------------------------------------⤶⤶  createHowToSaveMessageWindowOrBringItUpIfAlreadyCreated: ->⤶    if world.howToSaveDocWindow?⤶      if !world.howToSaveDocWindow.destroyed and world.howToSaveDocWindow.parent?⤶        world.add world.howToSaveDocWindow⤶        world.howToSaveDocWindow.bringToForeground()⤶        world.howToSaveDocWindow.fullRawMoveTo world.hand.position().add new Point 100, -50⤶        world.howToSaveDocWindow.fullRawMoveWithin world⤶        world.howToSaveDocWindow.rememberFractionalSituationInHoldingPanel()⤶        return⤶⤶    world.howToSaveDocWindow = HowToSaveMessageInfoWdg.create()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AlignCenterButtonWdgt_coffeSource = "class AlignCenterButtonWdgt extends Widget⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith ParentStainerMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.create 230, 230, 230⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new AlignCenterIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @actionableAsThumbnail = true⤶    @editorContentPropertyChangerButton = true⤶    @toolTipMessage = ＂align center＂⤶⤶  mouseClickLeft: ->⤶    if world.lastNonTextPropertyChangerButtonClickedOrDropped?.alignCenter?⤶      world.lastNonTextPropertyChangerButtonClickedOrDropped.alignCenter()⤶    else if world.lastNonTextPropertyChangerButtonClickedOrDropped?⤶      lastNonTextPropertyChangerButtonClickedOrDropped = world.lastNonTextPropertyChangerButtonClickedOrDropped.findRootForGrab()⤶      if lastNonTextPropertyChangerButtonClickedOrDropped?.layoutSpec? and⤶       lastNonTextPropertyChangerButtonClickedOrDropped.layoutSpec == LayoutSpec.ATTACHEDAS_VERTICAL_STACK_ELEMENT⤶        lastNonTextPropertyChangerButtonClickedOrDropped.layoutSpecDetails.setAlignmentToCenter()⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AlignLeftButtonWdgt_coffeSource = "class AlignLeftButtonWdgt extends Widget⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith ParentStainerMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.create 230, 230, 230⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new AlignLeftIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @actionableAsThumbnail = true⤶    @editorContentPropertyChangerButton = true⤶    @toolTipMessage = ＂align left＂⤶⤶  mouseClickLeft: ->⤶    if world.lastNonTextPropertyChangerButtonClickedOrDropped?.alignLeft?⤶      world.lastNonTextPropertyChangerButtonClickedOrDropped.alignLeft()⤶    else if world.lastNonTextPropertyChangerButtonClickedOrDropped?⤶      lastNonTextPropertyChangerButtonClickedOrDropped = world.lastNonTextPropertyChangerButtonClickedOrDropped.findRootForGrab()⤶      if lastNonTextPropertyChangerButtonClickedOrDropped?.layoutSpec? and⤶       lastNonTextPropertyChangerButtonClickedOrDropped.layoutSpec == LayoutSpec.ATTACHEDAS_VERTICAL_STACK_ELEMENT⤶        lastNonTextPropertyChangerButtonClickedOrDropped.layoutSpecDetails.setAlignmentToLeft()⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AlignRightButtonWdgt_coffeSource = "class AlignRightButtonWdgt extends Widget⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith ParentStainerMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.create 230, 230, 230⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new AlignRightIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @actionableAsThumbnail = true⤶    @editorContentPropertyChangerButton = true⤶    @toolTipMessage = ＂align right＂⤶⤶  mouseClickLeft: ->⤶    if world.lastNonTextPropertyChangerButtonClickedOrDropped?.alignRight?⤶      world.lastNonTextPropertyChangerButtonClickedOrDropped.alignRight()⤶    else if world.lastNonTextPropertyChangerButtonClickedOrDropped?⤶      lastNonTextPropertyChangerButtonClickedOrDropped = world.lastNonTextPropertyChangerButtonClickedOrDropped.findRootForGrab()⤶      if lastNonTextPropertyChangerButtonClickedOrDropped?.layoutSpec? and⤶       lastNonTextPropertyChangerButtonClickedOrDropped.layoutSpec == LayoutSpec.ATTACHEDAS_VERTICAL_STACK_ELEMENT⤶        lastNonTextPropertyChangerButtonClickedOrDropped.layoutSpecDetails.setAlignmentToRight()⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BarPlotWithAxesCreatorButtonWdgt_coffeSource = "class BarPlotWithAxesCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new BarPlotIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂bar plot＂⤶⤶  createWidgetToBeHandled: ->⤶    switcherooWm = new WindowWdgt nil, nil, new PlotWithAxesWdgt(new ExampleBarPlotWdgt), true, true⤶    switcherooWm.rawSetExtent new Point 200, 200⤶⤶    return switcherooWm⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BoldButtonWdgt_coffeSource = "class BoldButtonWdgt extends Widget⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith ParentStainerMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.create 230, 230, 230⤶⤶  constructor: ->⤶    super⤶    @appearance = new BoldIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @actionableAsThumbnail = true⤶    @editorContentPropertyChangerButton = true⤶    @toolTipMessage = ＂bold＂⤶⤶  mouseClickLeft: ->⤶    if world.lastNonTextPropertyChangerButtonClickedOrDropped?.toggleWeight?⤶      world.lastNonTextPropertyChangerButtonClickedOrDropped.toggleWeight()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CalculatingNodeCreatorButtonWdgt_coffeSource = "class CalculatingNodeCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new CalculatingNodeIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂calculating node＂⤶⤶  createWidgetToBeHandled: ->⤶    switcherooWm = new WindowWdgt nil, nil, new CalculatingPatchNodeWdgt, true⤶    switcherooWm.rawSetExtent new Point 260, 265⤶    return switcherooWm⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ChangeFontButtonWdgt_coffeSource = "class ChangeFontButtonWdgt extends IconMorph⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith ParentStainerMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.create 230, 230, 230⤶⤶  simpleDocument: nil⤶⤶  constructor: (@simpleDocument) ->⤶    super nil⤶    @appearance = new ChangeFontIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶⤶    @actionableAsThumbnail = true⤶    @editorContentPropertyChangerButton = true⤶    @toolTipMessage = ＂change font＂⤶⤶  mouseClickLeft: ->⤶    # if there is already a font selection menu for the editor,⤶    # bring that one up, otherwise create one and rember that we created it⤶    if @simpleDocument.fontSelectionMenu? and⤶     !@simpleDocument.fontSelectionMenu.destroyed⤶      @simpleDocument.fontSelectionMenu.popUp @position().subtract(new Point 80,0), world⤶    else⤶      menu = new MenuMorph @, false, @, true, true, ＂Fonts＂⤶      menu.addMenuItem ＂Arial＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, ＂justArialFontStack＂⤶      menu.addMenuItem ＂Times＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, ＂timesFontStack＂⤶      menu.addMenuItem ＂Georgia＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, ＂georgiaFontStack＂⤶      menu.addMenuItem ＂Garamo＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, ＂garamoFontStack＂⤶      menu.addMenuItem ＂Helve＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, ＂helveFontStack＂⤶      menu.addMenuItem ＂Verda＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, ＂verdaFontStack＂⤶      menu.addMenuItem ＂Treby＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, ＂trebuFontStack＂⤶      menu.addMenuItem ＂Heavy＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, ＂heavyFontStack＂⤶      menu.addMenuItem ＂Mono＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, ＂monoFontStack＂⤶⤶      menu.popUp @position().subtract(new Point 80,0), world⤶⤶      menu.editorContentPropertyChangerButton = true⤶      menu.forAllChildrenBottomToTop (eachDescendent) ->⤶        eachDescendent.editorContentPropertyChangerButton = true⤶⤶      @simpleDocument.fontSelectionMenu = menu⤶⤶  setFontName: (ignored1, ignored2, theNewFontName) ->⤶    if world.lastNonTextPropertyChangerButtonClickedOrDropped?.setFontName?⤶      widgetClickedLast = world.lastNonTextPropertyChangerButtonClickedOrDropped⤶      widgetClickedLast.setFontName(nil, ignored2, widgetClickedLast[theNewFontName])⤶⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CloseIconButtonMorph_coffeSource = "# sends a message to a target object when pressed.⤶# Takes the shape of an icon, and can also host⤶# a morph to be used as ＂face＂⤶#⤶# You could achieve something similar by having⤶# an empty button containing an icon, but changing⤶# the color of a face belonging to a button is⤶# not yet supported.⤶# i.e. this is currently the simplest way to change the color⤶# of a non-rectangular button.⤶⤶class CloseIconButtonMorph extends EmptyButtonMorph⤶⤶⤶  constructor: (@target) ->⤶    # can't set the parent as the target directly because this morph⤶    # might not have a parent yet.⤶    super true, @, 'actOnClick', new Widget⤶    @color_hover = Color.RED⤶    @color_pressed = @color_hover⤶    @appearance = new CloseIconAppearance @⤶    @toolTipMessage = ＂close window＂⤶⤶⤶  actOnClick: ->⤶    if @parent?⤶      if (@parent instanceof WindowWdgt) and @parent.contents?⤶        @parent.closeFromWindowBar()⤶      else⤶        @parent.close()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CollapseIconButtonMorph_coffeSource = "# sends a message to a target object when pressed.⤶# Takes the shape of an icon, and can also host⤶# a morph to be used as ＂face＂⤶#⤶# You could achieve something similar by having⤶# an empty button containing an icon, but changing⤶# the color of a face belonging to a button is⤶# not yet supported.⤶# i.e. this is currently the simplest way to change the color⤶# of a non-rectangular button.⤶⤶class CollapseIconButtonMorph extends EmptyButtonMorph⤶⤶  constructor: (@target) ->⤶    # can't set the parent as the target directly because this morph⤶    # might not have a parent yet.⤶    super true, @, 'actOnClick', new Widget⤶    @color_hover = Color.create 255,153,0⤶    @color_pressed = @color_hover⤶    @appearance = new CollapseIconAppearance @⤶    @toolTipMessage = ＂collapse window＂⤶⤶⤶  actOnClick: ->⤶    @parent.parent.contents.collapse()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ColorPaletteNodeCreatorButtonWdgt_coffeSource = "class ColorPaletteNodeCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new ColorPalettePatchProgrammingIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂color palette＂⤶⤶  createWidgetToBeHandled: ->⤶    switcherooWm = new WindowWdgt nil, nil, new ColorPaletteMorph, true⤶    switcherooWm.rawSetExtent new Point 200, 200⤶    return switcherooWm⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CreatorButtonWdgt_coffeSource = "class CreatorButtonWdgt extends Widget⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith ParentStainerMixin, @name⤶  @augmentWith WidgetCreatorAndSmartPlacerOnClickMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.create 230, 230, 230⤶⤶  constructor: ->⤶    super⤶    @actionableAsThumbnail = true⤶    @editorContentPropertyChangerButton = true⤶⤶  grabbedWidgetSwitcheroo: ->⤶    return @createWidgetToBeHandled()⤶⤶  # otherwise the glassbox bottom will answer on drags⤶  # and will just pick up the button and move it,⤶  # while we want the drag to create a textbox⤶  grabsToParentWhenDragged: ->⤶    false⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.DecreaseFontSizeButtonWdgt_coffeSource = "class DecreaseFontSizeButtonWdgt extends IconMorph⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith ParentStainerMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.create 230, 230, 230⤶⤶  constructor: ->⤶    super⤶    @appearance = new DecreaseFontSizeIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @actionableAsThumbnail = true⤶    @editorContentPropertyChangerButton = true⤶    @toolTipMessage = ＂decrease font size＂⤶⤶  mouseClickLeft: ->⤶    if world.lastNonTextPropertyChangerButtonClickedOrDropped?.originallySetFontSize?⤶      widgetClickedLast = world.lastNonTextPropertyChangerButtonClickedOrDropped⤶      if widgetClickedLast.originallySetFontSize > 90⤶        widgetClickedLast.setFontSize widgetClickedLast.originallySetFontSize - 10⤶      else if widgetClickedLast.originallySetFontSize > 80⤶        widgetClickedLast.setFontSize 80⤶      else if widgetClickedLast.originallySetFontSize > 72⤶        widgetClickedLast.setFontSize 72⤶      else if widgetClickedLast.originallySetFontSize > 48⤶        widgetClickedLast.setFontSize 48⤶      else if widgetClickedLast.originallySetFontSize > 36⤶        widgetClickedLast.setFontSize 36⤶      else if widgetClickedLast.originallySetFontSize > 28⤶        widgetClickedLast.setFontSize 28⤶      else if widgetClickedLast.originallySetFontSize > 12⤶        widgetClickedLast.setFontSize widgetClickedLast.originallySetFontSize - 2⤶      else⤶        widgetClickedLast.setFontSize widgetClickedLast.originallySetFontSize - 1⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.EditIconButtonWdgt_coffeSource = "# sends a message to a target object when pressed.⤶# Takes the shape of an icon, and can also host⤶# a morph to be used as ＂face＂⤶#⤶# You could achieve something similar by having⤶# an empty button containing an icon, but changing⤶# the color of a face belonging to a button is⤶# not yet supported.⤶# i.e. this is currently the simplest way to change the color⤶# of a non-rectangular button.⤶⤶class EditIconButtonWdgt extends EmptyButtonMorph⤶⤶⤶  constructor: (@target) ->⤶    # can't set the parent as the target directly because this morph⤶    # might not have a parent yet.⤶    super true, @, 'actOnClick', new Widget⤶    @color_hover = Color.create 255,153,0⤶    @color_pressed = @color_hover⤶    @appearance = new PencilIconAppearance @⤶    @toolTipMessage = ＂edit contents＂⤶⤶⤶  actOnClick: ->⤶    if @parent?⤶      if (@parent instanceof WindowWdgt)⤶        @parent.contents?.editButtonPressedFromWindowBar?()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ElasticWindowCreatorButtonWdgt_coffeSource = "# this is just the same as the ＂generic panel＂⤶⤶class ElasticWindowCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new ElasticWindowIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂elastic panel＂⤶⤶  createWidgetToBeHandled: ->⤶    genericPanel = new StretchableEditableWdgt⤶    switcherooWm = new WindowWdgt nil, nil, genericPanel, true, true⤶    switcherooWm.setTitleWithoutPrependedContentName ＂elastic panel＂⤶    switcherooWm.rawSetExtent new Point 200, 200⤶⤶    return switcherooWm⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.EmptyWindowCreatorButtonWdgt_coffeSource = "class EmptyWindowCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new EmptyWindowIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂empty window＂⤶⤶  createWidgetToBeHandled: ->⤶    switcherooWm = new WindowWdgt nil, nil, nil, true, true⤶    switcherooWm.rawSetExtent new Point 200, 200⤶    return switcherooWm⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ExternalIconButtonWdgt_coffeSource = "# sends a message to a target object when pressed.⤶# Takes the shape of an icon, and can also host⤶# a morph to be used as ＂face＂⤶#⤶# You could achieve something similar by having⤶# an empty button containing an icon, but changing⤶# the color of a face belonging to a button is⤶# not yet supported.⤶# i.e. this is currently the simplest way to change the color⤶# of a non-rectangular button.⤶⤶class ExternalIconButtonWdgt extends EmptyButtonMorph⤶⤶⤶  constructor: (@target) ->⤶    # can't set the parent as the target directly because this morph⤶    # might not have a parent yet.⤶    super true, @, 'actOnClick', new Widget⤶    @color_hover = Color.create 255,153,0⤶    @color_pressed = @color_hover⤶    @appearance = new ExternalIconAppearance @⤶    @toolTipMessage = ＂make this window droppable⧹ninto other documents＂⤶⤶⤶  actOnClick: ->⤶    if @parent?.parent?⤶      if (@parent.parent instanceof WindowWdgt)⤶        @parent.parent.makeInternal()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ExternalLinkButtonWdgt_coffeSource = "class ExternalLinkButtonWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new ExternalLinkIconAppearance @⤶⤶  mouseClickLeft: ->⤶    if @parent? and (@parent instanceof SimpleLinkWdgt)⤶      window.open @parent.outputTextArea.text⤶⤶  mouseEnter: ->⤶    world.worldCanvas.style.cursor = 'pointer'⤶  ⤶  mouseLeave: ->⤶    world.worldCanvas.style.cursor = ''⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ExternalLinkCreatorButtonWdgt_coffeSource = "class ExternalLinkCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new ExternalLinkIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂external link＂⤶⤶  createWidgetToBeHandled: ->⤶    switcheroo = new SimpleLinkWdgt⤶    switcheroo.fullRawMoveTo @position()⤶    switcheroo.rawSetExtent new Point 330, 65⤶    return switcheroo⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.FormatAsCodeButtonWdgt_coffeSource = "class FormatAsCodeButtonWdgt extends IconMorph⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith ParentStainerMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.create 230, 230, 230⤶⤶  constructor: ->⤶    super⤶    @appearance = new FormatAsCodeIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @actionableAsThumbnail = true⤶    @editorContentPropertyChangerButton = true⤶    @toolTipMessage = ＂format as code＂⤶⤶  mouseClickLeft: ->⤶    if world.lastNonTextPropertyChangerButtonClickedOrDropped?.setFontName?⤶      widgetClickedLast = world.lastNonTextPropertyChangerButtonClickedOrDropped⤶      if widgetClickedLast.fontName != widgetClickedLast.monoFontStack⤶        widgetClickedLast.setFontName nil, nil, widgetClickedLast.monoFontStack⤶      else⤶        widgetClickedLast.setFontName nil, nil, widgetClickedLast.justArialFontStack⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.FunctionPlotWithAxesCreatorButtonWdgt_coffeSource = "class FunctionPlotWithAxesCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new FunctionPlotIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂function plot＂⤶⤶  createWidgetToBeHandled: ->⤶    switcherooWm = new WindowWdgt nil, nil, new PlotWithAxesWdgt(new ExampleFunctionPlotWdgt), true, true⤶    switcherooWm.rawSetExtent new Point 200, 200⤶⤶    return switcherooWm⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.GrayscalePaletteNodeCreatorButtonWdgt_coffeSource = "class GrayscalePaletteNodeCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new GrayscalePalettePatchProgrammingIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂grayscale palette＂⤶⤶  createWidgetToBeHandled: ->⤶    switcherooWm = new WindowWdgt nil, nil, new GrayPaletteMorph, true⤶    switcherooWm.rawSetExtent new Point 200, 200⤶    return switcherooWm⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.IncreaseFontSizeButtonWdgt_coffeSource = "class IncreaseFontSizeButtonWdgt extends IconMorph⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith ParentStainerMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.create 230, 230, 230⤶⤶  constructor: ->⤶    super⤶    @appearance = new IncreaseFontSizeIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @actionableAsThumbnail = true⤶    @editorContentPropertyChangerButton = true⤶    @toolTipMessage = ＂increase font size＂⤶⤶  mouseClickLeft: ->⤶⤶    if world.lastNonTextPropertyChangerButtonClickedOrDropped?.originallySetFontSize?⤶      widgetClickedLast = world.lastNonTextPropertyChangerButtonClickedOrDropped⤶      if widgetClickedLast.originallySetFontSize < 12⤶        widgetClickedLast.setFontSize widgetClickedLast.originallySetFontSize + 1⤶      else if widgetClickedLast.originallySetFontSize < 28⤶        widgetClickedLast.setFontSize widgetClickedLast.originallySetFontSize + 2⤶      else if widgetClickedLast.originallySetFontSize < 36⤶        widgetClickedLast.setFontSize 36⤶      else if widgetClickedLast.originallySetFontSize < 48⤶        widgetClickedLast.setFontSize 48⤶      else if widgetClickedLast.originallySetFontSize < 72⤶        widgetClickedLast.setFontSize 72⤶      else if widgetClickedLast.originallySetFontSize < 80⤶        widgetClickedLast.setFontSize 80⤶      else⤶        widgetClickedLast.setFontSize widgetClickedLast.originallySetFontSize + 10⤶⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.InternalIconButtonWdgt_coffeSource = "# sends a message to a target object when pressed.⤶# Takes the shape of an icon, and can also host⤶# a morph to be used as ＂face＂⤶#⤶# You could achieve something similar by having⤶# an empty button containing an icon, but changing⤶# the color of a face belonging to a button is⤶# not yet supported.⤶# i.e. this is currently the simplest way to change the color⤶# of a non-rectangular button.⤶⤶class InternalIconButtonWdgt extends EmptyButtonMorph⤶⤶⤶  constructor: (@target) ->⤶    # can't set the parent as the target directly because this morph⤶    # might not have a parent yet.⤶    super true, @, 'actOnClick', new Widget⤶    @color_hover = Color.create 255,153,0⤶    @color_pressed = @color_hover⤶    @appearance = new InternalIconAppearance @⤶    @toolTipMessage = ＂pop-out window from documents,⧹nmake it un-droppable⧹ninto other documents＂⤶⤶⤶  actOnClick: ->⤶    if @parent?.parent?⤶      if (@parent.parent instanceof WindowWdgt)⤶        @parent.parent.makeExternal()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ItalicButtonWdgt_coffeSource = "class ItalicButtonWdgt extends Widget⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith ParentStainerMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.create 230, 230, 230⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new ItalicIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @actionableAsThumbnail = true⤶    @editorContentPropertyChangerButton = true⤶    @toolTipMessage = ＂italic＂⤶⤶  mouseClickLeft: ->⤶    if world.lastNonTextPropertyChangerButtonClickedOrDropped?.toggleItalic?⤶      world.lastNonTextPropertyChangerButtonClickedOrDropped.toggleItalic()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.PatchProgrammingComponentsToolbarCreatorButtonWdgt_coffeSource = "class PatchProgrammingComponentsToolbarCreatorButtonWdgt extends ToolbarCreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new PatchProgrammingComponentsIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂components that can be connected＂⤶⤶  createWidgetToBeHandled: ->⤶⤶    toolsPanel = new ScrollPanelWdgt new ToolPanelWdgt⤶⤶    toolsPanel.addMany [⤶      new SliderNodeCreatorButtonWdgt⤶      new ColorPaletteNodeCreatorButtonWdgt⤶      new GrayscalePaletteNodeCreatorButtonWdgt⤶      new CalculatingNodeCreatorButtonWdgt⤶    ]⤶⤶    toolsPanel.disableDragsDropsAndEditing()⤶⤶    switcherooWm = new WindowWdgt nil, nil, toolsPanel⤶    switcherooWm.fullRawMoveTo new Point 90, Math.floor((world.height()-192)/2)⤶    switcherooWm.fullRawMoveWithin world⤶    world.add switcherooWm⤶    switcherooWm.rawSetExtent new Point 61, 192⤶⤶    return switcherooWm⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.Plot3DCreatorButtonWdgt_coffeSource = "class Plot3DCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new Plot3DIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂3D plot＂⤶⤶  createWidgetToBeHandled: ->⤶    switcherooWm = new WindowWdgt nil, nil, new Example3DPlotWdgt, true, true⤶    switcherooWm.rawSetExtent new Point 200, 200⤶    return switcherooWm⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.PlotsToolbarCreatorButtonWdgt_coffeSource = "class PlotsToolbarCreatorButtonWdgt extends ToolbarCreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new AllPlotsIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂plots/graphs＂⤶⤶  createWidgetToBeHandled: ->⤶⤶    toolsPanel = new ScrollPanelWdgt new ToolPanelWdgt⤶⤶    toolsPanel.addMany [⤶      new ScatterPlotWithAxesCreatorButtonWdgt⤶      new FunctionPlotWithAxesCreatorButtonWdgt⤶      new BarPlotWithAxesCreatorButtonWdgt⤶      new Plot3DCreatorButtonWdgt⤶    ]⤶⤶    toolsPanel.disableDragsDropsAndEditing()⤶⤶    switcherooWm = new WindowWdgt nil, nil, toolsPanel⤶    switcherooWm.setExtent new Point 60, 192⤶    switcherooWm.fullRawMoveTo new Point 90, Math.floor((world.height()-192)/2)⤶    switcherooWm.fullRawMoveWithin world⤶    world.add switcherooWm⤶⤶    return switcherooWm⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ScatterPlotWithAxesCreatorButtonWdgt_coffeSource = "class ScatterPlotWithAxesCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new ScatterPlotIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂scatter plot＂⤶⤶  createWidgetToBeHandled: ->⤶    switcherooWm = new WindowWdgt nil, nil, new PlotWithAxesWdgt(new ExampleScatterPlotWdgt), true, true⤶    switcherooWm.rawSetExtent new Point 200, 200⤶⤶    return switcherooWm⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SliderNodeCreatorButtonWdgt_coffeSource = "class SliderNodeCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new SliderNodeIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂slider node＂⤶⤶  createWidgetToBeHandled: ->⤶    switcherooWdgt = new SliderMorph nil, nil, nil, nil, nil, true⤶    return switcherooWdgt⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SlidesToolbarCreatorButtonWdgt_coffeSource = "class SlidesToolbarCreatorButtonWdgt extends ToolbarCreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new SlidesToolbarIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂items for slides＂⤶⤶  createWidgetToBeHandled: ->⤶⤶    toolsPanel = new ScrollPanelWdgt new ToolPanelWdgt⤶⤶    toolsPanel.addMany [⤶      new TextBoxCreatorButtonWdgt⤶      new ExternalLinkCreatorButtonWdgt⤶      new VideoPlayCreatorButtonWdgt⤶⤶      new WorldMapCreatorButtonWdgt⤶      new USAMapCreatorButtonWdgt⤶⤶      new RectangleMorph⤶⤶      new MapPinIconWdgt⤶⤶      new SpeechBubbleWdgt⤶⤶      new DestroyIconMorph⤶      new ScratchAreaIconMorph⤶      new FloraIconMorph⤶      new ScooterIconMorph⤶      new HeartIconMorph⤶⤶      new FizzygumLogoIconWdgt⤶      new FizzygumLogoWithTextIconWdgt⤶      new VaporwaveBackgroundIconWdgt⤶      new VaporwaveSunIconWdgt⤶⤶      new ArrowNIconWdgt⤶      new ArrowSIconWdgt⤶      new ArrowWIconWdgt⤶      new ArrowEIconWdgt⤶      new ArrowNWIconWdgt⤶      new ArrowNEIconWdgt⤶      new ArrowSWIconWdgt⤶      new ArrowSEIconWdgt⤶    ]⤶⤶    toolsPanel.disableDragsDropsAndEditing()⤶⤶    switcherooWm = new WindowWdgt nil, nil, toolsPanel⤶    switcherooWm.fullRawMoveTo new Point 90, Math.floor((world.height()-192)/2)⤶    switcherooWm.fullRawMoveWithin world⤶    world.add switcherooWm⤶    switcherooWm.rawSetExtent new Point 105, 300⤶⤶    return switcherooWm⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.TemplatesButtonWdgt_coffeSource = "class TemplatesButtonWdgt extends IconMorph⤶⤶  @augmentWith HighlightableMixin, @name⤶  @augmentWith ParentStainerMixin, @name⤶⤶  color_hover: Color.create 90, 90, 90⤶  color_pressed: Color.GRAY⤶  color_normal: Color.create 230, 230, 230⤶⤶  constructor: ->⤶    super⤶    @appearance = new TemplatesIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶⤶    @actionableAsThumbnail = true⤶    @editorContentPropertyChangerButton = true⤶    @toolTipMessage = ＂useful snippets＂⤶⤶  bringTemplatesWindowIntoView: ->⤶    world.simpleEditorTemplates.bringToForeground()⤶    world.simpleEditorTemplates.fullRawMoveTo world.hand.position().subtract new Point 50, 50⤶    world.simpleEditorTemplates.fullRawMoveWithin world⤶⤶  mouseClickLeft: ->⤶    if world.simpleEditorTemplates?⤶      if world.simpleEditorTemplates.destroyed or !world.simpleEditorTemplates.parent?⤶        templatesWindow = menusHelper.createNewTemplatesWindow()⤶        @positionTemplatesWindowAndRegisterIt templatesWindow⤶      else if world.simpleEditorTemplates.parent? and world.simpleEditorTemplates.parent == world.basementWdgt.scrollPanel.contents⤶        world.add world.simpleEditorTemplates⤶        @bringTemplatesWindowIntoView()⤶      else if !world.simpleEditorTemplates.destroyed and world.simpleEditorTemplates.parent == world⤶        @bringTemplatesWindowIntoView()⤶    else⤶      templatesWindow = menusHelper.createNewTemplatesWindow()⤶      @positionTemplatesWindowAndRegisterIt templatesWindow⤶⤶  positionTemplatesWindowAndRegisterIt: (templatesWindow) ->⤶    templatesWindow.fullRawMoveTo world.hand.position().subtract new Point 50, 50⤶    templatesWindow.fullRawMoveWithin world⤶    world.add templatesWindow⤶    world.simpleEditorTemplates = templatesWindow⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.TextBoxCreatorButtonWdgt_coffeSource = "class TextBoxCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new TextIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂text box＂⤶⤶  createWidgetToBeHandled: ->⤶    switcheroo = new TextMorph2 ＂insert text here＂⤶    switcheroo.isEditable = true⤶    switcheroo.fittingSpecWhenBoundsTooLarge = FittingSpecTextInLargerBounds.SCALEUP⤶    switcheroo.fittingSpecWhenBoundsTooSmall = FittingSpecTextInSmallerBounds.SCALEDOWN⤶    switcheroo.alignMiddle()⤶    switcheroo.alignLeft()⤶    switcheroo.fullRawMoveTo @position()⤶    switcheroo.rawSetExtent new Point 150, 75⤶    return switcheroo⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.TextToolbarCreatorButtonWdgt_coffeSource = "class TextToolbarCreatorButtonWdgt extends ToolbarCreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new TextToolbarIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂Text tools＂⤶⤶  createWidgetToBeHandled: ->⤶⤶    toolsPanel = new ScrollPanelWdgt new ToolPanelWdgt⤶⤶    toolsPanel.addMany [⤶      new ChangeFontButtonWdgt @⤶      new BoldButtonWdgt⤶      new ItalicButtonWdgt⤶      new FormatAsCodeButtonWdgt⤶      new IncreaseFontSizeButtonWdgt⤶      new DecreaseFontSizeButtonWdgt⤶⤶      new AlignLeftButtonWdgt⤶      new AlignCenterButtonWdgt⤶      new AlignRightButtonWdgt⤶    ]⤶⤶    toolsPanel.disableDragsDropsAndEditing()⤶⤶    switcherooWm = new WindowWdgt nil, nil, toolsPanel⤶    switcherooWm.fullRawMoveTo new Point 90, Math.floor((world.height()-192)/2)⤶    switcherooWm.fullRawMoveWithin world⤶    world.add switcherooWm⤶    switcherooWm.rawSetExtent new Point 130, 156⤶⤶    return switcherooWm⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ToolbarCreatorButtonWdgt_coffeSource = "class ToolbarCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  mouseClickLeft: (ignored, ignored2, ignored3, ignored4, ignored5, ignored6, ignored7, partOfDoubleClick) ->⤶    if partOfDoubleClick⤶      return⤶    windowToBePlaced = @createWidgetToBeHandled()⤶    windowToBePlaced.fullRawMoveTo @topRight().add new Point 20,-40⤶    world.add windowToBePlaced⤶    windowToBePlaced.fullRawMoveWithin world⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.USAMapCreatorButtonWdgt_coffeSource = "class USAMapCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new LittleUSAIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂USA map＂⤶⤶  createWidgetToBeHandled: ->⤶    switcheroo = new SimpleUSAMapIconWdgt⤶    switcheroo.rawSetExtent new Point 230, 145⤶    switcheroo.setColor Color.create 183, 183, 183⤶    return switcheroo⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.UncollapseIconButtonMorph_coffeSource = "# sends a message to a target object when pressed.⤶# Takes the shape of an icon, and can also host⤶# a morph to be used as ＂face＂⤶#⤶# You could achieve something similar by having⤶# an empty button containing an icon, but changing⤶# the color of a face belonging to a button is⤶# not yet supported.⤶# i.e. this is currently the simplest way to change the color⤶# of a non-rectangular button.⤶⤶class UncollapseIconButtonMorph extends EmptyButtonMorph⤶⤶  constructor: (@target) ->⤶    # can't set the parent as the target directly because this morph⤶    # might not have a parent yet.⤶    super true, @, 'actOnClick', new Widget⤶    @color_hover = Color.create 255,153,0⤶    @color_pressed = @color_hover⤶    @appearance = new UncollapseIconAppearance @⤶    @toolTipMessage = ＂un-collapse window＂⤶⤶⤶  actOnClick: ->⤶    @parent.parent.contents.unCollapse()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.UpperRightTriangleIconicButton_coffeSource = "# like an UpperRightTriangle, but it adds an icon on the top-right⤶⤶# to test this:⤶# create a canvas. then:⤶# new UpperRightTriangleIconicButton(world.children[0])⤶⤶class UpperRightTriangleIconicButton extends UpperRightTriangle⤶⤶  @augmentWith HighlightableMixin, @name⤶⤶  color: Color.WHITE⤶  pencilIconMorph: nil⤶⤶  constructor: (parent = nil) ->⤶    super⤶    @pencilIconMorph = new PencilIconMorph Color.BLACK⤶⤶    @add @pencilIconMorph, nil, LayoutSpec.ATTACHEDAS_CORNER_INTERNAL_TOPRIGHT⤶    @pencilIconMorph.layoutSpec_cornerInternal_proportionOfParent = 1/2⤶    @pencilIconMorph.layoutSpec_cornerInternal_fixedSize = 0⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.UsefulTextSnippetsToolbarCreatorButtonWdgt_coffeSource = "class UsefulTextSnippetsToolbarCreatorButtonWdgt extends ToolbarCreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new TemplatesIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂Useful text snippets＂⤶⤶  createWidgetToBeHandled: ->⤶    return menusHelper.createNewTemplatesWindow()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.VideoPlayButtonWdgt_coffeSource = "class VideoPlayButtonWdgt extends ExternalLinkButtonWdgt⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new VideoPlayIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.VideoPlayCreatorButtonWdgt_coffeSource = "class VideoPlayCreatorButtonWdgt extends ExternalLinkCreatorButtonWdgt⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new VideoPlayIconAppearance @⤶    @toolTipMessage = ＂link to video＂⤶⤶  createWidgetToBeHandled: ->⤶    switcheroo = new SimpleVideoLinkWdgt⤶    switcheroo.fullRawMoveTo @position()⤶    switcheroo.rawSetExtent new Point 330, 65⤶    return switcheroo⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.WindowWithPanelCreatorButtonWdgt_coffeSource = "class WindowWithPanelCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new WindowWithCroppingPanelIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂cropping panel＂⤶⤶  createWidgetToBeHandled: ->⤶    switcherooWm = new WindowWdgt nil, nil, new PanelWdgt, true, true⤶    switcherooWm.rawSetExtent new Point 200, 200⤶    return switcherooWm⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.WindowWithScrollPanelCreatorButtonWdgt_coffeSource = "class WindowWithScrollPanelCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new WindowWithScrollingPanelIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂scroll panel＂⤶⤶  createWidgetToBeHandled: ->⤶    switcherooWm = new WindowWdgt nil, nil, new ScrollPanelWdgt, true, true⤶    switcherooWm.rawSetExtent new Point 200, 200⤶    return switcherooWm⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.WindowsToolbarCreatorButtonWdgt_coffeSource = "class WindowsToolbarCreatorButtonWdgt extends ToolbarCreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new WindowsToolbarIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂many types of⧹npre-made windows＂⤶⤶  createWidgetToBeHandled: ->⤶⤶    toolsPanel = new ScrollPanelWdgt new ToolPanelWdgt⤶⤶    toolsPanel.addMany [⤶      new EmptyWindowCreatorButtonWdgt⤶      new WindowWithPanelCreatorButtonWdgt⤶      new WindowWithScrollPanelCreatorButtonWdgt⤶      new ElasticWindowCreatorButtonWdgt⤶    ]⤶⤶    toolsPanel.disableDragsDropsAndEditing()⤶⤶    switcherooWm = new WindowWdgt nil, nil, toolsPanel⤶    switcherooWm.fullRawMoveTo new Point 90, Math.floor((world.height()-192)/2)⤶    switcherooWm.fullRawMoveWithin world⤶    world.add switcherooWm⤶    switcherooWm.rawSetExtent new Point 61, 192⤶    readmeWindow = WindowsToolbarInfoWdgt.createNextTo switcherooWm⤶    readmeWindow?.fullRawMoveTo new Point 300, 200⤶    readmeWindow?.rememberFractionalSituationInHoldingPanel()⤶⤶    return switcherooWm⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.WorldMapCreatorButtonWdgt_coffeSource = "class WorldMapCreatorButtonWdgt extends CreatorButtonWdgt⤶⤶  constructor: ->⤶    super⤶    @appearance = new LittleWorldIconAppearance @, WorldMorph.preferencesAndSettings.iconDarkLineColor⤶    @toolTipMessage = ＂world map＂⤶⤶  createWidgetToBeHandled: ->⤶    switcheroo = new SimpleWorldMapIconWdgt⤶    switcheroo.rawSetExtent new Point 240, 125⤶    switcheroo.setColor Color.create 183, 183, 183⤶    return switcheroo⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AxisWdgt_coffeSource = "class AxisWdgt extends Widget⤶⤶  majorDimLine: nil⤶  ticksRectangles: nil⤶  labelsTextBoxes: nil⤶  min: 0⤶  max: 0⤶⤶  constructor: (@min = -15, @max = 15) ->⤶    super()⤶    @ticksRectangles = []⤶    @labelsTextBoxes = []⤶    @buildAndConnectChildren()⤶⤶  buildAndConnectChildren: ->⤶⤶    @majorDimLine = new RectangleMorph⤶    @majorDimLine.minimumExtent = new Point 1,1⤶⤶    @add @majorDimLine⤶⤶    numberOfTicks = @max - @min + 1⤶    for i in [0 ... numberOfTicks]⤶      @ticksRectangles[i] = new RectangleMorph⤶      @ticksRectangles[i].minimumExtent = new Point 1,1⤶      @add @ticksRectangles[i]⤶⤶      @labelsTextBoxes[i] = new StringMorph2 ＂＂⤶      @labelsTextBoxes[i].fittingSpecWhenBoundsTooLarge = FittingSpecTextInLargerBounds.SCALEUP⤶      @labelsTextBoxes[i].fittingSpecWhenBoundsTooSmall = FittingSpecTextInSmallerBounds.SCALEDOWN⤶      @add @labelsTextBoxes[i]⤶⤶    @invalidateLayout()⤶⤶  rawSetExtent: (aPoint) ->⤶    super⤶    @invalidateLayout()⤶⤶  # TODO some duplication of code here with⤶  # the method below⤶  distanceOfAxisOriginFromEdge: ->⤶    height = @height()⤶    width = @width()⤶⤶    numberOfTicks = @max - @min + 1⤶    if height > width⤶      # vert axis⤶      tickHeight = height/(numberOfTicks + 1)⤶      return new Point -5, tickHeight⤶    else⤶      # horiz axis⤶      tickHeight = width/(numberOfTicks + 1)⤶      return new Point tickHeight, 5⤶⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    newBoundsForThisLayout = @__calculateNewBoundsWhenDoingLayout newBoundsForThisLayout⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # TODO should'be calling this rawSetBounds from here,⤶    # rather use super⤶    @rawSetBounds newBoundsForThisLayout⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶    height = @height()⤶    width = @width()⤶⤶    numberOfTicks = @max - @min + 1⤶    if height > width⤶      tickHeight = height/(numberOfTicks + 1)⤶    else⤶      tickHeight = width/(numberOfTicks + 1)⤶    heightOfTheDrawnBar = (numberOfTicks - 1) * tickHeight⤶⤶    thickness = 2⤶    labelSizeReduction = 0.7⤶    labelSpace = tickHeight* labelSizeReduction⤶⤶    if height > width⤶      @majorDimLine.fullRawMoveTo new Point @right() - 5, @top() + tickHeight⤶      @majorDimLine.setExtent new Point thickness, heightOfTheDrawnBar⤶    else⤶      @majorDimLine.fullRawMoveTo new Point @left() + tickHeight, @top() + 5⤶      @majorDimLine.setExtent new Point heightOfTheDrawnBar, thickness⤶⤶    for i in [0 ... numberOfTicks]⤶      if height > width⤶        @ticksRectangles[i].fullRawMoveTo new Point @right()-10, @top() + tickHeight + Math.round(i * tickHeight)⤶        @ticksRectangles[i].setExtent new Point 5 + thickness, thickness⤶⤶        @labelsTextBoxes[i].setText ＂＂ + (@max - i)⤶        @labelsTextBoxes[i].fullRawMoveTo new Point @left(), @top() + tickHeight + Math.round(i * tickHeight) - labelSpace/2⤶        @labelsTextBoxes[i].setExtent new Point width - 10, labelSpace⤶        @labelsTextBoxes[i].alignMiddle()⤶        @labelsTextBoxes[i].alignRight()⤶⤶      else⤶        @ticksRectangles[i].fullRawMoveTo new Point @left() + tickHeight + Math.round(i * tickHeight), @top() + 5⤶        @ticksRectangles[i].setExtent new Point thickness, 5 + thickness⤶⤶        @labelsTextBoxes[i].setText ＂＂ + (@min + i)⤶        @labelsTextBoxes[i].fullRawMoveTo new Point @left() + tickHeight + Math.round(i * tickHeight) - labelSpace/2, @top() + 5 + 5⤶        @labelsTextBoxes[i].setExtent new Point labelSpace, height - 10⤶        @labelsTextBoxes[i].alignTop()⤶        @labelsTextBoxes[i].alignCenter()⤶⤶⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶⤶    super⤶    @markLayoutAsFixed()⤶⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.Example3DPlotWdgt_coffeSource = "class Example3DPlotWdgt extends Widget⤶⤶⤶  vertices: nil⤶  quads: nil⤶  currentAngle: nil⤶  planeGrid: nil⤶  graphGrid: nil⤶  previousMousePoint: nil⤶  autoRotate: true⤶  ratio: nil⤶⤶  # a parameter for a slider to control,⤶  # so to show interactive graph/plot⤶  parameterValue: 0⤶⤶  constructor: ->⤶    super()⤶    @defaultRejectDrags = true⤶    @isLockingToPanels = true⤶⤶    @fps = 0⤶    world.steppingWdgts.add @⤶⤶    @setColor Color.create 255, 125, 125⤶    @rawSetExtent new Point 200, 200⤶⤶⤶⤶    @edges = []⤶⤶    @quads = []⤶    ⤶    @currentAngle = 0⤶⤶    @step()⤶⤶  colloquialName: ->⤶    ＂3D plot＂⤶⤶  setParameter: (parameterValue, ignored, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @connectionsCalculationToken = connectionsCalculationToken⤶    @parameterValue = parameterValue⤶    @calculateNewPlotValues()⤶⤶  reactToTargetConnection: ->⤶    @calculateNewPlotValues()⤶⤶  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    if !menuEntriesStrings?⤶      menuEntriesStrings = []⤶      functionNamesStrings = []⤶    menuEntriesStrings.push ＂param＂⤶    functionNamesStrings.push ＂setParameter＂⤶⤶    if @addShapeSpecificNumericalSetters?⤶      [menuEntriesStrings, functionNamesStrings] = @addShapeSpecificNumericalSetters menuEntriesStrings, functionNamesStrings⤶⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  # ---------------------------------------------------------------⤶  # Outside of a stack, the plot can take any dimension.⤶  # When IN a stack, then we⤶  # want the content to force the ratio of the window so that the⤶  # plot grows/shrinks in both dimensions harmoniously as the⤶  # page is widened/narrowed.⤶⤶  justDropped: (whereIn) ->⤶    super⤶    if (whereIn instanceof SimpleVerticalStackPanelWdgt) and !(whereIn instanceof WindowWdgt)⤶      @constrainToRatio()⤶⤶  holderWindowJustDropped: (whereIn) ->⤶    if (whereIn instanceof SimpleVerticalStackPanelWdgt) and !(whereIn instanceof WindowWdgt)⤶      @constrainToRatio()⤶⤶  constrainToRatio: ->⤶    if @layoutSpecDetails?⤶      @ratio = @width() / @height()⤶      @layoutSpecDetails.canSetHeightFreely = false⤶      # force a resize, so the slide and the window⤶      # it's in will take the right ratio, and hence⤶      # the content will take the whole window it's in.⤶      # Note that the height of 0 here is ignored since⤶      # ＂rawSetWidthSizeHeightAccordingly＂ will⤶      # calculate the height.⤶      @rawSetExtent new Point @width(), 0⤶⤶  holderWindowJustBeenGrabbed: (whereFrom) ->⤶    if whereFrom instanceof SimpleVerticalStackPanelWdgt⤶      @freeFromRatioConstraints()⤶⤶  justBeenGrabbed: (whereFrom) ->⤶    if whereFrom instanceof SimpleVerticalStackPanelWdgt⤶      @freeFromRatioConstraints()⤶⤶  freeFromRatioConstraints: ->⤶    if @layoutSpecDetails?⤶      @layoutSpecDetails.canSetHeightFreely = true⤶      @ratio = nil⤶⤶      availableHeight = world.height() - 20⤶      if @parent.height() > availableHeight⤶        @parent.rawSetExtent (new Point Math.min((@width()/@height()) * availableHeight, world.width()), availableHeight).round()⤶        @parent.fullRawMoveTo world.hand.position().subtract @parent.extent().floorDivideBy 2⤶        @parent.fullRawMoveWithin world⤶⤶  rawSetWidthSizeHeightAccordingly: (newWidth) ->⤶    if @ratio?⤶      @rawSetExtent new Point newWidth, Math.round(newWidth / @ratio)⤶    else⤶      super⤶  # -----------------------------------------------------------------⤶⤶  step: ->⤶    if @autoRotate⤶      @currentAngle++⤶    @calculateNewPlotValues()⤶⤶  ⤶  # TODO seems like in a plot and a grid like these⤶  # one could really reuse past vertices and just modify them⤶  # and avoid aaaaaall these constructions every time⤶  calculateNewPlotValues: ->⤶    @vertices = []⤶⤶    @graphGrid = new Grid3D 21, 21, []⤶⤶    for i in [-1..1] by 0.1⤶      for j in [-1..1] by 0.1⤶        @vertices.push new Point3D i, j, (Math.sin(i*@parameterValue/30)) + (Math.sin(i*3 + @currentAngle/160) + Math.cos(j*3 + @currentAngle/160))/2⤶        @graphGrid.vertexIndexes.push @vertices.length - 1⤶⤶⤶    @planeGrid = new PlaneGrid3D 21, 21⤶⤶    for i in [-1..1] by 0.1⤶      @vertices.push new Point3D i, -1, 0⤶      @planeGrid.vertexIndexes.push @vertices.length - 1⤶      @vertices.push new Point3D i, 1, 0⤶      @planeGrid.vertexIndexes.push @vertices.length - 1⤶⤶    for j in [-1..1] by 0.1⤶      @vertices.push new Point3D -1, j, 0⤶      @planeGrid.vertexIndexes.push @vertices.length - 1⤶      @vertices.push new Point3D 1, j, 0⤶      @planeGrid.vertexIndexes.push @vertices.length - 1⤶⤶⤶    @changed()⤶⤶  # This method only paints this very morph's ＂image＂,⤶  # it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which⤶  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if @preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return⤶⤶    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    aContext.save()⤶⤶    # clip out the dirty rectangle as we are⤶    # going to paint the whole of the box⤶    aContext.clipToRectangle al,at,w,h⤶⤶    aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @backgroundTransparency⤶⤶    # paintRectangle here is made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, this is why⤶    # it's called before the scaling.⤶    @paintRectangle aContext, al, at, w, h, @backgroundColor⤶    aContext.useLogicalPixelsUntilRestore()⤶⤶    morphPosition = @position()⤶    aContext.translate morphPosition.x, morphPosition.y⤶⤶    @renderingHelper aContext, Color.WHITE, appliedShadow⤶⤶    aContext.restore()⤶⤶    # paintHighlight here is made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, this is why⤶    # it's called outside the effect of the scaling⤶    # (after the restore).⤶    @paintHighlight aContext, al, at, w, h⤶⤶  mouseMove: (pos, mouseButton) ->⤶    if world.hand.isThisPointerDraggingSomething() then return⤶    if mouseButton == 'left'⤶        if @previousMousePoint?⤶          @currentAngle +=  @previousMousePoint.x - pos.x⤶        @previousMousePoint = pos⤶⤶  mouseDownLeft: (pos) ->⤶    @autoRotate = false⤶    @bringToForeground()⤶⤶  mouseUpLeft: ->⤶    @autoRotate = true⤶⤶  mouseLeave: ->⤶    @autoRotate = true⤶⤶  renderingHelper: (context, color, appliedShadow) ->⤶⤶    height = @height()⤶    width = @width()⤶⤶    # clean the background⤶    if appliedShadow?⤶      context.globalAlpha = appliedShadow.alpha * @alpha⤶      context.fillStyle = (Color.create 80, 80, 80).toString()⤶      context.fillRect 0, 0, width, height⤶      # let's avoid paint 3d stuff twice because⤶      # of the shadow⤶      return⤶⤶    context.fillStyle = WorldMorph.preferencesAndSettings.editableItemBackgroundColor.toString()⤶    context.fillRect 0, 0, width, height⤶⤶⤶    squareDim = Math.min width, height⤶    context.translate (width-squareDim)/2, (height-squareDim)/2⤶⤶    points = []⤶⤶    context.strokeStyle = Color.BLACK.toString()⤶    originalAlpha = context.globalAlpha⤶    context.globalAlpha = 0.6⤶⤶    context.scale squareDim/300, squareDim/300⤶⤶    for eachVertex in @vertices⤶      newPoint = eachVertex.rotateX(90).rotateY(@currentAngle/2).translateXYZ(0,0.5,0).project(300, 300, 220, 3)⤶      newPoint.y -= squareDim * 1/6⤶      points.push newPoint⤶⤶    for eachQuad in @quads⤶      context.beginPath()⤶      context.moveTo points[eachQuad[0]].x, points[eachQuad[0]].y⤶      context.lineTo points[eachQuad[1]].x, points[eachQuad[1]].y⤶      context.lineTo points[eachQuad[2]].x, points[eachQuad[2]].y⤶      context.lineTo points[eachQuad[3]].x, points[eachQuad[3]].y⤶      context.closePath()⤶      context.stroke()⤶⤶    for eachEdge in @edges⤶      context.beginPath()⤶      context.moveTo points[eachEdge[0]].x, points[eachEdge[0]].y⤶      context.lineTo points[eachEdge[1]].x, points[eachEdge[1]].y⤶      context.closePath()⤶      context.stroke()⤶⤶⤶    context.beginPath()⤶⤶    # draw the ＂horizontals＂ in the grid (each point x,y with x+1,y)⤶    for i in [0...@graphGrid.width-1]⤶      for j in [0...@graphGrid.height]⤶        if i+1+j*@graphGrid.width < @graphGrid.vertexIndexes.length⤶          context.moveTo points[@graphGrid.vertexIndexes[i+j*@graphGrid.width]].x, points[@graphGrid.vertexIndexes[i+j*@graphGrid.width]].y⤶          context.lineTo points[@graphGrid.vertexIndexes[(i+1)+j*@graphGrid.width]].x, points[@graphGrid.vertexIndexes[(i+1)+j*@graphGrid.width]].y⤶⤶    # draw the ＂verticals＂ in the grid (each point x,y with x,y+1)⤶    for i in [0...@graphGrid.width]⤶      for j in [0...@graphGrid.height-1]⤶        if i+(j+1)*@graphGrid.width < @graphGrid.vertexIndexes.length⤶          context.moveTo points[@graphGrid.vertexIndexes[i+j*@graphGrid.width]].x, points[@graphGrid.vertexIndexes[i+j*@graphGrid.width]].y⤶          context.lineTo points[@graphGrid.vertexIndexes[i+(j+1)*@graphGrid.width]].x, points[@graphGrid.vertexIndexes[i+(j+1)*@graphGrid.width]].y⤶⤶    context.closePath()⤶⤶    context.strokeStyle = Color.BLACK.toString()⤶    context.stroke()⤶⤶⤶⤶    context.beginPath()⤶⤶    for i in [0...@planeGrid.width-1]⤶      context.moveTo points[@planeGrid.vertexIndexes[2*i]].x, points[@planeGrid.vertexIndexes[2*i]].y⤶      context.lineTo points[@planeGrid.vertexIndexes[2*i+1]].x, points[@planeGrid.vertexIndexes[2*i+1]].y⤶⤶    for i in [@planeGrid.width-1...@planeGrid.width+@planeGrid.height]⤶      context.moveTo points[@planeGrid.vertexIndexes[2*i]].x, points[@planeGrid.vertexIndexes[2*i]].y⤶      context.lineTo points[@planeGrid.vertexIndexes[2*i+1]].x, points[@planeGrid.vertexIndexes[2*i+1]].y⤶⤶    context.closePath()⤶⤶    context.strokeStyle = Color.GRAY.toString()⤶    context.stroke()⤶⤶⤶    context.globalAlpha = originalAlpha⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ExampleBarPlotWdgt_coffeSource = "class ExampleBarPlotWdgt extends GraphsPlotsChartsWdgt⤶⤶  graphNumber: 1⤶  drawOnlyPartOfBoundingRect: false⤶⤶  constructor: (@drawOnlyPartOfBoundingRect)->⤶    super()⤶    @fps = 0.5⤶    world.steppingWdgts.add @⤶⤶  colloquialName: ->⤶    ＂Bar plot＂⤶⤶⤶  # This method only paints this very morph's ＂image＂,⤶  # it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which⤶  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if @preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return⤶⤶    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    aContext.save()⤶⤶    # clip out the dirty rectangle as we are⤶    # going to paint the whole of the box⤶    aContext.clipToRectangle al,at,w,h⤶⤶    aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @backgroundTransparency⤶⤶    # paintRectangle here is made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, this is why⤶    # it's called before the scaling.⤶    @paintRectangle aContext, al, at, w, h, @backgroundColor⤶    aContext.useLogicalPixelsUntilRestore()⤶⤶    morphPosition = @position()⤶    aContext.translate morphPosition.x, morphPosition.y⤶⤶    @renderingHelper aContext, Color.WHITE, appliedShadow⤶⤶    aContext.restore()⤶⤶    # paintHighlight here is made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, this is why⤶    # it's called outside the effect of the scaling⤶    # (after the restore).⤶    @paintHighlight aContext, al, at, w, h⤶⤶⤶  step: ->⤶    @graphNumber++⤶    @changed()⤶⤶  renderingHelper: (context, color, appliedShadow) ->⤶⤶    @seed = @graphNumber⤶    circleRadius = 5⤶    height = @height()⤶    width = @width()⤶⤶    if appliedShadow?⤶      @simpleShadow context, color, appliedShadow⤶      return⤶⤶    context.fillStyle = WorldMorph.preferencesAndSettings.editableItemBackgroundColor.toString()⤶    context.fillRect 0, 0, width, height⤶⤶    availableHeight = height⤶⤶    context.globalAlpha = @alpha⤶⤶    for i in [0..20]⤶      xPos = (i/21)*width⤶      heightPerc = 0.2 + Math.sin(i/100)*3 - i/10000 + @seeded_randn_bm() / 20⤶      if @seededRandom() > 0.5⤶        context.fillStyle = '#325FA2'⤶      else⤶        context.fillStyle = '#FF0000'⤶      context.fillRect Math.round(xPos), Math.round(availableHeight - (availableHeight * heightPerc)), Math.round((1/20)*width - 2), Math.round(availableHeight * heightPerc)⤶⤶    @drawBoundingBox context, color, appliedShadow⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ExampleFunctionPlotWdgt_coffeSource = "class ExampleFunctionPlotWdgt extends GraphsPlotsChartsWdgt⤶⤶  graphNumber: 1⤶  drawOnlyPartOfBoundingRect: false⤶⤶  constructor: (@drawOnlyPartOfBoundingRect)->⤶    super()⤶    @fps = 2⤶    world.steppingWdgts.add @⤶⤶  colloquialName: ->⤶    ＂Function plot＂⤶⤶⤶  # This method only paints this very morph's ＂image＂,⤶  # it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which⤶  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if @preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return⤶⤶    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    aContext.save()⤶⤶    # clip out the dirty rectangle as we are⤶    # going to paint the whole of the box⤶    aContext.clipToRectangle al,at,w,h⤶⤶    aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @backgroundTransparency⤶⤶    # paintRectangle here is made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, this is why⤶    # it's called before the scaling.⤶    @paintRectangle aContext, al, at, w, h, @backgroundColor⤶    aContext.useLogicalPixelsUntilRestore()⤶⤶    morphPosition = @position()⤶    aContext.translate morphPosition.x, morphPosition.y⤶⤶    @renderingHelper aContext, Color.WHITE, appliedShadow⤶⤶    aContext.restore()⤶⤶    # paintHighlight here is made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, this is why⤶    # it's called outside the effect of the scaling⤶    # (after the restore).⤶    @paintHighlight aContext, al, at, w, h⤶⤶⤶  step: ->⤶    @graphNumber++⤶    @changed()⤶⤶  renderingHelper: (context, color, appliedShadow) ->⤶⤶    @seed = @graphNumber⤶    circleRadius = 5⤶    height = @height()⤶    width = @width()⤶⤶    if appliedShadow?⤶      @simpleShadow context, color, appliedShadow⤶      return⤶⤶    context.fillStyle = WorldMorph.preferencesAndSettings.editableItemBackgroundColor.toString()⤶    context.fillRect 0, 0, width, height⤶⤶    availableHeight = height - 2 * circleRadius⤶    availableWidth = width - 2 * circleRadius⤶⤶    context.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @alpha⤶⤶    context.fillStyle = '#325FA2'⤶    angle = @seededRandom()⤶    for xPos in [0..width]⤶      i = xPos/width * 1000⤶      heightPerc = 0.5 + Math.sin(10*angle+i/(300*(angle+0.01)))/3 - i/(5000+50000*angle)⤶      context.fillRect xPos, availableHeight * heightPerc, 2,2⤶⤶    @drawBoundingBox context, color, appliedShadow⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ExampleScatterPlotWdgt_coffeSource = "class ExampleScatterPlotWdgt extends GraphsPlotsChartsWdgt⤶⤶⤶  graphNumber: 1⤶  drawOnlyPartOfBoundingRect: false⤶⤶  constructor: (@drawOnlyPartOfBoundingRect)->⤶    super()⤶    @fps = 1⤶    world.steppingWdgts.add @⤶⤶  colloquialName: ->⤶    ＂Scatter plot＂⤶⤶⤶  # This method only paints this very morph's ＂image＂,⤶  # it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which⤶  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if @preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return⤶⤶    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    aContext.save()⤶⤶    # clip out the dirty rectangle as we are⤶    # going to paint the whole of the box⤶    aContext.clipToRectangle al,at,w,h⤶⤶    aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @backgroundTransparency⤶⤶    # paintRectangle here is made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, this is why⤶    # it's called before the scaling.⤶    @paintRectangle aContext, al, at, w, h, @backgroundColor⤶    aContext.useLogicalPixelsUntilRestore()⤶⤶    morphPosition = @position()⤶    aContext.translate morphPosition.x, morphPosition.y⤶⤶    @renderingHelper aContext, Color.WHITE, appliedShadow⤶⤶    aContext.restore()⤶⤶    # paintHighlight here is made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, this is why⤶    # it's called outside the effect of the scaling⤶    # (after the restore).⤶    @paintHighlight aContext, al, at, w, h⤶⤶⤶  step: ->⤶    @graphNumber++⤶    @changed()⤶⤶  renderingHelper: (context, color, appliedShadow) ->⤶⤶    @seed = @graphNumber⤶    circleRadius = 5⤶    height = @height()⤶    width = @width()⤶⤶⤶    if appliedShadow?⤶      @simpleShadow context, color, appliedShadow⤶      return⤶⤶    context.fillStyle = WorldMorph.preferencesAndSettings.editableItemBackgroundColor.toString()⤶    context.fillRect 0, 0, width, height⤶⤶    availableHeight = height - 2 * circleRadius⤶    availableWidth = width - 2 * circleRadius⤶⤶    context.globalAlpha = @alpha⤶⤶    context.lineWidth = 1⤶⤶    context.beginPath()⤶    for i in [0...100]⤶      widthPerc = 0.4 + @seeded_randn_bm() / 10⤶      heightPerc = 0.4 + @seeded_randn_bm() / 10⤶⤶      context.moveTo Math.round(2 * circleRadius + availableWidth * widthPerc),Math.round(circleRadius + availableHeight * heightPerc)⤶      context.arc Math.round(circleRadius + availableWidth * widthPerc),Math.round(circleRadius + availableHeight * heightPerc),circleRadius,0,2*Math.PI⤶    context.strokeStyle = '#325FA2'⤶    context.stroke()⤶⤶    context.beginPath()⤶    for i in [0...100]⤶      widthPerc = 0.6 + @seeded_randn_bm() / 10⤶      heightPerc = 0.6 + @seeded_randn_bm() / 10⤶⤶      context.moveTo Math.round(2 * circleRadius + availableWidth * widthPerc),Math.round(circleRadius + availableHeight * heightPerc)⤶      context.arc Math.round(circleRadius + availableWidth * widthPerc),Math.round(circleRadius + availableHeight * heightPerc),circleRadius,0,2*Math.PI⤶⤶    context.strokeStyle = '#FF0000'⤶    context.stroke()⤶⤶    @drawBoundingBox context, color, appliedShadow⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.GraphsPlotsChartsWdgt_coffeSource = "class GraphsPlotsChartsWdgt extends Widget⤶⤶  @augmentWith KeepsRatioWhenInVerticalStackMixin, @name⤶⤶  drawOnlyPartOfBoundingRect: false⤶⤶  constructor: (@drawOnlyPartOfBoundingRect)->⤶    super()⤶    @setColor Color.create 255, 125, 125⤶    @rawSetExtent new Point 200, 200⤶⤶⤶  # see https://stackoverflow.com/a/19303725⤶  seededRandom: ->⤶    x = Math.sin(@seed++) * 10000⤶    return x - Math.floor(x)⤶⤶  # Standard Normal variate using Box-Muller transform⤶  # see https://stackoverflow.com/a/36481059⤶  seeded_randn_bm: ->⤶    u = 0⤶    v = 0⤶    while u == 0⤶      u = @seededRandom()⤶    #Converting [0,1) to (0,1)⤶    while v == 0⤶      v = @seededRandom()⤶    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v)⤶⤶  simpleShadow: (context, color, appliedShadow) ->⤶⤶    height = @height()⤶    width = @width()⤶⤶    if appliedShadow?⤶      context.globalAlpha = appliedShadow.alpha * @alpha⤶      context.fillStyle = (Color.create 80, 80, 80).toString()⤶      context.fillRect 0, 0, width, height⤶      # let's avoid paint 3d stuff twice because⤶      # of the shadow⤶  ⤶  drawBoundingBox: (context, color, appliedShadow) ->⤶⤶    height = @height()⤶    width = @width()⤶⤶    context.strokeStyle = (Color.create 30,30,30).toString()⤶    if @drawOnlyPartOfBoundingRect⤶      context.beginPath()⤶      context.moveTo 0, 0⤶      context.lineTo width, 0⤶      context.lineTo width, height⤶      context.stroke()⤶    else⤶      context.strokeRect 0, 0, width, height⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.Grid3D_coffeSource = "class Grid3D⤶⤶  @augmentWith DeepCopierMixin⤶⤶  width: nil⤶  height: nil⤶  vertexIndexes: nil⤶   ⤶  constructor: (@width, @height, @vertexIndexes = []) ->⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.PlaneGrid3D_coffeSource = "class PlaneGrid3D⤶⤶  @augmentWith DeepCopierMixin⤶⤶  width: nil⤶  height: nil⤶  vertexIndexes: nil⤶   ⤶  constructor: (@width, @height, @vertexIndexes = []) ->⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.PlotWithAxesWdgt_coffeSource = "class PlotWithAxesWdgt extends Widget⤶⤶  @augmentWith KeepsRatioWhenInVerticalStackMixin, @name⤶⤶  constructor: (@plot) ->⤶    super⤶    @plot.drawOnlyPartOfBoundingRect = true⤶    @appearance = new RectangularAppearance @⤶⤶    @add @plot⤶⤶    @vertAxis = new AxisWdgt -5, 5⤶    @add @vertAxis⤶    @horizAxis = new AxisWdgt -5, 5⤶    @add @horizAxis⤶⤶    @setColor Color.create 242,242,242⤶⤶    @invalidateLayout()⤶⤶  colloquialName: ->⤶    @plot.colloquialName()⤶⤶  rawSetExtent: (aPoint) ->⤶    super⤶    @invalidateLayout()⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    newBoundsForThisLayout = @__calculateNewBoundsWhenDoingLayout newBoundsForThisLayout⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # TODO should'be calling this rawSetBounds from here,⤶    # rather use super⤶    @rawSetBounds newBoundsForThisLayout⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶    height = @height()⤶    width = @width()⤶⤶    ftft = 35⤶⤶    @vertAxis.rawSetExtent (new Point width/10 - 4, height).round()⤶    @vertAxis.fullRawMoveTo (@position().add new Point 0, -2).subtract((new Point -width/ftft,height/ftft).round())⤶⤶    @horizAxis.rawSetExtent (new Point width, height/10).round()⤶    adjustmentX = (@vertAxis.left() + @horizAxis.distanceOfAxisOriginFromEdge().x) - ( @vertAxis.right() + @vertAxis.distanceOfAxisOriginFromEdge().x )⤶    @horizAxis.fullRawMoveTo (@bottomLeft().subtract new Point adjustmentX, height/10).round().subtract((new Point -width/ftft,height/ftft).round())⤶⤶    @plot.rawSetExtent (new Point width - 2 *  @horizAxis.distanceOfAxisOriginFromEdge().x , height - 2 *  @vertAxis.distanceOfAxisOriginFromEdge().y).round()⤶    @plot.fullRawMoveTo (@position().add new Point @horizAxis.distanceOfAxisOriginFromEdge().x - adjustmentX + 1, @vertAxis.distanceOfAxisOriginFromEdge().y - 1).round().subtract((new Point -width/ftft,height/ftft).round())⤶⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶⤶    super⤶    @markLayoutAsFixed()⤶⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.Point3D_coffeSource = "# adapted from thomasdarimont/spinning-cube.html⤶# https://gist.github.com/thomasdarimont/8c694b4522c6cb10d85c⤶⤶class Point3D⤶⤶  @augmentWith DeepCopierMixin⤶⤶  x: nil⤶  y: nil⤶  z: nil⤶⤶  constructor: (@x = 0, @y = 0, @z = 0) ->⤶⤶  # the order of the rotations does matter⤶  # and there is no reason to assume⤶  # a specific order, so we leave the⤶  # three rotations separate⤶⤶  rotateX: (angle) ->⤶    rad = angle * Math.PI / 180⤶    cosa = Math.cos rad⤶    sina = Math.sin rad⤶    y = @y * cosa - @z * sina⤶    z = @y * sina + @z * cosa⤶    new @constructor @x, y, z⤶⤶  rotateY: (angle) ->⤶    rad = angle * Math.PI / 180⤶    cosa = Math.cos rad⤶    sina = Math.sin rad⤶    z = @z * cosa - @x * sina⤶    x = @z * sina + @x * cosa⤶    new @constructor x, @y, z⤶⤶⤶⤶  # the order of the translations doesn't matter⤶  # so one can do them all together⤶⤶  translateXYZ: (dx,dy,dz) ->⤶    new @constructor @x+dx, @y+dy, @z+dz⤶⤶  project: (viewWidth, viewHeight, fieldOfView, viewDistance) ->⤶    factor = fieldOfView / (viewDistance + @z)⤶    x = @x * factor + viewWidth / 2⤶    y = @y * factor + viewHeight / 2⤶    new Point x, y⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AlignCenterIconAppearance_coffeSource = "class AlignCenterIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    #// Group⤶    #// outline⤶    #// outline line 2 Drawing⤶    context.beginPath()⤶    context.moveTo 30.5, 38.5⤶    context.lineTo 70.5, 38.5⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// outline line 3 Drawing⤶    context.beginPath()⤶    context.moveTo 25.03, 61.25⤶    context.lineTo 75.66, 61.25⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// outline line 1 Drawing⤶    context.beginPath()⤶    context.moveTo 15.5, 17.5⤶    context.lineTo 86.66, 17.46⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// outline line 4 Drawing⤶    context.beginPath()⤶    context.moveTo 17.16, 82.54⤶    context.lineTo 84.66, 82.54⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// lines⤶    #// line 1 Drawing⤶    context.beginPath()⤶    context.moveTo 14, 17⤶    context.lineTo 89, 17⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// line 4 Drawing⤶    context.beginPath()⤶    context.moveTo 15.75, 82⤶    context.lineTo 87, 82⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// line 3 Drawing⤶    context.beginPath()⤶    context.moveTo 23.69, 60.71⤶    context.lineTo 79, 60.71⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// line 2 Drawing⤶    context.beginPath()⤶    context.moveTo 29.88, 38.36⤶    context.lineTo 73, 38.36⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AlignCenterIconWdgt_coffeSource = "class AlignCenterIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new AlignCenterIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AlignLeftIconAppearance_coffeSource = "class AlignLeftIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    #// Group⤶    #// outline⤶    #// outline line 2 Drawing⤶    context.beginPath()⤶    context.moveTo 15.5, 38.5⤶    context.lineTo 55.5, 38.5⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// outline line 3 Drawing⤶    context.beginPath()⤶    context.moveTo 15.03, 61.25⤶    context.lineTo 65.66, 61.25⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// outline line 1 Drawing⤶    context.beginPath()⤶    context.moveTo 14.5, 17.5⤶    context.lineTo 85.66, 17.46⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// outline line 4 Drawing⤶    context.beginPath()⤶    context.moveTo 14.16, 82.54⤶    context.lineTo 81.66, 82.54⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// lines⤶    #// line 1 Drawing⤶    context.beginPath()⤶    context.moveTo 13, 17⤶    context.lineTo 88, 17⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// line 4 Drawing⤶    context.beginPath()⤶    context.moveTo 12.75, 82⤶    context.lineTo 84, 82⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// line 3 Drawing⤶    context.beginPath()⤶    context.moveTo 13.69, 60.71⤶    context.lineTo 69, 60.71⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// line 2 Drawing⤶    context.beginPath()⤶    context.moveTo 13.88, 38.36⤶    context.lineTo 57, 38.36⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AlignLeftIconWdgt_coffeSource = "class AlignLeftIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new AlignLeftIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AlignRightIconAppearance_coffeSource = "class AlignRightIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    #// Group⤶    #// outline⤶    #// outline line 2 Drawing⤶    context.beginPath()⤶    context.moveTo 44.5, 38.5⤶    context.lineTo 84.5, 38.5⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// outline line 3 Drawing⤶    context.beginPath()⤶    context.moveTo 35.03, 61.25⤶    context.lineTo 85.66, 61.25⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// outline line 1 Drawing⤶    context.beginPath()⤶    context.moveTo 14.5, 17.5⤶    context.lineTo 85.66, 17.46⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// outline line 4 Drawing⤶    context.beginPath()⤶    context.moveTo 18.16, 82.54⤶    context.lineTo 85.66, 82.54⤶    context.strokeStyle = outlineColorString⤶    context.lineWidth = 23⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// lines⤶    #// line 1 Drawing⤶    context.beginPath()⤶    context.moveTo 13, 17⤶    context.lineTo 88, 17⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// line 4 Drawing⤶    context.beginPath()⤶    context.moveTo 16.75, 82⤶    context.lineTo 88, 82⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// line 3 Drawing⤶    context.beginPath()⤶    context.moveTo 32.69, 60.71⤶    context.lineTo 88, 60.71⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶    #// line 2 Drawing⤶    context.beginPath()⤶    context.moveTo 43.88, 38.36⤶    context.lineTo 87, 38.36⤶    context.strokeStyle = iconColorString⤶    context.lineWidth = 8.5⤶    context.lineCap = 'round'⤶    context.stroke()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AlignRightIconWdgt_coffeSource = "class AlignRightIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new AlignRightIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AllPlotsIconAppearance_coffeSource = "class AllPlotsIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶⤶    context.fillStyle = iconColorString⤶⤶    # this is all done in one path - but note how it has some unconnected⤶    # parts: moveTo() is used to put together the unconnected parts⤶    # into one path⤶⤶    context.beginPath()⤶⤶    # axes⤶    # ...this would look like a better job for a stroke rather than a fill, however⤶    # hey hardware is fast and this way we only create one path that is filled⤶    # all at once.⤶    context.moveTo 7, 8⤶    context.lineTo 11.25, 8⤶    context.lineTo 11.25, 88.76⤶    context.lineTo 92, 88.76⤶    context.lineTo 92, 93⤶    context.lineTo 7, 93⤶    context.lineTo 7, 8⤶⤶    # dots⤶    # note that @circles don't need moveTo to draw correctly as⤶    # distinct parts of the path⤶    @circle context, 37, 20, 3⤶    @circle context, 20, 39, 3⤶    @circle context, 20, 18, 3⤶    @circle context, 29, 29, 3⤶    @circle context, 42, 29, 3⤶    @circle context, 53, 25, 3⤶    @circle context, 53, 15, 3⤶⤶    # function plot line drawing⤶    # ...this would look like a better job for a stroke rather than a fill, however⤶    # hey hardware is fast and this way we only create one path that is filled⤶    # all at once.⤶    context.moveTo 20.06, 79.26⤶    context.lineTo 15.23, 75.9⤶    context.lineTo 26.06, 56.31⤶    context.bezierCurveTo 30.65, 47.24, 35.32, 43.21, 40.07, 44.24⤶    context.bezierCurveTo 43.14, 44.9, 54.09, 61.41, 57.5, 57.37⤶    context.bezierCurveTo 58.98, 57.16, 82.84, 11.04, 82.84, 11.04⤶    context.lineTo 87.75, 14.04⤶    context.bezierCurveTo 87.75, 14.04, 64.04, 58.55, 62.73, 60.59⤶    context.bezierCurveTo 61.13, 62.57, 59.42, 63.75, 57.1, 63.64⤶    context.bezierCurveTo 54.43, 63.84, 52, 63, 48.31, 59.85⤶    context.bezierCurveTo 44.62, 56.71, 41.39, 52.14, 38.2, 51.57⤶    context.bezierCurveTo 35, 51, 32.45, 56.53, 30.62, 59.61⤶    # now close this part of the path back to its opening point⤶    context.lineTo 20.06, 79.26⤶⤶    # bars⤶    # note that rects don't need moveTo to draw correctly as⤶    # distinct parts of the path⤶    context.rect 79, 41, 11, 45⤶    context.rect 63, 66, 11, 20⤶    context.rect 47, 72, 11, 14⤶    context.rect 32, 66, 10, 20⤶⤶    context.fill()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AllPlotsIconWdgt_coffeSource = "class AllPlotsIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new AllPlotsIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AngledArrowUpLeftIconAppearance_coffeSource = "class AngledArrowUpLeftIconAppearance extends IconAppearance⤶⤶  paintFunction: (context) ->⤶    fillColor = @morph.color⤶⤶    context.save()⤶    context.translate 90, 37⤶    context.rotate 90 * Math.PI / 180⤶⤶    context.beginPath()⤶    context.moveTo -25, -9.04⤶    context.lineTo 16.6, 32.5⤶    context.lineTo 16.6, 1.35⤶    context.lineTo 79, 1.35⤶    context.lineTo 79, -102.5⤶    context.lineTo 58.2, -102.5⤶    context.lineTo 58.2, -19.42⤶    context.lineTo 16.6, -19.42⤶    context.lineTo 16.6, -50.58⤶    context.bezierCurveTo -4.2, -29.81, -25, -9.04, -25, -9.04⤶    context.closePath()⤶    context.fillStyle = fillColor.toString()⤶    context.fill()⤶⤶    context.restore()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.AngledArrowUpLeftIconMorph_coffeSource = "class AngledArrowUpLeftIconMorph extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new AngledArrowUpLeftIconAppearance @⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowEIconAppearance_coffeSource = "class ArrowEIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    #// Group⤶    #// Bezier 2 Drawing⤶    context.beginPath()⤶    context.moveTo 49.56, 2⤶    context.lineTo 30.42, 21.15⤶    context.bezierCurveTo 30.42, 21.15, 37.12, 27.85, 46.61, 37.35⤶    context.lineTo 2, 37.35⤶    context.lineTo 2, 63.64⤶    context.lineTo 46.61, 63.64⤶    context.lineTo 30.41, 79.85⤶    context.lineTo 49.56, 99⤶    context.lineTo 98, 50.5⤶    context.lineTo 49.56, 2⤶    context.closePath()⤶    context.fillStyle = outlineColorString⤶    context.fill()⤶    #// Bezier Drawing⤶    context.beginPath()⤶    context.moveTo 49.55, 4.94⤶    context.lineTo 33.42, 21.09⤶    context.bezierCurveTo 33.42, 21.09, 42.47, 30.15, 51.39, 39.07⤶    context.lineTo 3.96, 39.07⤶    context.lineTo 3.96, 61.92⤶    context.lineTo 51.39, 61.92⤶    context.lineTo 33.41, 79.91⤶    context.lineTo 49.55, 96.06⤶    context.lineTo 95.06, 50.5⤶    context.lineTo 49.55, 4.94⤶    context.closePath()⤶    context.fillStyle = iconColorString⤶    context.fill()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowEIconWdgt_coffeSource = "class ArrowEIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new ArrowEIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowNEIconAppearance_coffeSource = "class ArrowNEIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    #// Bezier 2 Drawing⤶    context.beginPath()⤶    context.moveTo 16.12, 7.13⤶    context.lineTo 16.26, 37.43⤶    context.bezierCurveTo 16.26, 37.43, 26.86, 37.47, 41.89, 37.54⤶    context.lineTo 6.73, 72.7⤶    context.lineTo 27.62, 93.59⤶    context.lineTo 62.78, 58.43⤶    context.lineTo 62.89, 84.08⤶    context.lineTo 93.2, 84.2⤶    context.lineTo 92.84, 7.49⤶    context.lineTo 16.12, 7.13⤶    context.closePath()⤶    context.fillStyle = outlineColorString⤶    context.fill()⤶    #// Bezier Drawing⤶    context.beginPath()⤶    context.moveTo 18.46, 9.47⤶    context.lineTo 18.57, 35.02⤶    context.bezierCurveTo 18.57, 35.02, 32.9, 35.08, 47.02, 35.14⤶    context.lineTo 9.64, 72.52⤶    context.lineTo 27.8, 90.68⤶    context.lineTo 65.18, 53.3⤶    context.lineTo 65.3, 81.76⤶    context.lineTo 90.86, 81.87⤶    context.lineTo 90.52, 9.8⤶    context.lineTo 18.46, 9.47⤶    context.closePath()⤶    context.fillStyle = iconColorString⤶    context.fill()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowNEIconWdgt_coffeSource = "class ArrowNEIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new ArrowNEIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowNIconAppearance_coffeSource = "class ArrowNIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    #// Group⤶    #// Bezier 2 Drawing⤶    context.beginPath()⤶    context.moveTo 1.5, 50.94⤶    context.lineTo 20.65, 70.08⤶    context.bezierCurveTo 20.65, 70.08, 27.35, 63.38, 36.85, 53.89⤶    context.lineTo 36.85, 98.5⤶    context.lineTo 63.14, 98.5⤶    context.lineTo 63.14, 53.89⤶    context.lineTo 79.35, 70.09⤶    context.lineTo 98.5, 50.94⤶    context.lineTo 50, 2.5⤶    context.lineTo 1.5, 50.94⤶    context.closePath()⤶    context.fillStyle = outlineColorString⤶    context.fill()⤶    #// Bezier Drawing⤶    context.beginPath()⤶    context.moveTo 4.44, 50.95⤶    context.lineTo 20.59, 67.08⤶    context.bezierCurveTo 20.59, 67.08, 29.65, 58.03, 38.57, 49.11⤶    context.lineTo 38.57, 96.54⤶    context.lineTo 61.42, 96.54⤶    context.lineTo 61.42, 49.11⤶    context.lineTo 79.41, 67.09⤶    context.lineTo 95.56, 50.95⤶    context.lineTo 50, 5.44⤶    context.lineTo 4.44, 50.95⤶    context.closePath()⤶    context.fillStyle = iconColorString⤶    context.fill()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowNIconWdgt_coffeSource = "class ArrowNIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new ArrowNIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowNWIconAppearance_coffeSource = "class ArrowNWIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    #// Bezier 2 Drawing⤶    context.beginPath()⤶    context.moveTo 6.63, 83.38⤶    context.lineTo 36.93, 83.24⤶    context.bezierCurveTo 36.93, 83.24, 36.97, 72.64, 37.04, 57.61⤶    context.lineTo 72.2, 92.77⤶    context.lineTo 93.09, 71.88⤶    context.lineTo 57.93, 36.72⤶    context.lineTo 83.58, 36.61⤶    context.lineTo 83.7, 6.3⤶    context.lineTo 6.99, 6.66⤶    context.lineTo 6.63, 83.38⤶    context.closePath()⤶    context.fillStyle = outlineColorString⤶    context.fill()⤶    #// Bezier Drawing⤶    context.beginPath()⤶    context.moveTo 8.97, 81.04⤶    context.lineTo 34.52, 80.93⤶    context.bezierCurveTo 34.52, 80.93, 34.58, 66.6, 34.64, 52.48⤶    context.lineTo 72.02, 89.86⤶    context.lineTo 90.18, 71.7⤶    context.lineTo 52.8, 34.32⤶    context.lineTo 81.26, 34.2⤶    context.lineTo 81.37, 8.64⤶    context.lineTo 9.3, 8.98⤶    context.lineTo 8.97, 81.04⤶    context.closePath()⤶    context.fillStyle = iconColorString⤶    context.fill()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowNWIconWdgt_coffeSource = "class ArrowNWIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new ArrowNWIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowSEIconAppearance_coffeSource = "class ArrowSEIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    #// Bezier 2 Drawing⤶    context.beginPath()⤶    context.moveTo 93.37, 16.62⤶    context.lineTo 63.07, 16.76⤶    context.bezierCurveTo 63.07, 16.76, 63.03, 27.36, 62.96, 42.39⤶    context.lineTo 27.8, 7.23⤶    context.lineTo 6.91, 28.12⤶    context.lineTo 42.07, 63.28⤶    context.lineTo 16.42, 63.39⤶    context.lineTo 16.3, 93.7⤶    context.lineTo 93.01, 93.34⤶    context.lineTo 93.37, 16.62⤶    context.closePath()⤶    context.fillStyle = outlineColorString⤶    context.fill()⤶    #// Bezier Drawing⤶    context.beginPath()⤶    context.moveTo 91.03, 18.96⤶    context.lineTo 65.48, 19.07⤶    context.bezierCurveTo 65.48, 19.07, 65.42, 33.4, 65.36, 47.52⤶    context.lineTo 27.98, 10.14⤶    context.lineTo 9.82, 28.3⤶    context.lineTo 47.2, 65.68⤶    context.lineTo 18.74, 65.8⤶    context.lineTo 18.63, 91.36⤶    context.lineTo 90.7, 91.02⤶    context.lineTo 91.03, 18.96⤶    context.closePath()⤶    context.fillStyle = iconColorString⤶    context.fill()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowSEIconWdgt_coffeSource = "class ArrowSEIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new ArrowSEIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowSIconAppearance_coffeSource = "class ArrowSIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    #// Bezier 2 Drawing⤶    context.beginPath()⤶    context.moveTo 98.5, 50.06⤶    context.lineTo 79.35, 30.92⤶    context.bezierCurveTo 79.35, 30.92, 72.65, 37.62, 63.15, 47.11⤶    context.lineTo 63.15, 2.5⤶    context.lineTo 36.86, 2.5⤶    context.lineTo 36.86, 47.11⤶    context.lineTo 20.65, 30.91⤶    context.lineTo 1.5, 50.06⤶    context.lineTo 50, 98.5⤶    context.lineTo 98.5, 50.06⤶    context.closePath()⤶    context.fillStyle = outlineColorString⤶    context.fill()⤶    #// Bezier Drawing⤶    context.beginPath()⤶    context.moveTo 95.56, 50.05⤶    context.lineTo 79.41, 33.92⤶    context.bezierCurveTo 79.41, 33.92, 70.35, 42.97, 61.43, 51.89⤶    context.lineTo 61.43, 4.46⤶    context.lineTo 38.58, 4.46⤶    context.lineTo 38.58, 51.89⤶    context.lineTo 20.59, 33.91⤶    context.lineTo 4.44, 50.05⤶    context.lineTo 50, 95.56⤶    context.lineTo 95.56, 50.05⤶    context.closePath()⤶    context.fillStyle = iconColorString⤶    context.fill()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowSIconWdgt_coffeSource = "class ArrowSIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new ArrowSIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowSWIconAppearance_coffeSource = "class ArrowSWIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    #// Bezier 2 Drawing⤶    context.beginPath()⤶    context.moveTo 83.88, 92.87⤶    context.lineTo 83.74, 62.57⤶    context.bezierCurveTo 83.74, 62.57, 73.14, 62.53, 58.11, 62.46⤶    context.lineTo 93.27, 27.3⤶    context.lineTo 72.38, 6.41⤶    context.lineTo 37.22, 41.57⤶    context.lineTo 37.11, 15.92⤶    context.lineTo 6.8, 15.8⤶    context.lineTo 7.16, 92.51⤶    context.lineTo 83.88, 92.87⤶    context.closePath()⤶    context.fillStyle = outlineColorString⤶    context.fill()⤶    #// Bezier Drawing⤶    context.beginPath()⤶    context.moveTo 81.54, 90.53⤶    context.lineTo 81.43, 64.98⤶    context.bezierCurveTo 81.43, 64.98, 67.1, 64.92, 52.98, 64.86⤶    context.lineTo 90.36, 27.48⤶    context.lineTo 72.2, 9.32⤶    context.lineTo 34.82, 46.7⤶    context.lineTo 34.7, 18.24⤶    context.lineTo 9.14, 18.13⤶    context.lineTo 9.48, 90.2⤶    context.lineTo 81.54, 90.53⤶    context.closePath()⤶    context.fillStyle = iconColorString⤶    context.fill()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowSWIconWdgt_coffeSource = "class ArrowSWIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new ArrowSWIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowWIconAppearance_coffeSource = "class ArrowWIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    #// Bezier 2 Drawing⤶    context.beginPath()⤶    context.moveTo 49.44, 99⤶    context.lineTo 68.58, 79.85⤶    context.bezierCurveTo 68.58, 79.85, 61.88, 73.15, 52.39, 63.65⤶    context.lineTo 97, 63.65⤶    context.lineTo 97, 37.36⤶    context.lineTo 52.39, 37.36⤶    context.lineTo 68.59, 21.15⤶    context.lineTo 49.44, 2⤶    context.lineTo 1, 50.5⤶    context.lineTo 49.44, 99⤶    context.closePath()⤶    context.fillStyle = outlineColorString⤶    context.fill()⤶    #// Bezier Drawing⤶    context.beginPath()⤶    context.moveTo 49.45, 96.06⤶    context.lineTo 65.58, 79.91⤶    context.bezierCurveTo 65.58, 79.91, 56.53, 70.85, 47.61, 61.93⤶    context.lineTo 95.04, 61.93⤶    context.lineTo 95.04, 39.08⤶    context.lineTo 47.61, 39.08⤶    context.lineTo 65.59, 21.09⤶    context.lineTo 49.45, 4.94⤶    context.lineTo 3.94, 50.5⤶    context.lineTo 49.45, 96.06⤶    context.closePath()⤶    context.fillStyle = iconColorString⤶    context.fill()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ArrowWIconWdgt_coffeSource = "class ArrowWIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new ArrowWIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BarPlotIconAppearance_coffeSource = "class BarPlotIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    #// Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶⤶    #// axes Drawing⤶    context.beginPath()⤶    context.moveTo 7, 8⤶    context.lineTo 11.25, 8⤶    context.lineTo 11.25, 88.76⤶    context.lineTo 92, 88.76⤶    context.lineTo 92, 93⤶    context.lineTo 7, 93⤶    context.lineTo 7, 8⤶    context.closePath()⤶    context.fillStyle = iconColorString⤶    context.fill()⤶    #// bars⤶    #// bar 5 Drawing⤶    context.beginPath()⤶    context.rect 78, 43, 11, 43⤶    context.fillStyle = iconColorString⤶    context.fill()⤶    #// bar 4 Drawing⤶    context.beginPath()⤶    context.rect 62, 31, 11, 55⤶    context.fillStyle = iconColorString⤶    context.fill()⤶    #// bar 3 Drawing⤶    context.beginPath()⤶    context.rect 45, 14, 11, 72⤶    context.fillStyle = iconColorString⤶    context.fill()⤶    #// bar 2 Drawing⤶    context.beginPath()⤶    context.rect 29, 22, 11, 64⤶    context.fillStyle = iconColorString⤶    context.fill()⤶    #// bar 1 Drawing⤶    context.beginPath()⤶    context.rect 14, 46, 10, 40⤶    context.fillStyle = iconColorString⤶    context.fill()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BarPlotIconWdgt_coffeSource = "class BarPlotIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new BarPlotIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BasementIconAppearance_coffeSource = "class BasementIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 100, 100⤶    @specificationSize = new Point 100, 100⤶⤶  paintFunction: (context) ->⤶    # Color Declarations⤶    if @ownColorInsteadOfWidgetColor? then iconColorString = @ownColorInsteadOfWidgetColor.toString() else iconColorString = @morph.color.toString()⤶    outlineColorString = WorldMorph.preferencesAndSettings.outlineColorString⤶    # outline Drawing⤶    context.beginPath()⤶    context.moveTo 49.93, 6⤶    context.lineTo 49.93, 6⤶    context.bezierCurveTo 49.66, 6.01, 49.39, 6.09, 49.16, 6.24⤶    context.lineTo 2.75, 36⤶    context.lineTo 2.75, 36⤶    context.bezierCurveTo 2, 36.48, 1.77, 40.4, 2.24, 41.18⤶    context.bezierCurveTo 2.54, 41.66, 3.05, 41.96, 3.6, 41.96⤶    context.lineTo 8.38, 41.96⤶    context.lineTo 8.38, 90.35⤶    context.lineTo 8.38, 90.35⤶    context.bezierCurveTo 8.38, 91.26, 9.1, 92, 9.98, 92⤶    context.lineTo 90.02, 92⤶    context.lineTo 90.02, 92⤶    context.bezierCurveTo 90.9, 92, 91.62, 91.26, 91.62, 90.35⤶    context.lineTo 91.62, 41.96⤶    context.lineTo 96.4, 41.96⤶    context.lineTo 96.4, 41.96⤶    context.bezierCurveTo 97.28, 41.96, 98, 41.22, 98, 40.3⤶    context.bezierCurveTo 98, 39.73, 97.72, 36.3, 97.25, 36⤶    context.lineTo 50.84, 6.24⤶    context.lineTo 50.84, 6.24⤶    context.bezierCurveTo 50.56, 6.07, 50.25, 5.99, 49.93, 6⤶    context.lineTo 49.93, 6⤶    context.closePath()⤶    context.fillStyle = outlineColorString⤶    context.fill()⤶    # basement Drawing⤶    context.beginPath()⤶    context.moveTo 50.43, 9⤶    context.lineTo 50.43, 9⤶    context.bezierCurveTo 50.18, 9.01, 49.93, 9.09, 49.71, 9.22⤶    context.lineTo 5.72, 36.91⤶    context.lineTo 5.72, 36.91⤶    context.bezierCurveTo 5.01, 37.36, 4.79, 38.31, 5.24, 39.03⤶    context.bezierCurveTo 5.52, 39.48, 6, 39.75, 6.53, 39.75⤶    context.lineTo 11.05, 39.75⤶    context.lineTo 11.05, 87.46⤶    context.lineTo 11.05, 87.46⤶    context.bezierCurveTo 11.05, 88.31, 11.73, 89, 12.57, 89⤶    context.lineTo 21.67, 89⤶    context.lineTo 21.67, 89⤶    context.bezierCurveTo 22.51, 89, 23.19, 88.31, 23.19, 87.46⤶    context.lineTo 23.19, 45.91⤶    context.lineTo 77.81, 45.91⤶    context.lineTo 77.81, 87.46⤶    context.lineTo 77.81, 87.46⤶    context.bezierCurveTo 77.81, 88.31, 78.49, 89, 79.33, 89⤶    context.lineTo 88.43, 89⤶    context.lineTo 88.43, 89⤶    context.bezierCurveTo 89.27, 89, 89.95, 88.31, 89.95, 87.46⤶    context.lineTo 89.95, 39.75⤶    context.lineTo 94.48, 39.75⤶    context.lineTo 94.48, 39.75⤶    context.bezierCurveTo 95.31, 39.75, 95.99, 39.06, 95.99, 38.21⤶    context.bezierCurveTo 95.99, 37.68, 95.72, 37.19, 95.28, 36.91⤶    context.lineTo 51.3, 9.23⤶    context.lineTo 51.29, 9.22⤶    context.bezierCurveTo 51.03, 9.06, 50.73, 8.99, 50.43, 9⤶    context.lineTo 50.43, 9⤶    context.closePath()⤶    context.moveTo 50.5, 12.35⤶    context.lineTo 89.15, 36.68⤶    context.lineTo 88.43, 36.68⤶    context.lineTo 88.43, 36.68⤶    context.bezierCurveTo 87.59, 36.68, 86.91, 37.37, 86.91, 38.22⤶    context.lineTo 86.91, 85.93⤶    context.lineTo 80.84, 85.93⤶    context.lineTo 80.84, 44.37⤶    context.lineTo 80.84, 44.37⤶    context.bezierCurveTo 80.84, 43.52, 80.16, 42.83, 79.33, 42.83⤶    context.lineTo 21.67, 42.83⤶    context.lineTo 21.67, 42.83⤶    context.bezierCurveTo 20.84, 42.83, 20.16, 43.52, 20.16, 44.37⤶    context.lineTo 20.16, 85.93⤶    context.lineTo 14.09, 85.93⤶    context.lineTo 14.09, 38.22⤶    context.lineTo 14.09, 38.22⤶    context.bezierCurveTo 14.09, 37.37, 13.41, 36.68, 12.57, 36.68⤶    context.lineTo 11.85, 36.68⤶    context.lineTo 50.5, 12.35⤶    context.closePath()⤶    context.moveTo 54.87, 52.06⤶    context.lineTo 54.87, 52.06⤶    context.bezierCurveTo 54.79, 52.06, 54.71, 52.07, 54.64, 52.08⤶    context.lineTo 48.82, 52.08⤶    context.lineTo 48.82, 52.08⤶    context.bezierCurveTo 47.98, 52.08, 47.31, 52.77, 47.31, 53.62⤶    context.lineTo 47.31, 66.12⤶    context.lineTo 40.55, 63.17⤶    context.lineTo 40.55, 63.17⤶    context.bezierCurveTo 40.29, 63, 39.98, 62.92, 39.67, 62.94⤶    context.lineTo 39.65, 62.94⤶    context.bezierCurveTo 39.4, 62.95, 39.16, 63.02, 38.95, 63.14⤶    context.lineTo 30.3, 66.92⤶    context.lineTo 30.31, 66.92⤶    context.bezierCurveTo 30.06, 66.97, 29.82, 67.09, 29.63, 67.26⤶    context.lineTo 29.62, 67.27⤶    context.bezierCurveTo 29.6, 67.29, 29.58, 67.31, 29.56, 67.33⤶    context.lineTo 29.58, 67.31⤶    context.bezierCurveTo 29.56, 67.33, 29.54, 67.35, 29.52, 67.37⤶    context.lineTo 29.52, 67.37⤶    context.lineTo 29.52, 67.38⤶    context.bezierCurveTo 29.12, 67.76, 28.96, 68.34, 29.11, 68.88⤶    context.lineTo 29.1, 80.26⤶    context.lineTo 29.11, 80.25⤶    context.bezierCurveTo 29.09, 80.39, 29.1, 80.52, 29.12, 80.66⤶    context.lineTo 29.12, 80.65⤶    context.bezierCurveTo 29.13, 80.67, 29.13, 80.69, 29.14, 80.7⤶    context.lineTo 29.13, 80.69⤶    context.bezierCurveTo 29.14, 80.71, 29.14, 80.73, 29.14, 80.75⤶    context.lineTo 29.14, 80.74⤶    context.bezierCurveTo 29.15, 80.77, 29.15, 80.79, 29.16, 80.82⤶    context.lineTo 29.16, 80.83⤶    context.bezierCurveTo 29.17, 80.84, 29.17, 80.85, 29.17, 80.86⤶    context.lineTo 29.18, 80.87⤶    context.bezierCurveTo 29.19, 80.91, 29.2, 80.95, 29.22, 80.99⤶    context.lineTo 29.22, 80.99⤶    context.bezierCurveTo 29.22, 80.99, 29.22, 81, 29.23, 81.01⤶    context.lineTo 29.23, 81.02⤶    context.bezierCurveTo 29.25, 81.06, 29.27, 81.1, 29.29, 81.14⤶    context.lineTo 29.28, 81.13⤶    context.bezierCurveTo 29.29, 81.15, 29.3, 81.16, 29.31, 81.18⤶    context.lineTo 29.31, 81.18⤶    context.bezierCurveTo 29.5, 81.51, 29.81, 81.76, 30.18, 81.88⤶    context.lineTo 38.98, 85.73⤶    context.lineTo 38.99, 85.73⤶    context.bezierCurveTo 39, 85.74, 39.02, 85.75, 39.03, 85.76⤶    context.lineTo 39.02, 85.75⤶    context.bezierCurveTo 39.1, 85.79, 39.17, 85.82, 39.24, 85.84⤶    context.lineTo 39.24, 85.84⤶    context.bezierCurveTo 39.45, 85.91, 39.68, 85.93, 39.9, 85.91⤶    context.lineTo 39.89, 85.91⤶    context.lineTo 39.88, 85.91⤶    context.bezierCurveTo 39.91, 85.91, 39.95, 85.9, 39.98, 85.89⤶    context.lineTo 39.99, 85.89⤶    context.bezierCurveTo 40.01, 85.89, 40.03, 85.89, 40.04, 85.88⤶    context.lineTo 40.04, 85.89⤶    context.bezierCurveTo 40.07, 85.88, 40.11, 85.87, 40.14, 85.86⤶    context.lineTo 40.14, 85.86⤶    context.bezierCurveTo 40.16, 85.86, 40.18, 85.85, 40.19, 85.85⤶    context.lineTo 40.18, 85.85⤶    context.bezierCurveTo 40.21, 85.84, 40.25, 85.83, 40.28, 85.81⤶    context.lineTo 40.28, 85.81⤶    context.bezierCurveTo 40.34, 85.79, 40.39, 85.76, 40.45, 85.73⤶    context.lineTo 47.31, 82.73⤶    context.lineTo 47.31, 84.39⤶    context.lineTo 47.31, 84.39⤶    context.bezierCurveTo 47.31, 85.24, 47.98, 85.93, 48.82, 85.93⤶    context.lineTo 67.03, 85.93⤶    context.lineTo 67.03, 85.93⤶    context.bezierCurveTo 67.87, 85.93, 68.55, 85.24, 68.55, 84.39⤶    context.lineTo 68.55, 69⤶    context.lineTo 68.55, 53.62⤶    context.lineTo 68.55, 53.62⤶    context.bezierCurveTo 68.55, 52.77, 67.87, 52.08, 67.03, 52.08⤶    context.lineTo 61.2, 52.08⤶    context.lineTo 61.2, 52.08⤶    context.bezierCurveTo 61.11, 52.06, 61.03, 52.06, 60.94, 52.06⤶    context.lineTo 60.94, 52.06⤶    context.bezierCurveTo 60.86, 52.06, 60.78, 52.07, 60.71, 52.08⤶    context.lineTo 55.13, 52.08⤶    context.lineTo 55.13, 52.08⤶    context.bezierCurveTo 55.04, 52.06, 54.96, 52.06, 54.87, 52.06⤶    context.closePath()⤶    context.moveTo 50.34, 55.16⤶    context.lineTo 53.37, 55.16⤶    context.lineTo 53.37, 59.48⤶    context.lineTo 53.37, 59.49⤶    context.bezierCurveTo 53.23, 60.33, 53.78, 61.13, 54.6, 61.28⤶    context.bezierCurveTo 54.79, 61.31, 54.97, 61.31, 55.16, 61.27⤶    context.lineTo 55.14, 61.27⤶    context.bezierCurveTo 55.16, 61.27, 55.18, 61.27, 55.2, 61.27⤶    context.lineTo 55.2, 61.26⤶    context.bezierCurveTo 55.21, 61.26, 55.22, 61.26, 55.23, 61.26⤶    context.lineTo 55.23, 61.26⤶    context.bezierCurveTo 55.31, 61.24, 55.4, 61.21, 55.48, 61.17⤶    context.lineTo 55.49, 61.17⤶    context.bezierCurveTo 55.5, 61.17, 55.51, 61.16, 55.51, 61.16⤶    context.lineTo 55.51, 61.16⤶    context.bezierCurveTo 55.53, 61.15, 55.54, 61.14, 55.56, 61.14⤶    context.lineTo 55.64, 61.1⤶    context.lineTo 55.64, 61.1⤶    context.bezierCurveTo 55.64, 61.1, 55.65, 61.09, 55.66, 61.09⤶    context.lineTo 57.9, 59.95⤶    context.lineTo 60.26, 61.14⤶    context.lineTo 60.25, 61.14⤶    context.bezierCurveTo 60.52, 61.28, 60.82, 61.33, 61.12, 61.29⤶    context.lineTo 61.12, 61.29⤶    context.bezierCurveTo 61.17, 61.29, 61.23, 61.28, 61.28, 61.26⤶    context.lineTo 61.29, 61.26⤶    context.bezierCurveTo 61.31, 61.26, 61.32, 61.25, 61.34, 61.25⤶    context.lineTo 61.33, 61.25⤶    context.bezierCurveTo 61.36, 61.24, 61.39, 61.24, 61.41, 61.23⤶    context.lineTo 61.42, 61.23⤶    context.bezierCurveTo 61.43, 61.23, 61.44, 61.22, 61.44, 61.22⤶    context.lineTo 61.43, 61.22⤶    context.bezierCurveTo 61.52, 61.19, 61.61, 61.15, 61.7, 61.11⤶    context.lineTo 61.71, 61.1⤶    context.lineTo 61.71, 61.09⤶    context.bezierCurveTo 61.76, 61.07, 61.8, 61.04, 61.85, 61.01⤶    context.lineTo 61.84, 61.01⤶    context.lineTo 61.85, 61.01⤶    context.bezierCurveTo 61.89, 60.97, 61.93, 60.94, 61.97, 60.9⤶    context.lineTo 61.97, 60.91⤶    context.bezierCurveTo 62, 60.88, 62.03, 60.85, 62.06, 60.81⤶    context.lineTo 62.07, 60.81⤶    context.bezierCurveTo 62.34, 60.52, 62.48, 60.13, 62.48, 59.73⤶    context.lineTo 62.48, 55.16⤶    context.lineTo 65.51, 55.16⤶    context.lineTo 65.51, 67.46⤶    context.lineTo 61.32, 67.46⤶    context.lineTo 61.3, 67.46⤶    context.bezierCurveTo 61.18, 67.43, 61.06, 67.42, 60.94, 67.42⤶    context.lineTo 60.94, 67.42⤶    context.bezierCurveTo 60.83, 67.42, 60.72, 67.43, 60.6, 67.46⤶    context.lineTo 55.25, 67.46⤶    context.lineTo 55.23, 67.46⤶    context.bezierCurveTo 55.11, 67.43, 54.99, 67.42, 54.87, 67.42⤶    context.lineTo 54.88, 67.42⤶    context.bezierCurveTo 54.76, 67.42, 54.65, 67.43, 54.53, 67.46⤶    context.lineTo 50.34, 67.46⤶    context.lineTo 50.34, 55.16⤶    context.closePath()⤶    context.moveTo 56.41, 55.16⤶    context.lineTo 59.44, 55.16⤶    context.lineTo 59.44, 57.28⤶    context.lineTo 58.58, 56.85⤶    context.lineTo 58.59, 56.85⤶    context.bezierCurveTo 58.36, 56.74, 58.11, 56.68, 57.85, 56.69⤶    context.lineTo 57.85, 56.69⤶    context.bezierCurveTo 57.64, 56.69, 57.43, 56.75, 57.24, 56.84⤶    context.lineTo 56.41, 57.26⤶    context.lineTo 56.41, 55.16⤶    context.closePath()⤶    context.moveTo 39.72, 66.16⤶    context.lineTo 44.98, 68.46⤶    context.lineTo 39.72, 70.76⤶    context.lineTo 37.57, 69.83⤶    context.lineTo 34.45, 68.46⤶    context.lineTo 39.72, 66.16⤶    context.closePath()⤶    context.moveTo 50.34, 70.54⤶    context.lineTo 53.37, 70.54⤶    context.lineTo 53.37, 74.87⤶    context.lineTo 53.37, 74.86⤶    context.bezierCurveTo 53.21, 75.7, 53.75, 76.5, 54.57, 76.67⤶    context.bezierCurveTo 54.63, 76.68, 54.68, 76.68, 54.73, 76.69⤶    context.lineTo 54.74, 76.69⤶    context.bezierCurveTo 54.79, 76.69, 54.85, 76.7, 54.9, 76.7⤶    context.lineTo 54.89, 76.7⤶    context.bezierCurveTo 55.17, 76.7, 55.45, 76.61, 55.69, 76.46⤶    context.lineTo 57.9, 75.34⤶    context.lineTo 60.26, 76.53⤶    context.lineTo 60.27, 76.54⤶    context.bezierCurveTo 60.35, 76.58, 60.45, 76.61, 60.54, 76.64⤶    context.lineTo 60.54, 76.64⤶    context.bezierCurveTo 60.58, 76.65, 60.63, 76.66, 60.67, 76.67⤶    context.lineTo 60.69, 76.67⤶    context.bezierCurveTo 60.78, 76.69, 60.88, 76.7, 60.98, 76.7⤶    context.lineTo 60.99, 76.7⤶    context.lineTo 61, 76.7⤶    context.lineTo 61.01, 76.7⤶    context.bezierCurveTo 61.84, 76.67, 62.49, 75.97, 62.48, 75.13⤶    context.lineTo 62.48, 70.54⤶    context.lineTo 65.51, 70.54⤶    context.lineTo 65.51, 82.85⤶    context.lineTo 50.34, 82.85⤶    context.lineTo 50.34, 80.51⤶    context.lineTo 50.34, 80.51⤶    context.bezierCurveTo 50.34, 80.45, 50.34, 80.4, 50.34, 80.35⤶    context.lineTo 50.34, 70.54⤶    context.closePath()⤶    context.moveTo 56.41, 70.54⤶    context.lineTo 59.44, 70.54⤶    context.lineTo 59.44, 72.68⤶    context.lineTo 58.58, 72.24⤶    context.lineTo 58.58, 72.24⤶    context.bezierCurveTo 58.35, 72.13, 58.09, 72.07, 57.83, 72.09⤶    context.lineTo 57.84, 72.09⤶    context.bezierCurveTo 57.63, 72.09, 57.42, 72.15, 57.23, 72.24⤶    context.lineTo 56.41, 72.66⤶    context.lineTo 56.41, 70.54⤶    context.closePath()⤶    context.moveTo 32.14, 70.8⤶    context.lineTo 33.06, 71.2⤶    context.lineTo 36.37, 72.65⤶    context.lineTo 38.2, 73.45⤶    context.lineTo 38.2, 82.03⤶    context.lineTo 32.14, 79.38⤶    context.lineTo 32.14, 70.8⤶    context.closePath()⤶    context.moveTo 47.3, 70.8⤶    context.lineTo 47.3, 79.38⤶    context.lineTo 41.24, 82.03⤶    context.lineTo 41.24, 73.45⤶    context.lineTo 47.3, 70.8⤶    context.closePath()⤶    context.fillStyle = iconColorString⤶    context.fill()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");