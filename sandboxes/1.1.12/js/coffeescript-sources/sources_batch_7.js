

window.SimpleUSAMapIconWdgt_coffeSource = "class SimpleUSAMapIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new SimpleUSAMapIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleWorldMapIconAppearance_coffeSource = "class SimpleWorldMapIconAppearance extends IconAppearance⤶⤶  constructor: (@morph) ->⤶    super⤶    @preferredSize = new Point 500, 265⤶    @specificationSize = new Point 1000, 530⤶⤶  paintFunction: (context) ->⤶    fillColor = @morph.color⤶    fillColorString = fillColor.toString()⤶⤶    #// October revol + Bolshevik Islands Drawing⤶    context.beginPath()⤶    context.moveTo 732, 22⤶    context.lineTo 738, 20⤶    context.lineTo 762, 33⤶    context.lineTo 748, 35⤶    context.lineTo 728, 29⤶    context.lineTo 732, 22⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Svalbard Drawing⤶    context.beginPath()⤶    context.moveTo 525, 21⤶    context.lineTo 542, 23⤶    context.lineTo 544, 28⤶    context.lineTo 528, 31⤶    context.lineTo 537, 42⤶    context.lineTo 528, 42⤶    context.lineTo 525, 36⤶    context.lineTo 520, 42⤶    context.lineTo 509, 42⤶    context.lineTo 508, 35⤶    context.lineTo 503, 30⤶    context.lineTo 506, 26⤶    context.lineTo 525, 21⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Zemlya Georga + other islands Drawing⤶    context.save()⤶    context.translate 81, -263⤶    context.beginPath()⤶    context.moveTo 547, 277⤶    context.lineTo 558, 274⤶    context.lineTo 557, 284⤶    context.lineTo 548, 287⤶    context.lineTo 517, 288⤶    context.lineTo 515, 284⤶    context.lineTo 535, 278⤶    context.lineTo 547, 277⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    context.restore()⤶    #// Novaya Zemlya Drawing⤶    context.beginPath()⤶    context.moveTo 639, 46⤶    context.lineTo 659, 41⤶    context.lineTo 658, 46⤶    context.lineTo 643, 49⤶    context.lineTo 635, 53⤶    context.lineTo 625, 60⤶    context.lineTo 627, 73⤶    context.lineTo 616, 71⤶    context.lineTo 614, 67⤶    context.lineTo 621, 50⤶    context.lineTo 639, 46⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Siberian Island 3 Drawing⤶    context.beginPath()⤶    context.moveTo 854, 46⤶    context.lineTo 859, 46⤶    context.lineTo 859, 50⤶    context.lineTo 856, 53⤶    context.lineTo 854, 52⤶    context.lineTo 854, 46⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Siberian Island 2 Drawing⤶    context.beginPath()⤶    context.moveTo 862, 48⤶    context.lineTo 868, 51⤶    context.lineTo 863, 52⤶    context.lineTo 862, 48⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Siberian Island 1 Drawing⤶    context.beginPath()⤶    context.moveTo 859, 55⤶    context.lineTo 868, 60⤶    context.lineTo 859, 60⤶    context.lineTo 859, 55⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Iceland Drawing⤶    context.beginPath()⤶    context.moveTo 405, 98⤶    context.lineTo 411, 91⤶    context.lineTo 416, 96⤶    context.lineTo 427, 94⤶    context.lineTo 429, 103⤶    context.lineTo 412, 110⤶    context.lineTo 405, 98⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// GB Drawing⤶    context.beginPath()⤶    context.moveTo 454, 128⤶    context.lineTo 460, 126⤶    context.lineTo 459, 131⤶    context.lineTo 463, 132⤶    context.lineTo 468, 146⤶    context.lineTo 472, 149⤶    context.lineTo 471, 155⤶    context.lineTo 457, 159⤶    context.lineTo 460, 154⤶    context.lineTo 454, 152⤶    context.lineTo 460, 146⤶    context.lineTo 454, 128⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Ireland Drawing⤶    context.beginPath()⤶    context.moveTo 443, 147⤶    context.lineTo 452, 143⤶    context.lineTo 451, 152⤶    context.lineTo 448, 156⤶    context.lineTo 443, 156⤶    context.lineTo 443, 147⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Japan Drawing⤶    context.beginPath()⤶    context.moveTo 864, 158⤶    context.lineTo 868, 151⤶    context.lineTo 868, 168⤶    context.lineTo 866, 181⤶    context.lineTo 873, 188⤶    context.lineTo 861, 196⤶    context.lineTo 862, 205⤶    context.lineTo 857, 219⤶    context.lineTo 844, 223⤶    context.lineTo 831, 229⤶    context.lineTo 831, 222⤶    context.lineTo 855, 206⤶    context.lineTo 858, 194⤶    context.lineTo 865, 172⤶    context.lineTo 864, 158⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Sardinia Drawing⤶    context.beginPath()⤶    context.moveTo 493, 203⤶    context.lineTo 492, 197⤶    context.lineTo 494, 195⤶    context.lineTo 495, 203⤶    context.lineTo 493, 203⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Cuba Drawing⤶    context.beginPath()⤶    context.moveTo 236, 257⤶    context.lineTo 248, 258⤶    context.lineTo 262, 264⤶    context.lineTo 255, 266⤶    context.lineTo 246, 261⤶    context.lineTo 238, 260⤶    context.lineTo 236, 257⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Haiti + Dominican Republic Drawing⤶    context.beginPath()⤶    context.moveTo 270, 267⤶    context.lineTo 279, 272⤶    context.lineTo 265, 273⤶    context.lineTo 270, 267⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Philippines Drawing⤶    context.beginPath()⤶    context.moveTo 805, 272⤶    context.lineTo 808, 274⤶    context.lineTo 816, 296⤶    context.lineTo 819, 313⤶    context.lineTo 811, 311⤶    context.lineTo 805, 296⤶    context.lineTo 802, 276⤶    context.lineTo 805, 272⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// South America Drawing⤶    context.beginPath()⤶    context.moveTo 266, 296⤶    context.lineTo 281, 296⤶    context.lineTo 297, 300⤶    context.lineTo 313, 311⤶    context.lineTo 325, 315⤶    context.lineTo 334, 334⤶    context.lineTo 369, 346⤶    context.lineTo 373, 358⤶    context.lineTo 365, 371⤶    context.lineTo 358, 393⤶    context.lineTo 352, 405⤶    context.lineTo 338, 412⤶    context.lineTo 326, 436⤶    context.lineTo 317, 445⤶    context.lineTo 310, 455⤶    context.lineTo 296, 462⤶    context.lineTo 285, 481⤶    context.lineTo 285, 496⤶    context.lineTo 279, 509⤶    context.lineTo 284, 520⤶    context.lineTo 278, 524⤶    context.lineTo 269, 523⤶    context.lineTo 262, 506⤶    context.lineTo 260, 483⤶    context.lineTo 262, 468⤶    context.lineTo 268, 440⤶    context.lineTo 270, 421⤶    context.lineTo 271, 389⤶    context.lineTo 261, 380⤶    context.lineTo 255, 371⤶    context.lineTo 246, 354⤶    context.lineTo 249, 333⤶    context.lineTo 256, 320⤶    context.lineTo 255, 309⤶    context.lineTo 266, 296⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Sri Lanka Drawing⤶    context.beginPath()⤶    context.moveTo 691, 303⤶    context.lineTo 696, 310⤶    context.lineTo 691, 313⤶    context.lineTo 691, 303⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Kalimantan Drawing⤶    context.beginPath()⤶    context.moveTo 773, 325⤶    context.lineTo 797, 311⤶    context.lineTo 797, 325⤶    context.lineTo 792, 344⤶    context.lineTo 775, 340⤶    context.lineTo 773, 325⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Sulawesi Drawing⤶    context.beginPath()⤶    context.moveTo 803, 330⤶    context.lineTo 810, 330⤶    context.lineTo 811, 351⤶    context.lineTo 800, 348⤶    context.lineTo 803, 330⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Papua Drawing⤶    context.beginPath()⤶    context.moveTo 833, 335⤶    context.lineTo 867, 346⤶    context.lineTo 877, 352⤶    context.lineTo 884, 367⤶    context.lineTo 855, 359⤶    context.lineTo 849, 350⤶    context.lineTo 839, 345⤶    context.lineTo 833, 335⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Java Drawing⤶    context.beginPath()⤶    context.moveTo 763, 351⤶    context.lineTo 789, 355⤶    context.lineTo 795, 361⤶    context.lineTo 783, 360⤶    context.lineTo 763, 354⤶    context.lineTo 763, 351⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Madagascar Drawing⤶    context.beginPath()⤶    context.moveTo 607, 368⤶    context.lineTo 602, 395⤶    context.lineTo 595, 403⤶    context.lineTo 590, 398⤶    context.lineTo 594, 387⤶    context.lineTo 592, 377⤶    context.lineTo 607, 368⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Australia Drawing⤶    context.beginPath()⤶    context.moveTo 860, 388⤶    context.lineTo 864, 370⤶    context.lineTo 876, 391⤶    context.lineTo 887, 409⤶    context.lineTo 892, 421⤶    context.lineTo 890, 442⤶    context.lineTo 883, 458⤶    context.lineTo 871, 462⤶    context.lineTo 857, 456⤶    context.lineTo 850, 451⤶    context.lineTo 843, 441⤶    context.lineTo 837, 438⤶    context.lineTo 826, 436⤶    context.lineTo 812, 441⤶    context.lineTo 804, 441⤶    context.lineTo 791, 445⤶    context.lineTo 791, 435⤶    context.lineTo 786, 419⤶    context.lineTo 785, 403⤶    context.lineTo 804, 395⤶    context.lineTo 809, 390⤶    context.lineTo 817, 380⤶    context.lineTo 827, 380⤶    context.lineTo 833, 371⤶    context.lineTo 847, 371⤶    context.lineTo 847, 383⤶    context.lineTo 860, 388⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// New Zealand Drawing⤶    context.beginPath()⤶    context.moveTo 949, 449⤶    context.lineTo 965, 462⤶    context.lineTo 943, 489⤶    context.lineTo 934, 493⤶    context.lineTo 931, 488⤶    context.lineTo 946, 472⤶    context.lineTo 956, 461⤶    context.lineTo 949, 449⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Tasmania Drawing⤶    context.beginPath()⤶    context.moveTo 870, 469⤶    context.lineTo 880, 469⤶    context.lineTo 878, 478⤶    context.lineTo 872, 476⤶    context.lineTo 870, 469⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Corsica Drawing⤶    context.beginPath()⤶    context.moveTo 493, 195⤶    context.lineTo 493, 192⤶    context.lineTo 494, 191⤶    context.lineTo 494, 195⤶    context.lineTo 493, 195⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Africa Drawing⤶    context.beginPath()⤶    context.moveTo 477, 210⤶    context.lineTo 490, 211⤶    context.lineTo 499, 211⤶    context.lineTo 498, 223⤶    context.lineTo 518, 232⤶    context.lineTo 531, 225⤶    context.lineTo 550, 230⤶    context.lineTo 558, 229⤶    context.lineTo 574, 269⤶    context.lineTo 592, 297⤶    context.lineTo 611, 294⤶    context.lineTo 609, 307⤶    context.lineTo 602, 319⤶    context.lineTo 582, 337⤶    context.lineTo 578, 349⤶    context.lineTo 582, 364⤶    context.lineTo 578, 378⤶    context.lineTo 566, 387⤶    context.lineTo 568, 396⤶    context.lineTo 560, 406⤶    context.lineTo 553, 417⤶    context.lineTo 532, 426⤶    context.lineTo 524, 426⤶    context.lineTo 521, 423⤶    context.lineTo 513, 408⤶    context.lineTo 505, 388⤶    context.lineTo 503, 374⤶    context.lineTo 508, 357⤶    context.lineTo 494, 334⤶    context.lineTo 494, 322⤶    context.lineTo 486, 318⤶    context.lineTo 483, 313⤶    context.lineTo 444, 318⤶    context.lineTo 426, 295⤶    context.lineTo 424, 290⤶    context.lineTo 423, 262⤶    context.lineTo 428, 250⤶    context.lineTo 440, 235⤶    context.lineTo 443, 227⤶    context.lineTo 454, 215⤶    context.lineTo 463, 216⤶    context.lineTo 471, 212⤶    context.lineTo 477, 210⤶    context.lineTo 477, 210⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Greenland Drawing⤶    context.beginPath()⤶    context.moveTo 353, 5⤶    context.lineTo 370, 3⤶    context.lineTo 407, 6⤶    context.lineTo 435, 17⤶    context.lineTo 425, 23⤶    context.lineTo 415, 34⤶    context.lineTo 420, 40⤶    context.lineTo 419, 51⤶    context.lineTo 410, 59⤶    context.lineTo 413, 71⤶    context.lineTo 401, 80⤶    context.lineTo 360, 97⤶    context.lineTo 350, 121⤶    context.lineTo 336, 116⤶    context.lineTo 328, 83⤶    context.lineTo 313, 52⤶    context.lineTo 306, 46⤶    context.lineTo 300, 44⤶    context.lineTo 272, 43⤶    context.lineTo 271, 31⤶    context.lineTo 287, 28⤶    context.lineTo 301, 12⤶    context.lineTo 314, 10⤶    context.lineTo 326, 12⤶    context.lineTo 353, 5⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Noth America Drawing⤶    context.beginPath()⤶    context.moveTo 287, 23⤶    context.lineTo 278, 23⤶    context.lineTo 258, 36⤶    context.lineTo 253, 37⤶    context.lineTo 247, 54⤶    context.lineTo 254, 55⤶    context.lineTo 257, 61⤶    context.lineTo 264, 62⤶    context.lineTo 267, 68⤶    context.lineTo 276, 70⤶    context.lineTo 281, 76⤶    context.lineTo 282, 82⤶    context.lineTo 300, 88⤶    context.lineTo 293, 98⤶    context.lineTo 285, 94⤶    context.lineTo 289, 100⤶    context.lineTo 289, 104⤶    context.lineTo 283, 105⤶    context.lineTo 286, 111⤶    context.lineTo 272, 109⤶    context.lineTo 266, 104⤶    context.lineTo 253, 104⤶    context.lineTo 253, 100⤶    context.lineTo 266, 98⤶    context.lineTo 268, 86⤶    context.lineTo 259, 84⤶    context.lineTo 257, 76⤶    context.lineTo 241, 76⤶    context.lineTo 245, 91⤶    context.lineTo 236, 95⤶    context.lineTo 241, 103⤶    context.lineTo 239, 106⤶    context.lineTo 235, 107⤶    context.lineTo 221, 103⤶    context.lineTo 210, 114⤶    context.lineTo 207, 124⤶    context.lineTo 212, 126⤶    context.lineTo 214, 132⤶    context.lineTo 221, 133⤶    context.lineTo 230, 139⤶    context.lineTo 241, 143⤶    context.lineTo 240, 149⤶    context.lineTo 249, 155⤶    context.lineTo 248, 145⤶    context.lineTo 250, 142⤶    context.lineTo 256, 138⤶    context.lineTo 255, 128⤶    context.lineTo 252, 123⤶    context.lineTo 254, 112⤶    context.lineTo 265, 110⤶    context.lineTo 269, 111⤶    context.lineTo 275, 116⤶    context.lineTo 280, 125⤶    context.lineTo 287, 123⤶    context.lineTo 291, 120⤶    context.lineTo 298, 134⤶    context.lineTo 310, 145⤶    context.lineTo 313, 160⤶    context.lineTo 327, 168⤶    context.lineTo 326, 172⤶    context.lineTo 306, 169⤶    context.lineTo 311, 156⤶    context.lineTo 299, 159⤶    context.lineTo 294, 160⤶    context.lineTo 295, 176⤶    context.lineTo 302, 179⤶    context.lineTo 286, 186⤶    context.lineTo 283, 181⤶    context.lineTo 278, 185⤶    context.lineTo 273, 193⤶    context.lineTo 263, 201⤶    context.lineTo 257, 217⤶    context.lineTo 252, 222⤶    context.lineTo 242, 232⤶    context.lineTo 246, 245⤶    context.lineTo 244, 249⤶    context.lineTo 235, 233⤶    context.lineTo 206, 236⤶    context.lineTo 201, 240⤶    context.lineTo 199, 252⤶    context.lineTo 198, 260⤶    context.lineTo 203, 270⤶    context.lineTo 214, 271⤶    context.lineTo 218, 269⤶    context.lineTo 226, 262⤶    context.lineTo 224, 280⤶    context.lineTo 238, 284⤶    context.lineTo 239, 300⤶    context.lineTo 255, 304⤶    context.lineTo 241, 306⤶    context.lineTo 234, 302⤶    context.lineTo 228, 292⤶    context.lineTo 221, 287⤶    context.lineTo 205, 280⤶    context.lineTo 187, 276⤶    context.lineTo 180, 272⤶    context.lineTo 175, 267⤶    context.lineTo 174, 258⤶    context.lineTo 169, 249⤶    context.lineTo 163, 240⤶    context.lineTo 151, 230⤶    context.lineTo 164, 255⤶    context.lineTo 153, 245⤶    context.lineTo 141, 221⤶    context.lineTo 134, 218⤶    context.lineTo 130, 207⤶    context.lineTo 125, 203⤶    context.lineTo 122, 186⤶    context.lineTo 122, 163⤶    context.lineTo 113, 161⤶    context.lineTo 111, 149⤶    context.lineTo 83, 124⤶    context.lineTo 57, 116⤶    context.lineTo 56, 119⤶    context.lineTo 47, 122⤶    context.lineTo 48, 117⤶    context.lineTo 42, 120⤶    context.lineTo 39, 126⤶    context.lineTo 30, 136⤶    context.lineTo 12, 143⤶    context.lineTo 21, 135⤶    context.lineTo 28, 132⤶    context.lineTo 30, 124⤶    context.lineTo 12, 118⤶    context.lineTo 8, 111⤶    context.lineTo 12, 106⤶    context.lineTo 19, 105⤶    context.lineTo 20, 100⤶    context.lineTo 5, 99⤶    context.lineTo 3, 94⤶    context.lineTo 19, 93⤶    context.lineTo 8, 80⤶    context.lineTo 23, 70⤶    context.lineTo 57, 72⤶    context.lineTo 89, 78⤶    context.lineTo 113, 71⤶    context.lineTo 119, 75⤶    context.lineTo 144, 78⤶    context.lineTo 144, 69⤶    context.lineTo 128, 68⤶    context.lineTo 125, 56⤶    context.lineTo 131, 52⤶    context.lineTo 148, 52⤶    context.lineTo 148, 45⤶    context.lineTo 130, 45⤶    context.lineTo 125, 42⤶    context.lineTo 162, 30⤶    context.lineTo 207, 31⤶    context.lineTo 204, 17⤶    context.lineTo 215, 16⤶    context.lineTo 227, 10⤶    context.lineTo 235, 11⤶    context.lineTo 269, 6⤶    context.lineTo 291, 7⤶    context.lineTo 301, 12⤶    context.lineTo 287, 23⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Eurasia Drawing⤶    context.beginPath()⤶    context.moveTo 762, 38⤶    context.lineTo 767, 42⤶    context.lineTo 781, 42⤶    context.lineTo 787, 52⤶    context.lineTo 775, 55⤶    context.lineTo 776, 58⤶    context.lineTo 788, 56⤶    context.lineTo 798, 59⤶    context.lineTo 796, 60⤶    context.lineTo 810, 62⤶    context.lineTo 813, 57⤶    context.lineTo 826, 63⤶    context.lineTo 831, 71⤶    context.lineTo 849, 70⤶    context.lineTo 856, 69⤶    context.lineTo 861, 62⤶    context.lineTo 885, 67⤶    context.lineTo 899, 71⤶    context.lineTo 912, 71⤶    context.lineTo 915, 76⤶    context.lineTo 955, 76⤶    context.lineTo 996, 97⤶    context.lineTo 990, 104⤶    context.lineTo 981, 103⤶    context.lineTo 973, 100⤶    context.lineTo 965, 102⤶    context.lineTo 966, 112⤶    context.lineTo 941, 122⤶    context.lineTo 927, 122⤶    context.lineTo 925, 124⤶    context.lineTo 922, 137⤶    context.lineTo 919, 145⤶    context.lineTo 914, 151⤶    context.lineTo 905, 159⤶    context.lineTo 904, 156⤶    context.lineTo 902, 143⤶    context.lineTo 907, 131⤶    context.lineTo 917, 123⤶    context.lineTo 922, 120⤶    context.lineTo 921, 116⤶    context.lineTo 911, 115⤶    context.lineTo 905, 116⤶    context.lineTo 900, 124⤶    context.lineTo 863, 124⤶    context.lineTo 847, 143⤶    context.lineTo 859, 149⤶    context.lineTo 859, 167⤶    context.lineTo 848, 183⤶    context.lineTo 842, 191⤶    context.lineTo 834, 189⤶    context.lineTo 827, 200⤶    context.lineTo 829, 216⤶    context.lineTo 821, 220⤶    context.lineTo 816, 204⤶    context.lineTo 814, 201⤶    context.lineTo 805, 198⤶    context.lineTo 796, 207⤶    context.lineTo 808, 210⤶    context.lineTo 810, 212⤶    context.lineTo 801, 218⤶    context.lineTo 806, 228⤶    context.lineTo 800, 252⤶    context.lineTo 790, 260⤶    context.lineTo 768, 266⤶    context.lineTo 760, 272⤶    context.lineTo 768, 280⤶    context.lineTo 774, 294⤶    context.lineTo 764, 304⤶    context.lineTo 750, 293⤶    context.lineTo 748, 305⤶    context.lineTo 750, 311⤶    context.lineTo 759, 327⤶    context.lineTo 753, 326⤶    context.lineTo 751, 322⤶    context.lineTo 744, 301⤶    context.lineTo 739, 278⤶    context.lineTo 732, 281⤶    context.lineTo 725, 261⤶    context.lineTo 715, 263⤶    context.lineTo 709, 268⤶    context.lineTo 693, 282⤶    context.lineTo 689, 302⤶    context.lineTo 682, 305⤶    context.lineTo 677, 295⤶    context.lineTo 674, 285⤶    context.lineTo 671, 264⤶    context.lineTo 665, 266⤶    context.lineTo 655, 249⤶    context.lineTo 644, 252⤶    context.lineTo 633, 249⤶    context.lineTo 616, 243⤶    context.lineTo 608, 234⤶    context.lineTo 606, 235⤶    context.lineTo 605, 241⤶    context.lineTo 610, 248⤶    context.lineTo 615, 250⤶    context.lineTo 635, 258⤶    context.lineTo 627, 274⤶    context.lineTo 621, 278⤶    context.lineTo 594, 291⤶    context.lineTo 590, 279⤶    context.lineTo 566, 236⤶    context.lineTo 562, 236⤶    context.lineTo 559, 229⤶    context.lineTo 567, 228⤶    context.lineTo 569, 213⤶    context.lineTo 549, 212⤶    context.lineTo 547, 210⤶    context.lineTo 543, 199⤶    context.lineTo 559, 194⤶    context.lineTo 566, 193⤶    context.lineTo 585, 196⤶    context.lineTo 582, 189⤶    context.lineTo 576, 184⤶    context.lineTo 570, 183⤶    context.lineTo 556, 178⤶    context.lineTo 553, 180⤶    context.lineTo 549, 187⤶    context.lineTo 548, 195⤶    context.lineTo 536, 198⤶    context.lineTo 534, 211⤶    context.lineTo 531, 209⤶    context.lineTo 524, 195⤶    context.lineTo 505, 181⤶    context.lineTo 505, 187⤶    context.lineTo 514, 196⤶    context.lineTo 521, 201⤶    context.lineTo 516, 201⤶    context.lineTo 511, 211⤶    context.lineTo 505, 208⤶    context.lineTo 513, 204⤶    context.lineTo 505, 196⤶    context.lineTo 495, 185⤶    context.lineTo 488, 186⤶    context.lineTo 478, 190⤶    context.lineTo 470, 201⤶    context.lineTo 465, 212⤶    context.lineTo 465, 212⤶    context.lineTo 465, 212⤶    context.lineTo 465, 212⤶    context.lineTo 465, 212⤶    context.lineTo 465, 212⤶    context.lineTo 465, 212⤶    context.lineTo 465, 212⤶    context.lineTo 456, 212⤶    context.lineTo 444, 205⤶    context.lineTo 448, 188⤶    context.lineTo 458, 187⤶    context.lineTo 467, 187⤶    context.lineTo 467, 180⤶    context.lineTo 459, 168⤶    context.lineTo 481, 155⤶    context.lineTo 485, 150⤶    context.lineTo 493, 148⤶    context.lineTo 493, 134⤶    context.lineTo 499, 132⤶    context.lineTo 499, 139⤶    context.lineTo 505, 139⤶    context.lineTo 524, 132⤶    context.lineTo 536, 115⤶    context.lineTo 527, 107⤶    context.lineTo 536, 93⤶    context.lineTo 531, 91⤶    context.lineTo 514, 112⤶    context.lineTo 514, 124⤶    context.lineTo 506, 132⤶    context.lineTo 499, 124⤶    context.lineTo 493, 128⤶    context.lineTo 489, 115⤶    context.lineTo 516, 86⤶    context.lineTo 513, 81⤶    context.lineTo 534, 69⤶    context.lineTo 551, 70⤶    context.lineTo 559, 78⤶    context.lineTo 568, 80⤶    context.lineTo 577, 83⤶    context.lineTo 582, 92⤶    context.lineTo 575, 94⤶    context.lineTo 564, 91⤶    context.lineTo 573, 102⤶    context.lineTo 576, 104⤶    context.lineTo 584, 95⤶    context.lineTo 590, 93⤶    context.lineTo 592, 83⤶    context.lineTo 597, 83⤶    context.lineTo 597, 92⤶    context.lineTo 610, 85⤶    context.lineTo 628, 83⤶    context.lineTo 639, 78⤶    context.lineTo 642, 79⤶    context.lineTo 660, 85⤶    context.lineTo 658, 73⤶    context.lineTo 659, 68⤶    context.lineTo 666, 58⤶    context.lineTo 678, 63⤶    context.lineTo 694, 63⤶    context.lineTo 697, 57⤶    context.lineTo 710, 56⤶    context.lineTo 715, 47⤶    context.lineTo 751, 43⤶    context.lineTo 753, 41⤶    context.lineTo 754, 39⤶    context.lineTo 762, 38⤶    context.lineTo 762, 38⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶    #// Sumatra Drawing⤶    context.beginPath()⤶    context.moveTo 764, 341⤶    context.lineTo 762, 350⤶    context.lineTo 754, 345⤶    context.lineTo 748, 336⤶    context.lineTo 736, 315⤶    context.lineTo 748, 323⤶    context.lineTo 764, 341⤶    context.closePath()⤶    context.fillStyle = fillColorString⤶    context.fill()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleWorldMapIconWdgt_coffeSource = "class SimpleWorldMapIconWdgt extends IconMorph⤶⤶  constructor: (@color) ->⤶    super⤶    @appearance = new SimpleWorldMapIconAppearance @⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.Class_coffeSource = "class Class⤶⤶  @allClasses: []⤶  nonStaticPropertiesSources: nil⤶  staticPropertiesSources: nil⤶  name: ＂＂⤶  superClassName: nil⤶  augmentedWith: nil⤶  superClass: nil⤶  subClasses: nil⤶  classRegex: /^class[ ⧹t]*([a-zA-Z_$][0-9a-zA-Z_$]*)/m⤶  propertyRegex: /^  (@?[a-zA-Z_$][0-9a-zA-Z_$]*) *: *(.*)/m⤶  augmentRegex: /^  @augmentWith[ ⧹t]*([a-zA-Z_$][0-9a-zA-Z_$]*)/m⤶  topLevelCommentRegex: /^  #.*/m⤶⤶⤶  # adds code into the constructor, such that when a⤶  # Widget is created, it registers itself as in instance⤶  # on the Class it belongs to AND TO ALL THE SUPERCLASSES⤶  # The way it's added to all the superclasses is via⤶  # the constructor always calling ＂super＂, so constructors⤶  # up the chain cause the object to register itself⤶  # with all the superclasses.⤶  # ⤶  # TODO this mechanism can be tested like so:⤶  # open AnalogClockWdgt and then from the console:⤶  #    window.AnalogClockWdgt.instances⤶  # ...should give one object⤶  #    window.AnalogClockWdgt.__super__.constructor.instances.forEach((each) => console.log(each.constructor.name===＂AnalogClockWdgt＂));⤶  # should only give one 'true'⤶  #    window.AnalogClockWdgt.instances.forEach((each) => each.fullDestroy());⤶  # should destroy all clocks⤶  #    window.AnalogClockWdgt.instances⤶  # should show empty set⤶  #    window.AnalogClockWdgt.__super__.constructor.instances.forEach((each) => console.log(each.constructor.name===＂AnalogClockWdgt＂));⤶  # should type all 'false'⤶  # ⤶  # Note that only Widgets have that kind⤶  # of tracking and hence the existence check of⤶  # the registerThisInstance function⤶  _addInstancesTracker: (aString) ->⤶    # the regex to get the actual spacing under the constructor⤶    # is:⤶    # [ ⧹t]*constructor:[ ⧹t]*->.*$⧹n([ ⧹t]*)⤶    # but let's keep it simple: there are going to be four spaces under for the⤶    # body of the constructor⤶⤶    # if there is a return, keep it, otherwise add it⤶    if !aString.includes ＂⧹n    return＂⤶      aString += ＂⧹n    return⧹n＂⤶    aString.replace(/^([ ⧹t]*)return/gm, ＂$1this.registerThisInstance?();⧹n$1return＂)⤶    ⤶  _equivalentforSuper: (fieldName, aString) ->⤶    if window.srcLoadCompileDebugWrites then console.log ＂removing super from: ＂ + aString⤶    # coffeescript won't compile ＂super＂ unless it's an instance⤶    # method (i.e. if it comes inside a class), so we need to⤶    # translate that manually into valid CS that doesn't use super.⤶    aString = aString.replace(/super⧹(⧹)/g, @name + ＂.__super__.＂ + fieldName + ＂.call(this)＂)⤶    aString = aString.replace(/super /g, @name + ＂.__super__.＂ + fieldName + ＂.call this, ＂)⤶    aString = aString.replace(/super⧹(/g, @name + ＂.__super__.＂ + fieldName + ＂.call(this, ＂)⤶    aString = aString.replace(/super$/gm, @name + ＂.__super__.＂ + fieldName + ＂.apply(this, arguments)＂)⤶⤶  # Coffeescript adds some helper functions at the top of the compiled code:⤶  #⤶  #  slice = [].slice⤶  #  indexOf = [].indexOf⤶  #  hasProp = {}.hasOwnProperty⤶  #⤶  # here we remove them them all, because they mangle the code,⤶  # also we just have them all in the global scope by now so⤶  # they are not needed multiple times⤶⤶  _removeHelperFunctions: (aString) ->⤶    aString = aString.replace /^var(.|⧹n)*?⧹(function/, ＂(function＂⤶⤶    if (aString.includes ＂[].indexOf＂) or⤶     (aString.includes ＂{}.hasProp＂) or⤶     (aString.includes ＂[].slice＂)⤶      console.log ＂code contains a helper var, it shouldn't: ＂ +  aString⤶      debugger⤶⤶    return aString⤶⤶  # not used as of now because we prefer to load the comments⤶  # as part of the sources. Note that the presence of multiline⤶  # comments (and strings, for that matter) could mangle the⤶  # parsing.⤶  # Maybe a more correct way of doing this is to remove⤶  # only multiline comments and strings into a ＂clean version＂,⤶  # and maintaining line-to-line correspondence between this⤶  # ＂clean＂ version and the original version.⤶  # Then do the regexing on the ＂clean＂⤶  # version, but getting the source from the ＂original＂⤶  # version (which should be relatively easy if we know from which⤶  # line to which line each field is defined in)⤶  removeComments: (source) ->⤶    splitSource = source.split ＂⧹n＂⤶    sourceWithoutComments = ＂＂⤶    multilineComment = false⤶    for eachLine in splitSource⤶      #console.log ＂eachLine: ＂ + eachLine⤶      if /^[ ⧹t]*###/m.test(eachLine)⤶        multilineComment = !multilineComment⤶⤶      if (! /^[ ⧹t]*#/m.test(eachLine)) and (!multilineComment)⤶        sourceWithoutComments += eachLine + ＂⧹n＂⤶    return sourceWithoutComments⤶⤶⤶  findIfItExtendsAnotherClass: (source) ->⤶    # find if it extends some other class⤶    extendsRegex = /^class[ ⧹t]*[a-zA-Z_$][0-9a-zA-Z_$]*[ ⧹t]*extends[ ⧹t]*([a-zA-Z_$][0-9a-zA-Z_$]*)/m⤶    if (m = extendsRegex.exec(source))?⤶        m.forEach (match, groupIndex) ->⤶            if window.srcLoadCompileDebugWrites then console.log(＂Found match, group #{groupIndex}: #{match}＂)⤶        superClassName = m[1]⤶        if window.srcLoadCompileDebugWrites then console.log ＂we should have already loaded ＂ + superClassName⤶        superClass = window[superClassName].class⤶⤶        if window.srcLoadCompileDebugWrites then console.log ＂superClassName: ＂ + superClassName⤶⤶    return [superClassName, superClass]⤶⤶  findUpTo: (sourceLines, regexStopPositive, regexStopNegative, regexStopPositive2, keepStashWhenEOF) ->⤶    # This works by prospectively collecting lines until a⤶    # stop regex is found.⤶    # If a stop positive is found, we return the stash and the line with the stop.⤶    # Otherwise, if a stop negative or end of file, we return false.⤶⤶    sourceLinesOrig = sourceLines⤶    linesUpToStop = []⤶⤶    # collect lines until a stop is found⤶    for eachLine in sourceLines⤶      if (regexStopPositive?.test eachLine) or (regexStopPositive2?.test eachLine)⤶        # we finally found the stop positive: all lines we found so far⤶        # are a good stash, we'll return the good finds⤶⤶        # re-assemble the lines we found so far⤶        everythingUpToStopPositive = linesUpToStop.join ＂⧹n＂⤶⤶        # remove what we found so far from what we were passed⤶        remainingSourceLinesIncludingStopPositive = sourceLines.slice linesUpToStop.length⤶⤶        # the first line of remainingSourceLinesIncludingStopPositive⤶        # now is the stop positive⤶        #console.log ＂stop positive: ＂ + remainingSourceLinesIncludingStopPositive[0]⤶        stopPositiveLine = remainingSourceLinesIncludingStopPositive[0]⤶        if window.srcLoadCompileDebugWrites⤶          console.log ＂stopPositiveLine: ＂ + stopPositiveLine + ＂ ================＂⤶          console.log ＂everythingUpToStopPositive: ＂ + everythingUpToStopPositive⤶⤶        remainingSourceLinesExcludingStopPositive = remainingSourceLinesIncludingStopPositive.slice 1⤶        return [stopPositiveLine, everythingUpToStopPositive, remainingSourceLinesExcludingStopPositive, remainingSourceLinesIncludingStopPositive]⤶⤶      else if regexStopNegative?.test eachLine⤶        # found the stop negative: what we collected is no good⤶        return false⤶⤶      # no stop found yet, keep collecting⤶      linesUpToStop.push eachLine⤶⤶    if keepStashWhenEOF⤶      return [＂＂, (sourceLinesOrig.join ＂⧹n＂), [], []]⤶    else⤶      # reached the end of the file without finding a stop:⤶      # what we collected is no good⤶      return false⤶⤶  findMixinsInTheClass: (remainingSourceLines) ->⤶    # This works by prospectively collecting comment lines until an⤶    # stop positive regex for augmentation is found, then stashing⤶    # both the comment and the augmentation, then looping over what remains⤶⤶    augmentationComments = []⤶    augmentationNames = []⤶⤶    while returned = @findUpTo remainingSourceLines, @augmentRegex, @propertyRegex⤶      augmentationNames.push (returned[0].match @augmentRegex)[1]⤶      augmentationComments.push returned[1]⤶      remainingSourceLines = returned[2]⤶      if window.srcLoadCompileDebugWrites⤶        console.log ＂augmentation: ＂ + (returned[0].match @augmentRegex)[1] + ＂ ==========＂⤶        console.log ＂comments: ⧹n＂ + returned[1]⤶⤶    return [augmentationNames, augmentationComments, remainingSourceLines]⤶⤶⤶  removeAugmentations: (source) ->⤶    source.replace(/^  @augmentWith[ ⧹t]*([a-zA-Z_$][0-9a-zA-Z_$, @]*)/gm,＂＂)⤶⤶  getSourceOfAllProperties: (remainingSourceLines) ->⤶    staticPropertiesSources = {}⤶    nonStaticPropertiesSources = {}⤶⤶    while returned = @findUpTo remainingSourceLines, @propertyRegex⤶      propertyName = (returned[0].match @propertyRegex)[1]⤶      propertyComment = returned[1]⤶      propertyFirstLineOfBody = (returned[0].match @propertyRegex)[2]⤶      remainingSourceLines = returned[2]⤶      if window.srcLoadCompileDebugWrites⤶        console.log ＂propertyName: ＂ + propertyName + ＂ ==========＂⤶        console.log ＂propertyComment: ⧹n＂ + propertyComment⤶        console.log ＂propertyFirstLineOfBody: ⧹n＂ + propertyFirstLineOfBody⤶⤶      propertyBodyExceptFirstLine = ＂＂⤶      if returned = @findUpTo remainingSourceLines, @topLevelCommentRegex, nil, @propertyRegex, true⤶        propertyBodyExceptFirstLine = returned[1]⤶        remainingSourceLines = returned[3] # leave the next top level comment or property regex IN⤶⤶      if propertyBodyExceptFirstLine.length == 0⤶        propertyBody = propertyFirstLineOfBody⤶      else⤶        propertyBody = propertyFirstLineOfBody + ＂⧹n＂ + propertyBodyExceptFirstLine⤶⤶      if window.srcLoadCompileDebugWrites⤶        console.log ＂propertyBody: ⧹n＂ + propertyBody⤶⤶      if propertyName.substring(0, 1) == ＂@＂⤶        staticPropertiesSources[propertyName.substring(1, propertyName.length)] = propertyBody⤶      else⤶        nonStaticPropertiesSources[propertyName] = propertyBody⤶⤶⤶    [staticPropertiesSources, nonStaticPropertiesSources]⤶⤶⤶⤶  findClassDescriptionHeaderCommentAndClassName: (sourceLines) ->⤶    [classLine, classDescriptionHeaderComment, remainingSourceLines] = @findUpTo sourceLines, @classRegex⤶    className = (classLine.match @classRegex)[1]⤶    if window.srcLoadCompileDebugWrites⤶      console.log ＂className: ＂ + name + ＂ ==========＂⤶      console.log ＂comments: ⧹n＂ + classDescriptionHeaderComment⤶    [className, classDescriptionHeaderComment, remainingSourceLines]⤶⤶  # You can create a Class in 3 main ＂modes＂ of use:⤶  #  1. you want to load up the CS source, turn it to JS⤶  #     and eval the JS so to create the class:⤶  #        generatePreCompiledJS == true⤶  #        createClass == true⤶  #  2. you want to load up the CS source, turn it to JS⤶  #     and just store the JS somewhere to generate the⤶  #     pre-compiled JS sources:⤶  #        generatePreCompiledJS == true⤶  #        createClass == false⤶  #  3. you want to just load up the CS source so it⤶  #     appears all neat in the inspectors:⤶  #        generatePreCompiledJS == false⤶  #        createClass == false⤶  constructor: (source, generatePreCompiledJS, createClass) ->⤶⤶    if !window.classDefinitionAsJS?⤶      window.classDefinitionAsJS = []⤶⤶    @subClasses = new Set⤶⤶    sourceLines = source.split ＂⧹n＂⤶⤶    [@name, ignored, sourceLines] = @findClassDescriptionHeaderCommentAndClassName sourceLines⤶    [@superClassName, @superClass] = @findIfItExtendsAnotherClass source⤶    # find which mixins need to be mixed-in⤶    [@augmentedWith, ignored, sourceLines] = @findMixinsInTheClass sourceLines⤶⤶    # remove the augmentations because we don't want⤶    # them to mangle up the parsing⤶    source = @removeAugmentations source⤶⤶    if window.srcLoadCompileDebugWrites then console.log ＂source ---------⧹n＂ + source⤶⤶    # Now find all the fields definitions⤶    # note that the constructor, methods, properties and static properties⤶    # are ALL fields definitions, so we are basically going to cycle through⤶    # everything⤶    [@staticPropertiesSources, @nonStaticPropertiesSources] = @getSourceOfAllProperties sourceLines⤶⤶    if generatePreCompiledJS or createClass⤶      # --------------------⤶      # OK we collected all the fields definitions, now go through them⤶      # and put them into action⤶      # --------------------⤶⤶      # collect all the definitions in JS form here⤶      JS_string_definitions = ＂// class ＂ + @name + ＂⧹n⧹n＂⤶⤶      # the class itself is a constructor function, the constructor.⤶      # we have to find its source (if it exists), and⤶      # we have to slightly modify it and then we have to⤶      # actually create this function, hence creating the class.⤶      if window.srcLoadCompileDebugWrites then console.log ＂adding the constructor＂⤶      if @nonStaticPropertiesSources.hasOwnProperty('constructor')⤶⤶        if window.srcLoadCompileDebugWrites then console.log ＂CS sources of constructor: ＂ + @nonStaticPropertiesSources[＂constructor＂]⤶        # if there is a source for the constructor⤶        constructorDeclaration = @_equivalentforSuper ＂constructor＂, @nonStaticPropertiesSources[＂constructor＂]⤶        constructorDeclaration = @_addInstancesTracker constructorDeclaration⤶        if window.srcLoadCompileDebugWrites then console.log ＂constructor declaration CS:⧹n＂ + constructorDeclaration⤶⤶        compiled = compileFGCode constructorDeclaration, true⤶⤶        constructorDeclaration = @_removeHelperFunctions compiled⤶        constructorDeclaration = ＂window.＂ + @name + ＂ = ＂ + constructorDeclaration⤶      else⤶        # there is no constructor source, so we⤶        # just have to synthesize one that does:⤶        #  constructor ->⤶        #    super⤶        #    register instance⤶        constructorDeclaration = ＂＂＂⤶          window.#{@name} = ->⤶            # first line here is equivalent to ＂super＂ the one⤶            # passing all the arguments⤶            window.#{@name}.__super__.constructor.apply this, arguments⤶            # register instance (only Widgets have this method)⤶            @registerThisInstance?()⤶            return⤶        ＂＂＂⤶        if window.srcLoadCompileDebugWrites then console.log ＂constructor declaration CS:⧹n＂ + constructorDeclaration⤶        constructorDeclaration = compileFGCode constructorDeclaration, true⤶⤶      if window.srcLoadCompileDebugWrites then console.log ＂constructor declaration JS: ＂ + constructorDeclaration⤶      #if @name == ＂StringMorph2＂ then debugger⤶      JS_string_definitions += constructorDeclaration + ＂⧹n＂⤶⤶      # if you declare a constructor (i.e. a Function) like this then you don't⤶      # get the ＂name＂ property set as it normally is when⤶      # defining functions in ways that specify the name, so⤶      # we add the name manually here.⤶      # the name property is tricky, see:⤶      # see http://stackoverflow.com/questions/5871040/how-to-dynamically-set-a-function-object-name-in-javascript-as-it-is-displayed-i⤶      # just doing this is not sufficient: window[@name].name = @name⤶⤶      # analogous to⤶      # Object.defineProperty(window[@name], 'name', { value: @name })⤶      JS_string_definitions += ＂Object.defineProperty(window.#{@name}, 'name', { value: '#{@name}' });＂ + ＂⧹n＂⤶⤶      # if the class extends another one⤶      if @superClassName?⤶        if window.srcLoadCompileDebugWrites then console.log ＂extend: ＂ + @name + ＂ extends ＂ + @superClassName⤶        # analogous to⤶        #window[@name].__super__ = window[@superClassName].prototype⤶        #window[@name] = extend window[@name], window[@superClassName]⤶        JS_string_definitions += ＂window.#{@name}.__super__ = window.#{@superClassName}.prototype;＂ + ＂⧹n＂⤶        JS_string_definitions += ＂window.#{@name} = extend(window.#{@name}, window.#{@superClassName});＂ + ＂⧹n＂⤶      else⤶        if window.srcLoadCompileDebugWrites then console.log ＂no extension (extends Object) for ＂ + @name⤶        # analogous to⤶        #window[@name].__super__ = Object.prototype⤶        JS_string_definitions += ＂window.#{@name}.__super__ = Object.prototype;＂ + ＂⧹n⧹n＂⤶⤶⤶      # if the class is augmented with one or more Mixins⤶      for eachAugmentation in @augmentedWith⤶        if window.srcLoadCompileDebugWrites then console.log ＂augmentedWith: ＂ + eachAugmentation⤶        # analogous to⤶        #window[@name].augmentWith window[eachAugmentation], @name⤶        JS_string_definitions += ＂window.#{@name}.augmentWith(window.#{eachAugmentation}, '#{@name}');＂ + ＂⧹n＂⤶⤶      # non-static fields, which are put in the prototype⤶      for own fieldName, fieldValue of @nonStaticPropertiesSources⤶        if fieldName != ＂constructor＂ and fieldName != ＂augmentWith＂ and fieldName != ＂addInstanceProperties＂⤶          if window.srcLoadCompileDebugWrites then console.log ＂building field ＂ + fieldName + ＂ ===== ＂⤶⤶          #if fieldName == ＂invalidateFullBoundsCache＂⤶          #  debugger⤶⤶          fieldDeclaration = @_equivalentforSuper fieldName, fieldValue⤶⤶          compiled = compileFGCode fieldDeclaration, true⤶⤶          fieldDeclaration = @_removeHelperFunctions compiled⤶          fieldDeclaration = ＂window.＂ + @name + ＂.prototype.＂ + fieldName + ＂ = ＂ + fieldDeclaration⤶⤶          if window.srcLoadCompileDebugWrites then console.log ＂field declaration: ＂ + fieldDeclaration⤶          #if @name == ＂StringMorph2＂ then debugger⤶          JS_string_definitions += fieldDeclaration + ＂⧹n＂⤶⤶      JS_staticConstantsBuiltWithClassItself_definitions = ＂＂⤶⤶      # now the static fields, which are put in the constructor⤶      # rather than in the prototype⤶      for own fieldName, fieldValue of @staticPropertiesSources⤶        if fieldName != ＂constructor＂ and fieldName != ＂augmentWith＂ and fieldName != ＂addInstanceProperties＂⤶          if window.srcLoadCompileDebugWrites then console.log ＂building STATIC field ＂ + fieldName + ＂ ===== ＂⤶⤶          fieldDeclaration = @_equivalentforSuper fieldName, fieldValue⤶⤶          compiled = compileFGCode fieldDeclaration, true⤶⤶          fieldDeclaration = @_removeHelperFunctions compiled⤶          fieldDeclaration = ＂window.＂ + @name + ＂.＂ + fieldName + ＂ = ＂ + fieldDeclaration⤶⤶          if window.srcLoadCompileDebugWrites then console.log fieldDeclaration⤶⤶          if ((new RegExp(＂⧹⧹s*new⧹⧹s*＂ + @name + ＂(⧹⧹s|$)＂)).test fieldValue) or ((new RegExp(＂⧹⧹s*＂ + @name + ＂⧹⧹.create(⧹⧹s|⧹⧹()＂)).test fieldValue)⤶            # for example, in the Color class:⤶            #    @BLACK: Color.create 0,0,0⤶            #      or the alternative (not actually used)⤶            #    @BLACK: new Color 0,0,0⤶            # we need to put these aside and add them last, so that the⤶            # rest of the class is defined and we can initialise these⤶            # properly.⤶            JS_staticConstantsBuiltWithClassItself_definitions += fieldDeclaration + ＂⧹n＂⤶          else⤶            JS_string_definitions += fieldDeclaration + ＂⧹n＂⤶⤶⤶      # analogous to⤶      # window[@name].instances = new Set⤶      JS_string_definitions += ＂window.#{@name}.instances = new Set;＂ + ＂⧹n＂⤶⤶      JS_string_definitions += JS_staticConstantsBuiltWithClassItself_definitions⤶⤶      JSSourcesContainer.content += JS_string_definitions + ＂⧹n＂⤶⤶      if createClass⤶        try⤶          if window.srcLoadCompileDebugWrites then console.log ＂actually evalling ＂ + @name + ＂ to create the class＂⤶          eval.call window, JS_string_definitions⤶        catch err⤶          console.log ＂ error ＂ + err + ＂ evaling : ＂ + JS_string_definitions⤶          alert ＂ error ＂ + err + ＂ evaling : ＂ + JS_string_definitions⤶⤶⤶      window.classDefinitionAsJS.push JS_string_definitions⤶⤶    # OK now that we have created the Class⤶    # (or if already created anyways, in pre-compiled mode)⤶    # then add the .class field⤶    window[@name].class = @⤶    if @superclass?⤶      @superclass.subClasses.add @⤶⤶⤶    #if @name == ＂LCLCodePreprocessor＂ then debugger⤶⤶  notifyInstancesOfSourceChange: (propertiesArray)->⤶    window[@name].instances.forEach (eachInstance) =>⤶      eachInstance.sourceChanged()⤶  ⤶    for eachProperty in propertiesArray⤶      @subClasses.forEach (eachSubClass) =>⤶        # if a subclass redefined a property, then⤶        # the change doesn't apply, so there is no⤶        # notification to propagate⤶        if !eachSubClass.nonStaticPropertiesSources[eachProperty]?⤶          eachSubClass.notifyInstancesOfSourceChange([eachProperty])⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ClassInspectorMorph_coffeSource = "class ClassInspectorMorph extends InspectorMorph2⤶⤶  notifyInstancesOfSourceChange: (propertiesArray)->⤶    @target.constructor.class.notifyInstancesOfSourceChange propertiesArray⤶⤶  buildAndConnectChildren: ->⤶    super⤶    @lastLabelInHierarchy.setText ＂this class＂⤶    #@label.setText ＂class ＂ + @target.constructor.name⤶⤶  colloquialName: ->⤶    ＂Class Inspector (＂ + @target.constructor.name.replace(＂Morph＂, ＂＂).replace(＂Wdgt＂, ＂＂) + ＂)＂⤶⤶  layoutOwnPropsOnlyToggle: (height) ->⤶⤶⤶    toggleBounds = new Rectangle new Point @left() + @externalPadding , height⤶    toggleBounds = toggleBounds.setBoundsWidthAndHeight (new Point (@width() - 2*@externalPadding - 2*@internalPadding)/4,15).round()⤶    @showMethodsToggle.doLayout toggleBounds⤶⤶    toggleBounds = new Rectangle new Point @showMethodsToggle.right() + @internalPadding, height⤶    toggleBounds = toggleBounds.setBoundsWidthAndHeight (new Point (@width() - 2*@externalPadding - 2*@internalPadding)/4,15).round()⤶    @showFieldsToggle.doLayout toggleBounds⤶⤶    toggleBounds = new Rectangle new Point @showFieldsToggle.right() + @internalPadding, height⤶    toggleBounds = toggleBounds.setBoundsWidthAndHeight (new Point 2*(@width() - 2*@externalPadding - 2*@internalPadding)/4,15).round()⤶    @showInheritedToggle.doLayout toggleBounds⤶⤶⤶  buildAndConnectObjOwnPropsButton: ->⤶⤶  # TODO: when inspecting objects, we added the functionality to⤶  # inject code in the objects themselves.⤶  # We'd have to do the same here, add a way to inject code in⤶  # object classes.⤶  save: ->⤶    txt = @detail.contents.children[0].text.toString()⤶    propertyName = @list.selected.labelString⤶⤶    # this.target[propertyName] = evaluate txt⤶    @target.evaluateString ＂@＂ + propertyName + ＂ = ＂ + txt⤶    # if we are saving a function, we'd like to⤶    # keep the source code so we can edit Coffeescript⤶    # again.⤶    if Utils.isFunction @target[propertyName]⤶      @target[propertyName + ＂_source＂] = txt⤶    @notifyInstancesOfSourceChange([propertyName])⤶⤶    @detail.textWdgt.considerCurrentTextAsReferenceText()⤶    @detail.checkIfTextContentWasModifiedFromTextAtStart()⤶⤶    # it's possible that the user might have fixed⤶    # a ＂painting＂ error, so give another chance to all⤶    # ＂banned＂ widgets (banned from repainting)⤶    for eachWidget in world.widgetsGivingErrorWhileRepainting⤶      eachWidget.show()⤶    world.widgetsGivingErrorWhileRepainting = []⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ConsoleWdgt_coffeSource = "class ConsoleWdgt extends Widget⤶⤶  tempPromptEntryField: nil⤶  textMorph: nil⤶⤶  runSelectionButton: nil⤶  runAllButton: nil⤶⤶  functionFromCompiledCode: nil⤶⤶  # the external padding is the space between the edges⤶  # of the container and all of its internals. The reason⤶  # you often set this to zero is because windows already put⤶  # contents inside themselves with a little padding, so this⤶  # external padding is not needed. Useful to keep it⤶  # separate and know that it's working though.⤶  externalPadding: 0⤶  # the internal padding is the space between the internal⤶  # components. It doesn't necessarily need to be equal to the⤶  # external padding⤶  internalPadding: 5⤶⤶  constructor: (@target) ->⤶    super new Point 200,400⤶    @buildAndConnectChildren()⤶⤶  colloquialName: ->⤶    ＂Console for: ＂ + @target.colloquialName().toLowerCase()⤶⤶  buildAndConnectChildren: ->⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @tempPromptEntryField = new SimplePlainTextScrollPanelWdgt ＂＂, false, 5⤶    @tempPromptEntryField.disableDrops()⤶    @tempPromptEntryField.contents.disableDrops()⤶    @tempPromptEntryField.color = Color.WHITE⤶⤶    @textMorph = @tempPromptEntryField.textWdgt⤶    @textMorph.backgroundColor = Color.TRANSPARENT⤶    @textMorph.setFontName nil, nil, @textMorph.monoFontStack⤶    @textMorph.isEditable = true⤶    @textMorph.enableSelecting()⤶⤶    @add @tempPromptEntryField⤶⤶    # ＂do＂ buttons -------------------------------⤶    # NOTE that you can also ＂doAll＂ or ＂doSelection＂ via⤶    # the context menu entries in the text panel!⤶    @runSelectionButton = new SimpleButtonMorph true, @, ＂doSelection＂, ＂run selection＂⤶    @runSelectionButton.editorContentPropertyChangerButton = true⤶    @add @runSelectionButton⤶⤶    @runAllButton = new SimpleButtonMorph true, @, ＂doAll＂, ＂run all＂⤶    @add @runAllButton⤶    # ---------------------------------------⤶⤶    @invalidateLayout()⤶⤶  doSelection: ->⤶    savedScript = @textMorph.selection()⤶    compiled = compileFGCode savedScript, true⤶    functionFromCompiledCode = new Function compiled⤶    functionFromCompiledCode.call @target⤶⤶  doAll: ->⤶    savedScript = @textMorph.text⤶    compiled = compileFGCode savedScript, true⤶    functionFromCompiledCode = new Function compiled⤶    functionFromCompiledCode.call @target⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶    textHeight = @height() - 2 * @externalPadding - @internalPadding - 15⤶    textBottom = @top() + @externalPadding + textHeight⤶    textWidth = @width() - 2 * @externalPadding⤶    buttonsWidth = (textWidth - 2 * @internalPadding - WorldMorph.preferencesAndSettings.handleSize)/2⤶⤶    if @tempPromptEntryField.parent == @⤶      @tempPromptEntryField.fullRawMoveTo new Point @left() + @externalPadding, @top() + @externalPadding⤶      @tempPromptEntryField.rawSetExtent new Point textWidth, textHeight⤶⤶⤶    # buttons -------------------------------⤶    ⤶⤶    if @runSelectionButton.parent == @⤶      buttonBounds = new Rectangle new Point @left() + @externalPadding, textBottom + @internalPadding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight buttonsWidth, 15⤶      @runSelectionButton.doLayout buttonBounds⤶⤶    if @runAllButton.parent == @⤶      buttonBounds = new Rectangle new Point buttonBounds.right() + @internalPadding, textBottom + @internalPadding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight buttonsWidth, 15⤶      @runAllButton.doLayout buttonBounds⤶⤶⤶    # ----------------------------------------------⤶⤶⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    super⤶    @markLayoutAsFixed()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.InspectorMorph2_coffeSource = "class InspectorMorph2 extends Widget⤶⤶  target: nil⤶  currentProperty: nil⤶  markOwnershipOfProperties: true⤶  # panes:⤶  list: nil⤶  detail: nil⤶⤶  classesButtons: nil⤶  classesNames: nil⤶  angledArrows: nil⤶  hierarchyHeaderString: nil⤶  propertyHeaderString: nil⤶⤶  showMethodsOnButton: nil⤶  showMethodsOffButton: nil⤶  showMethodsToggle: nil⤶⤶  showFieldsOnButton: nil⤶  showFieldsOffButton: nil⤶  showFieldsToggle: nil⤶⤶  showInheritedOnButton: nil⤶  showInheritedOffButton: nil⤶  showInheritedToggle: nil⤶⤶  showOwnPropsOnlyOnButton: nil⤶  showOwnPropsOnlyOffButton: nil⤶  showOwnPropsOnlyToggle: nil⤶⤶  lastLabelInHierarchy: nil⤶  lastArrowInHierarchy: nil⤶⤶  hierarchyBackgroundPanel: nil⤶⤶  showingFields: true⤶  showingMethods: true⤶  showingInherited: false⤶  showingOwnPropsOnly: false⤶⤶  addPropertyButton: nil⤶  renamePropertyButton: nil⤶  removePropertyButton: nil⤶  saveButton: nil⤶  saveTextWdgt: nil⤶⤶  externalPadding: 0⤶  internalPadding: 5⤶  padding: nil⤶⤶  # normally buttons only contain centered lower case text⤶  # so we can get away with just no padding between button⤶  # bounds and text. Some of these buttons however contain⤶  # left-aligned class names (with capital letters) so we⤶  # do need to add some padding...⤶  classNamesTextPadding: 2⤶⤶  colloquialName: ->⤶    ＂Object Inspector (＂ + @target.colloquialName() + ＂)＂⤶⤶  showFields: ->⤶    if !@showingFields⤶      @showingFields = true⤶      @buildAndConnectChildren()⤶⤶  showMethods: ->⤶    if !@showingMethods⤶      @showingMethods = true⤶      @buildAndConnectChildren()⤶⤶  showInherited: ->⤶    if !@showingInherited⤶      @showingInherited = true⤶      @buildAndConnectChildren()⤶⤶  showOwnPropsOnly: ->⤶    if !@showingOwnPropsOnly⤶      @showingOwnPropsOnly = true⤶      @buildAndConnectChildren()⤶⤶  hideFields: ->⤶    if @showingFields⤶      @showingFields = false⤶      @buildAndConnectChildren()⤶⤶  hideMethods: ->⤶    if @showingMethods⤶      @showingMethods = false⤶      @buildAndConnectChildren()⤶⤶  hideInherited: ->⤶    if @showingInherited⤶      @showingInherited = false⤶      @buildAndConnectChildren()⤶⤶  hideOwnPropsOnly: ->⤶    if @showingOwnPropsOnly⤶      @showingOwnPropsOnly = false⤶      @buildAndConnectChildren()⤶⤶  constructor: (@target) ->⤶    @classesButtons = []⤶    @classesNames = []⤶    @angledArrows = []⤶    super new Point 300, 300⤶    @buildAndConnectChildren()⤶  ⤶  buildAndConnectChildren: ->⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    # remove all submorhs i.e. panes and buttons⤶    # THE ONES THAT ARE STILL⤶    # submorphs of the inspector. If they⤶    # have been peeled away, they still live⤶    @fullDestroyChildren()⤶⤶    attribs = []⤶    @classesButtons = []⤶    @classesNames = []⤶    @angledArrows = []⤶⤶    # properties list. Note that this picks up ALL properties⤶    # (enumerable such as strings and un-enumerable such as functions)⤶    # of the whole prototype chain.⤶    #⤶    #   a) some of these are DECLARED as part of the class that defines the object⤶    #   and are proprietary to the object. These are shown RED⤶    # ⤶    #   b) some of these are proprietary to the object but are initialised by⤶    #   code higher in the prototype chain. These are shown GREEN⤶    #⤶    #   c) some of these are not proprietary, i.e. they belong to an object up⤶    #   the chain of prototypes. These are shown BLUE⤶    #⤶    # TODO show the static methods and variables in yet another color.⤶    ⤶    for property of @target⤶      # dummy condition, to be refined⤶      attribs.push property  if property⤶⤶    if !@showingMethods⤶      attribs = attribs.filter (prop) => !Utils.isFunction @target[prop]⤶⤶    if !@showingFields⤶      attribs = attribs.filter (prop) => Utils.isFunction @target[prop]⤶⤶    # if we don't show inherited props, then we let through two types of props (each side of the ＂or＂⤶    # takes care of one type):⤶    #   1) the ones that are defined in the immediate class of the object (i.e. are own properties of the prototype)⤶    #   2) the ones that are just stitched to the object but are in none of the classes upwards i.e.⤶    #      are not a reachable property from the prototype⤶    if !@showingInherited⤶      attribs = attribs.filter (prop) => @target.constructor.prototype.hasOwnProperty(prop) or (prop not of @target.constructor.prototype)⤶⤶    if @showingOwnPropsOnly⤶      attribs = attribs.filter (prop) => @target.hasOwnProperty(prop)⤶⤶⤶    # caches the own methods of the object⤶    if @markOwnershipOfProperties⤶      targetOwnMethods = Object.getOwnPropertyNames @target.constructor::⤶      #alert targetOwnMethods⤶⤶    if @target?⤶      goingUpTargetProtChain = @target.__proto__⤶      while goingUpTargetProtChain.constructor.name != ＂Object＂⤶        @classesNames.push goingUpTargetProtChain.constructor.name⤶        goingUpTargetProtChain = goingUpTargetProtChain.__proto__⤶⤶    @hierarchyBackgroundPanel = new RectangleMorph⤶    @hierarchyBackgroundPanel.setColor Color.create 255,255,255,.2⤶    @add @hierarchyBackgroundPanel⤶⤶    counter = 0⤶    for eachNamedClass in @classesNames⤶      classButton = new SimpleButtonMorph true, @, ＂openClassInspector＂, (new StringMorph2 eachNamedClass, WorldMorph.preferencesAndSettings.textInButtonsFontSize),nil,nil,nil,nil,eachNamedClass,nil,nil,@classNamesTextPadding⤶      @classesButtons.push classButton⤶      @add classButton⤶⤶      # the top class doesn't get an arrow pointing upwards⤶      if counter > 0⤶        angledArrow = new AngledArrowUpLeftIconMorph Color.BLACK⤶        @angledArrows.push angledArrow⤶        @add angledArrow⤶⤶      counter++⤶⤶    @lastLabelInHierarchy = new TextMorph ＂this object＂⤶    @add @lastLabelInHierarchy⤶    @lastArrowInHierarchy = new AngledArrowUpLeftIconMorph Color.BLACK⤶    @add @lastArrowInHierarchy⤶⤶    @showMethodsOnButton = new SimpleButtonMorph true, @, ＂hideMethods＂, ＂methods: on＂⤶    @showMethodsOffButton = new SimpleButtonMorph true, @, ＂showMethods＂, ＂methods: off＂⤶    @showMethodsToggle = new ToggleButtonMorph @showMethodsOnButton, @showMethodsOffButton, if @showingMethods then 0 else 1⤶    @add @showMethodsToggle⤶⤶    @showFieldsOnButton = new SimpleButtonMorph true, @, ＂hideFields＂, ＂fields: on＂⤶    @showFieldsOffButton = new SimpleButtonMorph true, @, ＂showFields＂, ＂fields: off＂⤶    @showFieldsToggle = new ToggleButtonMorph @showFieldsOnButton, @showFieldsOffButton, if @showingFields then 0 else 1⤶    @add @showFieldsToggle⤶⤶    @showInheritedOnButton = new SimpleButtonMorph true, @, ＂hideInherited＂, ＂inherited: on＂⤶    @showInheritedOffButton = new SimpleButtonMorph true, @, ＂showInherited＂, ＂inherited: off＂⤶    @showInheritedToggle = new ToggleButtonMorph @showInheritedOnButton, @showInheritedOffButton, if @showingInherited then 0 else 1⤶    @add @showInheritedToggle⤶⤶    @buildAndConnectObjOwnPropsButton()⤶⤶    @addPropertyButton = new SimpleButtonMorph true, @, ＂addPropertyPopout＂, ＂add...＂⤶    @add @addPropertyButton⤶    @renamePropertyButton = new SimpleButtonMorph true, @, ＂renamePropertyPopout＂, ＂rename...＂⤶    @add @renamePropertyButton⤶    @removePropertyButton = new SimpleButtonMorph true, @, ＂removeProperty＂, ＂remove＂⤶    @add @removePropertyButton⤶⤶    @saveTextWdgt = (new StringMorph2 ＂save＂, WorldMorph.preferencesAndSettings.textInButtonsFontSize).alignCenter()⤶    @saveButton = new SimpleButtonMorph true, @, ＂save＂, @saveTextWdgt⤶    @add @saveButton⤶⤶⤶⤶    # open a new inspector, just on objects so⤶    # the idea is that you can view / change⤶    # its fields⤶    doubleClickAction = =>⤶      if !Utils.isObject @currentProperty⤶        return⤶      inspector = new @constructor @currentProperty⤶      inspector.fullRawMoveTo world.hand.position()⤶      inspector.fullRawMoveWithin world⤶      world.add inspector⤶      inspector.changed()⤶⤶    @list = new ListMorph(⤶      @, # target⤶      ＂selectionFromList＂, #action⤶      (if @target instanceof Array then attribs else attribs.sort()), #elements⤶      nil, #labelGetter⤶      @filterProperties(targetOwnMethods), #format⤶      doubleClickAction #doubleClickAction⤶    )⤶    @list.disableDrops()⤶⤶    # we know that the content of this list in this pane is not going to need the⤶    # step function, so we disable that from here by setting it to nil, which⤶    # prevents the recursion to children. We could have disabled that from the⤶    # constructor of MenuMorph, but who knows, maybe someone might intend to use a MenuMorph⤶    # with some animated content? We know that in this specific case it won't need animation so⤶    # we set that here. Note that the ListMorph itself does require animation because of the⤶    # scrollbars, but the MenuMorph (which contains the actual list contents)⤶    # in this context doesn't.⤶    world.steppingWdgts.delete @list.listContents⤶    @add @list⤶⤶    # we add a Widget alignment here because adjusting IDs whenever⤶    # we add or remove methods is a pain...⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶⤶    # details pane⤶    @detail = new SimplePlainTextScrollPanelWdgt ＂＂, false, 5⤶    @detail.disableDrops()⤶    @detail.contents.disableDrops()⤶    @detail.color = Color.WHITE⤶    @detail.addModifiedContentIndicator()⤶    ⤶    # when there is no selected item in the list⤶    # (for example when the inspector is started)⤶    # we need to manually remove the ＂modified＂ indicator⤶    # and disable the ＂save＂ button⤶    if !@list.selected?⤶      @detail.modifiedTextTriangleAnnotation?.hide()⤶      @saveTextWdgt.setColor Color.create 200, 200, 200⤶⤶    # register this wdgt as one to be notified when the text⤶    # changes/unchanges from ＂reference＂ content⤶    # so we can enable/disable the ＂save＂ button⤶    @detail.widgetToBeNotifiedOfTextModificationChange = @⤶⤶    @textMorph = @detail.textWdgt⤶    @textMorph.backgroundColor = Color.TRANSPARENT⤶    @textMorph.setFontName nil, nil, @textMorph.monoFontStack⤶    @textMorph.isEditable = false⤶⤶    @add @detail⤶⤶⤶⤶    @hierarchyHeaderString = new StringMorph2 ＂Hierarchy＂, WorldMorph.preferencesAndSettings.textInButtonsFontSize⤶    @hierarchyHeaderString.toggleHeaderLine()⤶    @hierarchyHeaderString.alignCenter()⤶    @add @hierarchyHeaderString⤶⤶⤶    @propertyHeaderString = new StringMorph2 ＂Properties＂, WorldMorph.preferencesAndSettings.textInButtonsFontSize⤶    @propertyHeaderString.toggleHeaderLine()⤶    @propertyHeaderString.alignCenter()⤶    @add @propertyHeaderString⤶⤶    # resizer⤶    @resizer = new HandleMorph @⤶⤶    # update layout⤶    @invalidateLayout()⤶⤶  textContentModified: ->⤶    # TODO this would stand for enabling/disabling the button⤶    # but really we are just changing the color and the button⤶    # still works. Need some better enabling/disabling⤶    @saveTextWdgt.setColor Color.BLACK⤶⤶  textContentUnmodified: ->⤶    # TODO this would stand for enabling/disabling the button⤶    # but really we are just changing the color and the button⤶    # still works. Need some better enabling/disabling⤶    @saveTextWdgt.setColor Color.create 200, 200, 200⤶⤶⤶  buildAndConnectObjOwnPropsButton: ->⤶    @showOwnPropsOnlyOnButton = new SimpleButtonMorph true, @, ＂hideOwnPropsOnly＂, ＂obj own props only: on＂⤶    @showOwnPropsOnlyOffButton = new SimpleButtonMorph true, @, ＂showOwnPropsOnly＂, ＂obj own props only: off＂⤶    @showOwnPropsOnlyToggle = new ToggleButtonMorph @showOwnPropsOnlyOnButton, @showOwnPropsOnlyOffButton, if @showingOwnPropsOnly then 0 else 1⤶    @add @showOwnPropsOnlyToggle⤶⤶  openClassInspector: (ignored,ignored2,className) ->⤶    classInspector = new ClassInspectorMorph window[className].prototype⤶    wm = new WindowWdgt nil, nil, classInspector⤶    wm.setExtent new Point 560, 410⤶    wm.fullRawMoveTo world.hand.position().subtract new Point 50, 100⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶⤶  filterProperties: (targetOwnMethods)->⤶    if @markOwnershipOfProperties⤶      return [⤶        # give color criteria from the most general to the most specific⤶        [Color.create(0, 0, 180),⤶          (element) =>⤶            # if the element is either an enumerable property of the object⤶            # or it belongs to the own methods, then it is highlighted.⤶            # Note that hasOwnProperty doesn't pick up non-enumerable properties such as⤶            # functions.⤶            # In theory, getOwnPropertyNames should give ALL the properties but the methods⤶            # are still not picked up, maybe because of the coffeescript construction system, I am not sure⤶            true⤶        ],⤶        [Color.create(0, 180, 0),⤶          (element) =>⤶            # if the element is either an enumerable property of the object⤶            # or it belongs to the own methods, then it is highlighted.⤶            # Note that hasOwnProperty doesn't pick up non-enumerable properties such as⤶            # functions.⤶            # In theory, getOwnPropertyNames should give ALL the properties but the methods⤶            # are still not picked up, maybe because of the coffeescript construction system, I am not sure⤶            @target.constructor.prototype.hasOwnProperty(element)⤶        ]⤶      ]⤶    else⤶      return nil⤶⤶  selectionFromList: (selected) ->⤶    if selected == undefined then return⤶⤶    val = @target[selected]⤶    @currentProperty = val⤶⤶    # functions should have a source somewhere⤶    # either in the object or in a superclass,⤶    # try to find it.⤶    if Utils.isFunction(val)⤶      if @target[selected + ＂_source＂]?⤶          val = @target[selected + ＂_source＂]⤶      else⤶        goingUpTargetProtChain = @target⤶        while goingUpTargetProtChain != Object⤶          if goingUpTargetProtChain.constructor.class.nonStaticPropertiesSources[selected]?⤶            val = goingUpTargetProtChain.constructor.class.nonStaticPropertiesSources[selected]⤶            break⤶          goingUpTargetProtChain = goingUpTargetProtChain.__proto__⤶      txt = val.toString()⤶    else⤶      # this is for finding the static variables⤶      if val is undefined⤶        val = @target.constructor[selected]⤶      ⤶      if !val?⤶        txt = ＂nil＂⤶      else if Utils.isString val⤶        txt = '＂'+val+'＂'⤶      else⤶        txt = val.toString()⤶⤶    cnts = @detail.textWdgt⤶    cnts.setText txt⤶    cnts.setReceiver @target⤶    cnts.isEditable = true⤶    cnts.enableSelecting()⤶    cnts.considerCurrentTextAsReferenceText()⤶    @detail.checkIfTextContentWasModifiedFromTextAtStart()⤶  ⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶    headerBounds = new Rectangle new Point(Math.round(@left() + @externalPadding), Math.round(@top() + @externalPadding))⤶    headerBounds = headerBounds.setBoundsWidthAndHeight @width() - 2 * @externalPadding, 15⤶    @hierarchyHeaderString.doLayout headerBounds⤶⤶⤶    # classes diagram⤶    justAcounter = 0⤶    anotherCount = 0⤶    # reverse works in-place, so we need to remember⤶    # to put them back right after we are done⤶    @classesButtons.reverse()⤶    for eachClassButton in @classesButtons⤶      if eachClassButton.parent == @⤶        buttonBounds = new Rectangle new Point(Math.round(@left() + @externalPadding + @internalPadding + justAcounter), Math.round(@hierarchyHeaderString.bottom() + 2*@internalPadding + justAcounter))⤶        buttonBounds = buttonBounds.setBoundsWidthAndHeight 120 + @classNamesTextPadding * 2, 15 + @classNamesTextPadding * 2⤶        eachClassButton.doLayout buttonBounds⤶⤶        # the top class doesn't get an arrow pointing upwards⤶        if anotherCount > 0⤶          if @angledArrows[anotherCount-1].parent == @⤶            @angledArrows[anotherCount-1].fullRawMoveTo new Point(eachClassButton.left() - 15, Math.round(eachClassButton.top()))⤶            @angledArrows[anotherCount-1].rawSetExtent new Point 15, 15⤶⤶        justAcounter += 20⤶⤶      anotherCount++⤶    @classesButtons.reverse()⤶    @layoutLastLabelInHierarchy Math.round(@left() + @externalPadding + @internalPadding + justAcounter), Math.round(@hierarchyHeaderString.bottom() + 2 * @internalPadding + justAcounter)⤶⤶    @hierarchyBackgroundPanel.fullRawMoveTo new Point @left() + @externalPadding, @hierarchyHeaderString.bottom() + @internalPadding⤶    @hierarchyBackgroundPanel.rawSetExtent new Point @width() - 2 * @externalPadding, justAcounter + 20 + @internalPadding⤶⤶    headerBounds = new Rectangle new Point @left() + @externalPadding , @hierarchyBackgroundPanel.bottom()+ @internalPadding⤶    headerBounds = headerBounds.setBoundsWidthAndHeight @width() - 2 * @externalPadding , 15⤶    @propertyHeaderString.doLayout headerBounds⤶⤶    listWidth = Math.floor((@width() - 2 * @externalPadding - @internalPadding ) / 3)⤶    detailWidth = 2*listWidth⤶⤶    @layoutOwnPropsOnlyToggle @propertyHeaderString.bottom() + @internalPadding, listWidth, detailWidth⤶⤶    # list⤶    listHeight = (@bottom() - @externalPadding - @internalPadding - 15) - (@showMethodsToggle.bottom() + @internalPadding)⤶    if @list.parent == @⤶      @list.fullRawMoveTo new Point @left() + @externalPadding, @showMethodsToggle.bottom() + @internalPadding⤶      @list.rawSetExtent new Point listWidth, listHeight⤶⤶    # detail⤶    if @detail.parent == @⤶      @detail.fullRawMoveTo new Point @list.right() + @internalPadding, @list.top()⤶      @detail.rawSetExtent (new Point detailWidth, listHeight).round()⤶⤶    widthOfButtonsUnderList = Math.round((listWidth - 2 * @internalPadding)/3)⤶⤶    buttonBounds = new Rectangle new Point @left() + @externalPadding, @bottom() - 15 - @externalPadding⤶    buttonBounds = buttonBounds.setBoundsWidthAndHeight widthOfButtonsUnderList, 15⤶    @addPropertyButton.doLayout buttonBounds⤶⤶    buttonBounds = new Rectangle new Point @addPropertyButton.right() + @internalPadding, @bottom() - 15 - @externalPadding⤶    buttonBounds = buttonBounds.setBoundsWidthAndHeight widthOfButtonsUnderList, 15⤶    @renamePropertyButton.doLayout buttonBounds⤶⤶    buttonBounds = new Rectangle new Point @renamePropertyButton.right() + @internalPadding, @bottom() - 15 - @externalPadding⤶    buttonBounds = buttonBounds.setBoundsWidthAndHeight widthOfButtonsUnderList, 15⤶    @removePropertyButton.doLayout buttonBounds⤶⤶    buttonBounds = new Rectangle new Point Math.round(@right() - @width()/4 - @externalPadding - @internalPadding - WorldMorph.preferencesAndSettings.handleSize), @bottom() - 15 - @externalPadding⤶    buttonBounds = buttonBounds.setBoundsWidthAndHeight Math.round(@width()/4), 15⤶    @saveButton.doLayout buttonBounds⤶⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶⤶    super⤶    @markLayoutAsFixed()⤶⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶  layoutOwnPropsOnlyToggle: (height, listWidth, detailWidth) ->⤶⤶    toggleBounds = new Rectangle new Point @left()+@externalPadding , height⤶    toggleBounds = toggleBounds.setBoundsWidthAndHeight (new Point (listWidth-@internalPadding)/ 2,15).round()⤶    @showMethodsToggle.doLayout toggleBounds⤶⤶    toggleBounds = new Rectangle new Point @showMethodsToggle.right() + @internalPadding, height⤶    toggleBounds = toggleBounds.setBoundsWidthAndHeight (new Point (listWidth-@internalPadding)/ 2,15).round()⤶    @showFieldsToggle.doLayout toggleBounds⤶ ⤶    toggleBounds = new Rectangle new Point @showFieldsToggle.right() + @internalPadding, height⤶    toggleBounds = toggleBounds.setBoundsWidthAndHeight (new Point (detailWidth-@internalPadding)/ 2,15).round()⤶    @showInheritedToggle.doLayout toggleBounds⤶⤶    toggleBounds = new Rectangle new Point @showInheritedToggle.right() + @internalPadding, height⤶    toggleBounds = toggleBounds.setBoundsWidthAndHeight (new Point (detailWidth-@internalPadding)/ 2,15).round()⤶    @showOwnPropsOnlyToggle.doLayout toggleBounds⤶⤶⤶  layoutLastLabelInHierarchy: (posx, posy) ->⤶    if @lastLabelInHierarchy.parent == @⤶      @lastLabelInHierarchy.fullRawMoveTo new Point posx, posy⤶      @lastLabelInHierarchy.rawSetExtent new Point 150, 15⤶⤶    if @lastArrowInHierarchy.parent == @⤶      @lastArrowInHierarchy.fullRawMoveTo new Point posx - 15, posy⤶      @lastArrowInHierarchy.rawSetExtent new Point 15, 15⤶⤶⤶  notifyInstancesOfSourceChange: (propertiesArray)->⤶    @target.sourceChanged()⤶  ⤶  #InspectorMorph2 editing ops:⤶  save: ->⤶    if !@list.selected? then return⤶    txt = @detail.contents.children[0].text.toString()⤶    propertyName = @list.selected.labelString⤶    # inject code will also break the layout and the morph⤶    @target.injectProperty propertyName, txt⤶⤶    @detail.textWdgt.considerCurrentTextAsReferenceText()⤶    @detail.checkIfTextContentWasModifiedFromTextAtStart()⤶⤶    # it's possible that the user might have fixed⤶    # a ＂painting＂ error, so give another chance to all⤶    # ＂banned＂ widgets (banned from repainting)⤶    for eachWidget in world.widgetsGivingErrorWhileRepainting⤶      eachWidget.show()⤶    world.widgetsGivingErrorWhileRepainting = []⤶⤶⤶  # TODO should have a removeProperty method in Widget (and in the classes somehow)⤶  # rather than here⤶  addProperty: (ignoringThis, morphWithProperty) ->⤶    prop = morphWithProperty.text.text⤶    if prop?⤶      if prop.getValue?⤶        prop = prop.getValue()⤶      @target[prop] = nil⤶      @buildAndConnectChildren()⤶      @notifyInstancesOfSourceChange([prop])⤶  ⤶  addPropertyPopout: ->⤶    @prompt ＂new property name:＂, @, ＂addProperty＂, ＂property＂ # Chrome cannot handle empty strings (others do)⤶⤶  # TODO should have a removeProperty method in Widget (and in the classes somehow)⤶  # rather than here⤶  renameProperty: (ignoringThis, morphWithProperty) ->⤶    propertyName = @list.selected.labelString⤶    prop = morphWithProperty.text.text⤶    if prop.getValue?⤶      prop = prop.getValue()⤶    ⤶    delete @target[propertyName]⤶    @target[prop] = @currentProperty⤶⤶    @buildAndConnectChildren()⤶    @notifyInstancesOfSourceChange([prop, propertyName])⤶  ⤶  renamePropertyPopout: ->⤶    propertyName = @list.selected.labelString⤶    @prompt ＂property name:＂, @, ＂renameProperty＂, propertyName⤶  ⤶  # TODO should have a removeProperty method in Widget (and in the classes somehow)⤶  # rather than here⤶  removeProperty: ->⤶    propertyName = @list.selected.labelString⤶⤶    delete @target[propertyName]⤶⤶    @currentProperty = nil⤶    @buildAndConnectChildren()⤶    @notifyInstancesOfSourceChange([propertyName])⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.Mixin_coffeSource = "class Mixin⤶  @allMixines: []⤶  nonStaticPropertiesSources: nil⤶  staticPropertiesSources: nil⤶  name: ＂＂⤶⤶  _equivalentforSuper: (aString) ->⤶    #console.log ＂removing super from: ＂ + aString⤶⤶    # coffeescript won't compile ＂super＂ unless it's an instance⤶    # method (i.e. if it comes inside a class), so we need to⤶    # translate that manually into valid CS that doesn't use super.⤶⤶    # rephrasing ＂super＂ here...⤶    # we can't compile ＂super＂ in a mixin because we can't tell which⤶    # class this will be mixed in in advance, i.e. at compile time it doesn't⤶    # belong to a class, so at compile time it doesn't know which class⤶    # it will be injected in.⤶    # So that's why _at time of injection_ we need⤶    # to store the class it's injected in in a special⤶    # variable... and then at runtime here we use that variable to⤶    # implement super⤶⤶    aString = aString.replace(/super$/gm, ＂window[@[arguments.callee.name + '_class_injected_in']].__super__[arguments.callee.name].apply(this, arguments)＂)⤶    aString = aString.replace(/super /g, ＂window[@[arguments.callee.name + '_class_injected_in']].__super__[arguments.callee.name].call this, ＂)⤶⤶    # TODO un-translated cases as of yet⤶    # /super⧹(⧹)/g -> ...???...⤶    # /super⧹(/g -> ...???...⤶⤶  # Coffeescript adds some helper functions at the top of the compiled code:⤶  #⤶  #  slice = [].slice⤶  #  indexOf = [].indexOf⤶  #  hasProp = {}.hasOwnProperty⤶  #⤶  # here we remove them them all, because they mangle the code,⤶  # also we just have them all in the global scope by now so⤶  # they are not needed multiple times⤶⤶  _removeHelperFunctions: (aString) ->⤶    aString = aString.replace /indexOf = [].indexOf/, ＂$$$$$$＂⤶    aString = aString.replace /hasProp = {}.hasProp/, ＂$$$$$$＂⤶    aString = aString.replace /slice = [].slice/, ＂$$$$$$＂⤶⤶    if (aString.includes ＂[].indexOf＂) or⤶     (aString.includes ＂{}.hasProp＂) or⤶     (aString.includes ＂[].slice＂)⤶      console.log ＂code contains a helper var, it shouldn't: ＂ +  aString⤶      debugger⤶⤶    return aString⤶⤶  constructor: (source, generatePreCompiledJS, createMixin) ->⤶⤶    @nonStaticPropertiesSources = {}⤶    @staticPropertiesSources = {}⤶⤶    # find the Mixin name⤶    mixinRegex = /^([a-zA-Z_$][0-9a-zA-Z_$]*)Mixin *=/m⤶    if (m = mixinRegex.exec(source))?⤶        m.forEach((match, groupIndex) ->⤶            if srcLoadCompileDebugWrites then console.log(＂Found match, group #{groupIndex}: #{match}＂)⤶        )⤶        @name = m[1]⤶        if srcLoadCompileDebugWrites then console.log ＂mixin name: ＂ + @name⤶⤶    if srcLoadCompileDebugWrites then console.log ＂source ---------⧹n＂ + source⤶⤶    sourceToBeParsed = source + ＂⧹n      $$$STOPTOKEN_LASTFIELD :＂⤶⤶    # Now find all the fields definitions⤶    # note that the constructor, methods, properties and static properties⤶    # are ALL fields definitions, so we are basically going to cycle through⤶    # everything⤶⤶    # to match a valid JS variable name (we just ignore the keywords):⤶    #    [a-zA-Z_$][0-9a-zA-Z_$]*⤶    regex = /^      ([a-zA-Z_$][0-9a-zA-Z_$]*) *: *([^]*?)(?=^      ([a-zA-Z_$][0-9a-zA-Z_$]*) *:)/gm⤶⤶    while (m = regex.exec(sourceToBeParsed))?⤶        if (m.index == regex.lastIndex)⤶            regex.lastIndex++⤶        m.forEach (match, groupIndex) ->⤶            if srcLoadCompileDebugWrites then console.log ＂Found match, group #{groupIndex}: #{match}＂⤶⤶        if m[1].valueOf() == ＂$$$STOPTOKEN_LASTFIELD ＂⤶          break⤶        else⤶          if srcLoadCompileDebugWrites then console.log ＂not the stop field: ＂ + m[1].valueOf()⤶⤶        @nonStaticPropertiesSources[m[1]] = m[2]⤶⤶    if generatePreCompiledJS or createMixin⤶      JS_string_definitions = compileFGCode (@_equivalentforSuper source), true⤶      JSSourcesContainer.content += JS_string_definitions + ＂⧹n＂⤶      if createMixin⤶        try⤶          eval.call window, JS_string_definitions⤶        catch err⤶          console.log ＂ error ＂ + err + ＂ evaling : ＂ + JS_string_definitions⤶          debugger⤶⤶⤶    #if @name == ＂LCLCodePreprocessor＂ then debugger⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.BackBufferMixin_coffeSource = "# //////////////////////////////////////////////////////////⤶⤶# A BackBuffer is a canvas that a morph can keep for⤶# two reasons:⤶#   1) as a cache⤶#   2) because the morph has inherently a ＂raster＂ nature⤶#      such as the canvas where you can run a turtle to⤶#      draw stuff, or a Widget where you want to have⤶#      pixel-based filters.⤶#⤶# The cache use is useful for morphs that ideally⤶#  * have a small extent⤶#  * have an expensive painting process⤶#  * are repainted often⤶#⤶# (Note that the cache for the time being is only⤶# for the very morph, not for the whole of the⤶# hierarchy.)⤶#⤶# Ideal use of a cache is text because painting text⤶# can be a lengthy operation.⤶# Worst possible use of a cache is the large⤶# desktop background rectangle, where a lot of memory⤶# would be wasted for saving a very short painting⤶# operation.⤶#⤶# In theory the backing store use should be transparent and⤶# automatic, driven perhaps by dynamic considerations,⤶# but we are not there yet.⤶⤶BackBufferMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶      # note that image contains only the CURRENT morph, not the composition of this⤶      # morph with all of the submorphs. I.e. for an inspector, this will only⤶      # contain the background of the window pane. Not any of its contents.⤶      # for the worldMorph, this only contains the background⤶      backBuffer: nil⤶      backBufferContext: nil⤶⤶      # just a flag to indicate that the⤶      # backBufferContext value can be derived from others⤶      # currently unused⤶      # backBufferContext_isDerivedValue: true⤶⤶      # as seen by the ＂ * ceilPixelRatio ＂ parts in the code,⤶      # this function returns actual pixels, not logical pixels.⤶      # Hence, these values are only good outside of the⤶      # scope of the scaling due to the ceilPixelRatio⤶      calculateKeyValues: (aContext, clippingRectangle) ->⤶        area = clippingRectangle.intersect(@boundingBox()).round()⤶        # test whether anything that we are going to be drawing⤶        # is visible (i.e. within the clippingRectangle)⤶        if area.isNotEmpty()⤶          delta = @position().neg()⤶          src = area.translateBy(delta).round()⤶          ⤶          # the ＂ * ceilPixelRatio ＂ multiplications⤶          # tranform logical pixels into actual pixels.⤶          sl = src.left() * ceilPixelRatio⤶          st = src.top() * ceilPixelRatio⤶          al = area.left() * ceilPixelRatio⤶          at = area.top() * ceilPixelRatio⤶          # @backBuffer.width and @backBuffer.height are already in⤶          # physical coordinates so no need to adjust for pixelratio⤶          w = Math.min(src.width() * ceilPixelRatio, @backBuffer.width - sl)⤶          h = Math.min(src.height() * ceilPixelRatio, @backBuffer.height - st)⤶        return [area,sl,st,al,at,w,h]⤶⤶      isTransparentAt: (aPoint) ->⤶        @bounds.debugIfFloats()⤶        if @boundsContainPoint aPoint⤶          return false  if @texture⤶          data = @getPixelColor aPoint⤶          # check the 4th byte - the Alpha (RGBA)⤶          return data.a is 0⤶        false⤶⤶      # Widget pixel access:⤶      getPixelColor: (aPoint) ->⤶        [@backBuffer, @backBufferContext] = @createRefreshOrGetBackBuffer()⤶        point = aPoint.toLocalCoordinatesOf @⤶        data = @backBufferContext.getImageData point.x * ceilPixelRatio, point.y * ceilPixelRatio, 1, 1⤶        Color.create data.data[0], data.data[1], data.data[2], data.data[3]⤶⤶⤶      # This method only paints this very morph's ＂image＂,⤶      # it doesn't descend the children⤶      # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which⤶      # eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶      # Note that this morph might paint something on the screen even if⤶      # it's not a ＂leaf＂.⤶      paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶        @justBeforeBeingPainted?()⤶⤶        if !@visibleBasedOnIsVisibleProperty() or @isCollapsed()⤶          return nil⤶⤶        [@backBuffer, @backBufferContext] = @createRefreshOrGetBackBuffer()⤶⤶        if !@backBuffer?⤶          return nil⤶⤶        [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle⤶        return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶        aContext.save()⤶⤶        aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @alpha⤶⤶        aContext.drawImage @backBuffer,⤶          Math.round(sl),⤶          Math.round(st),⤶          Math.round(w),⤶          Math.round(h),⤶          Math.round(al),⤶          Math.round(at),⤶          Math.round(w),⤶          Math.round(h)⤶⤶        aContext.restore()⤶⤶        # paintHighlight is usually made to work with⤶        # al, at, w, h which are actual pixels⤶        # rather than logical pixels, so it's generally used⤶        # outside the effect of the scaling because⤶        # of the ceilPixelRatio⤶        @paintHighlight aContext, al, at, w, h⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ChildrenStainerMixin_coffeSource = "# some widgets are composed by a number of other widgets,⤶# and you'd want them all to change color at the same time⤶# an example is the reference widget, which is composed by⤶# the ＂reference arrow＂ and the ＂document＂ icons, and you⤶# want them to change color (e.g. on hover or click) at the⤶# same time⤶⤶ChildrenStainerMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶      setColor: (theColor, ignored, connectionsCalculationToken, superCall) ->⤶        if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @connectionsCalculationToken = connectionsCalculationToken⤶        super theColor, ignored, connectionsCalculationToken, true⤶        for w in @children⤶          w.setColor theColor, ignored, connectionsCalculationToken⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ClippingAtRectangularBoundsMixin_coffeSource = "ClippingAtRectangularBoundsMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶      clipsAtRectangularBounds: true⤶⤶      # used for example:⤶      # - to determine which morphs you can attach a morph to⤶      # - for a SliderMorph's ＂set target＂ so you can change properties of another Widget⤶      # - by the HandleMorph when you attach it to some other morph⤶      # Note that this method has a slightly different⤶      # version in Widget (because it doesn't clip)⤶      plausibleTargetAndDestinationMorphs: (theMorph) ->⤶        # find if I intersect theMorph,⤶        # then check my children recursively⤶        # exclude me if I'm a child of theMorph⤶        # (cause it's usually odd to attach a Widget⤶        # to one of its submorphs or for it to⤶        # control the properties of one of its submorphs)⤶        result = []⤶        if @visibleBasedOnIsVisibleProperty() and⤶            !@isCollapsed() and⤶            !theMorph.isAncestorOf(@) and⤶            @areBoundsIntersecting(theMorph) and⤶            !@anyParentPopUpMarkedForClosure()⤶          result = [@]⤶⤶        # Since the PanelWdgt clips its children⤶        # at its boundary, hence we need⤶        # to check that we don't consider overlaps with⤶        # morphs contained in this Panel that are clipped and⤶        # hence *actually* not overlapping with theMorph.⤶        # So continue checking the children only if the⤶        # Panel itself actually overlaps.⤶        if @areBoundsIntersecting theMorph⤶          @children.forEach (child) ->⤶            result = result.concat child.plausibleTargetAndDestinationMorphs theMorph⤶⤶        return result⤶⤶      # do nothing if the call comes from a child⤶      # otherwise, if it comes from me (say, because the⤶      # Panel has been moved), then⤶      # do invalidate the cache as normal.⤶      invalidateFullBoundsCache: (morphCalling) ->⤶        if morphCalling == @⤶          super @⤶⤶      invalidateFullClippedBoundsCache: (morphCalling) ->⤶        if morphCalling == @⤶          super @⤶      ⤶      # here is the magic of a Frame: the recursion⤶      # stops and we can ignore the bounds of potentially⤶      # hundreds of morphs that might be in here.⤶      SLOWfullBounds: ->⤶        @bounds⤶⤶      SLOWfullClippedBounds: ->⤶        if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()⤶          result = Rectangle.EMPTY⤶        else⤶          result = @clippedThroughBounds()⤶        #if this != world and result.corner.x > 400 and result.corner.y > 100 and result.origin.x ==0 and result.origin.y ==0⤶        #  debugger⤶        result⤶⤶      # Panels clip any of their children⤶      # at their boundaries⤶      # so there is no need to do a deep⤶      # traversal to find the bounds.⤶      fullBounds: ->⤶        if @cachedFullBounds?⤶          if world.doubleCheckCachedMethodsResults⤶            if !@cachedFullBounds.equals @SLOWfullBounds()⤶              debugger⤶              alert ＂fullBounds is broken (cached)＂⤶          return @cachedFullBounds⤶⤶        result = @bounds⤶⤶        if world.doubleCheckCachedMethodsResults⤶          if !result.equals @SLOWfullBounds()⤶            debugger⤶            alert ＂fullBounds is broken (uncached)＂⤶⤶        @cachedFullBounds = result⤶⤶      fullClippedBounds: ->⤶        if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()⤶          result = Rectangle.EMPTY⤶        else⤶          if @cachedFullClippedBounds?⤶            if @checkFullClippedBoundsCache == WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶              if world.doubleCheckCachedMethodsResults⤶                if !@cachedFullClippedBounds.equals @SLOWfullClippedBounds()⤶                  debugger⤶                  alert ＂fullClippedBounds is broken＂⤶              return @cachedFullClippedBounds⤶⤶          result = @clippedThroughBounds()⤶⤶        if world.doubleCheckCachedMethodsResults⤶          if !result.equals @SLOWfullClippedBounds()⤶            debugger⤶            alert ＂fullClippedBounds is broken＂⤶⤶        @checkFullClippedBoundsCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶        @cachedFullClippedBounds = result⤶⤶⤶⤶      fullPaintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶        super⤶⤶        # after all the contents are drawn,⤶        # draw the border of the Panel again.⤶        # This is because the border has to be drawn inside the Frame,⤶        # but the contents might paint over it. So, we need to⤶        # paint them AFTER the content has been painted.⤶        if !@preliminaryCheckNothingToDraw clippingRectangle, aContext⤶          if !appliedShadow?⤶            if !@paintStroke?⤶              debugger⤶            @paintStroke aContext, clippingRectangle⤶⤶      ⤶      fullPaintIntoAreaOrBlitFromBackBufferContentPotentiallyAsShadow: (aContext, clippingRectangle, appliedShadow) ->⤶⤶        # a PanelWdgt has the special property that all of its children⤶        # are actually inside its boundary.⤶        # This allows⤶        # us to avoid the further traversal of potentially⤶        # many many morphs if we see that the rectangle we⤶        # want to paint is outside its Panel.⤶        # If the rectangle we want to paint is inside the Panel⤶        # then we do have to continue traversing all the⤶        # children of the Frame.⤶⤶        # This is why as well it's good to use PanelWdgts whenever⤶        # it's clear that there is a ＂container＂ case. Think⤶        # for example that you could stick a small⤶        # RectangleMorph (not a Frame) on the desktop and then⤶        # attach a thousand⤶        # CircleBoxMorphs on it.⤶        # Say that the circles are all inside the rectangle,⤶        # apart from four that are at the corners of the world.⤶        # that's a nightmare scenegraph⤶        # to *completely* traverse for *any* broken rectangle⤶        # anywhere on the screen.⤶        # The traversal is complete because a) Widgetic doesn't⤶        # assume that the rectangle clips its children and⤶        # b) the bounding rectangle (which currently is not⤶        # efficiently calculated anyways) is the whole screen.⤶        # So the children could be anywhere and need to be all⤶        # checked for damaged areas to repaint.⤶        # If the RectangleMorph is made into a Panel, one can⤶        # avoid the traversal for any broken rectangle not⤶        # overlapping it.⤶⤶        # Also note that in theory you could stop recursion on any⤶        # PanelWdgt completely covered by a large opaque morph⤶        # (or on any Widget which fullBounds are completely⤶        # covered, for that matter). You could⤶        # keep for example a list of the top n biggest opaque morphs⤶        # (say, Panels and rectangles)⤶        # and check that case while you traverse the list.⤶        # (see https://github.com/davidedc/Fizzygum/issues/149 )⤶        ⤶        # the part to be redrawn could be outside the Panel entirely,⤶        # in which case we can stop going down the morphs inside the Panel⤶        # since the whole point of the Panel is to clip everything to a specific⤶        # rectangle. (note that you can't do the same trick with a⤶        # generic tree of morphs since the root morph doesn't⤶        # necessarily contain all the submorphs in its boundaries like⤶        # the PanelWdgt does)⤶        # So, check which part of the Frame should be redrawn:⤶        dirtyPartOfFrame = @boundingBox().intersect clippingRectangle⤶        ⤶        if !dirtyPartOfFrame.isEmpty()⤶        ⤶          if aContext == world.worldCanvasContext⤶            @recordDrawnAreaForNextBrokenRects()⤶⤶          # this draws the background of the Panel itself⤶          @paintIntoAreaOrBlitFromBackBuffer aContext, dirtyPartOfFrame, appliedShadow⤶⤶          @children.forEach (child) =>⤶            child.fullPaintIntoAreaOrBlitFromBackBuffer aContext, dirtyPartOfFrame, appliedShadow⤶⤶      fullPaintIntoAreaOrBlitFromBackBufferJustShadow: (aContext, clippingRectangle, appliedShadow) ->⤶        clippingRectangle = clippingRectangle.translateBy -appliedShadow.offset.x, -appliedShadow.offset.y⤶⤶        if !@preliminaryCheckNothingToDraw clippingRectangle, aContext⤶⤶          # the part to be redrawn could be outside the Panel entirely,⤶          # in which case we can stop going down the morphs inside the Panel⤶          # since the whole point of the Panel is to clip everything to a specific⤶          # rectangle.⤶          # So, check which part of the Frame should be redrawn:⤶          dirtyPartOfFrame = @boundingBox().intersect clippingRectangle⤶          ⤶          # if there is no dirty part in the Panel then do nothing⤶          if !dirtyPartOfFrame.isEmpty()⤶⤶            aContext.save()⤶            aContext.translate appliedShadow.offset.x * ceilPixelRatio, appliedShadow.offset.y * ceilPixelRatio⤶          ⤶            # this draws the background of the Panel itself⤶            @paintIntoAreaOrBlitFromBackBuffer aContext, dirtyPartOfFrame, appliedShadow⤶⤶            # since the morph clips at its boundaries, then we know that all of⤶            # its children are inside. Hence, if the Panel is fully opaque, then⤶            # since we are just drawing the shadow, we can just⤶            # draw the shadow of the Panel itself and skip all of the children.⤶            if @alpha != 1⤶              @children.forEach (child) =>⤶                child.fullPaintIntoAreaOrBlitFromBackBuffer aContext, dirtyPartOfFrame, appliedShadow⤶⤶            aContext.restore()⤶⤶⤶      # PanelWdgt scrolling optimization:⤶      fullRawMoveBy: (delta) ->⤶        #console.log ＂moving all morphs in the Panel＂⤶        @bounds = @bounds.translateBy delta⤶        #console.log ＂move 1＂⤶        @breakNumberOfRawMovesAndResizesCaches()⤶        @children.forEach (child) ->⤶          child.silentFullRawMoveBy delta⤶        @changed()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ControllerMixin_coffeSource = "# //////////////////////////////////////////////////////////⤶⤶# some morphs (for example ColorPaletteMorph⤶# or SliderMorph) can control a target⤶# and they have the same function to attach⤶# targets. Not worth having this in the⤶# whole Widget hierarchy, so... ideal use⤶# of mixins here.⤶⤶ControllerMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶      openTargetSelector: ->⤶        choices = world.plausibleTargetAndDestinationMorphs @⤶        if choices.length > 0⤶          menu = new MenuMorph @, false, @, true, true, ＂choose target:＂⤶          #choices.push @world()⤶          choices.forEach (each) =>⤶            if !(each instanceof FanoutPinWdgt)⤶              menu.addMenuItem (each.toString().replace ＂Wdgt＂, ＂＂).slice(0, 50) + ＂ ➜＂, false, @, ＂openTargetPropertySelector＂, nil, nil, nil, nil, nil, each, nil, true⤶        else⤶          menu = new MenuMorph @, false, @, true, true, ＂no targets available＂⤶        menu.popUpAtHand()⤶⤶      setTargetAndActionWithOnesPickedFromMenu: (ignored, ignored2, theTarget, each) ->⤶        @target = theTarget⤶        @action = each⤶        if @target[@action + ＂IsConnected＂]?⤶          @target[@action + ＂IsConnected＂] = true⤶        @connectionsCalculationToken = world.makeNewConnectionsCalculationToken()⤶        @reactToTargetConnection?()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CornerInternalHaloMixin_coffeSource = "CornerInternalHaloMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶      # floatDragging and dropping:⤶      isLockingToPanels: false⤶⤶      layoutSpec_cornerInternal_proportionOfParent: 4/8⤶      layoutSpec_cornerInternal_fixedSize: 0⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CreateShortcutOfDroppedItemsMixin_coffeSource = "CreateShortcutOfDroppedItemsMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶      # this is used in folder panels. Widgets that are⤶      # NOT shortcuts (object shortcuts or folders) that are⤶      # dropped are then going to be closed and their references⤶      # are going to be left in the folder instead.⤶      # HOWEVER we have to move that first ＂transient＂ widget dropped so that⤶      # it doesn't go ＂left＂ or ＂above＂ the folder panel, otherwise the⤶      # folder panel is going to resize so to fit the dropped widget⤶      # and the folder window is going to get scrollbars and the⤶      # subsequent shortcut is going to end up in a bad place instead⤶      # of the neat automatic grid positioning.⤶      # So, move the ＂transient＂ dropped widget just a bit to the⤶      # right and below the origin.⤶      aboutToDrop: (wdgtToDrop) ->⤶        if wdgtToDrop instanceof IconicDesktopSystemShortcutWdgt⤶          wdgtToDrop.fullRawMoveWithin @⤶        else⤶          wdgtToDrop.fullRawMoveTo @position().add new Point 10, 10⤶⤶      reactToDropOf: (droppedWidget) ->⤶        super⤶        if !(droppedWidget instanceof IconicDesktopSystemShortcutWdgt)⤶          droppedWidget.createReferenceAndClose nil, @⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.DeepCopierMixin_coffeSource = "# //////////////////////////////////////////////////////////⤶⤶DeepCopierMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶      # Note 1: we deep-copy all kinds of data structures, not just widgets⤶      # Note 2: the entire copying mechanism⤶      # should also take care of inserting the copied⤶      # widget in whatever other data structures where the⤶      # original widget was.⤶      # For example, if the widget appeared in a data⤶      # structure related to the broken rectangles mechanism,⤶      # we should place the copied widget there.⤶      deepCopy: (doSerialize, objOriginalsClonedAlready, objectClones, allMorphsInStructure)->⤶        haveIBeenCopiedAlready = objOriginalsClonedAlready.indexOf @⤶        if haveIBeenCopiedAlready >= 0⤶          if doSerialize⤶            return ＂$＂ + haveIBeenCopiedAlready⤶          else⤶            return objectClones[haveIBeenCopiedAlready]⤶        if (@ instanceof Widget) and (@ not in allMorphsInStructure)⤶          if doSerialize⤶            return ＂$EXTERNAL＂ + @uniqueIDString()⤶          else⤶            return @⤶     ⤶        positionInObjClonesArray = objOriginalsClonedAlready.length⤶⤶        # note that for immutable objects, in the non-serialisation case,⤶        # we actually don't create a copy, we just use the same object⤶        cloneOfMe = @getEmptyObjectOfSameTypeAsThisOne doSerialize⤶⤶        # this is the only place where we add to these arrays.⤶        # Note that we know for sure that @ is NOT already in objOriginalsClonedAlready⤶        # (because we do the check at the top of this function)⤶        # and also we know that cloneOfMe is NOT in objectClones either⤶        # (because we only do these two adds in together)⤶        objOriginalsClonedAlready.push @⤶        objectClones.push cloneOfMe⤶⤶        # cloneOfMe at this point is just an ＂empty shell＂ copy⤶⤶        @recursivelyCloneContent cloneOfMe, doSerialize, objOriginalsClonedAlready, objectClones, allMorphsInStructure⤶⤶        # cloneOfMe at this point is a full deep copy⤶⤶        if doSerialize⤶          return ＂$＂ + positionInObjClonesArray⤶⤶        # see comment in the method⤶        cloneOfMe.rebuildDerivedValues @⤶⤶        # if we deep-copied a morph, check whether the original⤶        # was in data structures related to the broken rects⤶        # mechanism, and if so, add the copy there too.⤶        # (since we deep-copy all kinds of data structures,⤶        # not just morphs, check if we have the relevant alignment⤶        # method to invoke).⤶        if @alignCopiedMorphToBrokenInfoDataStructures?⤶          @alignCopiedMorphToBrokenInfoDataStructures cloneOfMe⤶⤶        # if we deep-copied a morph, check whether the original⤶        # was in data structures related to stepping⤶        # mechanism, and if so, add the copy there too.⤶        # (since we deep-copy all kinds of data structures,⤶        # not just morphs, check if we have the relevant alignment⤶        # method to invoke).⤶        if @alignCopiedMorphToSteppingStructures?⤶          @alignCopiedMorphToSteppingStructures cloneOfMe⤶⤶        # if we deep-copied a morph, check whether the original⤶        # was in the data structure that keeps track of the⤶        # widgets that reference other widgets,⤶        # and if so, add the copy there too.⤶        # (since we deep-copy all kinds of data structures,⤶        # not just morphs, check if we have the relevant alignment⤶        # method to invoke).⤶        if @alignCopiedMorphToReferenceTracker?⤶          @alignCopiedMorphToReferenceTracker cloneOfMe⤶⤶        # last chance for a morph to do other⤶        # cleanup, for example a button that is⤶        # highlihted might want to un-highlight⤶        # itself⤶        cloneOfMe.justBeenCopied?()⤶⤶        return cloneOfMe⤶⤶      # some variables such as canvas contexts⤶      # are not copied, as they are derived values⤶      # so we take care or fixing the temporaries here⤶      rebuildDerivedValues: (theOriginal)->⤶        for property of @⤶          # also includes the ＂parent＂ property⤶          if @hasOwnProperty property⤶            # OK so we look at the original value⤶            # and check whether it has a rebuildDerivedValue⤶            # method. If it does, we invoke that method,⤶            # which rebuilds the value and adds it⤶            # *to the clone* (which is the @)⤶            if theOriginal[property]?.rebuildDerivedValue?⤶              theOriginal[property].rebuildDerivedValue(@, property)⤶⤶      recursivelyCloneContent: (cloneOfMe, doSerialize, objOriginalsClonedAlready, objectClones, allMorphsInStructure)->⤶        # these are all the properties that are NOT static⤶        # AND that are ＂attached＂ to the object.⤶        # Which means basically inherited and non-inherited, non-static properties that⤶        # have been re-assigned (Javascript runtime has a copy-on-write mechanism when you⤶        # change the properties of an object).⤶        # https://coffeescript.org/#try:class%20ColorExtended%0A%20%20%40extendedStatic%3A%204%0A%20%20extendedNonStatic%3A%205%0A%0A%0Aclass%20Color%20extends%20ColorExtended%0A%20%20%40aStatic%3A%202%0A%20%20nonStatic%3A%202%0A%20%20%0A%0AColor.aStatic%20%3D%2010%0AmyColor%20%3D%20new%20Color%0AmyColor.extendedNonStatic%20%3D%209%0A%0Afor%20property%20of%20myColor%0A%20%20alert%20property%20%2B%20%22%20%22%20%2B%20myColor.hasOwnProperty(property)⤶        for own property of @⤶          # also includes the ＂parent＂ property⤶⤶          #if property == ＂backBufferContext＂⤶          #  debugger⤶⤶          if !@[property]?⤶            # undefined, null, nil⤶            cloneOfMe[property] = nil⤶          else if typeof @[property] == 'object'⤶            # if the value can be rebuilt after the cloning⤶            # then skip it, otherwise clone it. We know when⤶            # that's the case because the object also has a⤶            # rebuildDerivedValue method to be used to⤶            # rebuild it⤶            if @[property].rebuildDerivedValue?⤶              cloneOfMe[property] = nil⤶            else⤶              if !@[property].deepCopy?⤶                console.dir @⤶                console.log property⤶                debugger⤶              cloneOfMe[property] = @[property].deepCopy doSerialize, objOriginalsClonedAlready, objectClones, allMorphsInStructure⤶          else⤶            # boolean, number, bigint, string, symbol and function⤶            if property != ＂instanceNumericID＂⤶              cloneOfMe[property] = @[property]⤶⤶⤶      # creates a new instance of target's type⤶      # note that⤶      #   1) the constructor method is not run!⤶      #   2) debuggers would show these instances as ＂Object＂⤶      #      even though their prototype is actually of⤶      #      the type you wanted, so all is good there⤶      #   3) this new object is not a copy⤶      #      of the original object. It just has the⤶      #      same type. The properties are not copied.⤶      # This is never run on Arrays because they⤶      # override deepCopy altogether⤶      getEmptyObjectOfSameTypeAsThisOne: (doSerialize)->⤶        #alert ＂cloning a ＂ + @constructor.name⤶        if typeof @ is ＂object＂⤶          theClone = Object.create(@constructor::)⤶          # add to the instances tracking.⤶          # note that only Widgets have that kind⤶          # of tracking⤶          theClone.registerThisInstance?()⤶          if doSerialize⤶            # add a className field if object is not an array⤶            theClone.className = @constructor.name⤶          #console.log ＂theClone class:＂ + theClone.constructor.name⤶⤶          # although we don't run the constructor,⤶          # it's useful to at least initialise the⤶          # object with a different ID⤶          if theClone.assignUniqueID?⤶            theClone.assignUniqueID()⤶          return theClone⤶        else⤶          return @⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.GridPositioningOfAddedShortcutsMixin_coffeSource = "GridPositioningOfAddedShortcutsMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶      numberOfIconsOnDesktop: 0⤶      laysIconsHorizontallyInGrid: true⤶      iconsLayingInGridWrapCount: 3⤶      iconsPaddingFromContainerEdges: 5⤶⤶      add: (aWdgt, position, layoutSpec, beingDropped) ->⤶        # TODO can't handle default parameters in mixins⤶        if !position?⤶          position = nil⤶        if !layoutSpec?⤶          layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING⤶⤶        super⤶        # If the user drops an icon, it's more natural to just position it⤶        # where it is. Conversely, if an icon is just ＂created＂ somewhere,⤶        # then automatic grid positioning is better.⤶        if !beingDropped and (aWdgt instanceof WidgetHolderWithCaptionWdgt) and !(aWdgt instanceof BasementOpenerWdgt)⤶          if @laysIconsHorizontallyInGrid⤶            xPos = @numberOfIconsOnDesktop % @iconsLayingInGridWrapCount⤶            yPos = Math.floor @numberOfIconsOnDesktop / @iconsLayingInGridWrapCount⤶          else⤶            xPos = Math.floor @numberOfIconsOnDesktop / @iconsLayingInGridWrapCount⤶            yPos = @numberOfIconsOnDesktop % @iconsLayingInGridWrapCount⤶          aWdgt.fullRawMoveTo (@position().add new Point xPos * 85, yPos * 85).add @iconsPaddingFromContainerEdges⤶          @numberOfIconsOnDesktop++⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.HighlightableMixin_coffeSource = "# changes the color of a morph based on whether pointer is⤶# hovering over or pressing on it⤶⤶HighlightableMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶      color_hover: Color.SILVER⤶      color_pressed: Color.GRAY⤶      color_normal: Color.create 245, 244, 245⤶⤶      state: 0⤶      STATE_NORMAL: 0⤶      STATE_HIGHLIGHTED: 1⤶      STATE_PRESSED: 2⤶⤶⤶      updateColor: ->⤶        @setColor switch @state⤶          when @STATE_NORMAL⤶            @color_normal⤶          when @STATE_HIGHLIGHTED⤶            @color_hover⤶          when @STATE_PRESSED⤶            @color_pressed⤶⤶        @changed()⤶      ⤶      mouseEnter: ->⤶        @state = @STATE_HIGHLIGHTED⤶        @updateColor()⤶        @startCountdownForBubbleHelp? @toolTipMessage  if @toolTipMessage⤶      ⤶      mouseLeave: ->⤶        @state = @STATE_NORMAL⤶        @updateColor()⤶        world.destroyToolTips()  if @toolTipMessage⤶      ⤶      mouseDownLeft: ->⤶        @state = @STATE_PRESSED⤶        @updateColor()⤶⤶        if !window[@[arguments.callee.name + ＂_class_injected_in＂]]?⤶          debugger⤶⤶        super⤶⤶      mouseUpLeft: ->⤶        @state = @STATE_NORMAL⤶        @updateColor()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.KeepIconicDesktopSystemLinksBackMixin_coffeSource = "# keeps folders and shortcuts and scripts in⤶# the background in respect to other windows⤶# and widgets⤶⤶KeepIconicDesktopSystemLinksBackMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶      childAdded: (theWidget) ->⤶        if theWidget instanceof IconicDesktopSystemLinkWdgt⤶          theWidget.moveOnTopOfTopReference()⤶⤶      childMovedInFrontOfOthers: (theWidget) ->⤶        if theWidget instanceof IconicDesktopSystemLinkWdgt⤶          theWidget.moveOnTopOfTopReference()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.KeepsRatioWhenInVerticalStackMixin_coffeSource = "KeepsRatioWhenInVerticalStackMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶    rawSetWidthSizeHeightAccordingly: (newWidth) ->⤶      @rawResizeToWithoutSpacing?()⤶      ratio = @height()/@width()⤶      @rawSetExtent new Point newWidth, Math.round newWidth * ratio⤶⤶    holderWindowJustBeenGrabbed: (whereFrom) ->⤶      if whereFrom instanceof SimpleVerticalStackPanelWdgt⤶        @freeFromRatioConstraints()⤶⤶    holderWindowMadeIntoExternal: ->⤶      @freeFromRatioConstraints()⤶⤶    freeFromRatioConstraints: ->⤶      if @layoutSpecDetails?⤶        @layoutSpecDetails.canSetHeightFreely = true⤶⤶        availableHeight = world.height() - 20⤶        if @parent.height() > availableHeight⤶          @parent.rawSetExtent (new Point Math.min((@width()/@height()) * availableHeight, world.width()), availableHeight).round()⤶          @parent.fullRawMoveTo world.hand.position().subtract @parent.extent().floorDivideBy 2⤶          @parent.fullRawMoveWithin world⤶⤶    holderWindowJustDropped: (whereIn) ->⤶      if (whereIn instanceof SimpleVerticalStackPanelWdgt) and !(whereIn instanceof WindowWdgt)⤶        @constrainToRatio()⤶⤶    constrainToRatio: ->⤶      if @layoutSpecDetails?⤶        @layoutSpecDetails.canSetHeightFreely = false⤶        # force a resize, so widget⤶        # will take the right ratio⤶        # Note that the height of 0 here is ignored since⤶        # ＂rawSetWidthSizeHeightAccordingly＂ will⤶        # calculate the height.⤶        @rawSetWidthSizeHeightAccordingly @width()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ParentStainerMixin_coffeSource = "ParentStainerMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶      setColor: (theColor, ignored, connectionsCalculationToken, superCall) ->⤶        if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @connectionsCalculationToken = connectionsCalculationToken⤶        super theColor, ignored, connectionsCalculationToken, true⤶        @parent?.setColor theColor, ignored, connectionsCalculationToken⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.WidgetCreatorAndSmartPlacerOnClickMixin_coffeSource = "WidgetCreatorAndSmartPlacerOnClickMixin =⤶  # class properties here:⤶  # none⤶⤶  # instance properties to follow:⤶  onceAddedClassProperties: (fromClass) ->⤶    @addInstanceProperties fromClass,⤶⤶      mouseClickLeft: (ignored, ignored2, ignored3, ignored4, ignored5, ignored6, ignored7, partOfDoubleClick) ->⤶        if partOfDoubleClick⤶          return⤶        widgetToBePlaced = @createWidgetToBeHandled()⤶⤶        # TODO un-handled cases:⤶        #  - empty window with drop-in placeholder⤶        #  - window with panel⤶        #  - window with scrollpanel⤶        where = world.topmostChildSuchThat (w) ->⤶          (w instanceof WindowWdgt) and⤶          (w.contents?) and⤶          ((w.contents instanceof StretchableEditableWdgt) or⤶           (w.contents instanceof SimpleDocumentWdgt) or⤶           (w.contents instanceof PatchProgrammingWdgt) or⤶           (w.contents instanceof SimpleSlideWdgt)) and⤶          (w.contents.dragsDropsAndEditingEnabled)⤶⤶        if where?⤶          if (where.contents instanceof StretchableEditableWdgt) or⤶           (where.contents instanceof PatchProgrammingWdgt) or⤶           (where.contents instanceof SimpleSlideWdgt)⤶            widgetToBePlaced.fullRawMoveTo where.contents.stretchableWidgetContainer.center().round().subtract widgetToBePlaced.extent().floorDivideBy 2⤶            where.contents.stretchableWidgetContainer.add widgetToBePlaced⤶            widgetToBePlaced.rememberFractionalSituationInHoldingPanel()⤶            where.contents.stretchableWidgetContainer.bringToForeground()⤶            @bringToForeground()⤶          else⤶            # this is in case of the simpleDocument⤶            where.contents.simpleDocumentScrollPanel.add widgetToBePlaced⤶            where.contents.simpleDocumentScrollPanel.scrollToBottom()⤶            where.contents.simpleDocumentScrollPanel.bringToForeground()⤶            @bringToForeground()⤶        else⤶          widgetToBePlaced.fullRawMoveTo @topRight().add new Point 20,-40⤶          widgetToBePlaced.fullRawMoveWithin world⤶          world.add widgetToBePlaced⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.CalculatingPatchNodeWdgt_coffeSource = "class CalculatingPatchNodeWdgt extends Widget⤶⤶  @augmentWith ControllerMixin⤶⤶  tempPromptEntryField: nil⤶  defaultFormulaBoxContents: nil⤶  textMorph: nil⤶⤶  formulaTextBoxLabel: nil⤶  outputTextBoxLabel: nil⤶⤶  outputTextArea: nil⤶  outputTextAreaText: nil⤶⤶  output: nil⤶⤶  input1: nil⤶  input2: nil⤶  input3: nil⤶  input4: nil⤶⤶  # we need to keep track of which inputs are⤶  # connected becayse we wait for those to be⤶  # all updated before the node fires⤶  setInput1IsConnected: false⤶  setInput2IsConnected: false⤶  setInput3IsConnected: false⤶  setInput4IsConnected: false⤶⤶  # to keep track of whether each input is⤶  # up-to-date or not⤶  input1connectionsCalculationToken: 0⤶  input2connectionsCalculationToken: 0⤶  input3connectionsCalculationToken: 0⤶  input4connectionsCalculationToken: 0⤶⤶  # the external padding is the space between the edges⤶  # of the container and all of its internals. The reason⤶  # you often set this to zero is because windows already put⤶  # contents inside themselves with a little padding, so this⤶  # external padding is not needed. Useful to keep it⤶  # separate and know that it's working though.⤶  externalPadding: 0⤶  # the internal padding is the space between the internal⤶  # components. It doesn't necessarily need to be equal to the⤶  # external padding⤶  internalPadding: 5⤶⤶  constructor: (@defaultFormulaBoxContents = ＂# function with formula here e.g.⧹n# (in1) -> in1 * 2⧹n＂) ->⤶    super new Point 200,400⤶    @buildAndConnectChildren()⤶⤶  colloquialName: ->⤶    ＂Calculating patch node＂⤶⤶  setInput1: (newvalue, ignored, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @input1connectionsCalculationToken then return else if !connectionsCalculationToken? then @input1connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @input1connectionsCalculationToken = connectionsCalculationToken⤶    @input1 = Number(newvalue)⤶    @updateTarget @input1connectionsCalculationToken⤶⤶  setInput2: (newvalue, ignored, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @input2connectionsCalculationToken then return else if !connectionsCalculationToken? then @input2connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @input2connectionsCalculationToken = connectionsCalculationToken⤶    @input2 = Number(newvalue)⤶    @updateTarget @input2connectionsCalculationToken⤶⤶  setInput3: (newvalue, ignored, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @input3connectionsCalculationToken then return else if !connectionsCalculationToken? then @input3connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @input3connectionsCalculationToken = connectionsCalculationToken⤶    @input3 = Number(newvalue)⤶    @updateTarget @input3connectionsCalculationToken⤶⤶  setInput4: (newvalue, ignored, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @input4connectionsCalculationToken then return else if !connectionsCalculationToken? then @input4connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @input4connectionsCalculationToken = connectionsCalculationToken⤶    @input4 = Number(newvalue)⤶    @updateTarget @input4connectionsCalculationToken⤶⤶  # the bang makes the node fire the current output value⤶  bang: (newvalue, ignored, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = world.makeNewConnectionsCalculationToken() else @connectionsCalculationToken = connectionsCalculationToken⤶    @updateTarget @connectionsCalculationToken, true⤶⤶  openTargetPropertySelector: (ignored, ignored2, theTarget) ->⤶    [menuEntriesStrings, functionNamesStrings] = theTarget.numericalSetters()⤶    menu = new MenuMorph @, false, @, true, true, ＂choose target property:＂⤶    for i in [0...menuEntriesStrings.length]⤶      menu.addMenuItem menuEntriesStrings[i], true, @, ＂setTargetAndActionWithOnesPickedFromMenu＂, nil, nil, nil, nil, nil, theTarget, functionNamesStrings[i]⤶    if menuEntriesStrings.length == 0⤶      menu = new MenuMorph @, false, @, true, true, ＂no target properties available＂⤶    menu.popUpAtHand()⤶⤶  updateTarget: (connectionsCalculationToken, fireBecauseBang) ->⤶    if !@setInput1IsConnected and⤶     !@setInput2IsConnected and⤶     !@setInput3IsConnected and⤶     !@setInput4IsConnected⤶      return⤶⤶    allConnectedInputsAreFresh = true⤶    if @setInput1IsConnected⤶      if @input1connectionsCalculationToken != connectionsCalculationToken⤶        allConnectedInputsAreFresh = false⤶    if @setInput2IsConnected⤶      if @input2connectionsCalculationToken != connectionsCalculationToken⤶        allConnectedInputsAreFresh = false⤶    if @setInput3IsConnected⤶      if @input3connectionsCalculationToken != connectionsCalculationToken⤶        allConnectedInputsAreFresh = false⤶    if @setInput4IsConnected⤶      if @input4connectionsCalculationToken != connectionsCalculationToken⤶        allConnectedInputsAreFresh = false⤶⤶    # if we are firing via bang then we use⤶    # the existing output value, we don't⤶    # recalculate a new one⤶    if allConnectedInputsAreFresh and !fireBecauseBang⤶      # note that we calculate an output value⤶      # even if this node has no target. This⤶      # is because the node might be visualising the⤶      # output in some other way.⤶      @recalculateOutput()⤶⤶    # if all the connected inputs are fresh OR we⤶    # are firing via bang, then at this point we⤶    # are going to update the target with the output⤶    # value.⤶    if allConnectedInputsAreFresh or fireBecauseBang⤶      @fireOutputToTarget connectionsCalculationToken⤶⤶    return⤶⤶  fireOutputToTarget: (calculationToken) ->⤶    # mark this node as fired.⤶    # if the update DOES come from the ＂bang!＂, then⤶    # @connectionsCalculationToken has already been updated⤶    # but we keep it simple and re-assign it here, not⤶    # worth complicating things with an additional check⤶    @connectionsCalculationToken = calculationToken⤶⤶    if @action and @action != ＂＂⤶      @target[@action].call @target, @output, nil, @connectionsCalculationToken⤶⤶  reactToTargetConnection: ->⤶    # we generate a new calculation token, that's OK because⤶    # we are definitely not in the middle of the calculation here⤶    # but we might be starting a new chain of calculations⤶    @fireOutputToTarget world.makeNewConnectionsCalculationToken()⤶⤶  recalculateOutput: ->⤶    if @textMorph.text != ＂＂⤶      @evaluateString ＂@functionFromCompiledCode = ＂ + @textMorph.text⤶      # now we have the user-defined function in @functionFromCompiledCode⤶      @output = @functionFromCompiledCode?.call world, @input1, @input2, @input3, @input4⤶      @outputTextAreaText.setText @output + ＂＂⤶⤶⤶  stringSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂bang!＂, ＂in1＂, ＂in2＂, ＂in3＂, ＂in4＂⤶    functionNamesStrings.push ＂bang＂, ＂setInput1＂, ＂setInput2＂, ＂setInput3＂, ＂setInput4＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂bang!＂, ＂in1＂, ＂in2＂, ＂in3＂, ＂in4＂⤶    functionNamesStrings.push ＂bang＂, ＂setInput1＂, ＂setInput2＂, ＂setInput3＂, ＂setInput4＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    menu.addLine()⤶    if world.isIndexPage⤶      menu.addMenuItem ＂connect to ➜＂, true, @, ＂openTargetSelector＂, ＂connect to⧹nanother widget＂⤶    else⤶      menu.addMenuItem ＂set target＂, true, @, ＂openTargetSelector＂, ＂choose another morph⧹nwhose numerical property⧹n will be＂ + ＂ controlled by this one＂⤶⤶⤶  buildAndConnectChildren: ->⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @tempPromptEntryField = new SimplePlainTextScrollPanelWdgt @defaultFormulaBoxContents, false, 5⤶    @tempPromptEntryField.disableDrops()⤶    @tempPromptEntryField.contents.disableDrops()⤶    @tempPromptEntryField.color = Color.WHITE⤶    @textMorph = @tempPromptEntryField.textWdgt⤶    @textMorph.backgroundColor = Color.TRANSPARENT⤶    @textMorph.setFontName nil, nil, @textMorph.monoFontStack⤶    @textMorph.isEditable = true⤶    @textMorph.enableSelecting()⤶    @add @tempPromptEntryField⤶⤶    @outputTextArea = new SimplePlainTextScrollPanelWdgt ＂＂, false, 5⤶    @outputTextArea.disableDrops()⤶    @outputTextArea.contents.disableDrops()⤶    @outputTextArea.color = Color.WHITE⤶    @outputTextAreaText = @outputTextArea.textWdgt⤶    @outputTextAreaText.backgroundColor = Color.TRANSPARENT⤶    @outputTextAreaText.setFontName nil, nil, @outputTextAreaText.monoFontStack⤶    @outputTextAreaText.isEditable = false⤶    @add @outputTextArea⤶⤶⤶    @formulaTextBoxLabel = new StringMorph2 ＂Formula＂, WorldMorph.preferencesAndSettings.textInButtonsFontSize⤶    @formulaTextBoxLabel.toggleHeaderLine()⤶    #@formulaTextBoxLabel.alignCenter()⤶    @add @formulaTextBoxLabel⤶⤶    @outputTextBoxLabel = new StringMorph2 ＂Output＂, WorldMorph.preferencesAndSettings.textInButtonsFontSize⤶    @outputTextBoxLabel.toggleHeaderLine()⤶    #@outputTextBoxLabel.alignCenter()⤶    @add @outputTextBoxLabel⤶⤶⤶    @invalidateLayout()⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts then debugger⤶⤶    if @_handleCollapsedStateShouldWeReturn() then return⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    world.disableTrackChanges()⤶⤶    availableHeight = @height() - 2 * @externalPadding - 3 * @internalPadding - 2 * 15⤶    text1Height = Math.round(availableHeight * 2/3)⤶    text2Height = Math.round(availableHeight * 1/3)⤶⤶    textBottom = @top() + @externalPadding + 15 + @internalPadding + text1Height⤶⤶    if @formulaTextBoxLabel.parent == @⤶      @formulaTextBoxLabel.fullRawMoveTo new Point @left() + @externalPadding, @top() + @externalPadding⤶      @formulaTextBoxLabel.rawSetExtent new Point @width() - 2 * @externalPadding, 15⤶⤶    if @tempPromptEntryField.parent == @⤶      @tempPromptEntryField.fullRawMoveTo new Point @left() + @externalPadding, @top() + @externalPadding + 15 + @internalPadding⤶      @tempPromptEntryField.rawSetExtent new Point @width() - 2 * @externalPadding, text1Height⤶⤶    if @outputTextBoxLabel.parent == @⤶      @outputTextBoxLabel.fullRawMoveTo new Point @left() + @externalPadding, @tempPromptEntryField.bottom() + @internalPadding⤶      @outputTextBoxLabel.rawSetExtent new Point @width() - 2 * @externalPadding, 15⤶⤶    if @outputTextArea.parent == @⤶      @outputTextArea.fullRawMoveTo new Point @left() + @externalPadding, textBottom + @internalPadding + 15 + @internalPadding⤶      @outputTextArea.rawSetExtent new Point @width() - 2 * @externalPadding, text2Height⤶⤶⤶    world.maybeEnableTrackChanges()⤶    @fullChanged()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    super⤶    @markLayoutAsFixed()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");