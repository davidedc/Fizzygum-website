// Generated by CoffeeScript 1.12.7
window.AnalogClockWdgt_coffeSource = '# this comment below is needed to figure out dependencies between classes\n# REQUIRES Widget\n\nclass AnalogClockWdgt extends Widget\n\n  hoursHandAngle: 0\n  minutesHandAngle: 0\n  secondsHandAngle: 0\n  strokeSizeToClockDimensionRatio: 1/250\n  dateLastTicked: nil\n\n  constructor: ->\n\n    @fps = 1\n    @synchronisedStepping = true\n    @dateLastTicked = WorldMorph.currentDate\n    world.addSteppingMorph @\n\n    super()\n    @setColor new Color 255, 125, 125\n    @rawSetExtent new Point 200, 200\n    return\n\n  colloquialName: ->\n    "analog clock"\n\n  widthWithoutSpacing: ->\n    Math.min @width(), @height()\n\n  rawResizeToWithoutSpacing: ->\n    @rawSetExtent new Point @widthWithoutSpacing(), @widthWithoutSpacing()\n\n  initialiseDefaultWindowContentLayoutSpec: ->\n    super\n    @layoutSpecDetails.canSetHeightFreely = false\n\n  rawSetWidthSizeHeightAccordingly: (newWidth) ->\n    @rawSetExtent new Point newWidth, newWidth\n\n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->\n\n    if @preliminaryCheckNothingToDraw clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return nil\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @backgroundTransparency\n\n      # paintRectangle here is made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, this is why\n      # it\'s called before the scaling.\n      @paintRectangle aContext, al, at, w, h, @backgroundColor\n      aContext.scale pixelRatio, pixelRatio\n\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n\n      @renderingHelper aContext, new Color(255, 255, 255), appliedShadow\n\n      aContext.restore()\n\n      # paintHighlight here is made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, this is why\n      # it\'s called outside the effect of the scaling\n      # (after the restore).\n      @paintHighlight aContext, al, at, w, h\n\n  step: ->\n    @dateLastTicked = WorldMorph.currentDate\n    @changed()\n\n  calculateHandsAngles: ->\n\n    if AutomatorRecorderAndPlayer? and\n     AutomatorRecorderAndPlayer.animationsPacingControl and\n     AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      @dateLastTicked = new Date 2011,10,30\n\n    #sec = @dateLastTicked.getSeconds()\n    sec = @dateLastTicked.getSeconds() + @dateLastTicked.getMilliseconds()/1000\n    min = @dateLastTicked.getMinutes()\n    hr = @dateLastTicked.getHours()\n    hr = if hr >= 12 then hr - 12 else hr\n    @hoursHandAngle = hr * Math.PI / 6 + Math.PI / 360 * min + Math.PI / 21600 * sec\n    @minutesHandAngle = Math.PI / 30 * min + Math.PI / 1800 * sec\n    @secondsHandAngle = sec * Math.PI / 30\n\n  renderingHelper: (context, color, appliedShadow) ->\n    height = @height()\n    width = @width()\n\n    context.lineWidth = 1 * Math.min(width,height) * @strokeSizeToClockDimensionRatio\n    context.lineCap = "round"\n\n    context.save()\n    context.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @alpha\n\n    squareDim = Math.min width/2, height/2\n\n    context.translate width/2, height/2\n    context.scale 0.9, 0.9\n\n    context.rotate -Math.PI / 2\n    context.strokeStyle = \'black\'\n    context.fillStyle = \'white\'\n    context.lineWidth = 6 * Math.min(width,height) * @strokeSizeToClockDimensionRatio\n    context.lineCap = \'round\'\n\n    # hour face ticks\n    context.save()\n    i = 0\n    while i < 12\n      context.beginPath()\n      context.rotate Math.PI / 6\n      context.moveTo squareDim*2.4/3, 0\n      context.lineTo squareDim, 0\n      context.stroke()\n      i++\n    context.restore()\n\n    # minute face ticks\n    context.save()\n    context.lineWidth = 5 * Math.min(width,height) * @strokeSizeToClockDimensionRatio\n    i = 0\n    while i < 60\n      if i % 5 != 0\n        context.beginPath()\n        context.moveTo squareDim*2.7/3, 0\n        context.lineTo squareDim, 0\n        context.stroke()\n      context.rotate Math.PI / 30\n      i++\n    context.restore()\n\n    context.fillStyle = \'black\'\n\n    @calculateHandsAngles()\n\n    @drawHoursHand context, squareDim\n    @drawMinutesHand context, squareDim\n    @drawSecondsHand context, squareDim\n    @drawDotInMiddleOfFace context, squareDim\n\n    context.beginPath()\n    context.lineWidth = 10 * Math.min(width,height) * @strokeSizeToClockDimensionRatio\n    context.strokeStyle = \'#325FA2\'\n    context.arc 0, 0, squareDim, 0, Math.PI * 2\n    context.stroke()\n\n\n    context.restore()\n\n    context.strokeStyle = color.toString()\n\n\n  drawHoursHand: (context, squareDim) ->\n    height = @height()\n    width = @width()\n    context.save()\n    context.rotate @hoursHandAngle\n    context.lineWidth = 8 * Math.min(width,height) * @strokeSizeToClockDimensionRatio\n    context.beginPath()\n    context.moveTo -squareDim/7, 0\n    context.lineTo squareDim/2, 0\n    context.stroke()\n    context.restore()\n\n\n  drawMinutesHand: (context, squareDim) ->\n    height = @height()\n    width = @width()\n    context.save()\n    context.rotate @minutesHandAngle\n    context.lineWidth = 5 * Math.min(width,height) * @strokeSizeToClockDimensionRatio\n    context.beginPath()\n    context.moveTo -squareDim/5, 0\n    context.lineTo squareDim/1.3, 0\n    context.stroke()\n    context.restore()\n\n  drawSecondsHand: (context, squareDim) ->\n    height = @height()\n    width = @width()\n    context.save()\n    context.rotate @secondsHandAngle\n    context.strokeStyle = \'#D40000\'\n    context.fillStyle = \'#D40000\'\n    context.lineWidth = 6 * Math.min(width,height) * @strokeSizeToClockDimensionRatio\n    context.beginPath()\n    context.moveTo -squareDim/5, 0\n    context.lineTo squareDim/1.3, 0\n    context.stroke()\n    context.restore()\n\n  drawDotInMiddleOfFace: (context, squareDim) ->\n    height = @height()\n    width = @width()\n    context.save()\n    context.fillStyle = \'#D40000\'\n    context.lineWidth = 6 * Math.min(width,height) * @strokeSizeToClockDimensionRatio\n    context.beginPath()\n    context.arc 0, 0, Math.min(width,height)/30, 0, Math.PI * 2\n    context.fill()\n    context.restore()\n\n';
