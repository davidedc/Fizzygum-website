// Generated by CoffeeScript 1.12.7
window.ColorPaletteMorph_coffeSource = '# REQUIRES ControllerMixin\n# REQUIRES BackBufferMixin\n\nclass ColorPaletteMorph extends Widget\n\n  @augmentWith ControllerMixin\n  @augmentWith BackBufferMixin\n\n  target: nil\n  action: nil\n  argumentToAction: nil\n  choice: nil\n\n  constructor: (@target = nil, sizePoint) ->\n    super()\n    @silentRawSetExtent sizePoint or new Point 80, 50\n\n  colloquialName: ->\n    "color palette"\n\n  initialiseDefaultWindowContentLayoutSpec: ->\n    @layoutSpecDetails = new WindowContentLayoutSpec PreferredSize.DONT_MIND , PreferredSize.DONT_MIND, 1\n  \n  detachesWhenDragged: ->\n    false\n\n  # no changes of position or extent should be\n  # performed in here\n  createRefreshOrGetBackBuffer: ->\n    cacheKey =\n      @constructor.name + "-" + @extent().toString()\n\n    cacheHit = world.cacheForImmutableBackBuffers.get cacheKey\n    if cacheHit? then return cacheHit\n\n    extent = @extent()\n    backBuffer = newCanvas extent.scaleBy pixelRatio\n    backBufferContext = backBuffer.getContext "2d"\n    backBufferContext.scale pixelRatio, pixelRatio\n    @choice = new Color()\n    for x in [0..extent.x]\n      h = 360 * x / extent.x\n      y = 0\n      for y in [0..extent.y]\n        l = 100 - (y / extent.y * 100)\n        # see link below for alternatives on how to set a single\n        # pixel color.\n        # You should really be using putImageData of the whole buffer\n        # here anyways. But this is clearer.\n        # http://stackoverflow.com/questions/4899799/whats-the-best-way-to-set-a-single-pixel-in-an-html5-canvas\n        backBufferContext.fillStyle = "hsl(" + h + ",100%," + l + "%)"\n        backBufferContext.fillRect x, y, 1, 1\n\n    cacheEntry = [backBuffer, backBufferContext]\n    world.cacheForImmutableBackBuffers.set cacheKey, cacheEntry\n    return cacheEntry\n  \n  nonFloatDragging: (nonFloatDragPositionWithinMorphAtStart, pos, deltaDragFromPreviousCall) ->\n    @choice = @getPixelColor pos.add (deltaDragFromPreviousCall or new Point 0, 0)\n    @connectionsCalculationToken = getRandomInt -20000, 20000\n    @updateTarget()\n  \n  mouseDownLeft: (pos) ->\n    @choice = @getPixelColor pos\n    @connectionsCalculationToken = getRandomInt -20000, 20000\n    @updateTarget()\n\n  stringSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "bang!"\n    functionNamesStrings.push "bang"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "bang!"\n    functionNamesStrings.push "bang"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n  colorSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "bang!"\n    functionNamesStrings.push "bang"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n\n  # the bang makes the node fire the current output value\n  bang: (newvalue, ignored, connectionsCalculationToken, superCall) ->\n    if !@choice? then return\n    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken\n    @updateTarget()\n  \n  updateTarget: ->\n    if !@target? then return\n\n    if !@action?\n      @action = "setColor"\n\n    @target[@action].call @target, @choice, nil, @connectionsCalculationToken\n    return  \n\n  reactToTargetConnection: ->\n\n  # ColorPaletteMorph menu:\n  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->\n    super\n    menu.addLine()\n    if world.isIndexPage\n      menu.addMenuItem "connect to âžœ", true, @, "openTargetSelector", "connect to\\nanother widget"\n    else\n      menu.addMenuItem "set target", true, @, "openTargetSelector", "choose another morph\\nwhose color property\\n will be" + " controlled by this one"\n  \n  # openTargetSelector: -> taken form the ControllerMixin\n\n  openTargetPropertySelector: (ignored, ignored2, theTarget) ->\n    [menuEntriesStrings, functionNamesStrings] = theTarget.colorSetters()\n    menu = new MenuMorph @, false, @, true, true, "choose target property:"\n    for i in [0...menuEntriesStrings.length]\n      menu.addMenuItem menuEntriesStrings[i], true, @, "setTargetAndActionWithOnesPickedFromMenu", nil, nil, nil, nil, nil, theTarget, functionNamesStrings[i]\n    if menuEntriesStrings.length == 0\n      menu = new MenuMorph @, false, @, true, true, "no target properties available"\n    menu.popUpAtHand()\n';
