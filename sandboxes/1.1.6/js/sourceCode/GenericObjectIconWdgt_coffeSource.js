// Generated by CoffeeScript 1.12.7
window.GenericObjectIconWdgt_coffeSource = '# REQUIRES ChildrenStainerMixin\n\nclass GenericObjectIconWdgt extends Widget\n\n  @augmentWith ChildrenStainerMixin, @name\n\n  objectIcon: nil\n\n  constructor: (@icon) ->\n    super()\n\n    @objectIcon = new ObjectIconWdgt()\n    @add @objectIcon\n\n\n    if !@icon?\n      @icon = new SimpleDropletWdgt "icon"\n    @rawSetExtent new Point 95, 95\n    @add @icon\n\n    # update layout\n    @invalidateLayout()\n\n  widthWithoutSpacing: ->\n    Math.min @width(), @height()\n\n  rawResizeToWithoutSpacing: ->\n    @rawSetExtent new Point @widthWithoutSpacing(), @widthWithoutSpacing()\n    @invalidateLayout()\n\n  initialiseDefaultWindowContentLayoutSpec: ->\n    super\n    @layoutSpecDetails.canSetHeightFreely = false\n\n  rawSetWidthSizeHeightAccordingly: (newWidth) ->\n    @rawResizeToWithoutSpacing()\n    @rawSetExtent new Point newWidth, newWidth\n    @invalidateLayout()\n\n  doLayout: (newBoundsForThisLayout) ->\n    #if !window.recalculatingLayouts\n    #  debugger\n\n    if !newBoundsForThisLayout?\n      if @desiredExtent?\n        newBoundsForThisLayout = @desiredExtent\n        @desiredExtent = nil\n      else\n        newBoundsForThisLayout = @extent()\n\n      if @desiredPosition?\n        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout\n        @desiredPosition = nil\n      else\n        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout\n\n    if @isCollapsed()\n      @layoutIsValid = true\n      @notifyChildrenThatParentHasReLayouted()\n      return\n\n    @rawSetBounds newBoundsForThisLayout\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Widget. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    trackChanges.push false\n\n    height = @height()\n    width = @width()\n\n    squareDim = Math.min width, height\n\n     # p0 is the origin, the origin being in the bottom-left corner\n    p0 = @topLeft()\n\n    # now the origin is in the middle of the widget\n    centerPoint = p0.add new Point width/2, height/2\n    p0 = centerPoint\n    \n    # now the origin is in the top left corner of the\n    # square centered in the morph\n    p0 = p0.subtract new Point squareDim/2, squareDim/2\n\n    @icon.setExtent (new Point squareDim*50/100, squareDim*50/100).round()\n    @icon.fullRawMoveTo (centerPoint.subtract new Point squareDim*25/100, squareDim*25/100).round()\n\n\n    @objectIcon.setExtent (new Point squareDim, squareDim).round()\n    @objectIcon.fullRawMoveTo p0\n\n\n    trackChanges.pop()\n    @fullChanged()\n\n    @layoutIsValid = true\n    @notifyChildrenThatParentHasReLayouted()\n\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()';
