// Generated by CoffeeScript 1.12.7
window.Point_coffeSource = '# REQUIRES DeepCopierMixin\n\n# See the Rectangle class about the "copy on change" policy\n# of this class.\n\nclass Point\n\n  @augmentWith DeepCopierMixin\n\n  x: nil\n  y: nil\n   \n  constructor: (@x = 0, @y = 0) ->\n\n  onlyContainingIntegers: ->\n    if Math.floor(@x) == @x and\n      Math.floor(@y) == @y\n        return true\n    else\n      return false\n\n  debugIfFloats: ->\n    return\n    #if !@onlyContainingIntegers()\n    #  debugger\n  \n  # Point string representation: e.g. \'12@68\'\n  toString: ->\n    Math.round(@x) + "@" + Math.round(@y)\n\n  prepareBeforeSerialization: ->\n    @className = @constructor.name\n    @classVersion = "0.0.1"\n    @serializerVersion = "0.0.1"\n    for property of @\n      if @[property]?\n        if typeof @[property] == \'object\'\n          if !@[property].className?\n            if @[property].prepareBeforeSerialization?\n              @[property].prepareBeforeSerialization()\n  \n  # Point copying:\n  copy: ->\n    new @constructor @x, @y\n\n  # Point comparison:\n  isZero: (aPoint) ->\n    # ==\n    @x is 0 and @y is 0\n  \n  # Point comparison:\n  eq: (aPoint) ->\n    # ==\n    @x is aPoint.x and @y is aPoint.y\n  \n  lt: (aPoint) ->\n    # <\n    @x < aPoint.x and @y < aPoint.y\n  \n  gt: (aPoint) ->\n    # >\n    @x > aPoint.x and @y > aPoint.y\n  \n  ge: (aPoint) ->\n    # >=\n    @x >= aPoint.x and @y >= aPoint.y\n  \n  le: (aPoint) ->\n    # <=\n    @x <= aPoint.x and @y <= aPoint.y\n  \n  max: (aPoint) ->\n    @debugIfFloats()\n    new @constructor Math.max(@x, aPoint.x), Math.max(@y, aPoint.y)\n  \n  min: (aPoint) ->\n    @debugIfFloats()\n    new @constructor Math.min(@x, aPoint.x), Math.min(@y, aPoint.y)  \n  \n  # Point conversion:\n  round: ->\n    new @constructor Math.round(@x), Math.round(@y)\n  \n  abs: ->\n    @debugIfFloats()\n    new @constructor Math.abs(@x), Math.abs(@y)\n  \n  neg: ->\n    @debugIfFloats()\n    new @constructor -@x, -@y\n  \n  mirror: ->\n    @debugIfFloats()\n    new @constructor @y, @x \n  \n  floor: ->\n    new @constructor Math.max(Math.floor(@x), 0), Math.max(Math.floor(@y), 0)\n  \n  ceil: ->\n    new @constructor Math.ceil(@x), Math.ceil(@y)\n  \n\n  # these two in theory don\'t make sense\n  # for a Point BUT it\'s handy because sometimes\n  # we store dimensions in Points\n  width: ->\n    return @x\n\n  height: ->\n    return @y\n\n  \n  # Point arithmetic:\n  add: (other) ->\n    @debugIfFloats()\n    return new @constructor @x + other.x, @y + other.y  if other instanceof Point\n    new @constructor @x + other, @y + other\n  \n  subtract: (other) ->\n    @debugIfFloats()\n    return new @constructor @x - other.x, @y - other.y  if other instanceof Point\n    new @constructor @x - other, @y - other\n  \n  multiplyBy: (other) ->\n    @debugIfFloats()\n    return new @constructor @x * other.x, @y * other.y  if other instanceof Point\n    new @constructor @x * other, @y * other\n  \n  divideBy: (other) ->\n    @debugIfFloats()\n    return new @constructor @x / other.x, @y / other.y  if other instanceof Point\n    new @constructor @x / other, @y / other\n  \n  floorDivideBy: (other) ->\n    @debugIfFloats()\n    if other instanceof Point\n      return new @constructor Math.floor(@x / other.x), Math.floor(@y / other.y)\n    new @constructor Math.floor(@x / other), Math.floor(@y / other)\n  \n  toLocalCoordinatesOf: (aMorph) ->\n    new @constructor @x - aMorph.left(), @y - aMorph.top()\n  \n  # Point polar coordinates:\n  r: ->\n    t = @multiplyBy @\n    Math.sqrt t.x + t.y\n  \n  degrees: ->\n    #\n    #    answer the angle I make with origin in degrees.\n    #    Right is 0, down is 90\n    #\n    if @x is 0\n      return 90  if @y >= 0\n      return 270\n    tan = @y / @x\n    theta = Math.atan tan\n    if @x >= 0\n      return radiansToDegrees theta  if @y >= 0\n      return 360 + radiansToDegrees theta\n    180 + radiansToDegrees theta\n  \n  theta: ->\n    #\n    #    answer the angle I make with origin in radians.\n    #    Right is 0, down is 90\n    #\n    if @x is 0\n      return degreesToRadians 90  if @y >= 0\n      return degreesToRadians 270\n    tan = @y / @x\n    theta = Math.atan(tan)\n    if @x >= 0\n      return theta  if @y >= 0\n      return degreesToRadians(360) + theta\n    degreesToRadians(180) + theta\n  \n  \n  # Point functions:\n  distanceTo: (aPoint) ->\n    aPoint.subtract(@).r()\n  \n  rotate: (direction, center) ->\n    # direction must be \'right\', \'left\' or \'pi\'\n    offset = @subtract center\n    return new @constructor(-offset.y, offset.y).add(center)  if direction is "right"\n    return new @constructor(offset.y, -offset.y).add(center)  if direction is "left"\n\n    # direction === \'pi\'\n    center.subtract offset\n  \n  flip: (direction, center) ->\n    # direction must be \'vertical\' or \'horizontal\'\n    return new @constructor @x, center.y * 2 - @y  if direction is "vertical"\n\n    # direction === \'horizontal\'\n    new @constructor center.x * 2 - @x, @y\n  \n  distanceAngle: (dist, angle) ->\n    deg = angle\n    if deg > 270\n      deg = deg - 360\n    else deg = deg + 360  if deg < -270\n    if -90 <= deg and deg <= 90\n      x = Math.sin(degreesToRadians(deg)) * dist\n      y = Math.sqrt((dist * dist) - (x * x))\n      return new @constructor x + @x, @y - y\n    x = Math.sin(degreesToRadians(180 - deg)) * dist\n    y = Math.sqrt((dist * dist) - (x * x))\n    new @constructor x + @x, @y + y\n  \n  \n  # Point transforming:\n  scaleBy: (scalePoint) ->\n    @multiplyBy scalePoint\n  \n  translateBy: (deltaPoint) ->\n    @add deltaPoint\n  \n  rotateBy: (\n    angle,\n    center = (new @constructor 0, 0)\n    ) ->\n    p = @subtract center\n    r = p.r()\n    theta = angle - p.theta()\n    new @constructor center.x + (r * Math.cos(theta)), center.y - (r * Math.sin(theta))\n  \n  \n  # Point conversion:\n  asArray: ->\n    [@x, @y]\n  \n  # creating Rectangle instances from Points:\n  corner: (cornerPoint) ->\n    # answer a new Rectangle\n    new Rectangle @x, @y, cornerPoint.x, cornerPoint.y\n  \n  rectangle: (aPoint) ->\n    # answer a new Rectangle\n    org = @min aPoint\n    crn = @max aPoint\n    new Rectangle org.x, org.y, crn.x, crn.y\n  \n  extent: (aPoint) ->\n    #answer a new Rectangle\n    crn = @add aPoint\n    new Rectangle @x, @y, crn.x, crn.y\n';
