// Generated by CoffeeScript 1.12.7
window.ScrollPanelWdgt_coffeSource = '# this comment below is needed to figure out dependencies between classes\n# REQUIRES globalFunctions\n\nclass ScrollPanelWdgt extends PanelWdgt\n\n  autoScrollTrigger: nil\n  hasVelocity: true # dto.\n  padding: 0 # around the scrollable area\n  growth: 0 # pixels or Point to grow right/left when near edge\n  isTextLineWrapping: false\n  isScrollingByfloatDragging: true\n  scrollBarsThickness: nil\n  contents: nil\n  vBar: nil\n  hBar: nil\n  # used to avoid recursively re-entering the\n  # adjustContentsBounds function\n  _adjustingContentsBounds: false\n\n  # there are several ways in which we allow\n  # scrolling when a ScrollPanel is scrollable\n  # (i.e. the scrollbars are showing).\n  # You can choose to scroll it by dragging the\n  # contents or by dragging the background,\n  # independently. Which could be useful for\n  # example when showing a geographic map.\n  canScrollByDraggingBackground: false\n  canScrollByDraggingForeground: false\n\n  constructor: (\n    @contents,\n    @scrollBarsThickness = (WorldMorph.preferencesAndSettings.scrollBarsThickness),\n    @sliderColor\n    ) ->\n    # super() paints the ScrollPanel, which we don\'t want,\n    # so we set 0 opacity here.\n    @alpha = 0\n    super()\n\n    @contents = new PanelWdgt @ unless @contents?\n    @addRaw @contents\n\n    # the ScrollPanel is never going to paint itself,\n    # but its values are going to mimick the values of the\n    # contained Panel\n    @color = @contents.color\n    @alpha = @contents.alpha\n    \n    #@setColor = @contents.setColor\n    #@setAlphaScaled = @contents.setAlphaScaled\n\n    @hBar = new SliderMorph nil, nil, nil, nil, @sliderColor\n    @hBar.rawSetHeight @scrollBarsThickness\n\n    @hBar.target = @\n    @addRaw @hBar\n\n    @vBar = new SliderMorph nil, nil, nil, nil, @sliderColor\n    @vBar.rawSetWidth @scrollBarsThickness\n    @vBar.target = @\n    @addRaw @vBar\n\n    @hBar.target = @\n    @hBar.action = "adjustContentsBasedOnHBar"\n    @vBar.target = @\n    @vBar.action = "adjustContentsBasedOnVBar"\n\n    @adjustScrollBars()\n\n  wantsDropOf: (aMorph) ->\n    if @contents instanceof FolderPanelWdgt\n      return false\n    return @_acceptsDrops\n\n  colloquialName: ->\n    if @contents instanceof FolderPanelWdgt\n      "folder"\n    else if @contents instanceof ToolPanelWdgt\n      "toolbar"\n    else\n      "scrollable panel"\n\n  adjustContentsBasedOnHBar: (num) ->\n    @contents.fullRawMoveTo new Point @left() - num, @contents.position().y\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  adjustContentsBasedOnVBar: (num) ->\n    @contents.fullRawMoveTo new Point @contents.position().x, @top() - num\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  setColor: (aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken, superCall) ->\n    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken\n\n    aColor = super aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken, true\n    # keep in synch the color of the content.\n    # Note that the container ScrollPanel.\n    # is actually not painted.\n    @contents.setColor aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken\n    return aColor\n\n  setAlphaScaled: (alphaOrMorphGivingAlpha, morphGivingAlpha) ->\n    alpha = super\n    # update the alpha of the ScrollPanel - note\n    # that we are never going to paint the ScrollPanel\n    # we are updating the alpha so that its value is the same as the\n    # contained Panel\n    @contents.setAlphaScaled alphaOrMorphGivingAlpha, morphGivingAlpha\n    return alpha\n\n  anyScrollBarShowing: ->\n    if (@hBar.visibleBasedOnIsVisibleProperty() and !@hBar.isCollapsed()) or\n    (@vBar.visibleBasedOnIsVisibleProperty() and !@vBar.isCollapsed())\n      return true\n    return false\n\n  adjustScrollBars: ->\n    # one typically has both scrollbars in view, plus a resizer\n    # in buttom right corner, so adjust the width/height of the\n    # scrollbars so that there is no overlap between the three things\n    spaceToLeaveOnOneSide = Math.max(@scrollBarsThickness, WorldMorph.preferencesAndSettings.handleSize) + 2 * @padding\n    hWidth = @width() - spaceToLeaveOnOneSide\n    vHeight = @height() - spaceToLeaveOnOneSide\n\n    unless @parent instanceof ListMorph\n      @changed()\n\n    # this check is to see whether the bar actually belongs to this\n    # ScrollPanel. The reason why the bar could belong to another\n    # ScrollPanel is the following: the bar could have been detached\n    # from a ScrollPanel A. The ScrollPanel A (which is still fully\n    # working albeit detached) is then duplicated into\n    # a ScrollPanel B. What happens is that because the bar is not\n    # a child of A (rather, it\'s only referenced as a property),\n    # the duplication mechanism does not duplicate the bar and it does\n    # not update the reference to it. This is correct because one cannot\n    # just change all the references to other objects that are not children\n    # , a good example being the targets, i.e. if you duplicate a colorPicker\n    # which targets a Widget you want the duplication of the colorPicker to\n    # still change color of that same Widget.\n    # So: the ScrollPanel B could still reference the scrollbar\n    # detached from A and that causes a problem because changes to B would\n    # change the dimensions and hiding/unhiding of the scrollbar.\n    # So here we avoid that by actually checking what the scrollbar is\n    # attached to.\n    if @hBar.target == @ \n      if @contents.width() >= @width() + 1\n        @hBar.show()\n        @hBar.rawSetWidth hWidth  if @hBar.width() isnt hWidth\n        # we check whether the bar has been detached. If it\'s still\n        # attached then we possibly move it, together with the\n        # ScrollPanel, otherwise we don\'t move it.\n        if @hBar.parent == @\n          @hBar.fullRawMoveTo new Point @left(), @bottom() - @hBar.height()\n        stopValue = @contents.width() - @width()\n        @hBar.updateSpecs(\n          0, # start\n          stopValue, # stop\n          @left() - @contents.left(), # value\n          @width() / @contents.width() * stopValue # size\n        )\n      else\n        @hBar.hide()\n\n    # see comment on equivalent if line above.\n    if @vBar.target == @\n      if @contents.height() >= @height() + 1\n        @vBar.show()\n        @vBar.rawSetHeight vHeight  if @vBar.height() isnt vHeight\n        # we check whether the bar has been detached. If it\'s still\n        # attached then we possibly move it, together with the\n        # ScrollPanel, otherwise we don\'t move it.\n        if @vBar.parent == @\n          @vBar.fullRawMoveTo new Point @right() - @vBar.width(), @top()\n        stopValue = @contents.height() - @height()\n        @vBar.updateSpecs(\n          0, # start\n          stopValue, # stop\n          @top() - @contents.top(), # value\n          @height() / @contents.height() * stopValue # size\n        )\n      else\n        @vBar.hide()\n  \n  # when you add things to the ScrollPanelWdgt they actually\n  # end up in the Panel inside it. This also applies to\n  # resizing handles!\n  add: (aMorph, position = nil, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING, beingDropped, unused, positionOnScreen) ->\n    if aMorph instanceof ModifiedTextTriangleAnnotationWdgt\n      super\n    else\n      @contents.add aMorph, position, layoutSpec, beingDropped, nil, positionOnScreen\n      @adjustContentsBounds()\n      @adjustScrollBars()\n\n  # see SimpleSlideWdgt for performance improvements\n  # of this over the non-\n  addMany: (widgetsToBeAdded) ->\n    @contents.addMany widgetsToBeAdded\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n\n  showResizeAndMoveHandlesAndLayoutAdjusters: ->\n    super\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  \n  setContents: (aMorph, extraPadding) ->\n    @extraPadding = extraPadding\n    # there should never be a shadow but one never knows...\n    @contents.closeChildren()\n    @contents.fullRawMoveTo @position()\n\n    aMorph.fullRawMoveTo @position().add @padding + @extraPadding\n\n    @add aMorph\n\n\n  rawSetExtent: (aPoint) ->\n    unless aPoint.eq @extent()\n      #console.log "move 15"\n      @breakNumberOfRawMovesAndResizesCaches()\n      if @isTextLineWrapping and !(@contents instanceof SimpleVerticalStackPanelWdgt)\n        @contents.fullRawMoveTo @position()\n      super aPoint\n      @contents.rawSetExtent aPoint\n      @adjustContentsBounds()\n      @adjustScrollBars()\n\n\n  reactToDropOf: ->\n    @adjustContentsBounds()\n    @adjustScrollBars()\n  \n  reactToGrabOf: ->\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  adjustContentsBounds: ->\n    # avoid recursively re-entering this function\n    if @_adjustingContentsBounds then return else @_adjustingContentsBounds = true\n\n    # if PanelWdgt is of type isTextLineWrapping\n    # it means that you don\'t want the TextMorph to\n    # extend indefinitely as you are typing. Rather,\n    # the width will be constrained and the text will\n    # wrap.\n    padding = Math.floor @extraPadding + @padding\n    totalPadding = 2*padding\n\n    if @contents instanceof SimpleVerticalStackPanelWdgt\n      @contents.adjustContentsBounds()\n    else if @isTextLineWrapping and @contents instanceof PanelWdgt\n      @contents.children.forEach (morph) =>\n        if (morph instanceof TextMorph) or (morph instanceof SimplePlainTextWdgt)\n          # this re-layouts the text to fit the width.\n          # The new height of the TextMorph will then be used\n          # to redraw the vertical slider.\n          morph.rawSetWidth @contents.width() - totalPadding\n          # the SimplePlainTextWdgt just needs this to be different from null\n          # while the TextMorph actually uses this number\n          morph.maxTextWidth = @contents.width() - totalPadding\n          @contents.rawSetHeight (Math.max morph.height(), @height()) - totalPadding\n\n    subBounds = @contents.subMorphsMergedFullBounds()?.ceil()\n    if subBounds\n\n      # add-in the content\'s own external padding\n      if @contents.externalPadding?\n        subBounds = subBounds.expandBy @contents.externalPadding\n\n      # in case of a SimpleVerticalStackScrollPanelWdgt then we really\n      # want to make sure that we don\'t stretch the view and the stack\n      # after the end of the contents (this can happen for example\n      # when you are completely scrolled to the bottom and remove a long\n      # chunk of text at the bottom: you don\'t want the extra vacant space\n      # to be in view, you want to shrink all that part up and reposition the\n      # stack so you actually see a bottom that has something in it)\n      # So we first size the stack according to the minimum area of the\n      # components in it, then we add the minimum space needed to fill\n      # the viewport, so we never end up with empty space filling the stack\n      # beyond the height of the viewport.\n      if @isTextLineWrapping or\n       (@ instanceof SimplePlainTextScrollPanelWdgt) or\n       (@ instanceof SimpleVerticalStackScrollPanelWdgt)\n        newBounds = subBounds.expandBy(padding)?.ceil()\n\n        # ok so this is tricky: say that you have a document with\n        # ONLY a centered icon in it.\n        # If you don\'t add this line, the subBounds will start at the\n        # origin of the icon, which is NOT aligned to the left of the\n        # viewport. So what will happen is that the panel will be moved\n        # so its left will coincide with the left of the viewport.\n        # So the icon will appear non-centered.\n        newBounds = newBounds.merge new Rectangle @contents.left(), @contents.top(), @contents.left() + @width(), @contents.top() + 1\n\n        if newBounds.height() < @height()\n          newBounds = newBounds.growBy new Point 0, @height() - newBounds.height()\n        # I don\'t think this check below is needed anymore,\n        # TODO verify when there are a healthy number of tests around\n        # vertical stack and text scroll panels\n        if newBounds.width() < @width()\n          newBounds = newBounds.growBy new Point @width() - newBounds.width(), 0\n      else\n        newBounds = subBounds.expandBy(padding).merge @boundingBox()?.ceil()\n    else\n      newBounds = @boundingBox()?.ceil()\n\n    unless @contents.boundingBox().eq newBounds\n      @contents.silentRawSetBounds newBounds\n      @contents.reLayout()\n    \n    # you\'d think that if @contents.boundingBox().eq newBounds\n    # then we don\'t need to check if the contents are "in good view"\n    # but actually for example a stack resizes itself automatically when the\n    # elements are resized (in the foreach loop above),\n    # so we need anyways to do this check and fix the view if the\n    # case. The good news is that it\'s a cheap check to do in case\n    # there is nothing to do.\n    @keepContentsInScrollPanelWdgt()\n    @_adjustingContentsBounds = false\n\n  keepContentsInScrollPanelWdgt: ->\n    if @contents.left() > @left()\n      @contents.fullRawMoveBy new Point @left() - @contents.left(), 0\n    if @contents.right() < @right()\n      @contents.fullRawMoveBy new Point @right() - @contents.right(), 0\n    if @contents.top() > @top()\n      @contents.fullRawMoveBy new Point 0, @top() - @contents.top()\n    if @contents.bottom() < @bottom()\n      @contents.fullRawMoveBy new Point 0, @bottom() - @contents.bottom()\n  \n  # ScrollPanelWdgt scrolling by floatDragging:\n  scrollX: (steps) ->\n    cl = @contents.left()\n    l = @left()\n    cw = @contents.width()\n    r = @right()\n    newX = cl + steps\n    newX = r - cw  if newX + cw < r\n    newX = l  if newX > l\n    # return true if any movement of\n    # the scrollbar button is\n    # actually happening, otherwise\n    # false. We use this to figure\n    # out in some places whether\n    # we need to trigger a bunch of\n    # updates of the content and scrollbars\n    # or not.\n    if newX isnt cl\n      @contents.fullRawMoveLeftSideTo newX\n      return true\n    else\n      return false\n\n  scrollTo: (whereTo) ->\n    @contents.fullRawMoveLeftSideTo -whereTo.x\n    @contents.fullRawMoveTopSideTo -whereTo.y\n    @adjustScrollBars()    \n\n\n  scrollToBottom: ->\n    @scrollY -100000\n    @adjustScrollBars()    \n  \n  scrollY: (steps) ->\n    ct = @contents.top()\n    t = @top()\n    ch = @contents.height()\n    b = @bottom()\n    newY = ct + steps\n    if newY + ch < b\n      newY = b - ch\n    # prevents content to be scrolled to the Panel\'s\n    # bottom if the content is otherwise empty\n    newY = t  if newY > t\n    # return true if any movement of\n    # the scrollbar button is\n    # actually happening, otherwise\n    # false. We use this to figure\n    # out in some places whether\n    # we need to trigger a bunch of\n    # updates of the content and scrollbars\n    # or not.\n    if newY isnt ct\n      @contents.fullRawMoveTopSideTo newY\n      return true\n    else\n      return false\n  \n  # sometimes you can scroll the contents of a ScrollPanel\n  # by floatDragging its contents. This is particularly\n  # useful in touch devices.\n  # You can test this also in non-touch mode\n  # by anchoring a ScrollPanel to something\n  # non-draggable such as a color palette (can\'t drag it\n  # because user can drag on it to pick a color)\n  # Ten you chuck a long text into the ScrollPanel and\n  # drag the Panel (on the side of the text, where there is no\n  # text) and you should see the ScrollPanel scrolling.\n  mouseDownLeft: (pos) ->\n\n    return nil  unless @isScrollingByfloatDragging\n\n    oldPos = pos\n    deltaX = 0\n    deltaY = 0\n    friction = 0.8\n    world.addSteppingMorph @\n    @step = =>\n      scrollbarJustChanged = false\n      if world.hand.mouseButton and\n        !world.hand.floatDraggingSomething() and\n        # if the Widget at hand is float draggable then\n        # we are probably about to detach it, so\n        # we shouldn\'t move anything, because user might\n        # just float-drag the morph as soon as the threshold is\n        # reached, and we don\'t want to scroll until that happens\n        # that would be strange because it would be giving the\n        # wrong cue to the user, we just want to hold steady\n        !world.hand.morphToGrab?.detachesWhenDragged() and\n        @boundsContainPoint(world.hand.position())\n          newPos = world.hand.position()\n          if @hBar.visibleBasedOnIsVisibleProperty() and\n          !@hBar.isCollapsed()\n            deltaX = newPos.x - oldPos.x\n            if deltaX isnt 0\n              scrollbarJustChanged ||= @scrollX deltaX\n          if @vBar.visibleBasedOnIsVisibleProperty() and\n          !@vBar.isCollapsed()\n            deltaY = newPos.y - oldPos.y\n            if deltaY isnt 0\n              scrollbarJustChanged ||= @scrollY deltaY\n          oldPos = newPos\n      else\n        unless @hasVelocity\n          @step = noOperation\n          world.removeSteppingMorph @\n        else\n          if (Math.abs(deltaX) < 0.5) and (Math.abs(deltaY) < 0.5)\n            @step = noOperation\n            world.removeSteppingMorph @\n          else\n            if @hBar.visibleBasedOnIsVisibleProperty() and\n            !@hBar.isCollapsed()\n              deltaX = deltaX * friction\n              if deltaX isnt 0\n                scrollbarJustChanged ||= @scrollX Math.round deltaX\n            if @vBar.visibleBasedOnIsVisibleProperty() and\n            !@vBar.isCollapsed()\n              deltaY = deltaY * friction\n              if deltaY isnt 0\n                scrollbarJustChanged ||= @scrollY Math.round deltaY\n      if scrollbarJustChanged\n        @adjustContentsBounds()\n        @adjustScrollBars()\n    super\n  \n  startAutoScrolling: ->\n    inset = WorldMorph.preferencesAndSettings.scrollBarsThickness * 3\n    if @isOrphan() then return nil\n    hand = world.hand\n    @autoScrollTrigger = Date.now()  unless @autoScrollTrigger\n    world.addSteppingMorph @\n    @step = =>\n      pos = hand.position()\n      inner = @boundingBox().insetBy inset\n      if @boundsContainPoint(pos) and\n        !inner.containsPoint(pos) and\n        hand.floatDraggingSomething()\n          @autoScroll pos\n      else\n        @step = noOperation\n        world.removeSteppingMorph @\n        @autoScrollTrigger = nil\n  \n  autoScroll: (pos) ->\n    return nil  if Date.now() - @autoScrollTrigger < 500\n    inset = WorldMorph.preferencesAndSettings.scrollBarsThickness * 3\n    area = @topLeft().extent new Point @width(), inset\n    scrollbarJustChanged = false\n    if area.containsPoint(pos)\n      scrollbarJustChanged ||= @scrollY inset - (pos.y - @top())\n    area = @topLeft().extent new Point inset, @height()\n    if area.containsPoint(pos)\n      scrollbarJustChanged ||= @scrollX inset - (pos.x - @left())\n    area = (new Point(@right() - inset, @top())).extent new Point inset, @height()\n    if area.containsPoint(pos)\n      scrollbarJustChanged ||= @scrollX -(inset - (@right() - pos.x))\n    area = (new Point(@left(), @bottom() - inset)).extent new Point @width(), inset\n    if area.containsPoint(pos)\n      scrollbarJustChanged ||= @scrollY -(inset - (@bottom() - pos.y))\n    if scrollbarJustChanged\n      @adjustContentsBounds()\n      @adjustScrollBars()  \n  \n  # ScrollPanelWdgt scrolling when editing text\n  # so to bring the caret fully into view.\n  scrollCaretIntoView: (caretMorph) ->\n    txt = caretMorph.target\n    offset = txt.position().subtract @contents.position()\n    ft = @top() + @padding\n    fb = @bottom() - @padding\n    fl = @left() + @padding\n    fr = @right() - @padding\n    @adjustContentsBounds()\n    marginAroundCaret = @padding\n    if @extraPadding?\n      marginAroundCaret += @extraPadding\n    if caretMorph.top() < ft\n      newT = @contents.top() + ft - caretMorph.top()\n      @contents.fullRawMoveTopSideTo newT + marginAroundCaret\n      caretMorph.fullRawMoveTopSideTo ft\n    else if caretMorph.bottom() > fb\n      newB = @contents.bottom() + fb - caretMorph.bottom()\n      @contents.fullRawMoveBottomSideTo newB - marginAroundCaret\n      caretMorph.fullRawMoveBottomSideTo fb\n    if caretMorph.left() < fl\n      newL = @contents.left() + fl - caretMorph.left()\n      @contents.fullRawMoveLeftSideTo newL + marginAroundCaret\n      caretMorph.fullRawMoveLeftSideTo fl\n    else if caretMorph.right() > fr\n      newR = @contents.right() + fr - caretMorph.right()\n      @contents.fullRawMoveRightSideTo newR - marginAroundCaret\n      caretMorph.fullRawMoveRightSideTo fr\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  # ScrollPanelWdgt events:\n  wheel: (xArg, yArg, zArg, altKeyArg, buttonArg, buttonsArg) ->\n\n    x = xArg\n    y = yArg\n    z = zArg\n    altKey = altKeyArg\n    button = buttonArg\n    buttons = buttonsArg\n\n    # if we don\'t destroy the resizing handles,\n    # they\'ll follow the contents being moved!\n    world.hand.destroyTemporaryHandlesAndLayoutAdjustersIfHandHasNotActionedThem @\n\n    scrollbarJustChanged = false\n\n    # this paragraph prevents too much\n    # diagonal movement when the intention\n    # is clearly to just move vertically or\n    # horizontally. Doesn\'t need to be always\n    # the case though.\n    if Math.abs(y) < Math.abs(x)\n      y = 0\n    if Math.abs(x) < Math.abs(y)\n      x = 0\n\n    if WorldMorph.preferencesAndSettings.invertWheelX\n      x *= -1\n    if WorldMorph.preferencesAndSettings.invertWheelY\n      y *= -1\n    if WorldMorph.preferencesAndSettings.invertWheelZ\n      z *= -1\n\n    if y != 0\n      # TODO this escalation should also\n      # be implemented in the touch case... user could scroll\n      # WITHOUT wheel, by just touch-dragging the contents...\n      #\n      # Escalate the scroll in case we are in a nested\n      # ScrollPanel situation and we already\n      # scrolled this inner one "up/down to the end".\n      # In such case, the outer one has to scroll...\n      #\n      # if scrolling up and the content top is already below the top (or just a little above the top)\n      #  OR\n      # if scrolling down and the content bottom is already above the bottom (or just a little below the bottom)\n      #  THEN\n      # escalate the method up, since there might be another scrollbar catching it\n      #\n      # The "just a little" caveats are because sometimes dimensions are non-integer\n      # (TODO ...which shouldn\'t really happen)\n      #\n      if (y > 0 and @contents.top() >= (@top() - 1)) or\n       (y < 0 and @contents.bottom() <= (@bottom() + 1))\n        @escalateEvent \'wheel\', xArg, yArg, zArg, altKeyArg, buttonArg, buttonsArg\n      else\n        scrollbarJustChanged = true\n        @scrollY y * WorldMorph.preferencesAndSettings.wheelScaleY\n    if x != 0\n      # similar to the vertical case, escalate the scroll in case\n      # we are in a nested ScrollPanel situation\n      if (x > 0 and @contents.left() >= (@left()-1)) or\n       (x < 0 and @contents.right() <= (@right()+1) )\n        @escalateEvent \'wheel\', xArg, yArg, zArg, altKeyArg, buttonArg, buttonsArg\n      else\n        scrollbarJustChanged = true\n        @scrollX x * WorldMorph.preferencesAndSettings.wheelScaleX\n\n    if scrollbarJustChanged\n      @adjustContentsBounds()\n      @adjustScrollBars()\n  \n\n  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->\n    if @takesOverAndCoalescesChildrensMenus\n      childrenNotHandlesNorCarets = @contents?.children.filter (m) ->\n        !((m instanceof HandleMorph) or (m instanceof CaretMorph))\n      if childrenNotHandlesNorCarets? and childrenNotHandlesNorCarets.length == 1\n        childrenNotHandlesNorCarets[0].addMorphSpecificMenuEntries morphOpeningThePopUp, menu\n    else\n      super\n  \n  toggleTextLineWrapping: ->\n    @isTextLineWrapping = not @isTextLineWrapping\n\n  enableDragsDropsAndEditing: (triggeringWidget) ->\n    if !triggeringWidget? then triggeringWidget = @\n    if @dragsDropsAndEditingEnabled\n      return\n    @parent?.makePencilYellow?()\n\n    @enableDrops()\n    @dragsDropsAndEditingEnabled = true\n\n    @contents.enableDragsDropsAndEditing @\n\n  disableDragsDropsAndEditing: (triggeringWidget) ->\n    if !triggeringWidget? then triggeringWidget = @\n    if !@dragsDropsAndEditingEnabled\n      return\n    @parent?.makePencilClear?()\n\n    @disableDrops()\n    @dragsDropsAndEditingEnabled = false\n\n    @contents.disableDragsDropsAndEditing @\n    @invalidateLayout()\n\n';
