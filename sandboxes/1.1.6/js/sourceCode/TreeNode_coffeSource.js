// Generated by CoffeeScript 1.12.7
window.TreeNode_coffeSource = '# Widgetic node class only cares about the\n# parent/child connection between\n# morphs. It\'s good to connect/disconnect\n# morphs and to find parents or children\n# who satisfy particular properties.\n# OUT OF SCOPE:\n# It\'s important to note that this layer\n# knows nothing about visibility, targets,\n# image buffers, dirty rectangles, events,\n# position and extent (and hence bounds).\n# Please no invocations to changed or fullChanged\n# or updateBackBuffer in here, and no\n# touching of any of the out-of-scope properties\n# mentioned.\n\nclass TreeNode\n\n  parent: nil\n  # "children" is an ordered list of the immediate\n  # children of this node. First child is at the\n  # back relative to other children, last child is at the\n  # top.\n  #\n  # The repaint mechanism in Fizzygum is back-to-front,\n  # so first the "parent" morph is drawn, then the children,\n  # where first child is re-painted first.\n  #\n  # The slight exception is the shadow, which, when it exists,\n  # is the first\n  # child, but includes the shadow of the parent morph.\n  # So, the shadow is drawn AFTER the parent morph, but it\'s\n  # drawn with a special blending mode, such that it can be\n  # painted over and it still looks like it\'s at the back.\n  #\n  # This makes intuitive sense if you think for example\n  # at a textMorph being added to a box morph: it is\n  # added to the children list of the box morph, at the end,\n  # and it\'s painted on top (otherwise it wouldn\'t be visible).\n  #\n  # Note that when you add a morph A to a morph B, it doesn\'t\n  # mean that A is cointained in B. The two potentially might\n  # not even overlap.\n  children: nil\n\n  rootCache: nil\n  rootCacheChecker: nil\n\n  checkFirstParentClippingAtBoundsCache: nil\n  cachedFirstParentClippingAtBounds: nil\n\n  gcSessionIdMark: 0\n  gcReferenceExaminedSessionIdMark: 0\n\n  constructor: (@parent = nil, @children = []) ->\n\n  \n  # TreeNode string representation: e.g. \'a TreeNode[3]\'\n  toString: ->\n    if @children?\n      childrenLength = @children.length\n    else\n      childrenLength = "-"\n    "a TreeNode" + "[" + childrenLength + "]"\n\n  # currently unused in ZK\n  childrenTopToBottom: ->\n    arrayShallowCopyAndReverse @children\n  \n  # TreeNode accessing:\n  addChild: (aMorphicNode, position = nil) ->\n    WorldMorph.numberOfAddsAndRemoves++\n    @invalidateFullBoundsCache @\n    @invalidateFullClippedBoundsCache @\n    if !position?\n      @children.push aMorphicNode\n    else\n      @children.splice position, 0, aMorphicNode\n    aMorphicNode.parent = @\n  \n  # currently used to add the shadow. The shadow\n  # is in the background in respect to everything\n  # else, BUT it\'s drawn as the first child\n  # (i.e. AFTER the morph itself, but the shadow has a hole\n  # or semi-transparency for it!)\n  addChildFirst: (aMorphicNode) ->\n    \n    @addChild aMorphicNode, 0\n\n  # used from bringToForeground method\n  # for example when you\n  # click morphs around... they\n  # pop to the foreground\n  moveAsLastChild: ->\n    return unless @parent?\n    idx = @parent.children.indexOf @\n    if idx == -1\n      return\n    # check if already last child\n    # i.e. topmost\n    if idx == @parent.children.length - 1\n      return\n    @parent.children.splice idx, 1\n    @parent.children.push @\n    @parent.childMovedInFrontOfOthers? @\n    # whoever invoked this should probably\n    # do a fullChanged() we don\'t do it\n    # here because it seems like a lower-level\n    # function calling a higher-level one.\n  \n  removeChild: (aMorphicNode) ->\n    # remove the array element from the\n    # array\n    WorldMorph.numberOfAddsAndRemoves++\n    @invalidateFullBoundsCache @\n    @invalidateFullClippedBoundsCache @\n    @children.remove aMorphicNode\n    aMorphicNode.parent = nil\n\n  markReferenceAsVisited: (newGcSessionId) ->\n    @gcReferenceExaminedSessionIdMark = newGcSessionId\n\n  wasReferenceVisited: (newGcSessionId) ->\n    @gcReferenceExaminedSessionIdMark == newGcSessionId\n\n  markItAndItsParentsAsReachable: (newGcSessionId) ->\n    @gcSessionId = newGcSessionId\n    if @parent?\n      if @parent.gcSessionId == newGcSessionId\n        return\n      if @isDirectlyInBasement()\n        return\n      @parent.markItAndItsParentsAsReachable newGcSessionId\n  \n  # is this Widget attached to neither the world nor to\n  # the hand?\n  isOrphan: ->\n    root = @root()\n    if root == world or root == world.hand\n      return false\n    return true\n\n  # check if the widget is on its own in the basement\n  # (rather than being part of a widget that is in the\n  # basement)\n  isDirectlyInBasement: ->\n    @parent?.parent?.parent instanceof BasementWdgt\n\n  # check if it\'s in the basement on its own or\n  # as part of another widget.\n  isInBasement: ->\n    thereCouldBeOne = @allParentsBottomToTopSuchThat (eachWdgt) ->\n      eachWdgt instanceof BasementWdgt \n    return thereCouldBeOne.length == 1\n\n  isInBasementButReachable: (newGcSessionId) ->\n    if @gcSessionId == newGcSessionId\n      return true\n    if @parent.gcSessionId == newGcSessionId\n      return true\n    if @parent instanceof BasementWdgt\n      return false\n    return @parent.isInBasementButReachable newGcSessionId\n\n\n  # TreeNode functions:\n  SLOWroot: ->\n    if @parent?\n      return @parent.SLOWroot()\n    else\n      return @\n\n  # TreeNode functions:\n  root: ->\n    if @rootCacheChecker == WorldMorph.numberOfAddsAndRemoves\n      #console.log "cache hit root"\n      result = @rootCache\n    else\n  \n      theRoot = @\n      if @parent?\n        theRoot = @parent.root()\n\n      @rootCacheChecker = WorldMorph.numberOfAddsAndRemoves\n      @rootCache = theRoot\n      result = @rootCache\n\n    if world.doubleCheckCachedMethodsResults\n      if result != @SLOWroot()\n        debugger\n        alert "root is broken"\n\n    return result\n\n  # returns the path of this morph in terms\n  # of children positions relative to the world.\n  # Meaning that if the morph is not attached to the\n  # world or if it\'s attached to the hand, then\n  # nil is returned.\n  # Example: [0, 2, 1] means that this morph is\n  # at\n  #  world.children[0].children[2].children[1]\n  pathOfChildrenPositionsRelativeToWorld: (pathSoFar) ->\n    if !pathSoFar?\n      pathSoFar = \n        actualPath: []\n        lengthOfChildrenArrays: []\n\n    if @parent?\n      pathSoFar.actualPath.push @parent.children.indexOf @\n      pathSoFar.lengthOfChildrenArrays.push @parent.children.length\n      @parent.pathOfChildrenPositionsRelativeToWorld pathSoFar\n    else\n      if @ == world\n        pathSoFar.actualPath.reverse()\n        pathSoFar.lengthOfChildrenArrays.reverse()\n        return pathSoFar\n      else\n        return nil\n\n  \n  # currently unused\n  depth: ->\n    return 0  unless @parent\n    @parent.depth() + 1\n  \n  # Returns all the internal AND terminal nodes in the subtree starting\n  # at this node - including this node.\n  # Remember that the @children property already sorts morphs\n  # from bottom to top\n\n  allChildrenBottomToTop: ->\n    result = [@] # includes myself\n    @children.forEach (child) ->\n      result = result.concat child.allChildrenBottomToTop()\n    result\n\n  allChildrenTopToBottom: ->\n    return allChildrenTopToBottomSuchThat -> true\n\n  # the easiest way here would be to just return\n  #   arrayShallowCopyAndReverse(@allChildrenBottomToTop())\n  # but that\'s slower.\n  # So we do the proper visit here instead.\n  allChildrenTopToBottomSuchThat: (predicate) ->\n    collected = []\n\n\n    # if I have children, then start from the top\n    # one (i.e. the last in the array) towards the bottom\n    # one and concatenate their respective\n    # top-to-bottom lists\n    for morphNumber in [@children.length-1..0] by -1\n      morph = @children[morphNumber]\n      collected = collected.concat morph.allChildrenTopToBottomSuchThat predicate\n\n    # base case: after we checked all the\n    # children, we add ourselves to the last position\n    # of the list since this node is at the bottom of all of\n    # its children...\n    if predicate.call nil, @\n      collected.push @ # include myself\n\n    return collected\n\n\n  # A shorthand to run a function on all the internal/terminal nodes in the subtree\n  # starting at this node - including this node.\n  # Note that the function first runs on this node\n  # (which is, when painted, the very bottom-est morph of them all)\n  # and the proceeds by visiting the first child\n  # which is the most "bottom" of the children\n  # (i.e. when painted, the first child in the "children" array\n  # and its children are painted just above the parent node)\n  # and then recursively depht-first all its children\n  # and then the second - bottomest child and children etc.\n  # Also note that there is a more elegant implementation where\n  # we just use @allChildrenBottomToTop() but that would mean to create\n  # all the intermediary arrays with also all the unneeded node elements,\n  # there is no need for that.\n  # This is the simplest and cheapest way to visit all Widgets in\n  # a tree of morphs.\n  forAllChildrenBottomToTop: (aFunction) ->\n    aFunction.call nil, @\n    if @children.length\n      @children.forEach (child) ->\n        child.forAllChildrenBottomToTop aFunction\n  \n  # not used in ZK so far\n  allLeafsBottomToTop: ->\n    if @children.length == 0\n      return [@]\n    result = []\n    @children.forEach (child) ->\n      result = result.concat child.allLeafsBottomToTop()\n    return result\n\n  # Return all "parent" nodes from the root down to this node (including both)\n  allParentsBottomToTop: ->\n    if @parent?\n      someParents = @parent.allParentsBottomToTop()\n      someParents.push @\n      return someParents\n    else\n      return [@]\n  \n  # Return all "parent" nodes from this node up to the root (including both)\n  # Implementation commented-out below works but it\'s probably\n  # slower than the one given, because concat is slower than pushing just\n  # an array element, since concat does a shallow copy of both parts of\n  # the array...\n  #   allParentsTopToBottom: ->\n  #    # includes myself\n  #    result = [@]\n  #    if @parent?\n  #      result = result.concat(@parent.allParentsTopToBottom())\n  #    result\n\n  # Return all "parent" nodes from this note up to the root (including both)\n  allParentsTopToBottom: ->\n    return @allParentsBottomToTop().reverse()\n\n  # this should be quicker than allParentsTopToBottomSuchThat\n  # cause there are no concats making shallow copies.\n  allParentsBottomToTopSuchThat: (predicate) ->\n    result = []\n    if @parent?\n      result = @parent.allParentsBottomToTopSuchThat predicate\n    if predicate.call(nil, @)\n      result.push @\n    result\n\n  allParentsTopToBottomSuchThat: (predicate) ->\n    collected = []\n    if predicate.call nil, @\n      collected = [@] # include myself\n    if @parent?\n      collected = collected.concat @parent.allParentsTopToBottomSuchThat predicate\n    return collected\n\n  # quicker version that doesn\'t need us\n  # to create any intermediate arrays\n  # but rather just loops up the chain\n  # and lets us return as soon as\n  # we find a match\n  isAncestorOf: (morph) ->\n    if !morph?\n      # this happens when in a test, you select\n      # a menu entry that doesn\'t exist.\n      # so it\'s a good thing that we block the test\n      # and let the user navigate through the world\n      # to find the state of affairs that caused\n      # the problem.\n      if AutomatorRecorderAndPlayer?\n        console.log "failed to find morph in test: " + window.world.automatorRecorderAndPlayer.name\n        console.log "trying to find item with text label: " +  window.world.automatorRecorderAndPlayer.getCommandBeingPlayed().textLabelOfClickedItem\n        console.log "...you can likely fix the test by correcting the label above in the test"\n        debugger\n    # test the morph itself\n    if morph is @\n      return true\n    examinedMorph = morph\n    # could use recursion, but\n    # a loop will do too\n    while examinedMorph.parent?\n      examinedMorph = examinedMorph.parent\n      if examinedMorph is @\n        return true\n    return false\n\n  # The direct children of the parent of this node. (current node not included)\n  # never used in ZK\n  # There is an alternative solution here below, in comment,\n  # but I believe to be slower because it requires applying a function to\n  # all the children. My version below just required an array copy, then\n  # finding an element and splicing it out. I didn\'t test it so I don\'t\n  # even know whether it works, but gut feeling...\n  #  siblings: ->\n  #    return []  unless @parent\n  #    @parent.children.filter (child) =>\n  #      child isnt @\n  siblings: ->\n    return []  unless @parent\n    siblings = arrayShallowCopy @parent.children\n    # now remove myself\n    siblings.remove @\n    return siblings\n\n  firstSiblingsSuchThat: (predicate) ->\n    for eachSibling in @parent.children\n      if predicate.call nil, eachSibling\n        return eachSibling\n    return nil\n\n  amITheFirstSibling: ->\n    if @parent.children[0] == @\n      return true\n    return false\n\n  amITheLastSibling: ->\n    if @parent.children[@parent.children.length - 1] == @\n      return true\n    return false\n\n  positionAmongSiblings: ->\n    theCount = 0\n    for eachSibling in @parent.children\n      if eachSibling == @\n        return theCount\n      theCount++\n\n  siblingBeforeMeIsA: (theConstructor) ->\n    if @amITheFirstSibling()\n      return false\n    if @parent.children[@positionAmongSiblings()-1] instanceof theConstructor\n      return true\n    return false\n\n  siblingAfterMeIsA: (theConstructor) ->\n    if @amITheLastSibling()\n      return false\n    if @parent.children[@positionAmongSiblings()+1] instanceof theConstructor\n      return true\n    return false\n\n\n  # find how many siblings before me\n  # satisfy a property\n  # This is used when figuring out\n  # how many buttons before a particular button\n  # are labeled in the same way,\n  # in the test system.\n  # (so that we can say: automatically\n  # click on the nth button labelled "X")\n  howManySiblingsBeforeMeSuchThat: (predicate) ->\n    theCount = 0\n    for eachSibling in @parent.children\n      if eachSibling == @\n        return theCount\n      if predicate.call nil, eachSibling\n        theCount++\n    return theCount\n\n  lastSiblingBeforeMeSuchThat: (predicate) ->\n    theCount = 0\n    indexOfMorph = nil\n    for eachSibling in @parent.children\n      if eachSibling == @\n        break\n      if predicate.call nil, eachSibling\n        indexOfMorph = theCount\n      theCount++\n\n    if indexOfMorph?\n      return @parent.children[indexOfMorph]\n    else\n      return nil\n\n  firstSiblingAfterMeSuchThat: (predicate) ->\n    searchActuallyOngoing = false\n    for eachSibling in @parent.children\n      if searchActuallyOngoing\n        if predicate.call nil, eachSibling\n          return eachSibling\n      if eachSibling == @\n        searchActuallyOngoing = true\n    return nil\n\n  # find the nth child satisfying\n  # a property.\n  # This is used when finding\n  # the nth buttons of a menu\n  # having a particular label.\n  # (so that we can say: automatically\n  # click on the nth button labelled "X")\n  nthChildSuchThat: (n, predicate) ->\n    theCount = 0\n    for eachChild in @children\n      if predicate.call nil, eachChild\n        theCount++\n        if theCount is n\n          return eachChild\n    return nil\n\n  firstChildSuchThat: (predicate) ->\n    @nthChildSuchThat 1, predicate\n\n  SLOWfirstParentClippingAtBounds: (morphToStartFrom = @) ->\n    if morphToStartFrom.parent?\n      if morphToStartFrom.parent.clipsAtRectangularBounds\n        return morphToStartFrom.parent\n      else\n        return morphToStartFrom.parent.SLOWfirstParentClippingAtBounds()\n    else\n      return nil\n\n  firstParentClippingAtBounds: (morphToStartFrom = @) ->\n    if @checkFirstParentClippingAtBoundsCache == WorldMorph.numberOfAddsAndRemoves\n      if world.doubleCheckCachedMethodsResults\n        if @cachedFirstParentClippingAtBounds != @SLOWfirstParentClippingAtBounds morphToStartFrom\n          debugger\n          alert "firstParentClippingAtBounds is broken (cached)"\n\n    if morphToStartFrom.parent?\n      if morphToStartFrom.parent.clipsAtRectangularBounds\n        result = morphToStartFrom.parent\n      else\n        result = morphToStartFrom.parent.firstParentClippingAtBounds()\n    else\n      result =  nil\n\n    if world.doubleCheckCachedMethodsResults\n      if result != @SLOWfirstParentClippingAtBounds morphToStartFrom\n        debugger\n        alert "firstParentClippingAtBounds is broken (uncached)"\n\n    @checkFirstParentClippingAtBoundsCache = WorldMorph.numberOfAddsAndRemoves\n    @cachedFirstParentClippingAtBounds = result\n\n\n  \n  # returns the first parent (going up from this node) that is of a particular class\n  # (includes this particular node)\n  # This is a subcase of "parentThatIsAnyOf".\n  parentThatIsA: (constructors...) ->\n    # including myself\n    for eachConstructor in constructors\n      if @ instanceof eachConstructor\n        return [@, eachConstructor]\n    return nil  unless @parent\n    @parent.parentThatIsA constructors...\n\n  # checks whether the morph is a child,\n  # directly or indirectly, of a specified\n  # supposed ancestor morph\n  # this is currently unused\n  isADescendantOf: (theSupposedAncestorMorph) ->\n    if @ == theSupposedAncestorMorph\n      return true\n    if !@parent?\n      return false\n    return @parent.isADescendantOf theSupposedAncestorMorph\n  \n\n  # There would be another, simpler, implementation\n  # which is also slower, where you first collect all\n  # the children from top to bottom and then do the\n  # test on each. But this is more efficient - we don\'t\n  # need to create that entire list to start with, we\n  # just navigate through the children arrays depth-first\n  # (in reverse order though, see below)\n  # and stop at the first morph that satisfies the test.\n  topMorphSuchThat: (predicate) ->\n    # base case - I am a leaf child, so I just test\n    # the predicate on myself and return myself\n    # if I satisfy, else I return nil\n    if @children.length == 0\n      if predicate.call nil, @\n        return @\n      else\n        return nil\n    # if I have children, then start to test from\n    # the top one (the last one in the array)\n    # and proceed to test "towards the back" i.e.\n    # testing elements of the array towards 0\n    # If you find any morph satisfying, the search is\n    # over.\n    for morphNumber in [@children.length-1..0] by -1\n      morph = @children[morphNumber]\n      foundMorph = morph.topMorphSuchThat predicate\n      if foundMorph?\n        return foundMorph\n    # now that all children are tested, test myself\n    if predicate.call nil, @\n      return @\n    else\n      return nil\n    # ok none of my children nor me test positive,\n    # so return nil.\n    return nil\n\n  topmostChildSuchThat: (predicate) ->\n    # start to test from\n    # the top one (the last one in the array)\n    # and proceed to test "towards the back" i.e.\n    # testing elements of the array towards 0\n    # If you find any child that satisfies, the search is\n    # over.\n    for morphNumber in [@children.length-1..0] by -1\n      morph = @children[morphNumber]\n      if predicate.call nil, morph\n        return morph\n    # ok none of my children test positive,\n    # so return nil.\n    return nil\n\n  collectAllChildrenBottomToTopSuchThat: (predicate) ->\n    collected = []\n    if predicate.call(nil, @)\n      collected = [@] # include myself\n    @children.forEach (child) ->\n      collected = collected.concat(child.collectAllChildrenBottomToTopSuchThat(predicate))\n    return collected\n\n';
