

window.SliderButtonMorph_coffeSource = "# This is the handle in the middle of any slider.⤶# Sliders (and hence this button)⤶# are also used in the ScrollPanelWdgts.⤶⤶# this comment below is needed to figure out dependencies between classes⤶# REQUIRES globalFunctions⤶⤶class SliderButtonMorph extends CircleBoxMorph⤶⤶  # careful: Objects are shared with all the instances of this class.⤶  # if you modify it, then all the objects will get the change⤶  # but if you replace it with a new Color, then that will only affect the⤶  # specific object instance. Same behaviour as with arrays.⤶  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333⤶  highlightColor: new Color 110, 110, 110⤶  # see note above about Colors and shared objects⤶  pressColor: new Color 100, 100, 100⤶  normalColor: new Color 0, 0, 0⤶⤶  state: 0⤶  STATE_NORMAL: 0⤶  STATE_HIGHLIGHTED: 1⤶  STATE_PRESSED: 2⤶⤶  constructor: ->⤶    super⤶    @isLockingToPanels = false⤶    @color = @normalColor.copy()⤶    @noticesTransparentClick = true⤶    @alpha = 0.4⤶⤶  detachesWhenDragged: ->⤶    if @parent instanceof SliderMorph⤶      return false⤶    else⤶      return true⤶⤶  reLayout: ->⤶    super()⤶⤶    if @parent?⤶⤶      sliderValue = @parent.value⤶      # notably, if you type ＂-2＂ as an input to the slider⤶      # then as you type the ＂-＂⤶      # you get ＂-＂ as the value, which becomes NaN⤶      if isNaN sliderValue⤶        sliderValue = 0⤶⤶      orientation = @parent.autoOrientation()⤶      if orientation is ＂vertical＂⤶        bw = @parent.width() - 2⤶        bh = Math.max bw, Math.round @parent.height() * @parent.ratio()⤶        @silentRawSetExtent new Point bw, bh⤶        posX = 1⤶        posY = Math.max(0,Math.min(⤶          Math.round((sliderValue - @parent.start) * @parent.unitSize()),⤶          @parent.height() - @height()))⤶        if @parent.smallestValueIsAtBottomEnd⤶          posY = @parent.height() - (posY + @height()) ⤶      else⤶        bh = @parent.height() - 2⤶        bw = Math.max bh, Math.round @parent.width() * @parent.ratio()⤶        @silentRawSetExtent new Point bw, bh⤶        posY = 1⤶        posX = Math.max(0, Math.min(⤶          Math.round((sliderValue - @parent.start) * @parent.unitSize()),⤶          @parent.width() - @width()))⤶⤶      @silentFullRawMoveTo new Point(posX, posY).add @parent.position()⤶⤶      @notifyChildrenThatParentHasReLayouted()⤶⤶  grabsToParentWhenDragged: ->⤶    if @parent instanceof SliderMorph⤶      return false⤶    return super⤶⤶  nonFloatDragging: (nonFloatDragPositionWithinWdgtAtStart, pos, deltaDragFromPreviousCall) ->⤶    @offset = pos.subtract nonFloatDragPositionWithinWdgtAtStart⤶    if world.hand.mouseButton and⤶    @visibleBasedOnIsVisibleProperty() and⤶    !@isCollapsed()⤶      oldButtonPosition = @position()⤶      if @parent.autoOrientation() is ＂vertical＂⤶        newX = @left()⤶        newY = Math.max(⤶          Math.min(@offset.y,⤶          @parent.bottom() - @height()), @parent.top())⤶⤶      else⤶        newY = @top()⤶        newX = Math.max(⤶          Math.min(@offset.x,⤶          @parent.right() - @width()), @parent.left())⤶⤶      newPosition = new Point newX, newY⤶      if !oldButtonPosition.eq newPosition⤶        @fullRawMoveTo newPosition⤶        @parent.updateValue()⤶  ⤶  endOfNonFloatDrag: ->  ⤶    if @state != @STATE_NORMAL⤶      @state = @STATE_NORMAL⤶      @color = @normalColor.copy()⤶      @changed()⤶⤶  setHiglightedColor: ->⤶    if @state != @STATE_HIGHLIGHTED⤶      @state = @STATE_HIGHLIGHTED⤶      @color = @highlightColor.copy()⤶      @changed()⤶⤶  setNormalColor: ->⤶    if @state != @STATE_NORMAL⤶      @state = @STATE_NORMAL⤶      @color = @normalColor.copy()⤶      @changed()⤶⤶  setPressedColor: ->⤶    if @state != @STATE_PRESSED⤶      @state = @STATE_PRESSED⤶      @color = @pressColor.copy()⤶      @changed()⤶⤶  mouseMove: ->⤶    # remember that a drag can start a few pixels after the⤶    # mouse button is pressed (because of de-noising), so⤶    # only checking for ＂isThisPointerDraggingSomething＂ is not going to be⤶    # enough since we receive a few moves without the ＂isThisPointerDraggingSomething＂⤶    # being set. So we also check for the ＂pressed＂ state.⤶    if @state == @STATE_PRESSED or world.hand.isThisPointerDraggingSomething()⤶      return⤶    @setHiglightedColor()⤶  ⤶  #SliderButtonMorph events:⤶  mouseEnter: ->⤶    if world.hand.isThisPointerDraggingSomething()⤶      return⤶    @setHiglightedColor()⤶  ⤶  mouseLeave: ->⤶    if world.hand.isThisPointerDraggingSomething()⤶      return⤶    @setNormalColor()⤶  ⤶  mouseDownLeft: (pos) ->⤶    @bringToForeground()⤶    @setPressedColor()⤶⤶  mouseClickLeft: ->⤶    @bringToForeground()⤶    @setHiglightedColor()⤶  ⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SliderMorph_coffeSource = "# Sliders (and hence slider button morphs)⤶# are also used in the ScrollPanelWdgts .⤶⤶# In previous versions the user could force an orientation, so⤶# that one could have a vertical slider even if the slider is⤶# more wide than tall. Simplified that code because it doesn't⤶# look like a common need.⤶⤶# this comment below is needed to figure out dependencies between classes⤶# REQUIRES globalFunctions⤶# REQUIRES ControllerMixin⤶⤶class SliderMorph extends CircleBoxMorph⤶⤶  @augmentWith ControllerMixin⤶⤶  target: nil⤶  action: nil⤶⤶  start: nil⤶  stop: nil⤶  value: nil⤶  size: nil⤶  offset: nil⤶  button: nil⤶  argumentToAction: nil⤶⤶  smallestValueIsAtBottomEnd: false⤶⤶  idealRatioWidthToHeight: 1/4⤶⤶  constructor: (⤶    @start = 1,⤶    @stop = 100,⤶    @value = 50,⤶    @size = 10,⤶    @color = (new Color 0, 0, 0),⤶    @smallestValueIsAtBottomEnd = false⤶    ) ->⤶    @button = new SliderButtonMorph⤶    super # if nil, then a vertical one will be created⤶    @alpha = 0.1⤶    @silentRawSetExtent new Point 20, 100⤶    @silentAdd @button⤶⤶  colloquialName: ->⤶    ＂slider＂⤶⤶⤶  initialiseDefaultVerticalStackLayoutSpec: ->⤶    # use the existing VerticalStackLayoutSpec (if it's there)⤶    unless @layoutSpecDetails instanceof VerticalStackLayoutSpec⤶      @layoutSpecDetails = new VerticalStackLayoutSpec 0⤶⤶  iHaveBeenAddedTo: (whereTo, beingDropped) ->⤶    @reLayout()⤶    ⤶    # might happen in phase of deserialization that⤶    # the button reference here is still a string⤶    # so skip in that case⤶    if @button? and @button instanceof SliderButtonMorph⤶      @button.reLayout()⤶      ⤶    @changed()⤶⤶  rawSetExtent: (aPoint) ->⤶    unless aPoint.eq @extent()⤶      #console.log ＂move 17＂⤶      @breakNumberOfRawMovesAndResizesCaches()  ⤶      super aPoint⤶      # my backing store had just been updated⤶      # in the call of super, now⤶      # it's the time of the button⤶      @button.reLayout()⤶    ⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    @layoutSpecDetails = new WindowContentLayoutSpec PreferredSize.THIS_ONE_I_HAVE_NOW , PreferredSize.THIS_ONE_I_HAVE_NOW, 0⤶    @layoutSpecDetails.resizerCanOverlapContents = false⤶⤶  ⤶  rangeSize: ->⤶    @stop - @start⤶  ⤶  ratio: ->⤶    @size / @rangeSize()⤶  ⤶  unitSize: ->⤶    # might happen in phase of deserialization that⤶    # the button reference here is still a string⤶    # so skip in that case⤶    if !(@button? and @button instanceof SliderButtonMorph)⤶      return 1⤶    if @autoOrientation() is ＂vertical＂⤶      return (@height() - @button.height()) / @rangeSize()⤶    else⤶      return (@width() - @button.width()) / @rangeSize()⤶⤶  setValue: (newvalue, ignored, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken⤶    @value = Number(newvalue)⤶    @updateTarget()⤶    @reLayout()⤶    ⤶    @button.reLayout()⤶    ⤶    @changed()⤶    ⤶  updateValue: ->⤶    if @autoOrientation() is ＂vertical＂⤶      if @smallestValueIsAtBottomEnd⤶        relPos = @bottom() - @button.bottom()⤶      else⤶        relPos = @button.top() - @top()⤶    else⤶      relPos = @button.left() - @left()⤶⤶    newvalue = Math.round relPos / @unitSize() + @start⤶⤶    if @value != newvalue⤶      @setValue newvalue, nil, nil⤶⤶  # the bang makes the node fire the current output value⤶  bang: (newvalue, ignored, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken⤶    @updateTarget()⤶⤶  ⤶  updateTarget: ->⤶    if @action and @action != ＂＂⤶      @target[@action].call @target, @value, @argumentToAction, @connectionsCalculationToken⤶    return⤶⤶  reactToTargetConnection: ->⤶    @updateTarget()⤶⤶  # SliderMorph menu:⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    menu.addLine()⤶    menu.addMenuItem ＂show value＂, true, @, ＂showValue＂, ＂display a dialog box⧹nshowing the selected number＂⤶    menu.addMenuItem ＂floor...＂, true, @, (->⤶      @prompt menu.title + ＂⧹nfloor:＂,⤶        @setStart,⤶        @start.toString(),⤶        nil,⤶        0,⤶        @stop - @size,⤶        true⤶    ), ＂set the minimum value⧹nwhich can be selected＂⤶    menu.addMenuItem ＂ceiling...＂, true, @, (->⤶      @prompt menu.title + ＂⧹nceiling:＂,⤶        @setStop,⤶        @stop.toString(),⤶        nil,⤶        @start + @size,⤶        @size * 100,⤶        true⤶    ), ＂set the maximum value⧹nwhich can be selected＂⤶    menu.addMenuItem ＂button size...＂, true, @, (->⤶      @prompt menu.title + ＂⧹nbutton size:＂,⤶        @setSize,⤶        @size.toString(),⤶        nil,⤶        1,⤶        @stop - @start,⤶        true⤶    ), ＂set the range⧹ncovered by⧹nthe slider button＂⤶    menu.addLine()⤶    if world.isIndexPage⤶      menu.addMenuItem ＂connect to ➜＂, true, @, ＂openTargetSelector＂, ＂connect to⧹nanother widget＂⤶    else⤶      menu.addMenuItem ＂set target＂, true, @, ＂openTargetSelector＂, ＂choose another morph⧹nwhose numerical property⧹n will be＂ + ＂ controlled by this one＂⤶  ⤶  showValue: ->⤶    @inform @value⤶  ⤶  userSetStart: (num) ->⤶    @start = Math.max num, @stop⤶⤶  ⤶  # once you set all the properties of a slider you⤶  # call this method so it updates itself⤶  updateSpecs: (start, stop, value, size)->⤶    if start? then @start = start⤶    if stop? then @stop = stop⤶    if value? then @value = value⤶    if size? then @size = size⤶    @reLayout()⤶    ⤶    @button.reLayout()⤶    ⤶    # if the parent is the same as the target⤶    # then issue a fullChanged on the parent.⤶    # It's likely to be duplicate, which doesn't⤶    # matter, but it will consolidate the updates⤶    # of the scrollbars too⤶    if @parent != @target⤶      @changed()⤶    else⤶      @parent.fullChanged()⤶  ⤶  setStart: (numOrMorphGivingNum) ->⤶⤶    if numOrMorphGivingNum.getValue?⤶      num = numOrMorphGivingNum.getValue()⤶    else⤶      num = numOrMorphGivingNum⤶⤶    if typeof num is ＂number＂⤶      @start = Math.min Math.max(num, 0), @stop - @size⤶    else⤶      newStart = parseFloat num⤶      @start = Math.min Math.max(newStart, 0), @stop - @size  unless isNaN newStart⤶    @value = Math.max @value, @start⤶    @updateTarget()⤶    @reLayout()⤶    ⤶    @button.reLayout()⤶    ⤶    @changed()⤶  ⤶  setStop: (numOrMorphGivingNum) ->⤶⤶    if numOrMorphGivingNum.getValue?⤶      num = numOrMorphGivingNum.getValue()⤶    else⤶      num = numOrMorphGivingNum⤶⤶    if typeof num is ＂number＂⤶      @stop = Math.max num, @start + @size⤶    else⤶      newStop = parseFloat num⤶      @stop = Math.max newStop, @start + @size  unless isNaN newStop⤶    @value = Math.min @value, @stop⤶    @updateTarget()⤶    @reLayout()⤶    ⤶    @button.reLayout()⤶    ⤶    @changed()⤶  ⤶  mouseDownLeft: (pos) ->⤶    if @button.parent == @ and ((@parent instanceof ScrollPanelWdgt) or (@parent instanceof PromptMorph))⤶      world.hand.nonFloatDragWdgtFarAwayToHere @button, pos⤶      # in an ideal world when a widget moves under the pointer⤶      # it gets all the right events like mouseEnter etc.⤶      # however that's difficult to do, just set the ＂pressed＂⤶      # color from here⤶      @button.setPressedColor()⤶    else⤶      @escalateEvent ＂mouseDownLeft＂, pos⤶    ⤶⤶  setSize: (sizeOrMorphGivingSize) ->⤶    if sizeOrMorphGivingSize.getValue?⤶      size = sizeOrMorphGivingSize.getValue()⤶    else⤶      size = sizeOrMorphGivingSize⤶⤶    if typeof size is ＂number＂⤶      @size = Math.min Math.max(size, 1), @stop - @start⤶    else⤶      newSize = parseFloat size⤶      @size = Math.min Math.max(newSize, 1), @stop - @start  unless isNaN newSize⤶    @value = Math.min @value, @stop - @size⤶    # it just so happens that, as hoped but somewhat⤶    # unexpectedly, as the slider resizes,⤶    # the resize mechanism is such that the⤶    # button keeps the same value, so there⤶    # is no need to update the target.⤶    #@updateTarget()⤶    @reLayout()⤶    ⤶    @button.reLayout()⤶    ⤶    @changed()⤶  ⤶  # openTargetSelector: -> taken form the ControllerMixin⤶  ⤶  openTargetPropertySelector: (ignored, ignored2, theTarget) ->⤶    [menuEntriesStrings, functionNamesStrings] = theTarget.numericalSetters()⤶    menu = new MenuMorph @, false, @, true, true, ＂choose target property:＂⤶    for i in [0...menuEntriesStrings.length]⤶      menu.addMenuItem menuEntriesStrings[i], true, @, ＂setTargetAndActionWithOnesPickedFromMenu＂, nil, nil, nil, nil, nil, theTarget, functionNamesStrings[i]⤶    if menuEntriesStrings.length == 0⤶      menu = new MenuMorph @, false, @, true, true, ＂no target properties available＂⤶    menu.popUpAtHand()⤶⤶  stringSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂bang!＂, ＂value＂⤶    functionNamesStrings.push ＂bang＂, ＂setValue＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂bang!＂, ＂value＂, ＂start＂, ＂stop＂, ＂size＂⤶    functionNamesStrings.push ＂bang＂, ＂setValue＂, ＂setStart＂, ＂setStop＂, ＂setSize＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶  ⤶  colorSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂bang!＂⤶    functionNamesStrings.push ＂bang＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  ".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.StringFieldMorph_coffeSource = "# a stringMorph that can ＂scroll＂ as the cursor moves along the text⤶# but note that there are no scrollbars, since the container⤶# is just a Panel not a ScrollPanel.⤶⤶class StringFieldMorph extends PanelWdgt⤶⤶  defaultContents: nil⤶  minTextWidth: nil⤶  fontSize: nil⤶  fontStyle: nil⤶  isBold: nil⤶  isItalic: nil⤶  isNumeric: nil⤶  text: nil⤶  isEditable: true⤶⤶  constructor: (⤶      @defaultContents = ＂＂,⤶      @minTextWidth = 100,⤶      @fontSize = 12,⤶      @fontStyle = ＂sans-serif＂,⤶      @isBold = false,⤶      @isItalic = false,⤶      @isNumeric = false⤶      ) ->⤶    super()⤶    @color = new Color 255, 255, 255⤶⤶  rawSetWidth: (newWidth)->⤶    super⤶    @text.rawSetWidth newWidth⤶⤶⤶  calculateAndUpdateExtent: ->⤶    txt = (if @text then @getValue() else @defaultContents)⤶    text = new StringMorph txt, @fontSize, @fontStyle, @isBold, @isItalic, @isNumeric⤶    #console.log ＂text morph extent: ＂ + text.text + ＂ : ＂ + text.extent()⤶    @rawSetWidth Math.max @minTextWidth, text.width()⤶    #console.log ＂string field morph extent: ＂ + @extent()⤶⤶  reLayout: ->⤶    super()⤶    txt = (if @text then @getValue() else @defaultContents)⤶    if !@text?⤶      @text = new StringMorph(txt, @fontSize, @fontStyle, @isBold, @isItalic, @isNumeric)⤶      @text.isNumeric = @isNumeric # for whichever reason...⤶      @text.isEditable = @isEditable⤶      @text.enableSelecting()    ⤶      @add @text⤶    @text.fullRawMoveTo @position()⤶    @silentRawSetExtent new Point Math.max(@width(), @minTextWidth), @text.height()⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶  ⤶  getValue: ->⤶    @text.text⤶  ⤶  mouseClickLeft: (pos)->⤶    @bringToForeground()⤶    if @isEditable⤶      @text.edit()⤶    else⤶      @escalateEvent 'mouseClickLeft', pos⤶  ⤶  ".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.StringFieldWdgt2_coffeSource = "# Like StringFieldMorph, but it uses the StringMorph2⤶⤶# REQUIRES StringMorph2⤶⤶class StringFieldWdgt2 extends PanelWdgt⤶⤶  defaultContents: nil⤶  minTextWidth: nil⤶  fontSize: nil⤶  fontStyle: nil⤶  isBold: nil⤶  isItalic: nil⤶  isNumeric: nil⤶  text: nil⤶  isEditable: true⤶⤶  constructor: (⤶      @defaultContents = ＂＂,⤶      @minTextWidth = 100,⤶      @fontSize = 12,⤶      @fontStyle = ＂sans-serif＂,⤶      @isBold = false,⤶      @isItalic = false,⤶      @isNumeric = false⤶      ) ->⤶    super()⤶    @color = new Color 255, 255, 255⤶⤶  rawSetWidth: (newWidth)->⤶    super⤶    @text.rawSetWidth 300⤶⤶⤶  calculateAndUpdateExtent: ->⤶    txt = (if @text then @getValue() else @defaultContents)⤶    text = new StringMorph2 txt, @fontSize, @fontStyle, @isBold, @isItalic, false, @isNumeric⤶    text.fittingSpecWhenBoundsTooSmall = FittingSpecTextInSmallerBounds.SCALEDOWN   ⤶    #console.log ＂text morph extent: ＂ + text.text + ＂ : ＂ + text.extent()⤶    @rawSetWidth Math.max @minTextWidth, text.width()⤶    #console.log ＂string field morph extent: ＂ + @extent()⤶⤶  reLayout: ->⤶    super()⤶    txt = (if @text then @getValue() else @defaultContents)⤶    if !@text?⤶      @text = new StringMorph2(txt, @fontSize, @fontStyle, @isBold, @isItalic, false, @isNumeric)⤶      @text.isNumeric = @isNumeric # for whichever reason...⤶      @text.isEditable = @isEditable⤶      @text.enableSelecting() ⤶      @text.fittingSpecWhenBoundsTooSmall = FittingSpecTextInSmallerBounds.SCALEDOWN⤶      @add @text⤶    @text.fullRawMoveTo @position().add new Point 5,2⤶    @text.rawSetExtent new Point 300, 18⤶    @silentRawSetExtent new Point @width(), 18⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶  ⤶  getValue: ->⤶    @text.text⤶  ⤶  mouseClickLeft: (pos)->⤶    @bringToForeground()⤶    if @isEditable⤶      @text.edit()⤶    else⤶      @escalateEvent 'mouseClickLeft', pos⤶  ⤶  ".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.StringMorph_coffeSource = "# A StringMorph is a single line of text. It can only be left-aligned.⤶# REQUIRES WorldMorph⤶# REQUIRES BackBufferMixin⤶⤶class StringMorph extends Widget⤶⤶  @augmentWith BackBufferMixin⤶⤶  text: ＂＂⤶  fontSize: nil⤶  fontName: nil⤶  fontStyle: nil⤶  isBold: nil⤶  isItalic: nil⤶  isEditable: false⤶  isNumeric: nil⤶  isPassword: false⤶  isShowingBlanks: false⤶  # careful: Objects are shared with all the instances of this class.⤶  # if you modify it, then all the objects will get the change⤶  # but if you replace it with a new Color, then that will only affect the⤶  # specific object instance. Same behaviour as with arrays.⤶  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333⤶  blanksColor: new Color 180, 140, 140⤶⤶  # Properties for text-editing⤶  isScrollable: true⤶  currentlySelecting: false⤶  startMark: nil⤶  endMark: nil⤶  # see note above about Colors and shared objects⤶  markedTextColor: new Color 255, 255, 255⤶  # see note above about Colors and shared objects⤶  markedBackgoundColor: new Color 60, 60, 120⤶⤶  constructor: (⤶      @text = (if text is ＂＂ then ＂＂ else ＂StringMorph＂),⤶      @fontSize = 12,⤶      @fontStyle = ＂sans-serif＂,⤶      @isBold = false,⤶      @isItalic = false,⤶      @isNumeric = false,⤶      @color = (new Color 0, 0, 0),⤶      @fontName = ＂＂⤶      ) ->⤶⤶    super()⤶⤶    # override inherited properties:⤶    @noticesTransparentClick = true⤶⤶  setText: (theTextContent, stringFieldMorph, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken⤶    if stringFieldMorph?⤶      theTextContent = stringFieldMorph.text.text⤶    theTextContent = theTextContent + ＂＂⤶    if @text != theTextContent⤶      @text = theTextContent⤶      @reLayout()⤶      ⤶      @changed()⤶⤶  actualFontSizeUsedInRendering: ->⤶    @fontSize⤶  ⤶  toString: ->⤶    # e.g. 'a StringMorph(＂Hello World＂)'⤶    firstPart = super()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.hidingOfMorphsContentExtractInLabels⤶      return firstPart⤶    else⤶      return firstPart + ＂ (⧹＂＂ + @text.slice(0, 30).replace(/(?:⧹r⧹n|⧹r|⧹n)/g, '↵') + ＂...⧹＂)＂⤶⤶  getTextDescription: ->⤶    if @textDescription?⤶      return @textDescription + ＂ (adhoc description of string)＂⤶    textWithoutLocationOrInstanceNo = @text.replace /#⧹d*/, ＂＂⤶    return textWithoutLocationOrInstanceNo.slice(0, 30) + ＂ (content of string)＂⤶  ⤶  password: (letter, length) ->⤶    ans = ＂＂⤶    for i in [0...length]⤶      ans += letter⤶    ans⤶⤶  buildCanvasFontProperty: ->⤶    # answer a font string, e.g. 'bold italic 12px sans-serif'⤶    font = ＂＂⤶    font = font + ＂bold ＂  if @isBold⤶    font = font + ＂italic ＂  if @isItalic⤶    font + @fontSize + ＂px ＂ + ((if @fontName then @fontName + ＂, ＂ else ＂＂)) + @fontStyle⤶⤶⤶  widthOfText: (text = @text)->⤶    text = (if @isPassword then @password(＂*＂, text.length) else text)⤶    world.canvasContextForTextMeasurements.font = @buildCanvasFontProperty()⤶    return Math.ceil Math.max world.canvasContextForTextMeasurements.measureText(text).width, 1⤶⤶  reLayout: ->⤶    super()⤶    width = @widthOfText @text⤶    @silentRawSetExtent new Point width, fontHeight @fontSize⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶  reflowText: ->⤶    @reLayout()⤶  ⤶  # no changes of position or extent should be⤶  # performed in here⤶  createRefreshOrGetBackBuffer: ->⤶⤶    cacheKey =⤶      @extent().toString()  + ＂-＂ +⤶      @isPassword  + ＂-＂ +⤶      @isShowingBlanks  + ＂-＂ +⤶      @buildCanvasFontProperty()  + ＂-＂ +⤶      @alignment  + ＂-＂ +⤶      @color.toString()  + ＂-＂ +⤶      hashCode(@text)  + ＂-＂ +⤶      @startMark  + ＂-＂ +⤶      @endMark  + ＂-＂ +⤶      @markedBackgoundColor.toString()⤶⤶    cacheHit = world.cacheForImmutableBackBuffers.get cacheKey⤶    if cacheHit? then return cacheHit⤶⤶    text = (if @isPassword then @password(＂*＂, @text.length) else @text)⤶    # initialize my surface property⤶    width = @widthOfText @text⤶    backBuffer = newCanvas (new Point width, @height()).scaleBy ceilPixelRatio⤶    backBufferContext = backBuffer.getContext ＂2d＂⤶⤶    backBufferContext.scale ceilPixelRatio, ceilPixelRatio⤶    backBufferContext.font = @buildCanvasFontProperty()⤶    backBufferContext.textAlign = ＂left＂⤶    backBufferContext.textBaseline = ＂bottom＂⤶⤶    backBufferContext.fillStyle = @color.toString()⤶    if @isShowingBlanks⤶      @renderWithBlanks backBufferContext, 0, fontHeight @fontSize⤶    else⤶      backBufferContext.fillText text, 0, fontHeight @fontSize⤶⤶    # draw the selection⤶    start = Math.min @startMark, @endMark⤶    stop = Math.max @startMark, @endMark⤶    for i in [start...stop]⤶      p = @slotCoordinates(i).subtract @position()⤶      c = text.charAt(i)⤶      backBufferContext.fillStyle = @markedBackgoundColor.toString()⤶      backBufferContext.fillRect p.x, p.y, Math.ceil(backBufferContext.measureText(c).width) + 1,⤶        fontHeight @fontSize⤶      backBufferContext.fillStyle = @markedTextColor.toString()⤶      backBufferContext.fillText c, p.x, fontHeight @fontSize⤶⤶    cacheEntry = [backBuffer, backBufferContext]⤶    world.cacheForImmutableBackBuffers.set cacheKey, cacheEntry⤶    return cacheEntry⤶  ⤶  renderWithBlanks: (context, x = 0, y) ->⤶    # create the blank form⤶    drawBlank = ->⤶      context.drawImage blank, Math.round(x), 0⤶      x += space⤶    space = Math.ceil context.measureText(＂ ＂).width⤶    blank = newCanvas new Point(space, @height()).scaleBy ceilPixelRatio⤶    ctx = blank.getContext ＂2d＂⤶    words = @text.split ＂ ＂⤶    isFirst = true⤶    ctx.fillStyle = @blanksColor.toString()⤶    ctx.arc space / 2, blank.height / 2, space / 2, degreesToRadians(0), degreesToRadians(360)⤶    ctx.fill()⤶⤶    # render my text inserting blanks⤶    words.forEach (word) ->⤶      drawBlank()  unless isFirst⤶      isFirst = false⤶      if word isnt ＂＂⤶        context.fillText word, x, y⤶        x += Math.ceil context.measureText(word).width⤶  ⤶  ⤶  # StringMorph measuring:⤶  slotCoordinates: (slot) ->⤶    # answer the position point of the given index (＂slot＂)⤶    # where the caret should be placed⤶    text = (if @isPassword then @password(＂*＂, @text.length) else @text)⤶⤶    # let's be defensive and check that the⤶    # slot is in the right interval⤶    checkedSlot = Math.min Math.max(slot, 0), text.length⤶    if slot != checkedSlot⤶      alert ＂something wrong - slot is out of range＂⤶    slot = checkedSlot⤶⤶    xOffset = Math.ceil @widthOfText text.substring 0, slot⤶    x = @left() + xOffset⤶    y = @top()⤶    new Point x, y⤶  ⤶  slotAt: (aPoint) ->⤶    # answer the slot (index) closest to the given point⤶    # so the caret can be moved accordingly⤶    text = (if @isPassword then @password(＂*＂, @text.length) else @text)⤶    idx = 0⤶    charX = 0⤶⤶    while aPoint.x - @left() > charX⤶      charX += Math.ceil @widthOfText text[idx]⤶      idx += 1⤶      if idx is text.length⤶        if (Math.ceil(@widthOfText(text)) - (Math.ceil(@widthOfText(text[idx-1])) / 2)) < (aPoint.x - @left())  ⤶          return idx⤶    idx - 1⤶  ⤶  upFrom: (slot) ->⤶    @startOfLine()⤶  ⤶  downFrom: (slot) ->⤶    @endOfLine()⤶⤶  startOfLine: ->⤶    # answer the first slot (index) of the line for the given slot⤶    0⤶  ⤶  endOfLine: ->⤶    # answer the slot (index) indicating the EOL for the given slot⤶    @text.length⤶    ⤶  fontSizePopup: (menuItem)->⤶    @prompt menuItem.parent.title + ＂⧹nfont⧹nsize:＂,⤶      @,⤶      ＂setFontSize＂,⤶      @fontSize.toString(),⤶      nil, 6, 500, true⤶⤶  # StringMorph menus:⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    menu.addLine()⤶    menu.addMenuItem ＂edit＂, true, @, ＂edit＂⤶    menu.addMenuItem ＂font size...＂, true, @, ＂fontSizePopup＂, ＂set this String's⧹nfont point size＂⤶    menu.addMenuItem ＂serif＂, true, @, ＂setSerif＂  if @fontStyle isnt ＂serif＂⤶    menu.addMenuItem ＂sans-serif＂, true, @, ＂setSansSerif＂  if @fontStyle isnt ＂sans-serif＂⤶⤶    if @isBold⤶      menu.addMenuItem ＂normal weight＂, true, @, ＂toggleWeight＂⤶    else⤶      menu.addMenuItem ＂bold＂, true, @, ＂toggleWeight＂⤶⤶    if @isItalic⤶      menu.addMenuItem ＂normal style＂, true, @, ＂toggleItalic＂⤶    else⤶      menu.addMenuItem ＂italic＂, true, @, ＂toggleItalic＂⤶⤶    if @isShowingBlanks⤶      menu.addMenuItem ＂hide blanks＂, true, @, ＂toggleShowBlanks＂⤶    else⤶      menu.addMenuItem ＂show blanks＂, true, @, ＂toggleShowBlanks＂⤶⤶    if @isPassword⤶      menu.addMenuItem ＂show characters＂, true, @, ＂toggleIsPassword＂⤶    else⤶      menu.addMenuItem ＂hide characters＂, true, @, ＂toggleIsPassword＂⤶⤶  toggleShowBlanks: ->⤶    @isShowingBlanks = not @isShowingBlanks⤶    @reLayout()⤶    ⤶    @changed()⤶  ⤶  toggleWeight: ->⤶    @isBold = not @isBold⤶    @reLayout()⤶    ⤶    @changed()⤶  ⤶  toggleItalic: ->⤶    @isItalic = not @isItalic⤶    @reLayout()⤶    ⤶    @changed()⤶  ⤶  toggleIsPassword: ->⤶    @isPassword = not @isPassword⤶    @reLayout()⤶    ⤶    @changed()⤶  ⤶  setSerif: ->⤶    @fontStyle = ＂serif＂⤶    @reLayout()⤶    ⤶    @changed()⤶  ⤶  setSansSerif: ->⤶    @fontStyle = ＂sans-serif＂⤶    @reLayout()⤶    ⤶    @changed()⤶  ⤶  setFontSize: (sizeOrMorphGivingSize, morphGivingSize) ->⤶    if morphGivingSize?.getValue?⤶      size = morphGivingSize.getValue()⤶    else⤶      size = sizeOrMorphGivingSize⤶⤶    if typeof size is ＂number＂⤶      @fontSize = Math.round(Math.min(Math.max(size, 4), 500))⤶    else⤶      newSize = parseFloat size⤶      @fontSize = Math.round Math.min Math.max(newSize, 4), 500  unless isNaN newSize⤶    @reLayout()⤶    ⤶    @changed()⤶  ⤶  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂alpha 0-100＂, ＂font size＂, ＂text＂⤶    functionNamesStrings.push ＂setAlphaScaled＂, ＂setFontSize＂, ＂setText＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶  ⤶  # StringMorph editing:⤶  edit: ->⤶    world.edit @⤶⤶  selection: ->⤶    start = Math.min @startMark, @endMark⤶    stop = Math.max @startMark, @endMark⤶    @text.slice start, stop⤶  ⤶  firstSelectedSlot: ->⤶    if !@startMark? or !@endMark?⤶      return nil⤶    return Math.min @startMark, @endMark⤶⤶  lastSelectedSlot: ->⤶    if !@startMark? or !@endMark?⤶      return nil⤶    return Math.max @startMark, @endMark⤶⤶  clearSelection: ->⤶    @currentlySelecting = false⤶    @startMark = nil⤶    @endMark = nil⤶    ⤶    @changed()⤶⤶  setEndMark: (slot) ->⤶    @endMark = slot⤶    @changed()⤶  ⤶  selectBetween: (start, end) ->⤶    @startMark = Math.min start, end⤶    @endMark = Math.max start, end⤶    @changed()  ⤶⤶  deleteSelection: ->⤶    text = @text⤶    start = Math.min @startMark, @endMark⤶    stop = Math.max @startMark, @endMark⤶    @text = text.slice(0, start) + text.slice(stop)⤶    ⤶    @changed()⤶    @clearSelection()⤶  ⤶  selectAll: ->⤶    @startMark = 0⤶    @endMark = @text.length⤶    ⤶    @changed()⤶⤶  # Every time the user clicks on the text, a new edit()⤶  # is triggered, which creates a new caret.⤶  mouseClickLeft: (pos) ->⤶    @bringToForeground()⤶    caret = world.caret⤶    if @isEditable⤶      @edit()  unless @currentlySelecting⤶      if caret then caret.gotoPos pos⤶      world.caret.gotoPos pos⤶      @currentlySelecting = true⤶    else⤶      @escalateEvent ＂mouseClickLeft＂, pos⤶  ⤶  enableSelecting: ->⤶    @mouseDownLeft = (pos) ->⤶      @clearSelection()⤶      if @isEditable and !@grabsToParentWhenDragged()⤶        @edit()⤶        world.caret.gotoPos pos⤶        @startMark = @slotAt pos⤶        @endMark = @startMark⤶        @currentlySelecting = true⤶    ⤶    @mouseMove = (pos) ->⤶      if @isEditable and @currentlySelecting⤶        newMark = @slotAt pos⤶        if newMark isnt @endMark⤶          @endMark = newMark⤶          ⤶          @changed()⤶      else⤶        @disableSelecting()⤶  ⤶  disableSelecting: ->⤶    # re-establish the original definition of the method⤶    @clearSelection()⤶    @mouseDownLeft = StringMorph::mouseDownLeft⤶    delete @mouseMove⤶⤶⤶  ".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.StringMorph2_coffeSource = "# It's a SINGLE line of text, i.e.⤶# it doesn't represent line breaks as multiple lines⤶# and there is no concept of soft-wrapping.⤶# It's useful when you mean an ＂enter＂ from the user to mean⤶# ＂accept the changes＂, and to represent things that are⤶# necessarily on one line and one line only such as⤶# numbers, booleans, method and property names, file names,⤶# colors, passwords etc.⤶# If there is a chance that the text might span more⤶# than one line (e.g. most button captions) then do⤶# use a TextMorph instead.⤶# It's like StringMorph BUT it fits any given size, so to⤶# behave well in layouts.⤶#⤶# REQUIRES WorldMorph⤶# REQUIRES BackBufferMixin⤶# REQUIRES ControllerMixin⤶# REQUIRES AlignmentSpecHorizontal⤶# REQUIRES AlignmentSpecVertical⤶# REQUIRES LRUCache⤶# REQUIRES FittingSpecTextInSmallerBounds⤶# REQUIRES FittingSpecTextInLargerBounds⤶# REQUIRES TextEditingState⤶⤶class StringMorph2 extends Widget⤶⤶  @augmentWith BackBufferMixin⤶  @augmentWith ControllerMixin⤶⤶  # clear unadulterated text⤶  text: ＂＂⤶  # the text as it actually shows.⤶  # It might have undergone transformations⤶  # and cropping.⤶  textPossiblyCroppedToFit: ＂＂⤶⤶  fittingFontSize: nil⤶  originallySetFontSize: nil⤶⤶  fontName: nil⤶  isBold: nil⤶  isItalic: nil⤶  # TODO there is no API to toggle this properly yet,⤶  # TODO?? ...and there is no menu entry for this⤶  # TODO???? ...should we let users pick any color?⤶  hasDarkOutline: false⤶  isHeaderLine: nil⤶  isEditable: false⤶  # if ＂isNumeric＂, it rejects all inputs⤶  # other than numbers and ＂-＂ and ＂.＂⤶  isNumeric: nil⤶  isPassword: false⤶  isShowingBlanks: false⤶  # careful: Objects are shared with all the instances of this class.⤶  # if you modify it, then all the objects will get the change⤶  # but if you replace it with a new Color, then that will only affect the⤶  # specific object instance. Same behaviour as with arrays.⤶  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333⤶  blanksColor: new Color 180, 140, 140⤶⤶  # Used for when the cursor movement causes the⤶  # text to scroll, so that the caret is in-view when⤶  # used, say, on a text in a ScrollPanelWdgt.⤶  isScrollable: true⤶⤶  # startMark and endMark contain the slot of the⤶  # slot first selected IN TIME, not ＂in space＂.⤶  # i.e. startMark might be higher than endMark if⤶  # text had been selected starting from the⤶  # right and ＂going left＂⤶  startMark: nil⤶  endMark: nil⤶⤶  # see note above about Colors and shared objects⤶  markedTextColor: new Color 255, 255, 255⤶  # see note above about Colors and shared objects⤶  markedBackgoundColor: new Color 60, 60, 120⤶⤶  horizontalAlignment: AlignmentSpecHorizontal.LEFT⤶  verticalAlignment: AlignmentSpecVertical.TOP⤶⤶  fittingSpecWhenBoundsTooLarge: FittingSpecTextInLargerBounds.FLOAT⤶  fittingSpecWhenBoundsTooSmall: FittingSpecTextInSmallerBounds.CROP⤶⤶  caretHorizPositionForVertMovement: nil⤶⤶  emptyCharacter: '⧹u2063'⤶⤶  # Since we let the browser paint the text, we can't guarantee that⤶  # a specific font will be available to the user.⤶  # So we do what web designers do: we allow for a few families of⤶  # very simialar fonts (at least in style in not in shape),⤶  # each specifying a list of fallbacks that⤶  # are chosen to be similar and, collectively, widely available.⤶  # On top of that we also add a justArialFontStack, since Arial⤶  # is actually available on all devices, it's useful for testing⤶  # to have a font that is supposed to be identical across all⤶  # devices.⤶  # These stacks have been taken from⤶  # http://www.sitepoint.com/eight-definitive-font-stacks/⤶  justArialFontStack: 'Arial, sans-serif'⤶  timesFontStack: 'Cambria, ＂Hoefler Text＂, Utopia, ＂Liberation Serif＂, ＂Nimbus Roman No9 L Regular＂, Times, ＂Times New Roman＂, serif'⤶  georgiaFontStack: 'Constantia, ＂Lucida Bright＂, Lucidabright, ＂Lucida Serif＂, Lucida, ＂DejaVu Serif＂, ＂Bitstream Vera Serif＂, ＂Liberation Serif＂, Georgia, serif'⤶  garamoFontStack: '＂Palatino Linotype＂, Palatino, Palladio, ＂URW Palladio L＂, ＂Book Antiqua＂, Baskerville, ＂Bookman Old Style＂, ＂Bitstream Charter＂, ＂Nimbus Roman No9 L＂, Garamond, ＂Apple Garamond＂, ＂ITC Garamond Narrow＂, ＂New Century Schoolbook＂, ＂Century Schoolbook＂, ＂Century Schoolbook L＂, Georgia, serif'⤶  helveFontStack: 'Frutiger, ＂Frutiger Linotype＂, Univers, Calibri, ＂Gill Sans＂, ＂Gill Sans MT＂, ＂Myriad Pro＂, Myriad, ＂DejaVu Sans Condensed＂, ＂Liberation Sans＂, ＂Nimbus Sans L＂, Tahoma, Geneva, ＂Helvetica Neue＂, Helvetica, Arial, sans-serif'⤶  verdaFontStack: 'Corbel, ＂Lucida Grande＂, ＂Lucida Sans Unicode＂, ＂Lucida Sans＂, ＂DejaVu Sans＂, ＂Bitstream Vera Sans＂, ＂Liberation Sans＂, Verdana, ＂Verdana Ref＂, sans-serif'⤶  trebuFontStack: '＂Segoe UI＂, Candara, ＂Bitstream Vera Sans＂, ＂DejaVu Sans＂, ＂Bitstream Vera Sans＂, ＂Trebuchet MS＂, Verdana, ＂Verdana Ref＂, sans-serif'⤶  heavyFontStack: 'Impact, Haettenschweiler, ＂Franklin Gothic Bold＂, Charcoal, ＂Helvetica Inserat＂, ＂Bitstream Vera Sans Bold＂, ＂Arial Black＂, sans-serif'⤶  monoFontStack: 'Consolas, ＂Andale Mono WT＂, ＂Andale Mono＂, ＂Lucida Console＂, ＂Lucida Sans Typewriter＂, ＂DejaVu Sans Mono＂, ＂Bitstream Vera Sans Mono＂, ＂Liberation Mono＂, ＂Nimbus Mono L＂, Monaco, ＂Courier New＂, Courier, monospace'⤶⤶  hashOfTextConsideredAsReference: nil⤶  widgetToBeNotifiedOfTextModificationChange: nil⤶⤶  undoHistory: nil⤶  redoHistory: nil⤶⤶  constructor: (⤶      @text = (if text is ＂＂ then ＂＂ else ＂StringMorph2＂),⤶      @originallySetFontSize = WorldMorph.preferencesAndSettings.normalTextFontSize,⤶      @fontName = @justArialFontStack,⤶      @isBold = false,⤶      @isItalic = false,⤶      @isHeaderLine = false,⤶      @isNumeric = false,⤶      @color = (new Color 37, 37, 37),⤶      backgroundColor,⤶      backgroundTransparency⤶      ) ->⤶    # additional properties:⤶    @textPossiblyCroppedToFit = @transformTextOneToOne @text⤶⤶    # properties that override existing ones only when passed⤶    @backgroundColor = backgroundColor if backgroundColor?⤶    @backgroundTransparency = backgroundTransparency if backgroundTransparency?      ⤶⤶    @undoHistory = []⤶    @redoHistory = []⤶⤶    super()⤶⤶    # override inherited properties:⤶    @noticesTransparentClick = true⤶    @changed()⤶⤶  # the actual font size used might be⤶  # different than the one specified originally⤶  # because this morph has to be able to fit⤶  # any extent by shrinking.⤶  actualFontSizeUsedInRendering: ->⤶    @reflowText()⤶    @fittingFontSize⤶⤶  pushUndoState: (slot, justFirstClickToPositionCursor) ->⤶⤶    # Little definition here: a ＂positional＂ change⤶    # are pairs of states that only differ for the⤶    # position.⤶⤶    # Since we push a:⤶    #                  position, text⤶    #⤶    # pair for each insert (see comment in ＂insert＂ for why)⤶    # we want to actually forget the ＂trivial＂ positional⤶    # changes when the user is just typing, so discard the⤶    # positional changes of one⤶    if @undoHistory.length > 0⤶      lastUndoState = @undoHistory[@undoHistory.length - 1]⤶      if lastUndoState.selectionStart == @startMark and⤶       lastUndoState.selectionEnd == @endMark and⤶       lastUndoState.textContent == @text and⤶       Math.abs(slot - lastUndoState.cursorPos) <= 1⤶        return⤶⤶    # when the user clicks around, we never want to⤶    # store three consecutive non-trivial positional⤶    # changes. We just want two: the initial and the last⤶    # one. So check the last two pushes, and if they are⤶    # positional then we discard the second one, then we are going⤶    # to add the new one after this check.⤶    # All this is because it's much *much* more natural⤶    # for the user to undo up to the position BEFORE an⤶    # edit. If you don't save that position before the⤶    # edit, you jump directly to the end of the edit before,⤶    # it's actually quite puzzling.⤶    # It's nominally ＂functional＂ to only jump to text changes,⤶    # but it's quite unnatural, it's not how undos work⤶    # in real editors.⤶    if @undoHistory.length > 1⤶      lastUndoState = @undoHistory[@undoHistory.length - 1]⤶      beforeLastUndoState = @undoHistory[@undoHistory.length - 2]⤶      if beforeLastUndoState.selectionStart == lastUndoState.selectionStart == @startMark and⤶       beforeLastUndoState.selectionEnd == lastUndoState.selectionEnd == @endMark and⤶       beforeLastUndoState.textContent == lastUndoState.textContent == @text⤶        @undoHistory.pop()⤶⤶⤶    @redoHistory = []⤶⤶    @undoHistory.push new TextEditingState @startMark, @endMark, slot, @text, justFirstClickToPositionCursor⤶⤶  popRedoState: (slot) ->⤶    poppedElement = @redoHistory.pop()⤶    if poppedElement?⤶      @undoHistory.push poppedElement⤶    return poppedElement⤶⤶  popUndoState: ->⤶    poppedElement = @undoHistory.pop()⤶    if poppedElement?⤶      @redoHistory.push poppedElement⤶    return poppedElement⤶⤶  setHorizontalAlignment: (newAlignment) ->⤶    if @horizontalAlignment != newAlignment⤶      @horizontalAlignment = newAlignment⤶      @changed()⤶⤶  setVerticalAlignment: (newAlignment) ->⤶    if @verticalAlignment != newAlignment⤶      @verticalAlignment = newAlignment⤶      @changed()⤶⤶  alignLeft: ->⤶    @setHorizontalAlignment AlignmentSpecHorizontal.LEFT⤶    @⤶  alignCenter: ->⤶    @setHorizontalAlignment AlignmentSpecHorizontal.CENTER⤶    @⤶  alignRight: ->⤶    @setHorizontalAlignment AlignmentSpecHorizontal.RIGHT⤶    @⤶  alignTop: ->⤶    @setVerticalAlignment AlignmentSpecVertical.TOP⤶    @⤶  alignMiddle: ->⤶    @setVerticalAlignment AlignmentSpecVertical.MIDDLE⤶    @⤶  alignBottom: ->⤶    @setVerticalAlignment AlignmentSpecVertical.BOTTOM⤶    @⤶  ⤶  toString: ->⤶    # e.g. 'a StringMorph2(＂Hello World＂)'⤶    firstPart = super()⤶    if Automator? and Automator.state != Automator.IDLE and⤶    Automator.hidingOfMorphsContentExtractInLabels⤶      return firstPart⤶    else⤶      return firstPart + ＂ (⧹＂＂ + @text.slice(0, 30).replace(/(?:⧹r⧹n|⧹r|⧹n)/g, '↵') + ＂...⧹＂)＂⤶⤶  # used to identify morphs in macros/tests.⤶  # identifying morphs this way resists more⤶  # to tampering such as adding/removing morphs and⤶  # changing their locations.⤶  getTextDescription: ->⤶    if @textDescription?⤶      return @textDescription + ＂ (adhoc description of string)＂⤶    textWithoutLocationOrInstanceNo = @text.replace /#⧹d*/, ＂＂⤶    return textWithoutLocationOrInstanceNo.slice(0, 30) + ＂ (content of string)＂⤶  ⤶⤶⤶  buildCanvasFontProperty: (overrideFontSize = @fittingFontSize) ->⤶    # answer a font string, e.g. 'bold italic 12px Arial'⤶    font = ＂＂⤶    font = font + ＂bold ＂  if @isBold⤶    font = font + ＂italic ＂  if @isItalic⤶    font + overrideFontSize + ＂px ＂ + @fontName⤶⤶  # does a binary search to see which font size⤶  # we need to apply to the text to fit to the⤶  # current extent.⤶  # If this gets slow: some optimisations can be done,⤶  # for example trying to make a couple of preliminary guesses⤶  # assuming that the user is just resizing something slightly,⤶  # which means that the font size is gonna change only slightly⤶  # from the current one, so you can try to narrow the bracket⤶  # a lot at the very start.⤶  searchLargestFittingFont: (textToFit) ->⤶⤶    # decimalFloatFiguresOfFontSizeGranularity allows you to go into sub-points⤶    # in the font size. This is so the resizing of the⤶    # text is less ＂jumpy＂.⤶    # ＂1＂ seems to be perfect in terms of jumpiness,⤶    # but obviously this routine gets quite a bit more⤶    # expensive.⤶    PreferencesAndSettings.decimalFloatFiguresOfFontSizeGranularity = 0⤶⤶    # minimum font size that we are gonna examine⤶    start = 0⤶    # maximum font size that we are gonna examine⤶    stop  = Math.round 200 * Math.pow 10,⤶            PreferencesAndSettings.decimalFloatFiguresOfFontSizeGranularity⤶    ⤶    if !@doesTextFitInExtent textToFit, start⤶      return -1⤶⤶⤶    if @doesTextFitInExtent textToFit, stop⤶      return stop / Math.pow 10, PreferencesAndSettings.decimalFloatFiguresOfFontSizeGranularity⤶⤶    # since we round the pivot to the floor, we⤶    # always end up start and pivot coinciding⤶    while start != (pivot = Math.floor (start + stop) / 2)⤶⤶      itFitsAtPivot = @doesTextFitInExtent textToFit, pivot / Math.pow 10, PreferencesAndSettings.decimalFloatFiguresOfFontSizeGranularity⤶⤶      if itFitsAtPivot⤶        # bring forward the start since there are still⤶        # zeroes at the pivot⤶        start = pivot⤶      else⤶        # bring backwards the stop since there is already⤶        # a one at the pivot⤶        stop = pivot⤶⤶    return start / Math.pow 10, PreferencesAndSettings.decimalFloatFiguresOfFontSizeGranularity⤶⤶  generateTextWithEllipsis: (startingText) ->⤶    if startingText != ＂＂⤶      return startingText + ＂…＂⤶    return ＂＂⤶⤶  # what we are tyring to do here is to fit the text into⤶  # a boundary that potentially is too small. We are not going⤶  # to fit it by changing the font size, rather we are fitting⤶  # it by cropping it.⤶  # Note that the text could be set to wrap, so we also have⤶  # to take that into account when measuring if it fits.⤶  #⤶  # Note that the resulting text might contain more than one⤶  # crop, because several lines might be extending beyond the⤶  # width of the boundary.⤶  #⤶  # See comment above for ＂searchLargestFittingFont＂ for some⤶  # ideas on how to optimise this further.⤶  searchLongestFittingTextByMultiCroppingIt: (textToFit) ->⤶    textToFit = @transformTextOneToOne @text⤶⤶    # check if it fits as is, maybe we don't⤶    # need to do any cropping.⤶    if @doesTextFitInExtent(textToFit, @originallySetFontSize)⤶       return textToFit⤶⤶⤶    # split textToFit into lines i.e. into paragraphs⤶    splitText = textToFit.split /⧹n/⤶    ⤶    fittingText = ＂＂⤶⤶    for i in [0...splitText.length]⤶⤶      eachParagraph  = splitText[i]⤶      fittingText += eachParagraph⤶      ⤶      # also add the newline, except if it's⤶      # the last element of the array, in which⤶      # case there is no newline after it.⤶      if i != splitText.length - 1⤶        fittingText += ＂⧹n＂⤶⤶      #console.log ＂searchLongestFittingTextByMultiCroppingIt trying to fit one more paragraph:＂⤶      #console.log ＂   ＂ + eachParagraph⤶      #console.log ＂ overal blurb we are fitting: ＂ + fittingText⤶⤶      # add each new line of textToFit to the existing blurb to be tested⤶      # (if we are done with adding lines of textToFit, then we have our⤶      # successful blurb)⤶⤶      if !@doesTextFitInExtent(fittingText, @originallySetFontSize)⤶⤶        start = 0    # minimum string length that we are gonna examine⤶        stop  = fittingText.length⤶⤶        # since we round the pivot to the floor, we⤶        # always end up start and pivot coinciding⤶        while start != (pivot = Math.floor (start + stop) / 2)⤶⤶          #console.log ＂start/stop/pivot: ＂ + start + ＂ / ＂ + stop + ＂ / ＂ + pivot⤶⤶          textAtPivot = fittingText.substring 0, pivot⤶          itFitsAtPivot = @doesTextFitInExtent textAtPivot, @originallySetFontSize⤶          #console.log ＂  what fits: ＂ + textAtPivot + ＂ fits: ＂ + valueAtPivot⤶⤶          if itFitsAtPivot⤶            #console.log ＂fits at pivot of ＂ + pivot + ＂ : start = pivot now＂⤶            # bring forward the start since there are still⤶            # zeroes at the pivot⤶            start = pivot⤶          else⤶            #console.log ＂doesn't fit at pivot of ＂ + pivot + ＂ : start = pivot now＂⤶            # bring backwards the stop since there is already⤶            # a one at the pivot⤶            stop = pivot⤶⤶        #replace the blurb we just tested with the piece of it that actually⤶        # fits, and that might have a crop in it.⤶        if start != fittingText.length⤶⤶          # todo you should count the newlines⤶          paragraphBeforeWithNewLineHasBeenCropped = false⤶          if fittingText.substr(fittingText.length - 1) == ＂⧹n＂⤶            paragraphBeforeWithNewLineHasBeenCropped = true⤶⤶          reducing = 0⤶          while (start - reducing > 0) and !@doesTextFitInExtent(⤶              @generateTextWithEllipsis(⤶                fittingText.substring(0, start - reducing)⤶                ),⤶              @originallySetFontSize⤶              )⤶            reducing++⤶⤶          if (start - reducing == 0)⤶            if @doesTextFitInExtent ＂…＂, @originallySetFontSize⤶              fittingText = ＂…＂⤶            else⤶              fittingText = ＂＂⤶          else⤶            fittingText = @generateTextWithEllipsis(fittingText.substring 0, start - reducing)⤶⤶          if paragraphBeforeWithNewLineHasBeenCropped⤶            if !@doesTextFitInExtent fittingText + ＂⧹n＂, @originallySetFontSize⤶              break⤶            else⤶              fittingText += ＂⧹n＂⤶⤶          if !@doesTextFitInExtent fittingText, @originallySetFontSize⤶            alert ＂something wrong, this really should have fit: >＂ + fittingText + ＂<＂⤶            debugger⤶            @doesTextFitInExtent fittingText, @originallySetFontSize⤶⤶      #console.log ＂what fits: ＂ + fittingText⤶⤶      # if there is no more space⤶      # for even a single line with the smallest character, then it means⤶      # that just there is no more vertical space, this is really the⤶      # end, then exit the loop, we have the biggest⤶      # possible blurb that we can fit.⤶      #if i != splitText.length - 1⤶      #  if !@doesTextFitInExtent fittingText + ＂⧹n＂, @originallySetFontSize⤶      #    console.log ＂break 2＂⤶      #    break⤶⤶    # we either found the fitting blurb or we are in the⤶    # degenerate case where almost nothing fits⤶⤶    # check degenerate case where (almost) nothing fits⤶    if fittingText.length == 0⤶      if @doesTextFitInExtent ＂…＂, @originallySetFontSize⤶        fittingText = ＂…＂⤶      else⤶        fittingText = ＂＂⤶⤶    #console.log ＂_________fittingText: ＂ + fittingText⤶⤶⤶    return fittingText⤶⤶⤶  synchroniseTextAndActualText: ->⤶    textToFit = @transformTextOneToOne @text⤶    if @doesTextFitInExtent textToFit, @originallySetFontSize⤶      @textPossiblyCroppedToFit = textToFit⤶      #console.log ＂@textPossiblyCroppedToFit = textToFit 1＂⤶    else⤶      if @fittingSpecWhenBoundsTooSmall == FittingSpecTextInSmallerBounds.SCALEDOWN⤶        @textPossiblyCroppedToFit = textToFit⤶        #console.log ＂@textPossiblyCroppedToFit = textToFit 2＂⤶⤶  eliminateInvisibleCharacter: (string) ->⤶    string.replace @emptyCharacter, ''⤶⤶  # there are many factors beyond the font size that affect⤶  # the measuring, such as font style, but we only pass⤶  # the font size here because is the one we are going to⤶  # change when we do the binary search for trying to⤶  # see the largest fitting size.⤶  measureText: (overrideFontSize = @fittingFontSize, text) ->⤶    cacheKey =  @buildCanvasFontProperty(overrideFontSize) + ＂-＂ + hashCode text⤶    cacheHit = world.cacheForTextMeasurements.get cacheKey⤶    if cacheHit? then return cacheHit⤶    world.canvasContextForTextMeasurements.font = @buildCanvasFontProperty overrideFontSize⤶    # you'd think that we don't need to eliminate the invisible character⤶    # to measure the text, as it's supposed to be of zero length.⤶    # Unfortunately some fonts do draw it, so we indeed have to eliminate⤶    # it.⤶    cacheEntry = world.canvasContextForTextMeasurements.measureText(@eliminateInvisibleCharacter text).width⤶    world.cacheForTextMeasurements.set cacheKey, cacheEntry⤶    #if cacheHit?⤶    #  if cacheHit != cacheEntry⤶    #    alert ＂problem with cache on: ＂ + overrideFontSize + ＂-＂ + text + ＂ hit is: ＂ + cacheHit + ＂ should be: ＂ + cacheEntry⤶    return cacheEntry⤶⤶⤶⤶  # this should be a 1-1 transformation.⤶  # for example substitute any letter with ＂*＂ for passwords⤶  # or turn everything to uppercase⤶  transformTextOneToOne: (theText) ->⤶    return (if @isPassword then @obfuscateAsPassword(＂*＂, theText.length) else theText)⤶⤶  # there are many factors beyond the font size that affect⤶  # the measuring, such as font style, but we only pass⤶  # the font size here because is the one we are going to⤶  # change when we do the binary search for trying to⤶  # see the largest fitting size.⤶  doesTextFitInExtent: (text = (@transformTextOneToOne @text), overrideFontSize) ->⤶    if !@measureText?⤶      debugger⤶    if text == ＂＂⤶      return true⤶    extentOccupiedByText = new Point Math.ceil(@measureText overrideFontSize, text), fontHeight(overrideFontSize)⤶⤶    return extentOccupiedByText.le @extent()⤶⤶  fitToExtent: ->⤶    # this if is just to check if the text fits in the⤶    # current extent. If it does, we either leave the size⤶    # as is or we try to⤶    # make the font size bigger if that's the policy.⤶    # If it doesn't fit, then we either crop it or make the⤶    # font smaller.⤶    ⤶    #if !window.globCounter? then window.globCounter = 0⤶    #window.globCounter++⤶    #console.log ＂fitting to extent ＂ + window.globCounter⤶⤶    textToFit = @transformTextOneToOne @text⤶⤶    if @doesTextFitInExtent textToFit, @originallySetFontSize⤶      @textPossiblyCroppedToFit = textToFit⤶      #console.log ＂@textPossiblyCroppedToFit = textToFit 3＂⤶      if @fittingSpecWhenBoundsTooLarge == FittingSpecTextInLargerBounds.SCALEUP⤶        largestFittingFontSize = @searchLargestFittingFont textToFit⤶        return largestFittingFontSize⤶      else⤶        return @originallySetFontSize⤶    else⤶      if @fittingSpecWhenBoundsTooSmall == FittingSpecTextInSmallerBounds.CROP⤶        @textPossiblyCroppedToFit = @searchLongestFittingTextByMultiCroppingIt textToFit⤶        return @originallySetFontSize⤶      else⤶        @textPossiblyCroppedToFit = textToFit⤶        #console.log ＂@textPossiblyCroppedToFit = textToFit 4＂⤶        largestFittingFontSize = @searchLargestFittingFont textToFit⤶        return largestFittingFontSize⤶⤶  calculateTextWidth: (text, overrideFontSize) ->⤶    return @measureText overrideFontSize, text⤶⤶  setFittingFontSize: (theValue) ->⤶    if @fittingFontSize != theValue⤶      @fittingFontSize = theValue⤶      @changed()⤶⤶  createBufferCacheKey: ->⤶    @extent().toString() + ＂-＂ +⤶    @isPassword  + ＂-＂ +⤶    @isShowingBlanks  + ＂-＂ +⤶    @originallySetFontSize + ＂-＂ +⤶    @buildCanvasFontProperty() + ＂-＂ +⤶    @hasDarkOutline + ＂-＂ +⤶    @isHeaderLine + ＂-＂ +⤶    @color.toString()  + ＂-＂ +⤶    (if @backgroundColor? then @backgroundColor.toString() else ＂transp＂) + ＂-＂ +⤶    (if @backgroundTransparency? then @backgroundTransparency.toString() else ＂transp＂) + ＂-＂ +⤶    hashCode(@text)  + ＂-＂ +⤶    hashCode(@textPossiblyCroppedToFit)  + ＂-＂ +⤶    @startMark  + ＂-＂ +⤶    @endMark  + ＂-＂ +⤶    @markedBackgoundColor.toString()  + ＂-＂ +⤶    @horizontalAlignment  + ＂-＂ +⤶    @verticalAlignment  + ＂-＂ +⤶    @fittingSpecWhenBoundsTooLarge  + ＂-＂ +⤶    @fittingSpecWhenBoundsTooSmall⤶⤶  textVerticalPosition: (heightOfText) -> ⤶    switch @verticalAlignment⤶      when AlignmentSpecVertical.TOP⤶        0⤶      when AlignmentSpecVertical.MIDDLE⤶        (@height() - heightOfText)/2⤶      when AlignmentSpecVertical.BOTTOM⤶        @height() - heightOfText⤶⤶  textHorizontalPosition: (widthOfText) ->⤶    switch @horizontalAlignment⤶      when AlignmentSpecHorizontal.LEFT⤶        0⤶      when AlignmentSpecHorizontal.CENTER⤶        @width()/2 - widthOfText/2⤶      when AlignmentSpecHorizontal.RIGHT⤶        @width() - widthOfText⤶⤶⤶  # no changes of position or extent should be⤶  # performed in here⤶  createRefreshOrGetBackBuffer: ->⤶⤶    cacheKey = @createBufferCacheKey @horizontalAlignment, @verticalAlignment⤶    cacheHit = world.cacheForImmutableBackBuffers.get cacheKey⤶    if cacheHit?⤶      # we might have hit a previously cached⤶      # backBuffer but here we are interested in⤶      # knowing whether the buffer we are gonna paint⤶      # is the same as the one being shown now. If⤶      # not, then we mark the caret as broken.⤶      if @backBuffer != cacheHit[0]⤶        if world.caret?⤶          world.caret.changed()      ⤶      return cacheHit⤶⤶    @reflowText()⤶⤶    # if we are calculating a new buffer then⤶    # for sure we have to mark the caret as broken⤶    if world.caret?⤶      world.caret.changed()      ⤶⤶    text = @textPossiblyCroppedToFit⤶    # Initialize my surface property.⤶    # If don't have to paint the background then the surface is just as⤶    # big as the text - which is likely to be smaller than the whole morph⤶    # (because it needs to fit in both height and width, it's likely that⤶    # it's gonna be smaller in one of the two dimensions).⤶    # If, on the other hand, we have to paint the background then the surface is⤶    # as big as the whole morph,⤶    # so potentially we could be wasting some space as the string might⤶    # be really small so to fit, say, the width, while a lot of height of⤶    # the morph could be ＂wasted＂ in memory.⤶    widthOfText = @calculateTextWidth text⤶    heightOfText = fontHeight @fittingFontSize⤶    if @backgroundColor? or⤶     @verticalAlignment != AlignmentSpecVertical.TOP or⤶     @horizontalAlignment != AlignmentSpecHorizontal.LEFT or⤶     @fittingSpecWhenBoundsTooLarge == FittingSpecTextInLargerBounds.FLOAT⤶      width = @width()⤶      height = @height()⤶    else⤶      width = widthOfText⤶      height = heightOfText⤶⤶    backBuffer = newCanvas (new Point width, height).scaleBy ceilPixelRatio⤶⤶    backBufferContext = backBuffer.getContext ＂2d＂⤶⤶    backBufferContext.scale ceilPixelRatio, ceilPixelRatio⤶    backBufferContext.font = @buildCanvasFontProperty()⤶    backBufferContext.textAlign = ＂left＂⤶    backBufferContext.textBaseline = ＂bottom＂⤶⤶    # paint the background so we have a better sense of⤶    # where the text is fitting into.⤶    # paintRectangle here is passed logical pixels⤶    # rather than actual pixels, contrary to how it's used⤶    # most other places. This is because it's inside⤶    # the scope of the ＂scale ceilPixelRatio, ceilPixelRatio＂.⤶    if @backgroundColor⤶      backBufferContext.save()⤶      backBufferContext.fillStyle = @backgroundColor.toString()⤶      backBufferContext.globalAlpha = @backgroundTransparency⤶      backBufferContext.fillRect  0,⤶          0,⤶          Math.round(@width()),⤶          Math.round(@height())⤶      backBufferContext.restore()⤶⤶⤶    textVerticalPosition = @textVerticalPosition(fontHeight @fittingFontSize) + fontHeight(@fittingFontSize)⤶    textHorizontalPosition = @textHorizontalPosition widthOfText⤶⤶    if @hasDarkOutline⤶      backBufferContext.fillStyle = ＂black＂⤶      backBufferContext.fillText text, textHorizontalPosition+0, textVerticalPosition+0⤶      backBufferContext.fillText text, textHorizontalPosition+1.5, textVerticalPosition+0⤶      backBufferContext.fillText text, textHorizontalPosition-1.5, textVerticalPosition+0⤶      backBufferContext.fillText text, textHorizontalPosition+0, textVerticalPosition+1.5⤶      backBufferContext.fillText text, textHorizontalPosition+1.5, textVerticalPosition+1.5⤶      backBufferContext.fillText text, textHorizontalPosition-1.5, textVerticalPosition+1.5⤶      backBufferContext.fillText text, textHorizontalPosition+0, textVerticalPosition-1.5⤶      backBufferContext.fillText text, textHorizontalPosition+1.5, textVerticalPosition-1.5⤶      backBufferContext.fillText text, textHorizontalPosition-1.5, textVerticalPosition-1.5⤶⤶    backBufferContext.fillStyle = @color.toString()⤶    backBufferContext.fillText text, textHorizontalPosition, textVerticalPosition⤶⤶    # header line⤶    if @isHeaderLine⤶      backBufferContext.strokeStyle = new Color 198, 198, 198⤶      backBufferContext.beginPath()⤶      backBufferContext.moveTo 0, textVerticalPosition - heightOfText / 2⤶      backBufferContext.lineTo textHorizontalPosition - 5, textVerticalPosition - heightOfText / 2⤶      backBufferContext.moveTo textHorizontalPosition + widthOfText + 5, textVerticalPosition - heightOfText / 2⤶      backBufferContext.lineTo @width(), textVerticalPosition - heightOfText / 2⤶      backBufferContext.stroke()⤶⤶⤶⤶⤶    @drawSelection backBufferContext⤶⤶    cacheEntry = [backBuffer, backBufferContext]⤶    world.cacheForImmutableBackBuffers.set cacheKey, cacheEntry⤶    return cacheEntry⤶⤶  # Draw the selection. This is done by re-drawing the⤶  # selected text, one character at the time, just with⤶  # a background rectangle.⤶  #⤶  # TODO would really benefit from some batching, it's often the⤶  # case that entire lines can be done in one shot instead of doing⤶  # them char by char. It's not just the painting that is slow, it's⤶  # also the slot coordinates calculations that become quite taxing done⤶  # this way. I profiled this, just see how highlighting gets slower⤶  # and slower as selection gets longer.⤶  #⤶  drawSelection: (backBufferContext) ->⤶    startSlot = @firstSelectedSlot()⤶    endSlot = @lastSelectedSlot()⤶    for i in [startSlot...endSlot]⤶      p = @slotCoordinates(i).subtract @position()⤶      c = @textPossiblyCroppedToFit.charAt(i)⤶      backBufferContext.fillStyle = @markedBackgoundColor.toString()⤶      backBufferContext.fillRect p.x, p.y, Math.ceil(@measureText nil, c) + 1, Math.ceil fontHeight @fittingFontSize⤶      backBufferContext.fillStyle = @markedTextColor.toString()⤶      backBufferContext.fillText c, p.x, p.y + Math.ceil fontHeight @fittingFontSize⤶    ⤶  ⤶  # StringMorph2 measuring:⤶  slotCoordinates: (slot) ->⤶    ⤶    # this makes it so when you type and the string becomes too big⤶    # then the edit stops to be directly in the screen and the⤶    # popout for editing takes over.⤶    if (@transformTextOneToOne @text) != @textPossiblyCroppedToFit and @fittingSpecWhenBoundsTooSmall == FittingSpecTextInSmallerBounds.CROP⤶      world.stopEditing()⤶      @edit()⤶      return nil⤶⤶    # answer the position point of the given index (＂slot＂)⤶    # where the caret should be placed⤶    text = @text⤶⤶    # let's be defensive and check that the⤶    # slot is in the right interval⤶    checkedSlot = Math.min Math.max(slot, 0), text.length⤶    if slot != checkedSlot⤶      alert ＂something wrong - slot is out of range＂⤶    slot = checkedSlot⤶⤶    xOffset = Math.ceil @calculateTextWidth text.substring 0, slot⤶    x = @left() + xOffset⤶    y = @top()⤶⤶    widthOfText = @calculateTextWidth text⤶⤶    textVerticalPosition = @textVerticalPosition fontHeight @fittingFontSize⤶    textHorizontalPosition = @textHorizontalPosition widthOfText⤶⤶    x += textHorizontalPosition⤶    y += textVerticalPosition⤶⤶    new Point x, y⤶⤶  slotAtSingleLineString: (xPosition, text) ->⤶⤶    widthOfText = @calculateTextWidth text⤶    textHorizontalPosition = @textHorizontalPosition widthOfText⤶⤶    xPosition = xPosition - textHorizontalPosition⤶    if xPosition - @left() >= widthOfText⤶      if text[text.length - 1] == '⧹u2063'⤶        return text.length - 1⤶      else⤶        return text.length⤶⤶    # answer the slot (index) closest to the given point⤶    # so the caret can be moved accordingly⤶    idx = 0⤶    charX = 0⤶⤶    # This code to pick the correct slot works but it's⤶    # way too convoluted, as I arrived to this⤶    # tweaking it by trial and error rather than by smarts.⤶    # TODO Probably need a little patience to rewrite, I got⤶    # other parts to move on to now.⤶    while true⤶      if charX > xPosition - @left()⤶        #console.log ＂xPosition - @left(): ＂ + (xPosition - @left()) + ＂ charXMinusOne ＂ + charXMinusOne + ＂  charX ＂ + charX ⤶        #console.log ＂Math.abs(xPosition - @left() - charXMinusOne) ＂ + Math.abs(xPosition - @left() - charXMinusOne) + ＂  Math.abs(xPosition - @left() - charX) ＂ + Math.abs(xPosition - @left() - charX) ⤶        if Math.abs(xPosition - @left() - charXMinusOne) < Math.abs(xPosition - @left() - charX)⤶          return idx - 1⤶        break⤶⤶      charXMinusOne = charX⤶      charX += @calculateTextWidth text[idx]⤶⤶      idx += 1⤶      if idx is text.length⤶        if ((@calculateTextWidth(text)) - ((@calculateTextWidth(text[idx-1])) / 2)) < (xPosition - @left())  ⤶          return idx⤶    idx⤶⤶  pointIsAboveFirstLine: (aPoint) ->⤶    textVerticalPosition = @textVerticalPosition fontHeight @fittingFontSize⤶⤶    if aPoint.y - @top() < textVerticalPosition⤶      return 0⤶⤶    return false⤶⤶  pointIsUnderLastLine: (aPoint) ->⤶    textVerticalPosition = @textVerticalPosition(fontHeight @fittingFontSize) + fontHeight(@fittingFontSize)⤶⤶    # if pointer is below the line, the slot is at⤶    # the last character.⤶    if (aPoint.y - textVerticalPosition) - @top() > Math.ceil fontHeight @fittingFontSize⤶      return @textPossiblyCroppedToFit.length⤶⤶    return false⤶  ⤶  slotAt: (aPoint) ->⤶    if (isPointBeforeFirstLine = @pointIsAboveFirstLine aPoint) != false⤶      return isPointBeforeFirstLine⤶⤶    if (isPointUnderLastLine = @pointIsUnderLastLine aPoint) != false⤶      return isPointUnderLastLine⤶⤶    return @slotAtSingleLineString aPoint.x, @textPossiblyCroppedToFit⤶  ⤶  upFrom: (slot) ->⤶    @startOfLine()⤶  ⤶  downFrom: (slot) ->⤶    @endOfLine()⤶  ⤶  startOfLine: ->⤶    # answer the first slot (index) of the line for the given slot⤶    0⤶  ⤶  endOfLine: ->⤶    # answer the slot (index) indicating the EOL for the given slot⤶    @textPossiblyCroppedToFit.length⤶⤶  fontSizePopup: (menuItem)->⤶    @prompt menuItem.parent.title + ＂⧹nfont⧹nsize:＂,⤶      @,⤶      ＂setFontSize＂,⤶      @originallySetFontSize.toString(),⤶      nil, 6, 500, true⤶⤶  editPopup: (menuItem)->⤶    if menuItem?⤶      title = menuItem.parent.title + ＂⧹nedit:＂⤶    else⤶      title = ＂edit:＂⤶⤶    @prompt title,⤶      @,⤶      ＂setText＂,⤶      @text,⤶      nil, 6, nil, true⤶⤶  setFontName: (menuItem, ignored2, theNewFontName) ->⤶    if @fontName != theNewFontName⤶      @fontName = theNewFontName⤶      @changed()⤶⤶      if menuItem?.parent? and (menuItem.parent instanceof MenuMorph)⤶        @updateFontsMenuEntriesTicks menuItem.parent⤶⤶⤶  fontsMenu: (a,targetMorph)->⤶    menu = new MenuMorph @, false, targetMorph, true, true, ＂Fonts＂⤶⤶    menu.addMenuItem untick + ＂Arial＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, @justArialFontStack⤶    menu.addMenuItem untick + ＂Times＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, @timesFontStack⤶    menu.addMenuItem untick + ＂Georgia＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, @georgiaFontStack⤶    menu.addMenuItem untick + ＂Garamo＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, @garamoFontStack⤶    menu.addMenuItem untick + ＂Helve＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, @helveFontStack⤶    menu.addMenuItem untick + ＂Verda＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, @verdaFontStack⤶    menu.addMenuItem untick + ＂Treby＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, @trebuFontStack⤶    menu.addMenuItem untick + ＂Heavy＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, @heavyFontStack⤶    menu.addMenuItem untick + ＂Mono＂, true, @, ＂setFontName＂, nil, nil, nil, nil, nil, @monoFontStack⤶⤶    @updateFontsMenuEntriesTicks menu⤶⤶    menu.popUpAtHand()⤶⤶  # cheap way to keep menu consistency when pinned⤶  # note that there is no consistency in case⤶  # there are multiple copies of this menu changing⤶  # the property, since there is no real subscription⤶  # of a menu to react to property change coming⤶  # from other menus or other means (e.g. API)...⤶  updateFontsMenuEntriesTicks: (menu) ->⤶    justArialFontStackTick = timesFontStackTick = georgiaFontStackTick =⤶    garamoFontStackTick = helveFontStackTick = verdaFontStackTick =⤶    trebuFontStackTick = heavyFontStackTick = monoFontStackTick = untick⤶⤶⤶    switch @fontName⤶      when @justArialFontStack⤶        justArialFontStackTick = tick⤶      when @timesFontStack⤶        timesFontStackTick = tick⤶      when @georgiaFontStack⤶        georgiaFontStackTick = tick⤶      when @garamoFontStack⤶        garamoFontStackTick = tick⤶      when @helveFontStack⤶        helveFontStackTick = tick⤶      when @verdaFontStack⤶        verdaFontStackTick = tick⤶      when @trebuFontStack⤶        trebuFontStackTick = tick⤶      when @heavyFontStack⤶        heavyFontStackTick = tick⤶      when @monoFontStack⤶        monoFontStackTick = tick⤶⤶    menu.children[1].label.setText justArialFontStackTick + ＂Arial＂⤶    menu.children[2].label.setText timesFontStackTick + ＂Times＂⤶    menu.children[3].label.setText georgiaFontStackTick + ＂Georgia＂⤶    menu.children[4].label.setText garamoFontStackTick + ＂Garamo＂⤶    menu.children[5].label.setText helveFontStackTick + ＂Helve＂⤶    menu.children[6].label.setText verdaFontStackTick + ＂Verda＂⤶    menu.children[7].label.setText trebuFontStackTick + ＂Treby＂⤶    menu.children[8].label.setText heavyFontStackTick + ＂Heavy＂⤶    menu.children[9].label.setText monoFontStackTick + ＂Mono＂⤶⤶⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    menu.addLine()⤶    menu.addMenuItem ＂edit...＂, true, @, ＂editPopup＂, ＂set this String's⧹ncontent＂⤶    menu.addMenuItem ＂font size...＂, true, @, ＂fontSizePopup＂, ＂set this String's⧹nfont point size＂⤶⤶    menu.addMenuItem ＂font ➜＂, false, @, ＂fontsMenu＂, ＂pick a font＂⤶⤶    if @isBold⤶      menu.addMenuItem ＂normal weight＂, true, @, ＂toggleWeight＂⤶    else⤶      menu.addMenuItem ＂bold＂, true, @, ＂toggleWeight＂⤶⤶    if @isItalic⤶      menu.addMenuItem ＂non-italic＂, true, @, ＂toggleItalic＂⤶    else⤶      menu.addMenuItem ＂italic＂, true, @, ＂toggleItalic＂⤶⤶    if @isHeaderLine⤶      menu.addMenuItem ＂no header line＂, true, @, ＂toggleHeaderLine＂⤶    else⤶      menu.addMenuItem ＂header line＂, true, @, ＂toggleHeaderLine＂⤶⤶⤶    if @isPassword⤶      menu.addMenuItem ＂show characters＂, true, @, ＂toggleIsPassword＂⤶    else⤶      menu.addMenuItem ＂hide characters＂, true, @, ＂toggleIsPassword＂⤶⤶    menu.addLine()⤶    if @horizontalAlignment != AlignmentSpecHorizontal.LEFT⤶      menu.addMenuItem ＂← align left＂, true, @, ＂alignLeft＂⤶    if @horizontalAlignment != AlignmentSpecHorizontal.CENTER⤶      menu.addMenuItem ＂∸ align center＂, true, @, ＂alignCenter＂⤶    if @horizontalAlignment != AlignmentSpecHorizontal.RIGHT⤶      menu.addMenuItem ＂→ align right＂, true, @, ＂alignRight＂⤶⤶    menu.addLine()⤶    if @verticalAlignment != AlignmentSpecVertical.TOP⤶      menu.addMenuItem ＂↑ align top＂, true, @, ＂alignTop＂⤶    if @verticalAlignment != AlignmentSpecVertical.MIDDLE⤶      menu.addMenuItem ＂⍿ align middle＂, true, @, ＂alignMiddle＂⤶    if @verticalAlignment != AlignmentSpecVertical.BOTTOM⤶      menu.addMenuItem ＂↓ align bottom＂, true, @, ＂alignBottom＂⤶⤶    menu.addLine()⤶⤶    if @fittingSpecWhenBoundsTooLarge == FittingSpecTextInLargerBounds.SCALEUP⤶      menu.addMenuItem ＂←☓→ don't expand to fill＂, true, @, ＂togglefittingSpecWhenBoundsTooLarge＂⤶    else⤶      menu.addMenuItem ＂←→ expand to fill＂, true, @, ＂togglefittingSpecWhenBoundsTooLarge＂⤶⤶    if @fittingSpecWhenBoundsTooSmall == FittingSpecTextInSmallerBounds.CROP⤶      menu.addMenuItem ＂→← shrink to fit＂, true, @, ＂togglefittingSpecWhenBoundsTooSmall＂⤶    else⤶      menu.addMenuItem ＂→⋯← crop to fit＂, true, @, ＂togglefittingSpecWhenBoundsTooSmall＂⤶⤶    if world.isIndexPage⤶      menu.addLine()⤶      if world.isIndexPage⤶        menu.addMenuItem ＂connect to ➜＂, true, @, ＂openTargetSelector＂, ＂connect to⧹nanother widget＂⤶      else⤶        menu.addMenuItem ＂set target＂, true, @, ＂openTargetSelector＂, ＂choose another morph⧹nwhose numerical property⧹n will be＂ + ＂ controlled by this one＂⤶⤶⤶  togglefittingSpecWhenBoundsTooSmall: ->⤶    @fittingSpecWhenBoundsTooSmall = not @fittingSpecWhenBoundsTooSmall⤶    @changed()⤶    world.stopEditing()⤶⤶  togglefittingSpecWhenBoundsTooLarge: ->⤶    world.stopEditing()⤶    @fittingSpecWhenBoundsTooLarge = not @fittingSpecWhenBoundsTooLarge⤶    @changed()⤶⤶  ⤶  toggleShowBlanks: ->⤶    @isShowingBlanks = not @isShowingBlanks⤶    @changed()⤶  ⤶  toggleWeight: ->⤶    @isBold = not @isBold⤶    @changed()⤶  ⤶  toggleItalic: ->⤶    @isItalic = not @isItalic⤶    @changed()⤶⤶  toggleHeaderLine: ->⤶    @isHeaderLine = not @isHeaderLine⤶    @changed()⤶  ⤶  toggleIsPassword: ->⤶    world.stopEditing()⤶    @isPassword = not @isPassword⤶    @changed()⤶⤶  changed: ->⤶    super⤶    if world.caret?⤶      world.caret.changed()⤶  ⤶  # adjust the data models behind the text. E.g.⤶  # is it going to be shown as cropped? What size⤶  # is it going to be? How is the text broken down⤶  # into rows?⤶  # this method doesn't draw anything.⤶  reflowText: ->⤶    @synchroniseTextAndActualText()⤶    @setFittingFontSize @fitToExtent()⤶⤶  # This is also invoked for example when you take a slider⤶  # and set it to target this.⤶  setText: (theTextContent, stringFieldMorph, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken⤶    if stringFieldMorph?⤶      # in this case, the stringFieldMorph has a⤶      # StringMorph in ＂text＂. The StringMorph has the⤶      # ＂text＂ inside it.⤶      theTextContent = stringFieldMorph.text.text⤶⤶    theNewText = theTextContent + ＂＂⤶    if @text != theNewText⤶      # other morphs might send something like a⤶      # number or a color so let's make sure we⤶      # convert to a string.⤶      @clearSelection()⤶      @text = theNewText⤶      @checkIfTextContentWasModifiedFromTextAtStart()⤶      @synchroniseTextAndActualText()⤶      @changed()⤶⤶    @updateTarget()⤶⤶  considerCurrentTextAsReferenceText: ->⤶    @hashOfTextConsideredAsReference = hashCode @text⤶⤶  checkIfTextContentWasModifiedFromTextAtStart: ->⤶    if @widgetToBeNotifiedOfTextModificationChange?⤶      if @hashOfTextConsideredAsReference == hashCode @text⤶        @widgetToBeNotifiedOfTextModificationChange.textContentUnmodified?()⤶      else⤶        @widgetToBeNotifiedOfTextModificationChange.textContentModified?()⤶  ⤶  setFontSize: (sizeOrMorphGivingSize, morphGivingSize) ->⤶    if morphGivingSize?.getValue?⤶      size = morphGivingSize.getValue()⤶    else⤶      size = sizeOrMorphGivingSize⤶⤶    if typeof size is ＂number＂⤶      newSize = Math.round Math.min Math.max(size, 4), 500⤶    else⤶      newSize = parseFloat size⤶      newSize = Math.round Math.min Math.max(newSize, 4), 500  unless isNaN newSize⤶⤶    if newSize != @originallySetFontSize⤶      @originallySetFontSize = newSize⤶      @changed()⤶  ⤶  openTargetPropertySelector: (ignored, ignored2, theTarget) ->⤶    [menuEntriesStrings, functionNamesStrings] = theTarget.stringSetters()⤶    menu = new MenuMorph @, false, @, true, true, ＂choose target property:＂⤶    for i in [0...menuEntriesStrings.length]⤶      menu.addMenuItem menuEntriesStrings[i], true, @, ＂setTargetAndActionWithOnesPickedFromMenu＂, nil, nil, nil, nil, nil, theTarget, functionNamesStrings[i]⤶    if menuEntriesStrings.length == 0⤶      menu = new MenuMorph @, false, @, true, true, ＂no target properties available＂⤶    menu.popUpAtHand()⤶  ⤶  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂alpha 0-100＂, ＂font size＂, ＂text＂⤶    functionNamesStrings.push ＂setAlphaScaled＂, ＂setFontSize＂, ＂setText＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶  ⤶  stringSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂bang!＂, ＂text＂⤶    functionNamesStrings.push ＂bang＂, ＂setText＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  updateTarget: ->⤶    if @action and @action != ＂＂⤶      @target[@action].call @target, @text, nil, @connectionsCalculationToken⤶    return⤶⤶  reactToTargetConnection: ->⤶    @updateTarget()⤶⤶  ⤶  # StringMorph2 editing:⤶  edit: ->⤶    if @textPossiblyCroppedToFit == @transformTextOneToOne @text⤶      world.edit @⤶      return true⤶    else⤶      @editPopup()⤶      return nil⤶⤶  selection: ->⤶    start = Math.min @startMark, @endMark⤶    stop = Math.max @startMark, @endMark⤶    @text.slice start, stop⤶  ⤶  firstSelectedSlot: ->⤶    if !@startMark? or !@endMark?⤶      return nil⤶    return Math.min @startMark, @endMark⤶⤶  lastSelectedSlot: ->⤶    if !@startMark? or !@endMark?⤶      return nil⤶    return Math.max @startMark, @endMark⤶⤶  currentlySelecting: ->⤶    if !@startMark? and !@endMark?⤶     return false⤶    return true⤶  ⤶  clearSelection: ->⤶    if !@startMark? and !@endMark?⤶      return⤶    @startMark = nil⤶    @endMark = nil⤶    @changed()⤶⤶  setEndMark: (slot) ->⤶    @endMark = slot⤶    @changed()⤶  ⤶  selectBetween: (start, end) ->⤶    @startMark = Math.min start, end⤶    @endMark = Math.max start, end⤶    @changed()⤶  ⤶  deleteSelection: ->⤶    start = Math.min @startMark, @endMark⤶    stop = Math.max @startMark, @endMark⤶    @setText @text.slice(0, start) + @text.slice(stop)⤶⤶  selectAll: ->⤶    @startMark = 0⤶    @endMark = @textPossiblyCroppedToFit.length    ⤶    @changed()⤶⤶  # used when shift-clicking somewhere when there is⤶  # no selection ongoing⤶  startSelectionUpToSlot: (previousCaretSlot, slotToExtendTo) ->⤶    @startMark = previousCaretSlot⤶    @endMark = slotToExtendTo⤶    @changed()⤶⤶  # used when shift-clicking somewhere when there is⤶  # already a selection ongoing⤶  extendSelectionUpToSlot: (slotToExtendTo) ->⤶    @endMark = slotToExtendTo⤶    @changed()⤶⤶  mouseDoubleClick: ->⤶    if @isEditable⤶      previousCaretSlot = world.caret?.slot⤶⤶      extendRight = 0⤶      while previousCaretSlot + extendRight < @text.length⤶        if !@text[previousCaretSlot + extendRight].isLetter()⤶          break⤶        extendRight++⤶⤶      extendLeft = 0⤶      while previousCaretSlot + extendLeft - 1 >= 0⤶        if !@text[previousCaretSlot + extendLeft - 1].isLetter()⤶          break⤶        extendLeft--⤶⤶      @selectBetween (previousCaretSlot + extendLeft), (previousCaretSlot + extendRight)⤶      world.caret?.gotoSlot (previousCaretSlot + extendRight)⤶⤶  mouseTripleClick: ->⤶    if @isEditable⤶      @selectAll()⤶      world.caret?.gotoSlot @text.length⤶⤶⤶  # Every time the user clicks on the text, a new edit()⤶  # is triggered, which creates a new caret.⤶  mouseClickLeft: (pos, ignored_button, ignored_buttons, ignored_ctrlKey, shiftKey, ignored_altKey, ignored_metaKey) ->⤶    @bringToForeground()⤶    world.caret?.bringToForeground()⤶    if @isEditable⤶      # doesn't matter what we set editResult to initially,⤶      # just not undefined or nil cause that's⤶      # going to be significant⤶      editResult = true⤶      previousCaretSlot = world.caret?.slot⤶      if !@currentlySelecting()⤶        editResult = @edit()⤶      slotUserClickedOn = @slotAt pos⤶⤶      if shiftKey⤶        if @currentlySelecting()⤶          @extendSelectionUpToSlot slotUserClickedOn⤶        else⤶          if previousCaretSlot?⤶            @startSelectionUpToSlot previousCaretSlot, slotUserClickedOn⤶      else⤶        @clearSelection()⤶⤶      if editResult?⤶        world.caret.gotoSlot slotUserClickedOn, true⤶        world.caret.show()⤶        @caretHorizPositionForVertMovement = world.caret.slot⤶⤶    else⤶      @escalateEvent ＂mouseClickLeft＂, pos⤶  ⤶  enableSelecting: ->⤶    @mouseDownLeft = (pos) ->⤶      @clearSelection()⤶      if @isEditable and !@grabsToParentWhenDragged()⤶        @edit()⤶        world.caret.gotoPos pos⤶        @startMark = @slotAt pos⤶        @endMark = @startMark⤶    ⤶    @mouseMove = (pos) ->⤶      if @isEditable and @currentlySelecting()⤶        newMark = @slotAt pos⤶        if newMark isnt @endMark⤶          @endMark = newMark⤶          @changed()⤶      else⤶        @disableSelecting()⤶  ⤶  disableSelecting: ->⤶    # re-establish the original definition of the method⤶    @clearSelection()⤶    @mouseDownLeft = StringMorph2::mouseDownLeft⤶    delete @mouseMove⤶⤶⤶  ".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.TextMorph_coffeSource = "# these comments below needed to figure out dependencies between classes⤶⤶# I am a multi-line, word-wrapping String⤶⤶⤶class TextMorph extends StringMorph⤶⤶  words: []⤶  lines: []⤶  lineSlots: []⤶  alignment: nil⤶  maxTextWidth: nil⤶  maxLineWidth: 0⤶  backgroundColor: nil⤶⤶  #additional properties for ad-hoc evaluation:⤶  receiver: nil⤶⤶  constructor: (⤶   @text = ＂TextMorph＂,⤶   @fontSize = 12,⤶   @fontStyle = ＂sans-serif＂,⤶   @isBold = false,⤶   @isItalic = false,⤶   @alignment = ＂left＂,⤶   @maxTextWidth = 0,⤶   @fontName = ＂＂,⤶   @shadowOffset = (new Point 0, 0),⤶   @shadowColor = nil⤶   ) ->⤶⤶    super ⧹⤶      @text,⤶      @fontSize,⤶      @fontStyle,⤶      @isBold,⤶      @isItalic,⤶      nil,⤶      @shadowOffset,⤶      @shadowColor,⤶      nil,⤶      @fontName⤶    # override inherited properties:⤶    @markedTextColor = new Color 255, 255, 255⤶    @markedBackgoundColor = new Color 60, 60, 120⤶    @color = new Color 0, 0, 0⤶    @noticesTransparentClick = true⤶  ⤶  breakTextIntoLines: ->⤶    paragraphs = @text.split ＂⧹n＂⤶    canvas = newCanvas()⤶    context = canvas.getContext ＂2d＂⤶    context.scale ceilPixelRatio, ceilPixelRatio⤶    currentLine = ＂＂⤶    slot = 0⤶    context.font = @buildCanvasFontProperty()⤶    @maxLineWidth = 0⤶    @lines = []⤶    @lineSlots = [0]⤶    @words = []⤶    ⤶    # put all the text in an array, word by word⤶    paragraphs.forEach (p) =>⤶      @words = @words.concat p.split ＂ ＂⤶      @words.push ＂⧹n＂⤶⤶    # takes the text, word by word, and re-flows⤶    # it according to the available width for the⤶    # text (if there is such limit).⤶    # The end result is an array of lines⤶    # called @lines, which contains the string for⤶    # each line (excluding the end of lines).⤶    # Also another array is created, called⤶    # @lineSlots, which memorises how many characters⤶    # of the text have been consumed up to each line⤶    #  example: original text: ＂Hello⧹nWorld＂⤶    # then @lines[0] = ＂Hello＂ @lines[1] = ＂World＂⤶    # and @lineSlots[0] = 6, @lineSlots[1] = 11⤶    # Note that this algorithm doesn't work in case⤶    # of single non-spaced words that are longer than⤶    # the allowed width.⤶    @words.forEach (word) =>⤶      if word is ＂⧹n＂⤶        # we reached the end of the line in the⤶        # original text, so push the line and the⤶        # slots count in the arrays⤶        @lines.push currentLine⤶        @lineSlots.push slot⤶        @maxLineWidth = Math.max @maxLineWidth, Math.ceil context.measureText(currentLine).width⤶        currentLine = ＂＂⤶      else⤶        if @maxTextWidth > 0⤶          # there is a width limit, so we need⤶          # to check whether we overflowed it. So create⤶          # a prospective line and then check its width.⤶          lineForOverflowTest = currentLine + word + ＂ ＂⤶          w = Math.ceil(context.measureText(lineForOverflowTest).width)⤶          if w > @maxTextWidth⤶            # ok we just overflowed the available space,⤶            # so we need to push the old line and its⤶            # ＂slot＂ number to the respective arrays.⤶            # the new line is going to only contain the⤶            # word that has caused the overflow.⤶            @lines.push currentLine⤶            @lineSlots.push slot⤶            @maxLineWidth = Math.max @maxLineWidth, Math.ceil context.measureText(currentLine).width⤶            currentLine = word + ＂ ＂⤶          else⤶            # no overflow happened, so just proceed as normal⤶            currentLine = lineForOverflowTest⤶        else⤶          currentLine = currentLine + word + ＂ ＂⤶        slot += word.length + 1⤶  ⤶⤶  reLayout: ->⤶    super()⤶    ANimage = newCanvas()⤶    context = ANimage.getContext ＂2d＂⤶    context.font = @buildCanvasFontProperty()⤶    @breakTextIntoLines()⤶⤶    shadowWidth = Math.abs @shadowOffset.x⤶    shadowHeight = Math.abs @shadowOffset.y⤶    height = @lines.length * (Math.ceil(fontHeight @fontSize) + shadowHeight)⤶    if @maxTextWidth is 0⤶      @silentRawSetExtent new Point @maxLineWidth + shadowWidth, height⤶    else⤶      @silentRawSetExtent new Point @maxTextWidth + shadowWidth, height⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶  # no changes of position or extent should be⤶  # performed in here⤶  createRefreshOrGetBackBuffer: ->⤶⤶    cacheKey =⤶      @extent().toString()  + ＂-＂ +⤶      @buildCanvasFontProperty()  + ＂-＂ +⤶      @alignment  + ＂-＂ +⤶      @backgroundColor?.toString()  + ＂-＂ +⤶      @color.toString()  + ＂-＂ +⤶      hashCode(@text)  + ＂-＂ +⤶      @startMark  + ＂-＂ +⤶      @endMark  + ＂-＂ +⤶      @markedBackgoundColor.toString()⤶⤶    cacheHit = world.cacheForImmutableBackBuffers.get cacheKey⤶    if cacheHit? then return cacheHit⤶⤶⤶    backBuffer = newCanvas()⤶    backBufferContext = backBuffer.getContext ＂2d＂⤶⤶    shadowWidth = Math.abs @shadowOffset.x⤶    shadowHeight = Math.abs @shadowOffset.y⤶⤶⤶    backBuffer.width = @width() * ceilPixelRatio⤶    backBuffer.height = @height() * ceilPixelRatio⤶⤶    # changing the canvas size resets many of⤶    # the properties of the canvas, so we need to⤶    # re-initialise the font and alignments here⤶    backBufferContext.scale ceilPixelRatio, ceilPixelRatio⤶    backBufferContext.font = @buildCanvasFontProperty()⤶    backBufferContext.textAlign = ＂left＂⤶    backBufferContext.textBaseline = ＂bottom＂⤶⤶    # fill the background, if desired⤶    if @backgroundColor⤶      backBufferContext.fillStyle = @backgroundColor.toString()⤶      backBufferContext.fillRect 0, 0, @width(), @height()⤶⤶    # draw the shadow, if any⤶    if @shadowColor⤶      offx = Math.max @shadowOffset.x, 0⤶      offy = Math.max @shadowOffset.y, 0⤶      #console.log 'shadow x: ' + offx + ＂ y: ＂ + offy⤶      backBufferContext.fillStyle = @shadowColor.toString()⤶      i = 0⤶      for line in @lines⤶        width = Math.ceil(backBufferContext.measureText(line).width) + shadowWidth⤶        x = switch @alignment⤶          when ＂right＂⤶            @width() - width⤶          when ＂center＂⤶            (@width() - width) / 2⤶          else # 'left'⤶            0⤶        y = (i + 1) * (Math.ceil(fontHeight @fontSize) + shadowHeight) - shadowHeight⤶        i++⤶        backBufferContext.fillText line, x + offx, y + offy⤶⤶    # now draw the actual text⤶    offx = Math.abs Math.min @shadowOffset.x, 0⤶    offy = Math.abs Math.min @shadowOffset.y, 0⤶    #console.log 'maintext x: ' + offx + ＂ y: ＂ + offy⤶    backBufferContext.fillStyle = @color.toString()⤶    i = 0⤶    for line in @lines⤶      width = Math.ceil(backBufferContext.measureText(line).width) + shadowWidth⤶      x = switch @alignment⤶        when ＂right＂⤶          @width() - width⤶        when ＂center＂⤶          (@width() - width) / 2⤶        else # 'left'⤶          0⤶      y = (i + 1) * (Math.ceil(fontHeight @fontSize) + shadowHeight) - shadowHeight⤶      i++⤶      backBufferContext.fillText line, x + offx, y + offy⤶⤶    # Draw the selection. This is done by re-drawing the⤶    # selected text, one character at the time, just with⤶    # a background rectangle.⤶    start = Math.min @startMark, @endMark⤶    stop = Math.max @startMark, @endMark⤶    for i in [start...stop]⤶      p = @slotCoordinates(i).subtract @position()⤶      c = @text.charAt i⤶      backBufferContext.fillStyle = @markedBackgoundColor.toString()⤶      backBufferContext.fillRect p.x, p.y, Math.ceil(backBufferContext.measureText(c).width) + 1, Math.ceil(fontHeight @fontSize)⤶      backBufferContext.fillStyle = @markedTextColor.toString()⤶      backBufferContext.fillText c, p.x, p.y + Math.ceil fontHeight @fontSize⤶⤶    cacheEntry = [backBuffer, backBufferContext]⤶    world.cacheForImmutableBackBuffers.set cacheKey, cacheEntry⤶    return cacheEntry⤶  ⤶  rawSetExtent: (aPoint) ->⤶    unless aPoint.eq @extent()⤶      #console.log ＂move 18＂⤶      @breakNumberOfRawMovesAndResizesCaches()⤶      @maxTextWidth = Math.max aPoint.x, 0⤶      @reLayout()⤶      @changed()⤶  ⤶  # TextMorph measuring ////⤶⤶  # answer the logical position point of the given index (＂slot＂)⤶  # i.e. the row and the column where a particular character is.⤶  slotRowAndColumn: (slot) ->⤶    idx = 0⤶    # Note that this solution scans all the characters⤶    # in all the rows up to the slot. This could be⤶    # done a lot quicker by stopping at the first row⤶    # such that @lineSlots[theRow] <= slot⤶    # You could even do a binary search if one really⤶    # wanted to, because the contents of @lineSlots are⤶    # in order, as they contain a cumulative count...⤶    for row in [0...@lines.length]⤶      idx = @lineSlots[row]⤶      for col in [0...@lines[row].length]⤶        return [row, col]  if idx is slot⤶        idx += 1⤶    [@lines.length - 1, @lines[@lines.length - 1].length - 1]⤶  ⤶  # Answer the position (in pixels) of the given index (＂slot＂)⤶  # where the caret should be placed.⤶  # This is in absolute world coordinates.⤶  # This function assumes that the text is left-justified.⤶  slotCoordinates: (slot) ->⤶    [slotRow, slotColumn] = @slotRowAndColumn slot⤶    shadowHeight = Math.abs @shadowOffset.y⤶    yOffset = slotRow * (Math.ceil(fontHeight @fontSize) + shadowHeight)⤶    xOffset = Math.ceil @backBufferContext.measureText((@lines[slotRow]).substring(0,slotColumn)).width⤶    x = @left() + xOffset⤶    y = @top() + yOffset⤶    new Point x, y⤶  ⤶  # Returns the slot (index) closest to the given point⤶  # so the caret can be moved accordingly⤶  # This function assumes that the text is left-justified.⤶  slotAt: (aPoint) ->⤶    charX = 0⤶    row = 0⤶    col = 0⤶    shadowHeight = Math.abs @shadowOffset.y⤶    row += 1  while aPoint.y - @top() > (Math.ceil(fontHeight @fontSize) + shadowHeight) * row⤶    row = Math.max row, 1⤶    while aPoint.x - @left() > charX⤶      charX += Math.ceil @backBufferContext.measureText(@lines[row - 1][col]).width⤶      col += 1⤶    @lineSlots[Math.max(row - 1, 0)] + col - 1⤶  ⤶  upFrom: (slot) ->⤶    # answer the slot above the given one⤶    [slotRow, slotColumn] = @slotRowAndColumn slot⤶    return slot  if slotRow < 1⤶    above = @lines[slotRow - 1]⤶    return @lineSlots[slotRow - 1] + above.length  if above.length < slotColumn - 1⤶    @lineSlots[slotRow - 1] + slotColumn⤶  ⤶  downFrom: (slot) ->⤶    # answer the slot below the given one⤶    [slotRow, slotColumn] = @slotRowAndColumn slot⤶    return slot  if slotRow > @lines.length - 2⤶    below = @lines[slotRow + 1]⤶    return @lineSlots[slotRow + 1] + below.length  if below.length < slotColumn - 1⤶    @lineSlots[slotRow + 1] + slotColumn⤶  ⤶  startOfLine: (slot) ->⤶    # answer the first slot (index) of the line for the given slot⤶    @lineSlots[@slotRowAndColumn(slot).y]⤶  ⤶  endOfLine: (slot) ->⤶    # answer the slot (index) indicating the EOL for the given slot⤶    @startOfLine(slot) + @lines[@slotRowAndColumn(slot).y].length - 1⤶  ⤶  # TextMorph menus:⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    menu.addLine()⤶    menu.addMenuItem ＂align left＂, true, @, ＂setAlignmentToLeft＂  if @alignment isnt ＂left＂⤶    menu.addMenuItem ＂align right＂, true, @, ＂setAlignmentToRight＂  if @alignment isnt ＂right＂⤶    menu.addMenuItem ＂align center＂, true, @, ＂setAlignmentToCenter＂  if @alignment isnt ＂center＂⤶    menu.addMenuItem ＂run contents＂, true, @, ＂doContents＂⤶  ⤶  setAlignmentToLeft: ->⤶    @alignment = ＂left＂⤶    @reLayout()⤶    @changed()⤶  ⤶  setAlignmentToRight: ->⤶    @alignment = ＂right＂⤶    @reLayout()⤶    @changed()⤶  ⤶  setAlignmentToCenter: ->⤶    @alignment = ＂center＂⤶    @reLayout()⤶    @changed()  ⤶  ⤶  # TextMorph evaluation:⤶  evaluationMenu: ->⤶    menu = @buildHierarchyMenu()⤶⤶    if @text.length > 0⤶      menu.prependLine()⤶      menu.prependMenuItem ＂select all＂, true, @, ＂selectAllAndEdit＂⤶      menu.prependMenuItem ＂do all＂, true, @, ＂doAll＂⤶⤶    # only show the do it / show it / inspect it entries⤶    # if there is actually something selected.⤶    if @selection().replace(/^⧹s⧹s*/, '').replace(/⧹s⧹s*$/, '') != ''⤶      menu.prependLine()⤶      menu.prependMenuItem ＂inspect selection＂, true, @, ＂inspectSelection＂, ＂evaluate the⧹nselected expression⧹nand inspect the result＂⤶      menu.prependMenuItem ＂show selection＂, true, @, ＂showSelection＂, ＂evaluate the⧹nselected expression⧹nand show the result＂⤶      menu.prependMenuItem ＂do selection＂, true, @, ＂doSelection＂, ＂evaluate the⧹nselected expression＂⤶    menu⤶⤶  selectAllAndEdit: ->⤶    @edit()⤶    @selectAll()⤶⤶  # TODO this can be done more⤶  # abstractly, bypassing the⤶  # actual selection and doSelection...⤶  doAll: ->⤶    @edit()⤶    @selectAll()⤶    @doSelection()⤶    @clearSelection()⤶⤶  # this is set by the inspector. It tells the TextMorph⤶  # that any following doSelection/showSelection/inspectSelection⤶  # action needs to be done apropos a particular obj,⤶  # and also replaces the normal context menu with the evaluation Menu⤶  # because if you right click in these panes of the Inspector you⤶  # want to ＂run＂ code that has been typed⤶  setReceiver: (obj) ->⤶    @receiver = obj⤶    @overridingContextMenu = @evaluationMenu⤶  ⤶  doSelection: ->⤶    @receiver.evaluateString @selection()⤶    @edit()⤶⤶  doContents: ->⤶    if @receiver?⤶      @receiver.evaluateString @text⤶    else⤶      @evaluateString @text⤶⤶  showSelection: ->⤶    result = @receiver.evaluateString @selection()⤶    if result? then @inform result⤶  ⤶  inspectSelection: ->⤶    # evaluateString is a pimped-up eval in⤶    # the Widget class.⤶    result = @receiver.evaluateString @selection()⤶    if result? then @spawnInspector result⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.TextMorph2_coffeSource = "# these comments below needed to figure out dependencies between classes⤶# REQUIRES LRUCache⤶⤶# A multi-line, word-wrapping String⤶⤶class TextMorph2 extends StringMorph2⤶⤶  wrappedLines: []⤶  wrappedLineSlots: []⤶  softWrap: true⤶  #emptyCharacter: '^'⤶⤶  backgroundColor: nil⤶⤶  #additional properties for ad-hoc evaluation:⤶  receiver: nil⤶  heightOfPossiblyCroppedText: nil⤶  widthOfPossiblyCroppedText: nil⤶⤶  constructor: (⤶   @text = ＂TextMorph2＂,⤶   @originallySetFontSize = WorldMorph.preferencesAndSettings.normalTextFontSize,⤶   @fontName = @justArialFontStack,⤶   @isBold = false,⤶   @isItalic = false,⤶   #@isNumeric = false,⤶   @color,⤶   @backgroundColor = nil,⤶   @backgroundTransparency = nil⤶   ) ->⤶⤶    super(⤶      @text,⤶      @originallySetFontSize,⤶      @fontName,⤶      @isBold,⤶      @isItalic,⤶      false, # isHeaderLine⤶      false, # isNumeric⤶      @color,⤶      @backgroundColor,⤶      @backgroundTransparency⤶      )⤶    # override inherited properties:⤶    @markedTextColor = new Color 255, 255, 255⤶    @markedBackgoundColor = new Color 60, 60, 120⤶    @textPossiblyCroppedToFit = @transformTextOneToOne @text⤶    @noticesTransparentClick = true⤶⤶    @fittingSpecWhenBoundsTooLarge = FittingSpecTextInLargerBounds.SCALEUP⤶    @fittingSpecWhenBoundsTooSmall = FittingSpecTextInSmallerBounds.CROP⤶  ⤶⤶  # there are many factors beyond the font size that affect⤶  # the measuring, such as font style, but we only pass⤶  # the font size here because is the one we are going to⤶  # change when we do the binary search for trying to⤶  # see the largest fitting size.⤶  doesTextFitInExtent: (text = (@transformTextOneToOne @text), overrideFontSize) ->⤶    if text == ＂＂⤶      return true⤶    doesItFit = @breakTextIntoLines text, overrideFontSize, @extent()⤶    return doesItFit⤶⤶  getParagraphs: (text) ->⤶    cacheKey = hashCode text⤶    paragraphs = world.cacheForTextParagraphSplits.get cacheKey⤶    if paragraphs? then return paragraphs⤶    paragraphs = text.split ＂⧹n＂⤶    world.cacheForTextParagraphSplits.set cacheKey, paragraphs⤶    paragraphs⤶⤶  getWordsOfParapraph: (eachParagraph) ->⤶    cacheKey = hashCode eachParagraph⤶    wordsOfThisParagraph = world.cacheForParagraphsWordsSplits.get cacheKey⤶    if wordsOfThisParagraph? then return wordsOfThisParagraph⤶    wordsOfThisParagraph = eachParagraph.split ＂ ＂⤶    wordsOfThisParagraph.push ＂⧹n＂⤶    world.cacheForParagraphsWordsSplits.set cacheKey, wordsOfThisParagraph⤶    wordsOfThisParagraph⤶⤶  replaceLastSpaceWithInvisibleCarriageReturn: (string) ->⤶    string = string.substr(0, string.length-1)⤶    string = string + @emptyCharacter⤶⤶  getWrappingData: (overrideFontSize, maxTextWidth, eachParagraph, wordsOfThisParagraph) ->⤶    cacheKey = @buildCanvasFontProperty(overrideFontSize) + ＂-＂ + maxTextWidth + ＂-＂ + hashCode eachParagraph⤶    wrappingData = world.cacheForParagraphsWrappingData.get cacheKey⤶⤶⤶    if wrappingData? then return wrappingData⤶    wrappedLinesOfThisParagraph = []⤶    wrappedLineSlotsOfThisParagraph = []⤶    maxWrappedLineWidthOfThisParagraph = 0⤶⤶    currentLine = ＂＂⤶    slotsInParagraph = 0⤶⤶    # currently unused because token-level wrapping⤶    # is commented-out, see below⤶    carryoverFromWrappingLine = ＂＂⤶⤶    for word in wordsOfThisParagraph⤶⤶      # TOKEN-LEVEL WRAPPING i.e.⤶      # handling a single token that is too long.⤶      # This works with the manual tests I've done so far⤶      # BUT it brought up a logical error, because the⤶      # following can happen: when the line wraps,⤶      # it pushes down the lines. In doing so, the text⤶      # might resize. In doing so, the line doesn't need⤶      # to wrap anymore, and hence the text can embiggen,⤶      # and hence the line wraps...⤶      # In other words there is no fixed point in the font⤶      # size...⤶      # So this can be done only if the textbox is⤶      # constrained horizontally but not vertically...⤶⤶      #if !word.substr(0, word.length-1).includes(＂ ＂)⤶      #  console.log ＂>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>＂⤶      #  console.log ＂> no space word: ＂ + word⤶      #  checkingLongerSingleWorld = Math.ceil @measureText overrideFontSize, word⤶      #  console.log ＂> length of: ＂ + word + ＂ : ＂ + checkingLongerSingleWorld⤶      #  console.log ＂> maxTextWidth: ＂ + maxTextWidth⤶      #⤶      #  while checkingLongerSingleWorld > maxTextWidth⤶      #    console.log ＂> ＂ + word + ＂ is too long at overrideFontSize: ＂ + overrideFontSize⤶      #    maxLengthNotOverflowing = 0⤶      #    for scanning in [0..word.length]⤶      #      subword = word.substring 0, scanning⤶      #      checkingLongerSingleWorld2 = Math.ceil @measureText overrideFontSize, subword⤶      #      console.log ＂> length at size ＂ + overrideFontSize + ＂ of subword: ＂ + subword + ＂ : ＂ + checkingLongerSingleWorld2⤶      #      if checkingLongerSingleWorld2 > maxTextWidth⤶      #        maxLengthNotOverflowing = scanning - 1⤶      #        break⤶      #    console.log ＂> maxLengthNotOverflowing: ＂ + maxLengthNotOverflowing⤶      #    if maxLengthNotOverflowing == 0⤶      #      word = word.substring 1, word.length⤶      #    else⤶      #      currentLineCanStayInLine = word.substring 0, maxLengthNotOverflowing⤶      #      carryoverFromWrappingLine = word.substring maxLengthNotOverflowing, word.length⤶      #      console.log ＂> part that is not overflowing: ＂ + currentLineCanStayInLine⤶      #      console.log ＂> part that is overflowing: ＂ + carryoverFromWrappingLine⤶      #      slotsInParagraph += currentLineCanStayInLine.length⤶      #      wrappedLinesOfThisParagraph.push currentLineCanStayInLine⤶      #      wrappedLineSlotsOfThisParagraph.push slotsInParagraph⤶      #      word = carryoverFromWrappingLine⤶      #    checkingLongerSingleWorld = Math.ceil @measureText overrideFontSize, word⤶⤶      if word is ＂⧹n＂⤶        # we reached the end of the line in the⤶        # original text, so push the line and the⤶        # slotsInParagraph count in the arrays⤶        currentLine = @replaceLastSpaceWithInvisibleCarriageReturn currentLine⤶        wrappedLinesOfThisParagraph.push currentLine⤶        wrappedLineSlotsOfThisParagraph.push slotsInParagraph⤶        maxWrappedLineWidthOfThisParagraph = Math.max maxWrappedLineWidthOfThisParagraph, Math.ceil @measureText overrideFontSize, currentLine⤶        currentLine = ＂＂⤶      else⤶        if maxTextWidth > 0 # there is a width limit, we might have to wrap⤶          # there is a width limit, so we need⤶          # to check whether we overflowed it. So create⤶          # a prospective line and then check its width.⤶          lineForOverflowTest = currentLine + word + ＂ ＂⤶          w = Math.ceil @measureText overrideFontSize, lineForOverflowTest⤶          if w > maxTextWidth⤶            # ok we just overflowed the available space,⤶            # so we need to push the line *without the last word*⤶            # and the corresponding ＂slotsInParagraph＂ number in the⤶            # respective arrays.⤶            # the new line is going to only contain the⤶            # word that has caused the overflow.⤶⤶            currentLine = @replaceLastSpaceWithInvisibleCarriageReturn currentLine⤶            # if we don't do this test there is a strange behaviour⤶            # when one types a very long word⤶            if currentLine != @emptyCharacter⤶              wrappedLinesOfThisParagraph.push currentLine⤶              wrappedLineSlotsOfThisParagraph.push slotsInParagraph⤶              maxWrappedLineWidthOfThisParagraph = Math.max maxWrappedLineWidthOfThisParagraph, Math.ceil @measureText overrideFontSize, currentLine⤶            currentLine = word + ＂ ＂⤶          else⤶            # no overflow happened, so just proceed as normal⤶            currentLine = lineForOverflowTest⤶        else # there is no width limit, we never have to wrap⤶          currentLine = currentLine + word + ＂ ＂⤶        slotsInParagraph += word.length + 1⤶⤶    # words of this paragraph have been scanned⤶    wrappingDataCacheEntry = [wrappedLinesOfThisParagraph,wrappedLineSlotsOfThisParagraph,maxWrappedLineWidthOfThisParagraph, slotsInParagraph]⤶    world.cacheForParagraphsWrappingData.set cacheKey, wrappingDataCacheEntry⤶    wrappingData = wrappingDataCacheEntry⤶⤶  # there are many factors beyond the font size that affect⤶  # how the text wraps, such as font style, but we only pass⤶  # the font size here because is the one we are going to⤶  # change when we do the binary search for trying to⤶  # see the largest fitting size.⤶  getTextWrappingData: (overrideFontSize, maxTextWidth, text, paragraphs, justCheckIfItFitsInThisExtent) ->⤶    if @ instanceof SimplePlainTextWdgt⤶      justCheckIfItFitsInThisExtent = null⤶      overrideFontSize = @originallySetFontSize⤶⤶    cacheKey = @buildCanvasFontProperty(overrideFontSize) + ＂-＂ + maxTextWidth + ＂-＂ + hashCode(text) + ＂-＂ + justCheckIfItFitsInThisExtent⤶    textWrappingData = world.cacheForTextWrappingData.get cacheKey⤶    if textWrappingData? then return textWrappingData⤶    wrappedLinesOfWholeText = []⤶    wrappedLineSlotsOfWholeText = [0]⤶    maxWrappedLineWidthOfWholeText = 0⤶    cumulativeSlotAcrossText = 0⤶    previousCumulativeSlotAcrossText = 0⤶⤶    for eachParagraph in paragraphs⤶⤶      wordsOfThisParagraph = @getWordsOfParapraph eachParagraph⤶⤶      ## ////////////////////////////////////////////////////////////////⤶⤶      ## You want this method to be FAST because it would be done⤶      ## a dozen times for each resize (while the painting is⤶      ## only done once!)⤶      ## you can have the words per paragraph, and cache all⤶      ## operations below by paragraph (and font size and width),⤶      ## the cache would return⤶      ## two arrays ＂linesHit＂ and ＂lineslotsHit＂ AND the⤶      ## ＂maxlinewidthHit＂ which you can⤶      ## concatenate to the ＂running＂ ones⤶      ## basically a) make two nested forach, outer by paragraph and⤶      ## inner by words.⤶      ## Then cache the hell out of each loop.⤶⤶      ## LATER FOR ANOTHER TIME IS TO MAKE THE PAINTING ALSO FAST.⤶      ## You'd also love to cache the bitmap of each paragraph⤶      ## rather than keeping one huge bitmap.⤶      ## so this wouldn't be a BackBuffer anymore⤶      ## SO you need to REMOVE the mixin from this class.⤶      ## cause there would be a paint method and it would⤶      ## compose the ⤶      ## it would be much better to handle AND in theory⤶      ## the single bitmaps per paragraph would be easy⤶      ## to cache and could be created⤶      ## only on demand if they ever get damaged.⤶      ## GET THE stringMorph2 to cache the actual bitmap that they⤶      ## generate so you can use that too from here, cause there⤶      ## might be a lot of reuse rather than re-painting the⤶      ## text all the times or even a paragraph.⤶⤶      # takes the text, word by word, and re-flows⤶      # it according to the available width for the⤶      # text (if there is such limit).⤶      # The end result is an array of lines⤶      # called @wrappedLines, which contains the string for⤶      # each line (excluding the end of lines).⤶      # Also another array is created, called⤶      # @wrappedLineSlots, which memorises how many characters⤶      # of the text have been consumed up to each line⤶      #  example: original text: ＂Hello⧹nWorld＂⤶      # then @wrappedLines[0] = ＂Hello＂ @wrappedLines[1] = ＂World＂⤶      # and @wrappedLineSlots[0] = 6, @wrappedLineSlots[1] = 11⤶      # Note that this algorithm doesn't work in case⤶      # of single non-spaced words that are longer than⤶      # the allowed width.⤶      ⤶      wrappingData = @getWrappingData overrideFontSize, maxTextWidth, eachParagraph, wordsOfThisParagraph⤶⤶      # we either cache-hit wrappingData or we re-built it⤶      [wrappedLinesOfThisParagraph, wrappedLineSlotsOfThisParagraph, maxWrappedLineWidthOfThisParagraph, slotsInParagraph] = wrappingData⤶⤶      previousCumulativeSlotAcrossText = cumulativeSlotAcrossText⤶      cumulativeSlotAcrossText += slotsInParagraph⤶      wrappedLinesOfWholeText = wrappedLinesOfWholeText.concat wrappedLinesOfThisParagraph⤶      advancedWrappedLineSlotsOfThisParagraph =  wrappedLineSlotsOfThisParagraph.map (i) -> i + previousCumulativeSlotAcrossText⤶      #alert ＂unadvanced wrappedLineSlotsOfThisParagraph: ＂ + wrappedLineSlotsOfThisParagraph + ＂ advanced: ＂ + advancedWrappedLineSlotsOfThisParagraph⤶      wrappedLineSlotsOfWholeText = wrappedLineSlotsOfWholeText.concat advancedWrappedLineSlotsOfThisParagraph⤶      maxWrappedLineWidthOfWholeText = Math.max maxWrappedLineWidthOfWholeText, maxWrappedLineWidthOfThisParagraph⤶⤶      if justCheckIfItFitsInThisExtent?⤶        heightOfPossiblyCroppedText = (wrappedLineSlotsOfWholeText.length - 1) * Math.ceil(fontHeight overrideFontSize)⤶        #console.log ＂heightOfPossiblyCroppedText: ＂ + heightOfPossiblyCroppedText + ＂ justCheckIfItFitsInThisExtent: ＂ + justCheckIfItFitsInThisExtent⤶        if heightOfPossiblyCroppedText > justCheckIfItFitsInThisExtent.y or maxWrappedLineWidthOfWholeText > justCheckIfItFitsInThisExtent.x⤶          world.cacheForTextWrappingData.set cacheKey, false⤶          return false⤶⤶⤶    # here all paragraphs have been visited⤶    #alert ＂wrappedLineSlotsOfWholeText: ＂ + wrappedLineSlotsOfWholeText⤶⤶    if justCheckIfItFitsInThisExtent?⤶      world.cacheForTextWrappingData.set cacheKey, true⤶      return true⤶    heightOfPossiblyCroppedText = wrappedLinesOfWholeText.length * Math.ceil(fontHeight overrideFontSize)⤶    textWrappingDataCacheEntry = [wrappedLinesOfWholeText, wrappedLineSlotsOfWholeText, maxWrappedLineWidthOfWholeText, heightOfPossiblyCroppedText]⤶    world.cacheForTextWrappingData.set cacheKey, textWrappingDataCacheEntry⤶    textWrappingData = textWrappingDataCacheEntry⤶⤶  # there are many factors beyond the font size that affect⤶  # how the text is broken, such as font style, but we only pass⤶  # the font size here because is the one we are going to⤶  # change when we do the binary search for trying to⤶  # see the largest fitting size.⤶  breakTextIntoLines: (text = (@transformTextOneToOne @text), overrideFontSize, justCheckIfItFitsInThisExtent) ->⤶    ⤶    if @ instanceof SimplePlainTextWdgt⤶      overrideFontSize = @originallySetFontSize⤶⤶    # Easy, lazy way to get soft-wrapping.⤶    # TODO you can actually simplify lots of code in the⤶    # case of soft-wrapping as really there is a lot⤶    # less to measure and the wrapping becomes trivial.⤶    # Also testing if it fits in an extent can be made⤶    # really easy.⤶    if @softWrap⤶      morphWidth = @width()⤶    else⤶      morphWidth = Number.MAX_VALUE⤶⤶    cacheKey = hashCode(text) + ＂-＂ + @buildCanvasFontProperty(overrideFontSize) + ＂-＂ + morphWidth + ＂-＂ + justCheckIfItFitsInThisExtent⤶    textWrappingData = world.cacheForTextBreakingIntoLinesTopLevel.get cacheKey⤶    if textWrappingData? then return textWrappingData⤶⤶    #console.log ＂breakTextIntoLines // ＂ + ＂ morphWidth: ＂ + morphWidth + ＂ overrideFontSize: ＂ + overrideFontSize⤶⤶    ⤶    ## // this section only needs to be re-done when @text changes ////⤶    # put all the text in an array, word by word⤶    # >>> avoid to do this double-split, jus split by spacing and then⤶    # you'll find and remove the newline in the running code⤶    # below.⤶    # put all the text in an array, word by word⤶⤶    paragraphs = @getParagraphs text⤶⤶    textWrappingData = @getTextWrappingData overrideFontSize, morphWidth, text, paragraphs, justCheckIfItFitsInThisExtent⤶⤶⤶    world.cacheForTextBreakingIntoLinesTopLevel.set cacheKey, textWrappingData⤶    return textWrappingData⤶⤶  # adjust the data models behind the text. E.g.⤶  # is it going to be shown as cropped? What size⤶  # is it going to be? How is the text broken down⤶  # into rows?⤶  # this method doesn't draw anything.⤶  reflowText: ->⤶    super⤶    [@wrappedLines,@wrappedLineSlots,@widthOfPossiblyCroppedText,@heightOfPossiblyCroppedText] =⤶      @breakTextIntoLines @textPossiblyCroppedToFit, @fittingFontSize⤶⤶    # a changed() is already done in the⤶    # super but adding it here as well for clarity⤶⤶    return @heightOfPossiblyCroppedText⤶⤶  createBufferCacheKey: ->⤶    return super() +  ＂-＂ + @softWrap⤶⤶  # no changes of position or extent should be⤶  # performed in here⤶  createRefreshOrGetBackBuffer: ->⤶    ⤶    cacheKey = @createBufferCacheKey()⤶⤶    cacheHit = world.cacheForImmutableBackBuffers.get cacheKey⤶    if cacheHit?⤶      # we might have hit a previously cached⤶      # backBuffer but here we are interested in⤶      # knowing whether the buffer we are gonna paint⤶      # is the same as the one being shown now. If⤶      # not, then we mark the caret as broken.⤶      if @backBuffer != cacheHit[0]⤶        if world.caret?⤶          world.caret.changed()      ⤶      return cacheHit⤶⤶    contentHeight = @reflowText()⤶⤶    if @ instanceof SimplePlainTextWdgt⤶      contentHeight = @wrappedLines.length *  Math.ceil fontHeight @originallySetFontSize⤶⤶    # if we are calculating a new buffer then⤶    # for sure we have to mark the caret as broken⤶    if world.caret?⤶      world.caret.changed()      ⤶⤶    backBuffer = newCanvas()⤶    backBufferContext = backBuffer.getContext ＂2d＂⤶⤶    backBuffer.width = @width() * ceilPixelRatio⤶    backBuffer.height = @height() * ceilPixelRatio⤶⤶    backBufferContext.scale ceilPixelRatio, ceilPixelRatio⤶    backBufferContext.font = @buildCanvasFontProperty()⤶    backBufferContext.textAlign = ＂left＂⤶    backBufferContext.textBaseline = ＂bottom＂⤶⤶    # paint the background so we have a better sense of⤶    # where the text is fitting into.⤶    # paintRectangle here is passed logical pixels⤶    # rather than actual pixels, contrary to how it's used⤶    # most other places. This is because it's inside⤶    # the scope of the ＂scale ceilPixelRatio, ceilPixelRatio＂.⤶    if @backgroundColor⤶      backBufferContext.save()⤶      backBufferContext.fillStyle = @backgroundColor.toString()⤶      backBufferContext.globalAlpha = @backgroundTransparency⤶      backBufferContext.fillRect  0,⤶          0,⤶          Math.round(@width()),⤶          Math.round(@height())⤶      backBufferContext.restore()⤶⤶    textVerticalPosition = @textVerticalPosition contentHeight⤶⤶    # now draw the actual text⤶    backBufferContext.fillStyle = @color.toString()⤶    i = 0⤶    for line in @wrappedLines⤶      width = Math.ceil(@measureText nil, line)⤶      x = switch @horizontalAlignment⤶        when AlignmentSpecHorizontal.RIGHT⤶          @width() - width⤶        when AlignmentSpecHorizontal.CENTER⤶          (@width() - width) / 2⤶        else # 'left'⤶          0⤶      y = (i + 1) * Math.ceil fontHeight @fittingFontSize⤶      i++⤶⤶      # you'd think that we don't need to eliminate the invisible character⤶      # to draw the text, as it's supposed to be, well, invisible.⤶      # Unfortunately some fonts do draw it, so we indeed have to eliminate⤶      # it.⤶      backBufferContext.fillText (@eliminateInvisibleCharacter line), x, y + textVerticalPosition⤶⤶      # header line⤶      # TODO string2 has very similar code, can be factored-out⤶      # paying attention that in string2 some variables with the same⤶      # name as here actually have slightly different meaning⤶      if @isHeaderLine and @wrappedLines.length <= 1⤶        heightOfText = fontHeight @fittingFontSize⤶        textHorizontalPosition = x⤶        textVertPosition = y + textVerticalPosition⤶        widthOfText = width⤶        backBufferContext.strokeStyle = new Color 198, 198, 198⤶        backBufferContext.beginPath()⤶        backBufferContext.moveTo 0, textVertPosition - heightOfText / 2⤶        backBufferContext.lineTo textHorizontalPosition - 5, textVertPosition - heightOfText / 2⤶        backBufferContext.moveTo textHorizontalPosition + widthOfText + 5, textVertPosition - heightOfText / 2⤶        backBufferContext.lineTo @width(), textVertPosition - heightOfText / 2⤶        backBufferContext.stroke()⤶⤶    @drawSelection backBufferContext⤶⤶    cacheEntry = [backBuffer, backBufferContext]⤶    world.cacheForImmutableBackBuffers.set cacheKey, cacheEntry⤶    return cacheEntry⤶⤶⤶  # TextMorph measuring ////⤶⤶  # answer the logical position point of the given index (＂slot＂)⤶  # i.e. the row and the column where a particular character is.⤶  slotRowAndColumn: (slot) ->⤶⤶    #if !window.globCounter2? then window.globCounter2 = 0⤶    #window.globCounter2++⤶    #console.log ＂slotRowAndColumn ＂ + window.globCounter2⤶⤶    @reflowText()⤶    idx = 0⤶    # Note that this solution scans all the characters⤶    # in all the rows up to the slot. This could be⤶    # done a lot quicker by stopping at the first row⤶    # such that @wrappedLineSlots[theRow] <= slot⤶    # You could even do a binary search if one really⤶    # wanted to, because the contents of @wrappedLineSlots are⤶    # in order, as they contain a cumulative count...⤶    for row in [0...@wrappedLines.length]⤶      idx = @wrappedLineSlots[row]⤶      for col in [0...@wrappedLines[row].length]⤶        return [row, col]  if idx is slot⤶        idx += 1⤶    [@wrappedLines.length - 1, @wrappedLines[@wrappedLines.length - 1].length - 1]⤶  ⤶  # Answer the position (in pixels) of the given index (＂slot＂)⤶  # where the caret should be placed.⤶  # This is in absolute world coordinates.⤶  # This function assumes that the text is left-justified.⤶  slotCoordinates: (slot) ->⤶⤶    #if !window.globCounter3? then window.globCounter3 = 0⤶    #window.globCounter3++⤶    #console.log ＂slotCoordinates ＂ + window.globCounter3⤶⤶    # this makes it so when you type and the string becomes too big⤶    # then the edit stops to be directly in the screen and the⤶    # popout for editing takes over.⤶    if (@transformTextOneToOne @text) != @textPossiblyCroppedToFit and @fittingSpecWhenBoundsTooSmall == FittingSpecTextInSmallerBounds.CROP⤶      world.stopEditing()⤶      @edit()⤶      return nil⤶⤶    @reflowText()⤶    [slotRow, slotColumn] = @slotRowAndColumn slot⤶⤶    lineWidth = @measureText nil, @wrappedLines[slotRow]⤶    xOffset = Math.ceil @measureText nil, (@wrappedLines[slotRow]).substring(0,slotColumn)⤶    yOffset = slotRow * Math.ceil fontHeight @fittingFontSize⤶⤶    textVerticalPosition = @textVerticalPosition @heightOfPossiblyCroppedText⤶    textHorizontalPosition = @textHorizontalPosition lineWidth⤶⤶    x = @left() + xOffset + textHorizontalPosition⤶    y = @top() + yOffset + textVerticalPosition⤶    #alert ＂slotCoordinates slot:＂ + slot + ＂ x,y: ＂ + x + ＂, ＂ + y⤶    new Point x, y⤶⤶⤶  slotAtRow: (row, xPosition) ->⤶⤶    if row > @wrappedLines.length⤶      return @textPossiblyCroppedToFit.length⤶    ⤶    return @wrappedLineSlots[Math.max(row - 1, 0)] +⤶      @slotAtSingleLineString xPosition, @wrappedLines[row - 1]⤶⤶⤶  pointIsAboveFirstLine: (aPoint) ->⤶    textVerticalPosition = @textVerticalPosition @heightOfPossiblyCroppedText⤶⤶    if aPoint.y - @top() < textVerticalPosition⤶      return 0⤶⤶    return false⤶  ⤶  # Returns the slot (index) closest to the given point⤶  # so the caret can be moved accordingly⤶  # This function assumes that the text is left-justified.⤶  slotAt: (aPoint) ->⤶⤶    if (isPointBeforeFirstLine = @pointIsAboveFirstLine aPoint) != false⤶      return isPointBeforeFirstLine⤶⤶    textVerticalPosition = @textVerticalPosition @heightOfPossiblyCroppedText⤶⤶    row = 0⤶⤶    while aPoint.y - @top() > textVerticalPosition + row * Math.ceil fontHeight @fittingFontSize⤶      row += 1⤶    row = Math.max row, 1⤶⤶    return @slotAtRow row, aPoint.x⤶⤶  ⤶  upFrom: (slot) ->⤶    # answer the slot above the given one⤶    [slotRow, slotColumn] = @slotRowAndColumn slot⤶    if slotRow < 1⤶      return 0⤶    return @slotAtRow slotRow, (@slotCoordinates @caretHorizPositionForVertMovement).x⤶  ⤶  downFrom: (slot) ->⤶    # answer the slot below the given one⤶    [slotRow, slotColumn] = @slotRowAndColumn slot⤶    if slotRow > @wrappedLines.length - 2⤶      return @textPossiblyCroppedToFit.length⤶    return @slotAtRow(slotRow+2, (@slotCoordinates @caretHorizPositionForVertMovement).x)⤶  ⤶  startOfLine: (slot) ->⤶    # answer the first slot (index) of the line for the given slot⤶    @wrappedLineSlots[@slotRowAndColumn(slot).y]⤶  ⤶  endOfLine: (slot) ->⤶    # answer the slot (index) indicating the EOL for the given slot⤶    @startOfLine(slot) + @wrappedLines[@slotRowAndColumn(slot).y].length - 1⤶⤶  toggleSoftWrap: ->⤶    @softWrap = not @softWrap⤶    @changed()⤶    world.stopEditing()⤶⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    menu.addLine()⤶    if @softWrap⤶      menu.addMenuItem ＂soft wrap＂.tick(), true, @, ＂toggleSoftWrap＂⤶    else⤶      menu.addMenuItem ＂soft wrap＂, true, @, ＂toggleSoftWrap＂⤶    menu.addLine()⤶⤶    if @parent?.parent?.parent? and (@parent.parent.parent instanceof ConsoleWdgt)⤶      if @currentlySelecting()⤶        menu.addMenuItem ＂run selection＂, true, @parent.parent.parent, ＂doSelection＂⤶      menu.addMenuItem ＂run contents＂, true, @parent.parent.parent, ＂doAll＂⤶    else⤶      menu.addMenuItem ＂run contents＂, true, @, ＂doContents＂⤶  ⤶  setAlignmentToLeft: ->⤶    @alignment = ＂left＂⤶    @changed()⤶  ⤶  setAlignmentToRight: ->⤶    @alignment = ＂right＂⤶    @changed()⤶  ⤶  setAlignmentToCenter: ->⤶    @alignment = ＂center＂⤶    @changed()⤶  ⤶  # TextMorph evaluation. This menu is placed as the⤶  # ＂overridingContextMenu＂ in the Inspector panes, where⤶  # the text contents is executed against the target Widget⤶  evaluationMenu: ->⤶    menu = @buildHierarchyMenu()⤶⤶    if @text.length > 0⤶      menu.prependLine()⤶      menu.prependMenuItem ＂select all＂, true, @, ＂selectAllAndEdit＂⤶      menu.prependMenuItem ＂do all＂, true, @, ＂doAll＂⤶⤶    # only show the do it / show it / inspect it entries⤶    # if there is actually something selected.⤶    if @selection().replace(/^⧹s⧹s*/, '').replace(/⧹s⧹s*$/, '') != ''⤶      menu.prependLine()⤶      menu.prependMenuItem ＂inspect selection＂, true, @, ＂inspectSelection＂, ＂evaluate the⧹nselected expression⧹nand inspect the result＂⤶      menu.prependMenuItem ＂show selection＂, true, @, ＂showSelection＂, ＂evaluate the⧹nselected expression⧹nand show the result＂⤶      menu.prependMenuItem ＂do selection＂, true, @, ＂doSelection＂, ＂evaluate the⧹nselected expression＂⤶    menu⤶⤶  # StringMorph2 editing:⤶  edit: ->⤶    # when you edit a TextMorph, potentially⤶    # you need to change the alignment of the⤶    # text, because managing the caret with⤶    # alignments other than the top-left⤶    # ones is complex. So during editing⤶    # we might change the alignment, hence⤶    # ths method here with @changed()⤶    @changed()⤶    return super⤶⤶  selectAllAndEdit: ->⤶    @edit()⤶    @selectAll()⤶⤶  doAll: ->⤶    @receiver.evaluateString @text⤶   ⤶  # this is set by the inspector. It tells the TextMorph⤶  # that any following doSelection/showSelection/inspectSelection⤶  # action needs to be done apropos a particular obj,⤶  # and also replaces the normal context menu with the evaluation Menu⤶  # because if you right click in these panes of the Inspector you⤶  # want to ＂run＂ code that has been typed⤶  setReceiver: (obj) ->⤶    @receiver = obj⤶    @overridingContextMenu = @evaluationMenu⤶  ⤶  doSelection: ->⤶    @receiver.evaluateString @selection()⤶    @edit()⤶⤶  doContents: ->⤶    if @receiver?⤶      @receiver.evaluateString @text⤶    else⤶      @evaluateString @text⤶⤶  showSelection: ->⤶    result = @receiver.evaluateString @selection()⤶    if result? then @inform result⤶  ⤶  inspectSelection: ->⤶    # evaluateString is a pimped-up eval in⤶    # the Widget class.⤶    result = @receiver.evaluateString @selection()⤶    if result? then @spawnInspector result⤶⤶  # selects the whole line (if it's wrapped, just⤶  # what sits on the very line, not what wraps⤶  # above or under). Just like normal editors.⤶  mouseTripleClick: ->⤶    if @isEditable⤶      [row, column] = @slotRowAndColumn world.caret?.slot⤶      slotBeginOfLine = @slotAtRow row + 1, 0⤶      slotsInRow = @wrappedLineSlots[row + 1]⤶      @selectBetween slotBeginOfLine, slotsInRow⤶      world.caret?.gotoSlot slotsInRow⤶⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.TriggerMorph_coffeSource = "# **************************************⤶# This Widget is now deprecated, use the⤶# SimpleButton instead⤶# **************************************⤶⤶# I provide basic button functionality.⤶# All menu items and buttons are TriggerMorphs.⤶# The handling of the triggering is not⤶# trivial, as the concepts of⤶# dataSourceMorphForTarget, target and action⤶# are used - see comments.⤶⤶class TriggerMorph extends Widget⤶⤶  target: nil⤶  action: nil⤶  dataSourceMorphForTarget: nil⤶  morphEnv: nil⤶  label: nil⤶  labelString: nil⤶  labelColor: nil⤶  labelBold: nil⤶  labelItalic: nil⤶  doubleClickAction: nil⤶  argumentToAction1: nil⤶  argumentToAction2: nil⤶  toolTipMessage: nil⤶  fontSize: nil⤶  fontStyle: nil⤶  # careful: Objects are shared with all the instances of this class.⤶  # if you modify it, then all the objects will get the change⤶  # but if you replace it with a new Color, then that will only affect the⤶  # specific object instance. Same behaviour as with arrays.⤶  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333⤶  highlightColor: new Color 192, 192, 192⤶  # see note above about Colors and shared objects⤶  pressColor: new Color 128, 128, 128⤶  centered: false⤶  ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked: true⤶  ⤶  # tells if the button represents a morph, in which⤶  # case we are going to highlight the Widget on hover⤶  representsAMorph: false⤶⤶  state: 0⤶  STATE_NORMAL: 0⤶  STATE_HIGHLIGHTED: 1⤶  STATE_PRESSED: 2⤶⤶⤶  constructor: (⤶      @ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked = true,⤶      @target = nil,⤶      @action = nil,⤶      @labelString = nil,⤶      @fontSize = WorldMorph.preferencesAndSettings.menuFontSize,⤶      @fontStyle = ＂sans-serif＂,⤶      @centered = false,⤶      @dataSourceMorphForTarget = nil,⤶      @morphEnv,⤶      @toolTipMessage = nil,⤶      @labelColor = WorldMorph.preferencesAndSettings.menuButtonsLabelColor,⤶      @labelBold = false,⤶      @labelItalic = false,⤶      @doubleClickAction = nil,⤶      @argumentToAction1 = nil,⤶      @argumentToAction2 = nil,⤶      @representsAMorph = false⤶      ) ->⤶⤶    # additional properties:⤶⤶    super()⤶⤶    # you shouldn't be able to drag a compound⤶    # morphs containing a trigger by dragging the trigger⤶    # (because you expect buttons attached to anything but the⤶    # world to be ＂slippery＂, i.e.⤶    # you can ＂skid＂ your drag over it in case you change⤶    # your mind on pressing it)⤶    # and at the same time (again if it's not on the desktop)⤶    # you don't want it to be ＂floating＂⤶    # either⤶    @defaultRejectDrags = true⤶⤶    @color = WorldMorph.preferencesAndSettings.menuBackgroundColor⤶    if @labelString?⤶      @layoutSubmorphs()⤶  ⤶  layoutSubmorphs: (morphStartingTheChange = nil) ->⤶    super()⤶    if not @label?⤶      @createLabel()⤶    if @centered⤶      @label.fullRawMoveTo @center().subtract @label.extent().floorDivideBy 2⤶⤶  getTextDescription: ->⤶    if @textDescription?⤶      return @textDescription + ＂ (adhoc description of button)＂⤶    if @labelString⤶      textWithoutLocationOrInstanceNo = @labelString.replace /#⧹d*/, ＂＂⤶      return textWithoutLocationOrInstanceNo + ＂ (text in button)＂⤶    else⤶      return super()⤶⤶⤶  setLabel: (@labelString) ->⤶    # just recreated the label⤶    # from scratch⤶    if @label?⤶      @label = @label.fullDestroy()⤶    @layoutSubmorphs()⤶⤶  alignCenter: ->⤶    if !@centered⤶      @centered = true⤶      @layoutSubmorphs()⤶⤶  alignLeft: ->⤶    if @centered⤶      @centered = false⤶      @layoutSubmorphs()⤶  ⤶⤶  # This method only paints this very morph's ＂image＂,⤶  # it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which⤶  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if !@visibleBasedOnIsVisibleProperty() or @isCollapsed()⤶      return nil⤶⤶    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    if appliedShadow?⤶      color = ＂black＂⤶    else⤶      color = switch @state⤶        when @STATE_NORMAL⤶          @color⤶        when @STATE_HIGHLIGHTED⤶          @highlightColor⤶        when @STATE_PRESSED⤶          @pressColor⤶⤶    # paintRectangle is usually made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, so it's generally used⤶    # outside the effect of the scaling because⤶    # of the ceilPixelRatio⤶    @paintRectangle ⧹⤶      aContext,⤶      al, at, w, h,⤶      color,⤶      @alpha,⤶      true, # push and pop the context⤶      appliedShadow⤶⤶    # paintHighlight is usually made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, so it's generally used⤶    # outside the effect of the scaling because⤶    # of the ceilPixelRatio⤶    @paintHighlight aContext, al, at, w, h⤶⤶  createLabel: ->⤶    # bold⤶    # italic⤶    # numeric⤶    # shadow offset⤶    # shadow color⤶    @label = new StringMorph(⤶      @labelString or ＂＂,⤶      @fontSize,⤶      @fontStyle,⤶      @labelBold,⤶      @labelItalic,⤶      false,⤶      @labelColor      ⤶    )⤶    @add @label⤶    ⤶  # you shouldn't be able to drag a compound⤶  # morphs containing a button by dragging the button⤶  # (because you expect buttons attached to anything but the⤶  # world to be ＂slippery＂, i.e.⤶  # you can ＂skid＂ your drag over it in case you change⤶  # your mind on pressing it)⤶  # and you shouldn't be able to drag the button away either⤶  # so the drag is entirely rejected⤶  rejectDrags: ->⤶    if @parent instanceof WorldMorph⤶      return false⤶    else⤶      return @defaultRejectDrags⤶  ⤶  # TriggerMorph action:⤶  trigger: ->⤶    if @action and @action != ＂＂⤶      #console.log ＂@target: ＂ + @target + ＂ @morphEnv: ＂ + @morphEnv⤶      @target[@action].call @target, @dataSourceMorphForTarget, @morphEnv, @argumentToAction1, @argumentToAction2⤶    return⤶⤶  triggerDoubleClick: ->⤶    # same as trigger() but use doubleClickAction instead of action property⤶    # note that specifying a doubleClickAction is optional⤶    return  unless @doubleClickAction⤶    @target[@doubleClickAction]()  ⤶  ⤶  # TriggerMorph events:⤶  mouseEnter: ->⤶    @state = @STATE_HIGHLIGHTED⤶    @changed()⤶    @startCountdownForBubbleHelp @toolTipMessage  if @toolTipMessage⤶  ⤶  # a copied trigger usually wants to un-highlight⤶  # itself. This happens for example when you duplicate⤶  # by clicking on a ＂duplicate＂ button INSIDE it.⤶  justBeenCopied: ->⤶    @mouseLeave()⤶⤶  mouseLeave: ->⤶    @state = @STATE_NORMAL⤶    @changed()⤶    world.destroyToolTips()  if @toolTipMessage⤶  ⤶  mouseDownLeft: ->⤶    @state = @STATE_PRESSED⤶    @changed()⤶    super⤶  ⤶  mouseClickLeft: ->⤶    @bringToForeground()⤶    @state = @STATE_HIGHLIGHTED⤶    @changed()⤶    if @ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked⤶      @propagateKillPopUps()⤶    @trigger()⤶⤶  mouseDoubleClick: ->⤶    @triggerDoubleClick()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.Widget_coffeSource = "# ＂Widget＂ is a more understandable name for the concept of ＂Morph＂⤶# (from the Greek ＂shape＂ or ＂form＂). A Widget is an interactive⤶# graphical object.⤶# (General information on the Morphic system⤶# can be found at http://wiki.squeak.org/squeak/30 )⤶⤶# Widgets exist in a tree, rooted at a World or at the Hand.⤶# The morphs owns submorphs. Widgets are drawn recursively;⤶# if a Widget has no owner it never gets drawn⤶# (but note that there are other ways to hide a Widget).⤶⤶# this comment below is needed to figure out dependencies between classes⤶# REQUIRES globalFunctions⤶# REQUIRES DeepCopierMixin⤶# REQUIRES LayoutSpec⤶# REQUIRES PreferredSize⤶# REQUIRES VerticalStackLayoutSpec⤶# REQUIRES WindowContentLayoutSpec⤶⤶class Widget extends TreeNode⤶⤶  @augmentWith DeepCopierMixin⤶⤶  # we want to keep track of how many instances we have⤶  # of each Widget for a few reasons:⤶  # 1) it gives us an identifier for each Widget⤶  # 2) profiling⤶  # 3) generate a uniqueIDString that we can use⤶  #    for example for hashtables⤶  # each subclass of Widget has its own static⤶  # instancesCounter which starts from zero. First object⤶  # has instanceNumericID of 1.⤶  # instanceNumericID is initialised in the constructor.⤶  @instancesCounter: 0⤶  # see roundNumericIDsToNextThousand method for an⤶  # explanation of why we need to keep this extra⤶  # count⤶  @lastBuiltInstanceNumericID: 0⤶  instanceNumericID: 0⤶⤶  appearance: nil⤶⤶  dragsDropsAndEditingEnabled: true⤶⤶  # Just some tests here ////////////////////⤶  propertyUpTheChain: [1,2,3]⤶  morphMethod: ->⤶    3.14⤶  @morphStaticMethod: ->⤶    3.14⤶  # End of tests here ////////////////////⤶⤶  isMorph: true⤶⤶  # we conveniently keep all geometry information⤶  # into a single property (a Rectangle). Only⤶  # a few geometry-related methods should directly⤶  # access this property.⤶  bounds: nil⤶  minimumExtent: nil⤶  color: new Color 80, 80, 80⤶  strokeColor: nil⤶  texture: nil # optional url of a fill-image⤶  cachedTexture: nil # internal cache of actual bg image⤶  lastTime: nil⤶  # when you use the high-level geometry-change APIs⤶  # you don't actually change the geometry right away,⤶  # you just ask for the desired change and wait for the⤶  # layouting mechanism to do its best to satisfy it.⤶  # Here we store the desired extent and position.⤶  desiredExtent: nil⤶  desiredPosition: nil⤶⤶  # 1: fully opaque, 0: fully transparent⤶  alpha: 1⤶⤶  # the padding area of a morph is INSIDE a morph and⤶  # responds to mouse events.⤶  # The padding area should be empty, not drawn, except⤶  # for debugging or ＂interim painting＂ purposes such⤶  # as highlights.⤶  # The padding's purpose is to give the option to morphs⤶  # to accommodate for spacing between their contents and⤶  # their bounds, so to enable consecutive morphs to⤶  # have some spacing in between them.⤶  # Note that paddings of consecutive morphs do add up.⤶  # The padding area reacts to mouse events ONLY IF⤶  # it's filled with color. Otherwise, it doesn't.⤶  # This is consistent with the concept that Widgets only⤶  # react within their ＂filled＂ region.⤶  paddingTop: 0⤶  paddingBottom: 0⤶  paddingLeft: 0⤶  paddingRight: 0⤶⤶  # backgroundColor and backgroundTransparency fill the⤶  # entire rectangular bounds of the morph.⤶  # I.e. they area they fill is not affected by the⤶  # padding or the actual design of the morph.⤶  backgroundColor: nil⤶  backgroundTransparency: 1⤶⤶  # for a Widget, being visible and collapsed⤶  # are two separate things.⤶  # isVisible means that the morph is meant to show⤶  #  as empty or without any surface. BUT the morph⤶  #  will still take the usual space.⤶  # Collapsed means that the morph, whatever its⤶  #  content or appearance or design, is not drawn⤶  #  on the desktop AND it doesn't occupy any space.⤶  isVisible: true⤶  collapsed: false⤶⤶  # if a morph is a ＂template＂ it means that⤶  # when you floatDrag it, it creates a copy of itself.⤶  # it's a nice shortcut instead of doing⤶  # right click and then ＂duplicate...＂⤶  isTemplate: false⤶  _acceptsDrops: false⤶  noticesTransparentClick: false⤶  fps: 0⤶⤶  # usually Widgets can be detached from Panels⤶  # by grabbing them (there are exceptions, for example⤶  # buttons don't stick to the world but stick to Panels,⤶  # morph that ＂select＂ based on dragging such as the ColorPanelMorph).⤶  # However you can get them to stick to Panels (and the desktop)⤶  # by toggling this flag⤶  isLockingToPanels: false⤶  # even if a Widget is locked to its parent (which is⤶  # the default) or locks to Panels (because isLockingToPanels is⤶  # set to true), it could be STILL BE dragged⤶  # (if any of its parents is loose).⤶  #⤶  # Setting this flag prevents that: a Widget rejecting⤶  # a drag can never be part of a chain that is dragged.⤶  # An example is buttons that are part of a compund Widget⤶  # (such as the Inspector):⤶  # in those cases you can never drag the compound Widget by⤶  # dragging a button (because it is a common behaviour to⤶  # ＂drag away＂ from a button to avoid actioning it when one⤶  # mousedowns on it). (Note however that buttont on the desktop⤶  # are draggable).⤶  # Another example are morphs like the ColorPanelMorph where⤶  # users can drag the mouse on them to pick a color: it would be⤶  # weird if that caused a drag of anything.⤶  defaultRejectDrags: false⤶⤶  # if you place a menu construction function here,⤶  # it gets the priority over the normal context⤶  # menu. This is done for example in the Inspector⤶  # panes, where the context menu is about running the⤶  # code contained in the text panel, rather than⤶  # to fiddle with the properties of the text panel⤶  # itself.⤶  overridingContextMenu: nil⤶⤶  # menu coalescing is useful when you want a ＂parent＂⤶  # menu to take over the menus of their children.⤶  # This assumes that for certain morphs is OK to just exist⤶  # ＂in their whole＂ without letting the user obviously take it⤶  # apart or mess with its parts.⤶  #⤶  # The best example is scrollable text: when one right-clicks⤶  # on scrollable text, the menu OF THE SCROLLFRAME that⤶  # contains it takes over.⤶  #⤶  # Otherwise, without coalescing, there would FIRST be a⤶  # multiple-selection menu to spacially demultiplex which⤶  # morph is the one of interest⤶  # (the TextMorph, or the Panel, or the ScrollPanelWdgt?). And⤶  # if the user wanted to resize the scroll text, which Widget⤶  # would the user have to pick? It would be very confusing.⤶  #⤶  # Instead, in this example above, one can naturally⤶  # resize the ScrollPanel, or change its color, or delete it,⤶  # instead of operating on the text content.⤶  #⤶  # Note that, on the other side, for this to work the menu of⤶  # the ScrollPanelWdgt has to give menu entries ＂peeking＂ them⤶  # from the TextMorph it contains, e.g. to change the font size⤶  #⤶  # Note that this mechanism could be overridden for ＂advanced＂⤶  # users who want to mangle with the sub-components of a scrollable⤶  # text⤶  takesOverAndCoalescesChildrensMenus: false⤶⤶  shadowBlur: 10⤶  onNextStep: nil # optional function to be run once. Not currently used in Fizzygum⤶⤶  clickOutsideMeOrAnyOfMeChildrenCallback: [nil]⤶⤶  textDescription: nil⤶⤶  # note that not all the changed morphs have this flag set⤶  # because if a parent does a fullChanged, we don't set this⤶  # flag in the children. This is intentionally so,⤶  # as we don't want to navigate the children too many times.⤶  # If you want to know whether a morph has changed its⤶  # position, use the hasMaybeChangedGeometryOrPosition:⤶  # method instead, which looks at this flag (and another one).⤶  # See comment below on fullGeometryOrPositionPossiblyChanged⤶  # for more information.⤶  geometryOrPositionPossiblyChanged: false⤶  clippedBoundsWhenLastPainted: nil⤶⤶  # you'd be tempted to check this flag to figure out⤶  # whether any morph has possibly changed position but⤶  # you can't. If a PARENT has done a fullChanged, the⤶  # children are NOT set this flag. This flag is set⤶  # only for the parent morph, and it's important that⤶  # it stays that way for how the mechanism for fleshing out⤶  # the broken rectangles works. We flesh out the rectangles⤶  # of the ＂fully broken＂ morphs separately looking at this⤶  # flag, and we remove the rectangles of the sub-morphs that⤶  # have a parent with this flag since we know that they are⤶  # already covered.⤶  # If you want to figure out whether a morph has changed,⤶  # use the hasMaybeChangedGeometryOrPosition: method,⤶  # which checks recursively with the parents both the⤶  # fullGeometryOrPositionPossiblyChanged flag and the⤶  # geometryOrPositionPossiblyChanged flag.⤶  # Another way of doing this is to mark with a special flag⤶  # all the morph that touch their bounds or positions, but⤶  # then it's sort of costly to un-set such flag in all such⤶  # morphs, as we'd have to keep the ＂changed＂ morphs in a special⤶  # array to do that. Seems quite a bit more work and complication,⤶  # so just use the method.⤶  fullGeometryOrPositionPossiblyChanged: false⤶  fullClippedBoundsWhenLastPainted: nil⤶⤶  cachedFullBounds: nil⤶  childrenBoundsUpdatedAt: -1⤶⤶  cachedFullClippedBounds: nil⤶  checkFullClippedBoundsCache: nil⤶⤶  visibleBasedOnIsVisiblePropertyCache: nil⤶  checkVisibleBasedOnIsVisiblePropertyCache: ＂＂⤶⤶  clippedThroughBoundsCache: nil⤶  checkClippedThroughBoundsCache: ＂＂⤶⤶  clipThroughCache: nil⤶  checkClipThroughCache: nil⤶⤶  srcBrokenRect: nil⤶  dstBrokenRect: nil⤶⤶  layoutIsValid: true⤶  layoutSpec: LayoutSpec.ATTACHEDAS_FREEFLOATING⤶  layoutSpecDetails: nil⤶⤶  _showsAdders: false⤶⤶  highlighted: false⤶  # if this morph has the purpose of highlighting⤶  # another morph, then this field points to the⤶  # morph that this morph is supposed to highlight⤶  wdgtThisWdgtIsHighlighting: nil⤶⤶  destroyed: false⤶⤶  shadowInfo: nil⤶⤶  # some morphs such as references are given a⤶  # default ＂computed＂ position on the screen.⤶  # As long as the user didn't manually⤶  # reposition them, then we keep giving them a⤶  # computed position. BUT as soon as the user manually⤶  # places them, then we quit giving the widget a⤶  # computed position and rather we stick with the⤶  # position the user gave.⤶  userMovedThisFromComputedPosition: false⤶  positionFractionalInHoldingPanel: nil⤶  wasPositionedSlightlyOutsidePanel: false⤶⤶  connectionsCalculationToken: 314⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    @layoutSpecDetails = new WindowContentLayoutSpec PreferredSize.THIS_ONE_I_HAVE_NOW , PreferredSize.THIS_ONE_I_HAVE_NOW, 1⤶⤶  initialiseDefaultVerticalStackLayoutSpec: ->⤶    # use the existing VerticalStackLayoutSpec (if it's there)⤶    unless @layoutSpecDetails instanceof VerticalStackLayoutSpec⤶      @layoutSpecDetails = new VerticalStackLayoutSpec 1⤶⤶  mouseClickRight: ->⤶    # you could bring up what you right-click,⤶    # however for example that's not how OSX works.⤶    # Perhaps this could be a system setting?⤶    #@bringToForeground()⤶⤶    world.hand.openContextMenuAtPointer @⤶⤶  getTextDescription: ->⤶    if @textDescription?⤶      #console.log ＂got name: ＂ + @textDescription + ＂＂ + @constructor.name + ＂ (adhoc description of morph)＂⤶      return @textDescription + ＂＂ + (@constructor.name.replace ＂Wdgt＂, ＂＂) + ＂ (adhoc description of morph)＂⤶    else⤶      #console.log ＂got name: ＂ + @constructor.name + ＂ (class name)＂⤶      return (@constructor.name.replace ＂Wdgt＂, ＂＂) + ＂ (class name)＂⤶⤶  identifyViaTextLabel: ->⤶    myTextDescription = @getTextDescription()⤶    allCandidateMorphsWithSameTextDescription = ⤶      world.allChildrenTopToBottomSuchThat (m) ->⤶        m.getTextDescription() == myTextDescription⤶⤶    position = allCandidateMorphsWithSameTextDescription.indexOf @⤶⤶    theLenght = allCandidateMorphsWithSameTextDescription.length⤶    #console.log [myTextDescription, position, theLenght]⤶    return [myTextDescription, position, theLenght]⤶⤶⤶⤶  uniqueIDString: ->⤶    @morphClassString() + ＂#＂ + @instanceNumericID⤶⤶  morphClassString: ->⤶    @constructor.name or @constructor.toString().split(＂ ＂)[1].split(＂(＂)[0]⤶⤶  @morphFromUniqueIDString: (theUniqueID) ->⤶    result = world.topWdgtSuchThat (m) =>⤶      m.uniqueIDString() is theUniqueID⤶    if not result?⤶      alert ＂theUniqueID ＂ + theUniqueID + ＂ not found!＂⤶    return result⤶⤶  assignUniqueID: ->⤶    @constructor.instancesCounter++⤶    @constructor.lastBuiltInstanceNumericID++⤶    @instanceNumericID = @constructor.lastBuiltInstanceNumericID⤶⤶  # some test commands specify morphs via⤶  # their uniqueIDString. This means that⤶  # if there is one more TextMorph anywhere during⤶  # the playback, for example because⤶  # one new menu item is added, then⤶  # all the subsequent IDs for the TextMorph will be off.⤶  # In order to sort that out, we occasionally re-align⤶  # the counts to the next 1000, so the next Widgets⤶  # being created will all be aligned and⤶  # minor discrepancies are ironed-out⤶  @roundNumericIDsToNextThousand: ->⤶    #console.log ＂@roundNumericIDsToNextThousand＂⤶    # this if is because zero and multiples of 1000⤶    # don't go up to 1000⤶    if @lastBuiltInstanceNumericID % 1000 == 0⤶      @lastBuiltInstanceNumericID++⤶    @lastBuiltInstanceNumericID = 1000 * Math.ceil @lastBuiltInstanceNumericID / 1000⤶⤶  startCountdownForBubbleHelp: (contents) ->⤶    ToolTipWdgt.createInAWhileIfHandStillContainedInMorph @, contents⤶⤶  constructor: ->⤶    super()⤶    @assignUniqueID()⤶⤶    if Automator? and Automator.state == Automator.RECORDING⤶      arr = world.automator.tagsCollectedWhileRecordingTest⤶      if @constructor.name not in arr⤶        arr.push @constructor.name⤶⤶    @bounds = Rectangle.EMPTY⤶    @minimumExtent = new Point 5,5⤶⤶    @silentRawSetBounds new Rectangle 0,0,50,40⤶⤶    @lastTime = Date.now()⤶    # Note that we don't call ⤶    # that's because the actual extending morph will probably⤶    # set more details of how it should look (e.g. size),⤶    # so we wait and we let the actual extending⤶    # morph to draw itself.⤶⤶⤶⤶  # this happens when the Widget's constructor runs⤶  # and also when the Widget is duplicated⤶  registerThisInstance: ->⤶    goingUpClassHyerarchy = @constructor⤶    loop⤶      # __super__ will always get to Object,⤶      # which doesn't have the ＂instances＂ property⤶      if !goingUpClassHyerarchy.instances?⤶        break⤶      goingUpClassHyerarchy.instances.add @⤶      goingUpClassHyerarchy = goingUpClassHyerarchy.__super__.constructor⤶⤶  # this happens when the Widget is destroyed⤶  unregisterThisInstance: ->⤶    # remove instance from the instances tracker⤶    # in the class. To see this: just create an⤶    # AnalogClockWdgt, see that⤶    # AnalogClockWdgt.instances has one⤶    # element. Then delete the clock, and see that the⤶    # tracker is now an empty array.⤶    goingUpClassHyerarchy = @constructor⤶    loop⤶      # __super__ will always get to Object,⤶      # which doesn't have the ＂instances＂ property⤶      if !goingUpClassHyerarchy.instances?⤶        break⤶      goingUpClassHyerarchy.instances.delete @⤶      goingUpClassHyerarchy = goingUpClassHyerarchy.__super__.constructor⤶⤶⤶  isTransparentAt: (aPoint) ->⤶    @appearance?.isTransparentAt aPoint⤶⤶  # useful for example when hovering over references⤶  # to morphs. Can only modify the rendering of a morph,⤶  # so any highlighting is only visible in the measure that⤶  # the morph is visible (as opposed to HighlighterMorph being⤶  # used to highlight a morph)⤶  paintHighlight: (aContext, al, at, w, h) ->⤶    @appearance?.paintHighlight aContext, al, at, w, h⤶⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶    @appearance?.paintIntoAreaOrBlitFromBackBuffer aContext, clippingRectangle, appliedShadow⤶⤶  # painting strokes is a little delicate because they need to⤶  # be painted INSIDE the morph (otherwise a) adjacent morphs, of morphs⤶  # within a layout would make a mess and b) clipping morph would⤶  # present a problem).⤶  # Also, Panels are tricky⤶  # because they need to paint the strokes after they paint their⤶  # content (because the content could paint everywhere inside the⤶  # Panel).⤶  # If you are thinking that you could paint the stroke before⤶  # the contents, by just⤶  # painting the contents of the Panel slightly clipped ＂inside＂ the⤶  # border of the Panel, that could potentially work with enough⤶  # changes, but it would only be easy to do with rectangular Panels,⤶  # since clipping ＂on the inside＂ of a border of arbitrary shape is⤶  # not trivial, maybe you'd have to examine how the lines cross at⤶  # different angles to paint ＂inside＂ of the lines, looks very messy.⤶  # Much easier to just paint the stroke after the content.⤶  paintStroke: (aContext, clippingRectangle) ->⤶    if @appearance?⤶      if @appearance.paintStroke?⤶        @appearance.paintStroke aContext, clippingRectangle⤶⤶  addShapeSpecificMenuItems: (menu) ->⤶    if @appearance?.addShapeSpecificMenuItems?⤶      return @appearance.addShapeSpecificMenuItems menu⤶    return menu⤶⤶⤶  addShapeSpecificNumericalSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    if !menuEntriesStrings? ⤶      menuEntriesStrings = []⤶      functionNamesStrings = []⤶⤶    if @appearance?.addShapeSpecificNumericalSetters?⤶      [menuEntriesStrings, functionNamesStrings] = @appearance.addShapeSpecificNumericalSetters menuEntriesStrings, functionNamesStrings⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  ⤶  #⤶  #    damage list housekeeping⤶  #⤶  #	the trackChanges property of the Widget prototype is a Boolean switch⤶  #	that determines whether the World's damage list ('broken' rectangles)⤶  #	tracks changes. By default the switch is always on. If set to false,⤶  #	changes are not stored. This can be very useful for housekeeping of⤶  #	the damage list in situations where a large number of (sub-) morphs⤶  #	are changed more or less at once. Instead of keeping track of every⤶  #	single submorph's changes tremendous performance improvements can be⤶  #	achieved by setting the trackChanges flag to false before propagating⤶  #	the layout changes, setting it to true again and then storing the full⤶  #	bounds of the surrounding morph. An an example refer to the⤶  #⤶  #		layoutSubmorphs()⤶  #		⤶  #	method of InspectorMorph⤶  ⤶  ⤶  # Widget string representation: e.g. 'a Widget' or 'a Widget#2'⤶  toString: ->⤶    firstPart = ＂a ＂⤶⤶    if Automator? and Automator.state != Automator.IDLE and Automator.hidingOfMorphsNumberIDInLabels⤶      return firstPart + @morphClassString()⤶    else⤶      return firstPart + @uniqueIDString()⤶⤶  close: ->⤶⤶    # closing window content: also close the window⤶    # UNLESS we are an internal window, in such case⤶    # leave the parent one as is⤶    if !(@ instanceof WindowWdgt) and @parent? and @parent instanceof WindowWdgt⤶      @parent.close()⤶      return⤶⤶    world.wdgtsDetectingClickOutsideMeOrAnyOfMeChildren.delete @⤶    @parent?.childBeingClosed? @⤶    if world.basementWdgt?⤶      world.basementWdgt.scrollPanel.contents.addInPseudoRandomPosition @⤶    else⤶      world.inform ＂There is no⧹nbasement to go in!＂⤶⤶  closeFromContainerWindow: (containerWindow) ->⤶    containerWindow.close()  ⤶  ⤶  # Widgets destroying ======⤶  # this is different from a widget being closed/deleted⤶  # when a widget is destroyed, it's removed from the stepping⤶  # list and marked as destroyed.⤶  # NOTE that the tree under this widget is kept intact,⤶  # so this widget could be duplicated and revived⤶  destroy: ->⤶⤶    @parent?.childBeingDestroyed? @⤶    @unregisterThisInstance()⤶    world.wdgtsDetectingClickOutsideMeOrAnyOfMeChildren.delete @⤶⤶    @destroyed = true⤶    @parent?.invalidateLayout()⤶    @breakNumberOfRawMovesAndResizesCaches()⤶    WorldMorph.numberOfAddsAndRemoves++⤶⤶    world.steppingWdgts.delete @⤶⤶    # if there is anything being edited inside⤶    # what we are destroying, then also⤶    # invoke stopEditing()⤶    if world.caret?⤶      if @isAncestorOf world.caret.target⤶        world.stopEditing()⤶⤶    # remove callback when user clicks outside⤶    # me or any of my children⤶    @onClickOutsideMeOrAnyOfMyChildren nil⤶⤶    if @parent?⤶      previousParent = @parent⤶      # if the morph contributes to a shadow, unfortunately⤶      # we have to walk towards the top to⤶      # break the morph that has the shadow.⤶      firstParentOwningMyShadow = @firstParentOwningMyShadow()⤶      if firstParentOwningMyShadow?⤶        firstParentOwningMyShadow.fullChanged()⤶      else⤶        @fullChanged()⤶⤶      previousParent.removeChild @⤶      if previousParent.childRemoved?⤶        previousParent.childRemoved @⤶⤶    # in case I'm a destory at the end of a fullDestroy,⤶    # the children array is already empty⤶    if @children.length != 0⤶      @children = []⤶⤶    return nil⤶  ⤶  # destroys the whole tree⤶  # from the bottom (leaf widgets, drawn on top⤶  # of everything) to the top⤶  fullDestroy: ->⤶    WorldMorph.numberOfAddsAndRemoves++⤶    # we can't use a normal iterator because⤶    # we are iterating over an array that changes⤶    # its length as we are deleting its contents⤶    # while we are iterating on it.⤶    until @children.length == 0⤶      @children[0].fullDestroy()⤶    @destroy()⤶    return nil⤶⤶  closeChildren: ->⤶    WorldMorph.numberOfAddsAndRemoves++⤶    # we can't use a normal iterator because⤶    # we are iterating over an array that changes⤶    # its length as we are deleting its contents⤶    # while we are iterating on it.⤶    until @children.length == 0⤶      @children[0].close()⤶    return nil⤶⤶  fullDestroyChildren: ->⤶    if @children.length == 0⤶      return⤶⤶    WorldMorph.numberOfAddsAndRemoves++⤶    # we can't use a normal iterator because⤶    # we are iterating over an array that changes⤶    # its length as we are deleting its contents⤶    # while we are iterating on it.⤶    until @children.length == 0⤶      @children[0].fullDestroy()⤶    return nil⤶⤶  setLayoutSpec: (newLayoutSpec) ->⤶    if @layoutSpec == newLayoutSpec⤶      return⤶⤶    @layoutSpec = newLayoutSpec⤶⤶    # The resizing handle becomes visible/invisible⤶    # when the layout spec of the parent changes⤶    # (typically it's visible only when freefloating)⤶    isThereAnHandle = @firstChildSuchThat (m) ->⤶      m instanceof HandleMorph⤶    if isThereAnHandle?⤶      isThereAnHandle.updateVisibilityAndPosition()⤶⤶⤶⤶  ⤶  # leaving this function as step means that the morph wants to do nothing⤶  # but the children *are* traversed and their step function is invoked.⤶  # If a Widget wants to do nothing and wants to prevent the children to be⤶  # traversed, then this function should be set to nil.⤶  step: noOperation⤶  ⤶  ⤶  # Widget accessing - geometry getting:⤶  left: ->⤶    @bounds.left()⤶  ⤶  right: ->⤶    @bounds.right()⤶  ⤶  top: ->⤶    @bounds.top()⤶  ⤶  bottom: ->⤶    @bounds.bottom()⤶  ⤶  center: ->⤶    @bounds.center()⤶  ⤶  bottomCenter: ->⤶    @bounds.bottomCenter()⤶  ⤶  bottomLeft: ->⤶    @bounds.bottomLeft()⤶  ⤶  bottomRight: ->⤶    @bounds.bottomRight()⤶  ⤶  boundingBox: ->⤶    @bounds⤶  ⤶  # Widget accessing - geometry getting:⤶  leftTight: ->⤶    @bounds.left() + @paddingLeft⤶  ⤶  rightTight: ->⤶    @bounds.right() - @paddingRight⤶  ⤶  topTight: ->⤶    @bounds.top() + @paddingTop⤶  ⤶  bottomTight: ->⤶    @bounds.bottom() - @paddingBottom⤶  ⤶  bottomCenterTight: ->⤶    @bounds.bottomCenter().subtract new Point 0, @paddingBottom⤶  ⤶  bottomLeftTight: ->⤶    @bounds.bottomLeft().add new Point @paddingLeft, -@paddingBottom⤶  ⤶  bottomRightTight: ->⤶    @bounds.bottomRight().subtract new Point @paddingRight, @paddingBottom⤶  ⤶  boundingBoxTight: ->⤶    new Rectangle @leftTight(), @topTight(), @rightTight(), @bottomTight()⤶⤶  rawResizeToWithoutSpacing: ->⤶⤶  rawSetWidthSizeHeightAccordingly: (newWidth) ->⤶    @rawSetWidth newWidth⤶    if @implementsDeferredLayout()⤶      @invalidateLayout()⤶  ⤶  # note that using this one, the children⤶  # morphs attached as floating don't move⤶  rawSetBounds: (newBounds) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    if @bounds.eq newBounds⤶      return⤶⤶    unless @bounds.origin.eq newBounds.origin⤶      @bounds = @bounds.translateTo newBounds.origin⤶      @breakNumberOfRawMovesAndResizesCaches()⤶      @changed()⤶⤶    @rawSetExtent newBounds.extent()⤶⤶  # high-level geometry-change API,⤶  # you don't actually change the geometry right away,⤶  # you just ask for the desired change and wait for the⤶  # layouting mechanism to do its best to satisfy it⤶  setBounds: (aRectangle, morphStartingTheChange = nil) ->⤶    #if window.recalculatingLayouts⤶    #  debugger⤶    if @layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING⤶      return⤶    else⤶      aRectangle = aRectangle.round()⤶⤶      newExtent = new Point aRectangle.width(), aRectangle.height()⤶      unless @extent().eq newExtent⤶        @desiredExtent = newExtent⤶        @invalidateLayout()⤶⤶      newPos = aRectangle.origin.copy()⤶      unless @position().eq newPos⤶        @desiredPosition = newPos⤶        @invalidateLayout()⤶⤶⤶  silentRawSetBounds: (newBounds) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    if @bounds.eq newBounds⤶      return⤶⤶    unless @bounds.origin.eq newBounds.origin⤶      @bounds = @bounds.translateTo newBounds.origin⤶      @breakNumberOfRawMovesAndResizesCaches()⤶⤶    @silentRawSetExtent newBounds.extent()⤶  ⤶⤶  ⤶  leftCenter: ->⤶    @bounds.leftCenter()⤶  ⤶  rightCenter: ->⤶    @bounds.rightCenter()⤶  ⤶  topCenter: ->⤶    @bounds.topCenter()⤶  ⤶  # same as position()⤶  topLeft: ->⤶    @bounds.origin⤶  ⤶  topRight: ->⤶    @bounds.topRight()⤶  ⤶  position: ->⤶    @bounds.origin⤶⤶  positionFractionalInMorph: (theMorph) ->⤶    [relativeXPos, relativeYPos] = @positionPixelsInMorph theMorph⤶    fractionalXPos = relativeXPos / theMorph.width()⤶    fractionalYPos = relativeYPos / theMorph.height()⤶    return [fractionalXPos, fractionalYPos]⤶⤶  extentFractionalInMorph: (theMorph) ->⤶    width = @width()⤶    height = @height()⤶    fractionalWidth = width / theMorph.width()⤶    fractionalHeight = height / theMorph.height()⤶    return [fractionalWidth, fractionalHeight]⤶⤶  positionPixelsInMorph: (theMorph) ->⤶    relativePos = @position().toLocalCoordinatesOf theMorph⤶    return [relativePos.x, relativePos.y]⤶  ⤶  extent: ->⤶    @bounds.extent()⤶  ⤶  width: ->⤶    @bounds.width()⤶⤶  # e.g. images can have a lot of spacing⤶  # around them, so here is a method to get⤶  # the width of the actual thing, ignoring all⤶  # the spacing that might be around⤶  widthWithoutSpacing: ->⤶    @width()⤶  ⤶  height: ->⤶    @bounds.height()⤶⤶⤶  ⤶  leftCenterTight: ->⤶    @bounds.leftCenter().add new Point @paddingLeft, 0⤶  ⤶  rightCenterTight: ->⤶    @bounds.rightCenter().subtract new Point @paddingRight, 0⤶  ⤶  topCenterTight: ->⤶    @bounds.topCenter().add new Point 0, @paddingTop⤶  ⤶  # same as position()⤶  topLeftTight: ->⤶    @bounds.origin.add new Point @paddingLeft, @paddingTop⤶  ⤶  topRightTight: ->⤶    @bounds.topRight.add new Point -@paddingRight, @paddingTop⤶  ⤶  positionTight: ->⤶    @bounds.origin.add new Point @paddingLeft, @paddingTop⤶  ⤶  extentTight: ->⤶    @bounds.extent().subtract new Point - (@paddingLeft + @paddingRight), - (@paddingTop + @paddingBottom)⤶  ⤶  widthTight: ->⤶    @bounds.width() - (@paddingLeft + @paddingRight)⤶  ⤶  heightTight: ->⤶    @bounds.height() - (@paddingTop + @paddingBottom)⤶⤶⤶  # used for example:⤶  # - to determine which morphs you can attach a morph to⤶  # - for a SliderMorph's ＂set target＂ so you can change properties of another Widget⤶  # - by the HandleMorph when you attach it to some other morph⤶  # Note that this method has a slightly different⤶  # version in PanelWdgt (because it clips, so we need⤶  # to check that we don't consider overlaps with⤶  # morphs contained in a Panel that are clipped and⤶  # hence *actually* not overlapping).⤶  plausibleTargetAndDestinationMorphs: (theMorph) ->⤶    # find if I intersect theMorph,⤶    # then check my children recursively⤶    # exclude me if I'm a child of theMorph⤶    # (cause it's usually odd to attach a Widget⤶    # to one of its submorphs or for it to⤶    # control the properties of one of its submorphs)⤶    result = []⤶    if @visibleBasedOnIsVisibleProperty() and⤶        !@isCollapsed() and⤶        !theMorph.isAncestorOf(@) and⤶        @areBoundsIntersecting(theMorph) and⤶        !@anyParentPopUpMarkedForClosure()⤶      result = [@]⤶⤶    @children.forEach (child) ->⤶      result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph))⤶⤶    return result⤶⤶⤶  # both methods invoked in here⤶  # are cached⤶  # used in the method fleshOutBroken⤶  # to skip the ＂destination＂ broken rects⤶  # for morphs that marked themselves⤶  # as broken but at moment of destination⤶  # might be invisible⤶  # TODO for sure this should also check for the .destroyed flag⤶  surelyNotShowingUpOnScreenBasedOnVisibilityCollapseAndOrphanage: ->⤶    if !@isVisible⤶      return true⤶⤶    if @isOrphan()⤶      return true⤶⤶    if !@visibleBasedOnIsVisibleProperty()⤶      return true⤶⤶    if @isCollapsed()⤶      return true⤶⤶    return false⤶⤶⤶  SLOWvisibleBasedOnIsVisibleProperty: ->⤶    if !@isVisible⤶      return false⤶    if @parent?⤶      return @parent.SLOWvisibleBasedOnIsVisibleProperty()⤶    else⤶      return true⤶⤶  # doesn't check orphanage⤶  visibleBasedOnIsVisibleProperty: ->⤶    if !@isVisible⤶      # I'm not sure updating the cache here does⤶      # anything but it's two lines so let's do it⤶      @checkVisibleBasedOnIsVisiblePropertyCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges⤶      @visibleBasedOnIsVisiblePropertyCache = false⤶      result = @visibleBasedOnIsVisiblePropertyCache⤶    else # @isVisible is true⤶      if !@parent?⤶        result = true⤶      else⤶        if @checkVisibleBasedOnIsVisiblePropertyCache == WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges⤶          #console.log ＂cache hit visibleBasedOnIsVisibleProperty＂⤶          result = @visibleBasedOnIsVisiblePropertyCache⤶        else⤶          #console.log ＂cache miss visibleBasedOnIsVisibleProperty＂⤶          @checkVisibleBasedOnIsVisiblePropertyCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges⤶          @visibleBasedOnIsVisiblePropertyCache = @parent.visibleBasedOnIsVisibleProperty()⤶          result = @visibleBasedOnIsVisiblePropertyCache⤶⤶    if world.doubleCheckCachedMethodsResults⤶      if result != @SLOWvisibleBasedOnIsVisibleProperty()⤶        debugger⤶        alert ＂visibleBasedOnIsVisibleProperty is broken＂⤶⤶    return result⤶⤶⤶  # Note that in a case of a fullMove*⤶  # you should also invalidate all the morphs in⤶  # the subtree as well.⤶  # This happens indirectly as the fullMove* methods⤶  # move all the children too, so *that*⤶  # invalidates them. Note that things might change⤶  # if you use a different coordinate system, in which⤶  # case you have to invalidate the caches in all the⤶  # submorphs manually or use some other cache⤶  # invalidation mechanism.⤶  invalidateFullBoundsCache: ->⤶    if !@cachedFullBounds?⤶      return⤶    @cachedFullBounds = nil⤶    if @parent?.cachedFullBounds?⤶        @parent.invalidateFullBoundsCache @⤶⤶  invalidateFullClippedBoundsCache: ->⤶    if !@checkFullClippedBoundsCache?⤶      return⤶    @checkFullClippedBoundsCache = nil⤶    if @parent?.checkFullClippedBoundsCache?⤶        @parent.invalidateFullClippedBoundsCache @⤶⤶⤶  # doesn't take into account orphanage⤶  # or visibility⤶  SLOWfullBounds: ->⤶    result = @bounds⤶    @children.forEach (child) ->⤶      if child.visibleBasedOnIsVisibleProperty() and⤶      !child.isCollapsed()⤶        result = result.merge child.SLOWfullBounds()⤶    result⤶⤶  SLOWfullClippedBounds: ->⤶    if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()⤶      return Rectangle.EMPTY⤶    result = @clippedThroughBounds()⤶    @children.forEach (child) ->⤶      if child.visibleBasedOnIsVisibleProperty() and !child.isCollapsed()⤶        result = result.merge child.SLOWfullClippedBounds()⤶    #if this != world and result.corner.x > 400 and result.corner.y > 100 and result.origin.x ==0 and result.origin.y ==0⤶    #  debugger⤶    result⤶⤶  # for PanelWdgt scrolling support⤶  subMorphsMergedFullBounds: ->⤶    result = nil⤶    if @children.length⤶      result = @children[0].bounds⤶      @children.forEach (child) ->⤶        # we exclude the HandleMorphs because they⤶        # mangle how the Panel inside ScrollPanelWdgts⤶        # calculate their size when they are resized⤶        # (remember that the resizing handle of ScrollPanelWdgts⤶        # actually end up in the Panel inside them.)⤶        if !(child instanceof HandleMorph) and !(child instanceof CaretMorph)⤶          # if a morph implements deferred layout, then⤶          # really we can't consider the sizes and positions⤶          # of its children, so stick to the parent bounds⤶          # only⤶          if child.implementsDeferredLayout()⤶            result = result.merge child.bounds⤶          else⤶            result = result.merge child.fullBounds()⤶    result    ⤶⤶  # does not take into account orphanage or visibility⤶  fullBounds: ->⤶    if @cachedFullBounds?⤶      if world.doubleCheckCachedMethodsResults⤶        if !@cachedFullBounds.eq @SLOWfullBounds()⤶          debugger⤶          alert ＂fullBounds is broken (cached)＂⤶      return @cachedFullBounds⤶⤶    result = @bounds⤶    @children.forEach (child) ->⤶      if child.visibleBasedOnIsVisibleProperty() and !child.isCollapsed()⤶        result = result.merge child.fullBounds()⤶⤶    if world.doubleCheckCachedMethodsResults⤶      if !result.eq @SLOWfullBounds()⤶        debugger⤶        alert ＂fullBounds is broken (uncached)＂⤶⤶    @cachedFullBounds = result⤶⤶  # this one does take into account orphanage and⤶  # visibility. The reason is that this is used to⤶  # find the smallest broken rectangle created by⤶  # a fullChanged(), which means that really we⤶  # are interested in what's visible on screen so⤶  # we do take into account orphanage and⤶  # visibility.⤶  fullClippedBounds: ->⤶    if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()⤶      result = Rectangle.EMPTY⤶    else⤶      if @checkFullClippedBoundsCache == WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶        if world.doubleCheckCachedMethodsResults⤶          if !@cachedFullClippedBounds.eq @SLOWfullClippedBounds()⤶            debugger⤶            alert ＂fullClippedBounds is broken＂⤶        return @cachedFullClippedBounds⤶⤶      # you'd be thinking this is the same as⤶      #   result = @fullBounds().intersect @clipThrough()⤶      # but it's not, because fullBounds doesn't⤶      # take into account orphanage and visibility⤶⤶      result = @clippedThroughBounds()⤶      @children.forEach (child) ->⤶        if child.visibleBasedOnIsVisibleProperty() and !child.isCollapsed()⤶          result = result.merge child.fullClippedBounds()⤶⤶    if world.doubleCheckCachedMethodsResults⤶      if !result.eq @SLOWfullClippedBounds()⤶        debugger⤶        alert ＂fullClippedBounds is broken＂⤶⤶    @checkFullClippedBoundsCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶    @cachedFullClippedBounds = result⤶  ⤶  # this one does take into account orphanage and⤶  # visibility. The reason is that this is used to⤶  # find the smallest broken rectangle created by⤶  # a changed(), which means that really we⤶  # are interested in what's visible on screen so⤶  # we do take into account orphanage and⤶  # visibility.⤶  clippedThroughBounds: ->⤶⤶    if @checkClippedThroughBoundsCache == WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶      #console.log ＂cache hit @checkClippedThroughBoundsCache＂⤶      return @clippedThroughBoundsCache⤶    #else⤶    #  console.log ＂cache miss @checkClippedThroughBoundsCache＂⤶    #  #console.log (WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes) + ＂ cache: ＂ + @checkClippedThroughBoundsCache⤶    #  #debugger⤶⤶    if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()⤶      @checkClippedThroughBoundsCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶      @clippedThroughBoundsCache = Rectangle.EMPTY⤶      return @clippedThroughBoundsCache ⤶⤶    @checkClippedThroughBoundsCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶    @clippedThroughBoundsCache = @boundingBox().intersect @clipThrough()⤶    return @clippedThroughBoundsCache⤶  ⤶  # this one does take into account orphanage and⤶  # visibility. The reason is that this is used to⤶  # find the ＂smallest broken rectangles＂⤶  # which means that really we⤶  # are interested in what's visible on screen so⤶  # we do take into account orphanage and⤶  # visibility.⤶  clipThrough: ->⤶    # answer which part of me is not clipped by a Panel⤶    if @ == Window⤶      debugger⤶⤶    if @checkClipThroughCache == WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶      #console.log ＂cache hit @checkClipThroughCache＂⤶      return @clipThroughCache⤶    #else⤶    #  console.log ＂cache miss @checkClipThroughCache＂⤶    #  #console.log (WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes) + ＂ cache: ＂ + @checkClipThroughCache⤶    #  #debugger⤶⤶    if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()⤶      @checkClipThroughCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶      @clipThroughCache = Rectangle.EMPTY⤶      return @clipThroughCache ⤶⤶    firstParentClippingAtBounds = @firstParentClippingAtBounds()⤶    if !firstParentClippingAtBounds?⤶      firstParentClippingAtBounds = world⤶    firstParentClippingAtBoundsClipThroughBounds = firstParentClippingAtBounds.clipThrough()⤶    @checkClipThroughCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶    if @clipsAtRectangularBounds⤶      @clipThroughCache = @boundingBox().intersect firstParentClippingAtBoundsClipThroughBounds⤶    else⤶      @clipThroughCache = firstParentClippingAtBoundsClipThroughBounds⤶⤶⤶    return @clipThroughCache⤶  ⤶  ⤶  # Widget accessing - simple changes:⤶  fullRawMoveBy: (delta) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    if delta.isZero() then return⤶    #console.log ＂move 4＂⤶    @breakNumberOfRawMovesAndResizesCaches()⤶    @fullChanged()⤶    @bounds = @bounds.translateBy delta⤶⤶    # note that if I am a submorph of a morph directly⤶    # inside a non-text-wrapping ScrollPanelWdgt then this⤶    # is not going to work. So if I'm a box attached to a⤶    # box inside a non-text-wrapping ScrollPanelWdgt then⤶    # there will be no adjusting of bounds of the ScrollPanel⤶    # not the adjusting of the scrollbars.⤶    # This could be done, we could check up the chain to find⤶    # if we are indirectly inside a ScrollPanel however⤶    # there might be performance implications, so I'd probably⤶    # have to introduce caching, and this whole mechanism should⤶    # go away with proper layouts...⤶    if @amIDirectlyInsideNonTextWrappingScrollPanelWdgt()⤶      @parent.parent.adjustContentsBounds()⤶      @parent.parent.adjustScrollBars()⤶    if @parent instanceof SimpleVerticalStackPanelWdgt⤶      @parent.adjustContentsBounds()⤶⤶    @children.forEach (child) ->⤶      child.silentFullRawMoveBy delta⤶⤶  silentFullRawMoveBy: (delta) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    #console.log ＂move 5＂⤶    @breakNumberOfRawMovesAndResizesCaches()⤶    @bounds = @bounds.translateBy delta    ⤶    @children.forEach (child) ->⤶      child.silentFullRawMoveBy delta⤶  ⤶  breakNumberOfRawMovesAndResizesCaches: ->⤶    @invalidateFullBoundsCache @⤶    @invalidateFullClippedBoundsCache @⤶    if @ instanceof ActivePointerWdgt⤶      if @children.length == 0⤶        return⤶    WorldMorph.numberOfRawMovesAndResizes++⤶⤶  # moving to fractional position within the desktop is⤶  # different from the case below because the desktop can be⤶  # resized to any ratio⤶  fullRawMoveInDesktopToFractionalPosition: (boundsOfParent) ->⤶    if !boundsOfParent?⤶      boundsOfParent = @parent.bounds⤶⤶    # we do one dimension at a time here for a subtle reason: if⤶    # say a window has the left side beyond the left side of the desktop⤶    # then the x of positionFractionalInHoldingPanel is NEGATIVE⤶    # and as one shrinks the browser the window comes TO THE RIGHT.⤶    # This might make some mathematical sense but is very unintuitive so⤶    # we just don't move widgets along the dimensions that have a negative⤶    # fractional component⤶    if @positionFractionalInHoldingPanel[0] > 0⤶      @fullRawMoveTo (new Point boundsOfParent.left() + (boundsOfParent.width() * @positionFractionalInHoldingPanel[0]), @top()).round()⤶    if @positionFractionalInHoldingPanel[1] > 0⤶      @fullRawMoveTo (new Point @left(), boundsOfParent.top() + (boundsOfParent.height() * @positionFractionalInHoldingPanel[1])).round()⤶⤶  fullRawMoveInStretchablePanelToFractionalPosition: (boundsOfParent) ->⤶    if !boundsOfParent?⤶      boundsOfParent = @parent.bounds⤶⤶    @fullRawMoveTo (⤶      new Point ⧹⤶       boundsOfParent.left() + (boundsOfParent.width() * @positionFractionalInHoldingPanel[0]),⤶       boundsOfParent.top() + (boundsOfParent.height() * @positionFractionalInHoldingPanel[1])⤶    ).round()⤶⤶  rawSetExtentToFractionalExtentInPaneUserHasSet: (boundsOfParent) ->⤶    if !boundsOfParent?⤶      boundsOfParent = @parent.bounds⤶⤶    @rawSetExtent new Point @extentFractionalInHoldingPanel[0] * boundsOfParent.width(), @extentFractionalInHoldingPanel[1] * boundsOfParent.height()⤶⤶  ⤶  fullRawMoveTo: (aPoint) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    aPoint.debugIfFloats()⤶    delta = aPoint.toLocalCoordinatesOf @⤶    if !delta.isZero()⤶      #console.log ＂move 6＂⤶      @breakNumberOfRawMovesAndResizesCaches()⤶      @fullRawMoveBy delta⤶    @bounds.debugIfFloats()⤶⤶  # high-level geometry-change API,⤶  # you don't actually change the geometry right away,⤶  # you just ask for the desired change and wait for the⤶  # layouting mechanism to do its best to satisfy it⤶  fullMoveTo: (aPoint, morphStartingTheChange = nil) ->⤶    #if window.recalculatingLayouts⤶    #  debugger⤶⤶    if @layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING⤶      return⤶    else⤶      aPoint = aPoint.round()⤶      newX = Math.max aPoint.x, 0⤶      newY = Math.max aPoint.y, 0⤶      newPos = new Point newX, newY⤶      unless @position().eq newPos⤶        @desiredPosition = newPos⤶        @invalidateLayout()⤶        # all the moves via the handles arrive here,⤶        # where we remember the fractional position in the⤶        # holding panel. That is so for example moving⤶        # items inside a StretchablePanel causes their⤶        # relative position to be remembered, so resizing⤶        # the stretchable panel will get them to the⤶        # correct positions⤶        if morphStartingTheChange? and @parent? and (morphStartingTheChange instanceof HandleMorph)⤶          @rememberFractionalPositionInHoldingPanel()⤶⤶⤶  rememberFractionalPositionInHoldingPanel: ->⤶    @positionFractionalInHoldingPanel = @positionFractionalInMorph @parent⤶⤶  rememberFractionalExtentInHoldingPanel: ->⤶    @extentFractionalInHoldingPanel = @extentFractionalInMorph @parent⤶⤶  # TODO this is used a lot, where I suspect all we need to do⤶  # is to do this automatically ALSO when a widget is added/moved⤶  # to a new parent. I don't dare to do this now because I don't⤶  # have enough tests in the new environment to check for⤶  # bad implications.⤶  rememberFractionalSituationInHoldingPanel: ->⤶    @rememberFractionalPositionInHoldingPanel()⤶    @rememberFractionalExtentInHoldingPanel()⤶    @wasPositionedSlightlyOutsidePanel = ! @parent.bounds.containsRectangle @bounds⤶  ⤶  silentFullRawMoveTo: (aPoint) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    #console.log ＂move 7＂⤶    @breakNumberOfRawMovesAndResizesCaches()⤶    delta = aPoint.toLocalCoordinatesOf @⤶    @silentFullRawMoveBy delta  if (delta.x isnt 0) or (delta.y isnt 0)⤶  ⤶  fullRawMoveLeftSideTo: (x) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    @fullRawMoveTo new Point x, @top()⤶  ⤶  fullRawMoveRightSideTo: (x) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    @fullRawMoveTo new Point x - @width(), @top()⤶  ⤶  fullRawMoveTopSideTo: (y) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    @fullRawMoveTo new Point @left(), y⤶  ⤶  fullRawMoveBottomSideTo: (y) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    @fullRawMoveTo new Point @left(), y - @height()⤶  ⤶  fullRawMoveCenterTo: (aPoint) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    @fullRawMoveTo aPoint.subtract @extent().floorDivideBy 2⤶⤶  fullRawMoveToSideOf: (aWidget) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    @fullRawMoveTo aWidget.topRight().add new Point 10, -Math.round((@height() - aWidget.height())/2)⤶    @fullRawMoveWithin @parent⤶  ⤶  fullRawMoveFullCenterTo: (aPoint) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    @fullRawMoveTo aPoint.subtract @fullBounds().extent().floorDivideBy 2⤶  ⤶  # make sure I am completely within another Widget's bounds⤶  fullRawMoveWithin: (aWdgt) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    # in case of widgets with deferred layouts we need⤶    # to look into desired extent and desired position⤶    if @desiredExtent?⤶      newBoundsForThisLayout = @desiredExtent⤶      @desiredExtent = nil⤶    else⤶      newBoundsForThisLayout = @extent()⤶⤶    if @desiredPosition?⤶      newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout⤶      @desiredPosition = nil⤶    else⤶      newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout⤶⤶    # ＂bake＂ the ＂deferred＂ size and position⤶    # into the current size and position⤶    @rawSetBounds newBoundsForThisLayout⤶⤶    # adjust the top side and the left side last, so that⤶    # the control buttons in the window bars are still⤶    # visible/reachable⤶    # Note that we have to update newBoundsForThisLayout as⤶    # we update the widget position!⤶⤶    rightOff = newBoundsForThisLayout.right() - aWdgt.right()⤶    if rightOff > 0⤶      @fullRawMoveBy new Point -rightOff, 0⤶      newBoundsForThisLayout = @bounds⤶⤶    leftOff = newBoundsForThisLayout.left() - aWdgt.left()⤶    if leftOff < 0⤶      @fullRawMoveBy new Point -leftOff, 0⤶      newBoundsForThisLayout = @bounds⤶⤶    bottomOff = newBoundsForThisLayout.bottom() - aWdgt.bottom()⤶    if bottomOff > 0⤶      @fullRawMoveBy new Point 0, -bottomOff⤶      newBoundsForThisLayout = @bounds⤶    ⤶    topOff = newBoundsForThisLayout.top() - aWdgt.top()⤶    if topOff < 0⤶      @fullRawMoveBy new Point 0, -topOff⤶      newBoundsForThisLayout = @bounds⤶⤶    return⤶⤶  notifyChildrenThatParentHasReLayouted: ->⤶    for child in @children.slice()⤶      child.parentHasReLayouted()⤶⤶  # normally morphs do nothing when the⤶  # parent is layouting, as they are⤶  # placed with absolute positioning.⤶  # In some cases though, such as in the⤶  # case of the HandleMorph, a Widget⤶  # make take the occasion to do special things⤶  # In the case of the HandleMorph, it's going⤶  # to place itself in the bottom-right⤶  # corner.⤶  parentHasReLayouted: ->⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶  layoutInset: (morphStartingTheChange = nil) ->⤶    if @insetMorph?⤶      if @insetMorph != morphStartingTheChange⤶        @insetMorph.fullRawMoveTo @insetPosition()⤶        @insetMorph.rawSetExtent @insetSpaceExtent(), @⤶  ⤶  # the default of layoutSubmorphs⤶  # is to do nothing apart from notifying⤶  # the children (in case, for example,⤶  # there is a HandleMorph in this morph⤶  # which will cause the HandleMorph to⤶  # replace itself in the new position)⤶  # , but things like⤶  # the inspector might well want to⤶  # tweak many of their children...⤶  layoutSubmorphs: (morphStartingTheChange = nil) ->⤶    @layoutInset morphStartingTheChange⤶⤶    for child in @children.slice()⤶      if morphStartingTheChange != child⤶        child.parentHasReLayouted()⤶  ⤶⤶  # do nothing in most cases but for example for⤶  # layouts, if something inside a layout wants to⤶  # change extent, then the whole layout might need to⤶  # change extent.⤶  childChangedExtent: (theMorphChangingTheExtent) ->⤶    if @insetMorph == theMorphChangingTheExtent⤶      @rawSetExtent @extentBasedOnInsetExtent(theMorphChangingTheExtent), theMorphChangingTheExtent⤶⤶  # more complex Widgets, e.g. layouts, might⤶  # do a more complex calculation to get the⤶  # minimum extent⤶  getMinimumExtent: ->⤶    @minimumExtent⤶⤶  setMinimumExtent: (@minimumExtent) ->⤶⤶  # Widget accessing - dimensional changes requiring a complete redraw⤶  rawSetExtent: (aPoint, morphStartingTheChange = nil) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    #console.log ＂move 8＂⤶    if @ == morphStartingTheChange⤶      return⤶    if !morphStartingTheChange?⤶      morphStartingTheChange = @⤶    # check whether we are actually changing the extent.⤶    unless aPoint.eq @extent()⤶      @breakNumberOfRawMovesAndResizesCaches()⤶⤶      @silentRawSetExtent aPoint⤶      @changed()⤶      @reLayout()⤶      ⤶      @layoutSubmorphs morphStartingTheChange⤶      if @parent?⤶        if @parent != morphStartingTheChange⤶          @parent.childChangedExtent @⤶⤶  # high-level geometry-change API,⤶  # you don't actually change the geometry right away,⤶  # you just ask for the desired change and wait for the⤶  # layouting mechanism to do its best to satisfy it⤶  setExtent: (aPoint, morphStartingTheChange = nil) ->⤶    #if window.recalculatingLayouts⤶    #  debugger⤶    if @layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING⤶      return⤶    else⤶      aPoint = aPoint.round()⤶      newWidth = Math.max aPoint.x, 0⤶      newHeight = Math.max aPoint.y, 0⤶      newExtent = new Point newWidth, newHeight⤶      unless @extent().eq newExtent⤶        @desiredExtent = newExtent⤶        @invalidateLayout()⤶        # all the resizes via the handles arrive here,⤶        # where we remember the fractional size in the⤶        # holding panel. That is so for example resizing⤶        # items inside a StretchablePanel causes their⤶        # relative size to be remembered, so resizing⤶        # the stretchable panel will get them to the⤶        # correct dimensions⤶        if morphStartingTheChange? and @parent? and (morphStartingTheChange instanceof HandleMorph)⤶          @extentFractionalInHoldingPanel = @extentFractionalInMorph @parent⤶⤶  ⤶  silentRawSetExtent: (aPoint) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    aPoint = aPoint.round()⤶    #console.log ＂move 9＂⤶⤶    minExtent = @getMinimumExtent()⤶    if ! aPoint.ge minExtent⤶      aPoint = aPoint.max minExtent⤶⤶    newWidth = Math.max aPoint.x, 0⤶    newHeight = Math.max aPoint.y, 0⤶⤶    newBounds = new Rectangle @bounds.origin, new Point @bounds.origin.x + newWidth, @bounds.origin.y + newHeight⤶⤶    unless @bounds.eq newBounds⤶      @bounds = newBounds⤶      @breakNumberOfRawMovesAndResizesCaches()⤶⤶      # note that if I am a submorph of a morph directly⤶      # inside a non-text-wrapping ScrollPanelWdgt then this⤶      # is not going to work. So if I'm a box attached to a⤶      # box inside a non-text-wrapping ScrollPanelWdgt then⤶      # there will be no adjusting of bounds of the ScrollPanel⤶      # not the adjusting of the scrollbars.⤶      # This could be done, we could check up the chain to find⤶      # if we are indirectly inside a ScrollPanel however⤶      # there might be performance implications, so I'd probably⤶      # have to introduce caching, and this whole mechanism should⤶      # go away with proper layouts...⤶      if @amIDirectlyInsideNonTextWrappingScrollPanelWdgt()⤶        @parent.parent.adjustContentsBounds()⤶        @parent.parent.adjustScrollBars()⤶      if @parent instanceof SimpleVerticalStackPanelWdgt⤶        @parent.adjustContentsBounds()⤶⤶⤶  refreshScrollPanelWdgtOrVerticalStackIfIamInIt: ->⤶    if @amIDirectlyInsideScrollPanelWdgt()⤶      @parent.parent.adjustContentsBounds()⤶      @parent.parent.adjustScrollBars()⤶    if @parent instanceof SimpleVerticalStackPanelWdgt⤶      @parent.adjustContentsBounds()⤶⤶⤶  rawSetWidth: (width) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    #console.log ＂move 10＂⤶    @breakNumberOfRawMovesAndResizesCaches()⤶    @rawSetExtent new Point(width or 0, @height())⤶⤶  # high-level geometry-change API,⤶  # you don't actually change the geometry right away,⤶  # you just ask for the desired change and wait for the⤶  # layouting mechanism to do its best to satisfy it⤶  setWidth: (width) ->⤶    #if window.recalculatingLayouts⤶    #  debugger⤶    if @layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING⤶      return⤶    else⤶      newWidth = Math.max width, 0⤶      newExtent = new Point newWidth, @height()⤶      unless @extent().eq newExtent⤶        @desiredExtent = newExtent⤶        @invalidateLayout()⤶  ⤶  silentRawSetWidth: (width) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    #console.log ＂move 11＂⤶    @breakNumberOfRawMovesAndResizesCaches()⤶    w = Math.max Math.round(width or 0), 0⤶    @bounds = new Rectangle @bounds.origin, new Point @bounds.origin.x + w, @bounds.corner.y⤶  ⤶  rawSetHeight: (height) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    #console.log ＂move 12＂⤶    @breakNumberOfRawMovesAndResizesCaches()⤶    @rawSetExtent new Point(@width(), height or 0)⤶⤶  # high-level geometry-change API,⤶  # you don't actually change the geometry right away,⤶  # you just ask for the desired change and wait for the⤶  # layouting mechanism to do its best to satisfy it⤶  setHeight: (height) ->⤶    #if window.recalculatingLayouts⤶    #  debugger⤶    if @layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING⤶      return⤶    else⤶      newHeight = Math.max 0, height⤶      newExtent = new Point @width(), newHeight⤶      unless @extent().eq newExtent⤶        @desiredExtent = newExtent⤶        @invalidateLayout()⤶⤶  ⤶  silentRawSetHeight: (height) ->⤶    # TODO in theory the low-level APIs should only be⤶    # in the ＂recalculateLayouts＂ phase⤶    if false and !window.recalculatingLayouts⤶      debugger⤶⤶    #console.log ＂move 13＂⤶    @breakNumberOfRawMovesAndResizesCaches()⤶    h = Math.max Math.round(height or 0), 0⤶    @bounds = new Rectangle @bounds.origin, new Point @bounds.corner.x, @bounds.origin.y + h⤶  ⤶  setColor: (aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken⤶⤶    if morphGivingColor?.getColor?⤶      aColor = morphGivingColor.getColor()⤶    else⤶      aColor = aColorOrAMorphGivingAColor⤶    if aColor⤶⤶      # if the color is set using the color string literal⤶      # e.g. ＂red＂ then we can't check equality using .eq⤶      # so just skip the check and set the color⤶      # TODO either all colors should be set as Color instead⤶      # of strings, or this check should be smarter⤶      if @color?.eq?⤶        if @color.eq aColor⤶          return⤶⤶      @color = aColor⤶      @changed()⤶        ⤶    return aColor⤶  ⤶  setBackgroundColor: (aColorOrAMorphGivingAColor, morphGivingColor, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken⤶⤶    if morphGivingColor?.getColor?⤶      aColor = morphGivingColor.getColor()⤶    else⤶      aColor = aColorOrAMorphGivingAColor⤶    if aColor⤶⤶      # if the color is set using the color string literal⤶      # e.g. ＂red＂ then we can't check equality using .eq⤶      # so just skip the check and set the color⤶      # TODO either all colors should be set as Color instead⤶      # of strings, or this check should be smarter⤶      if @backgroundColor?.eq?⤶        if @backgroundColor.eq aColor⤶          return⤶⤶      @backgroundColor = aColor⤶      @changed()⤶⤶    return aColor⤶  ⤶  # Widget displaying ---------------------------------------------------------⤶⤶  # There are three fundamental methods for rendering and displaying anything.⤶  # * updateBackBuffer: this one creates/updates the local canvas of this morph only⤶  #   i.e. not the children. For example: a ColorPickerMorph is a Widget which⤶  #   contains three children Widgets (a color palette, a greyscale palette and⤶  #   a feedback). The updateBackBuffer method of ColorPickerMorph only creates⤶  #   a canvas for the container Widget. So that's just a canvas with a⤶  #   solid color. As the⤶  #   ColorPickerMorph constructor runs, the three childredn Widgets will⤶  #   run their own updateBackBuffer method, so each child will have its own⤶  #   canvas with their own contents.⤶  #   Note that updateBackBuffer should be called sparingly. A morph should repaint⤶  #   its buffer pretty much only *after* it's been added to its first parent and⤶  #   whenever it changes dimensions. Things like changing parent and updating⤶  #   the position shouldn't normally trigger an update of the buffer.⤶  #   Also note that before the buffer is painted for the first time, they⤶  #   might not know their extent. Typically text-related Widgets know their⤶  #   extensions after they painted the text for the first time...⤶  # * paintIntoAreaOrBlitFromBackBuffer: takes the local canvas and paints it to a specific area in a passed⤶  #   canvas. The local canvas doesn't contain any rendering of the children of⤶  #   this morph.⤶  # * fullPaintIntoAreaOrBlitFromBackBuffer: recursively draws all the local canvas of this morph and all⤶  #   its children into a specific area of a passed canvas.⤶⤶⤶  ⤶  ⤶  boundsContainPoint: (aPoint) ->⤶    @bounds.containsPoint aPoint⤶⤶  areBoundsIntersecting: (aWdgt) ->⤶    @bounds.isIntersecting aWdgt.bounds⤶⤶  calculateKeyValues: (aContext, clippingRectangle) ->⤶    area = clippingRectangle.intersect(@bounds).round()⤶    # test whether anything that we are going to be drawing⤶    # is visible (i.e. within the clippingRectangle)⤶    if area.isNotEmpty()⤶      delta = @position().neg()⤶      src = area.translateBy(delta).round()⤶⤶      sl = src.left() * ceilPixelRatio⤶      st = src.top() * ceilPixelRatio⤶      al = area.left() * ceilPixelRatio⤶      at = area.top() * ceilPixelRatio⤶      w = Math.min(src.width() * ceilPixelRatio, @width() * ceilPixelRatio - sl)⤶      h = Math.min(src.height() * ceilPixelRatio, @height() * ceilPixelRatio - st)⤶⤶    return [area,sl,st,al,at,w,h]⤶⤶  turnOnHighlight: ->⤶    if !@highlighted⤶      @highlighted = true⤶      world.morphsToBeHighlighted.add @⤶      @changed()⤶⤶  turnOffHighlight: ->⤶    if @highlighted⤶      @highlighted = false⤶      world.morphsToBeHighlighted.delete @⤶      @changed()⤶⤶⤶  # paintRectangle can work in two patterns:⤶  #  * passing actual pixels, when used⤶  #    outside the effect of the scope of⤶  #    ＂scale ceilPixelRatio, ceilPixelRatio＂, or⤶  #  * passing logical pixels, when used⤶  #    inside the effect of the scope of⤶  #    ＂scale ceilPixelRatio, ceilPixelRatio＂, or⤶  # Mostly, the first pattern is used.⤶  # Note that the resulting rectangle WILL reflect⤶  # if it's being painted as a shadow or not,⤶  # so it can't be used to paint on a backbuffer,⤶  # since you always want to paint on a backbuffer⤶  # ＂pristine＂, since the shadow effect is applied⤶  # when the backbuffer is in turn blitte to⤶  # screen, LATER.⤶⤶  paintRectangle: (⤶    aContext,⤶    al, at, w, h,⤶    color,⤶    transparency = nil,⤶    pushAndPopContext = false,⤶    appliedShadow⤶  ) ->⤶⤶      if !color?⤶        return⤶⤶      if pushAndPopContext⤶        aContext.save()⤶⤶      aContext.fillStyle = color.toString()⤶      if transparency?⤶        aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * transparency⤶⤶      aContext.fillRect  Math.round(al),⤶          Math.round(at),⤶          Math.round(w),⤶          Math.round(h)⤶⤶      if pushAndPopContext⤶        aContext.restore()⤶⤶⤶  preliminaryCheckNothingToDraw: (clippingRectangle, aContext) ->⤶⤶    if !@isVisible⤶      return true⤶⤶    if clippingRectangle.isEmpty()⤶      return true⤶⤶    if aContext == world.worldCanvasContext and @isOrphan()⤶      return true⤶⤶    if aContext == world.worldCanvasContext and !@visibleBasedOnIsVisibleProperty()⤶      return true⤶⤶    if aContext == world.worldCanvasContext and @isCollapsed()⤶      return true⤶⤶    return false⤶⤶  recordDrawnAreaForNextBrokenRects: ->⤶    if @childrenBoundsUpdatedAt < WorldMorph.frameCount⤶      @childrenBoundsUpdatedAt = WorldMorph.frameCount⤶      @clippedBoundsWhenLastPainted = @clippedThroughBounds()⤶      #if (@ != world) and (@clippedBoundsWhenLastPainted.containsPoint (new Point(10,10)))⤶      #  debugger⤶      @fullClippedBoundsWhenLastPainted = @fullClippedBounds()⤶      #if (@ != world) and (@fullClippedBoundsWhenLastPainted.containsPoint (new Point(10,10)))⤶      #  debugger⤶      #if (@ instanceof MenuMorph) and (@fullClippedBoundsWhenLastPainted.containsPoint (new Point(10,10)))⤶      #  debugger⤶⤶  # in general, the children of a Widget could be outside the⤶  # bounds of the parent (they could also be much larger⤶  # then the parent). This means that we have to traverse⤶  # all the children to find out whether any of those overlap⤶  # the clipping rectangle. Note that we can be smarter with⤶  # PanelWdgts, as their children are actually all contained⤶  # within the parent's boundary.⤶  #⤶  # Note that if we could dynamically and cheaply keep an updated⤶  # fullBounds property, then we could be smarter⤶  # in discarding whole sections of the scene graph.⤶  # (see https://github.com/davidedc/Fizzygum/issues/150 )⤶  #⤶  # To draw a widget, basically you first have to draw its shadow⤶  # and then you draw the contents. See methods below.⤶  #⤶  # How the shadow painting works -----------------⤶  # If appliedShadow is defined, it means that we are painting the whole⤶  # of the widget recursively AS SHADOW. Since there are no shadows of a shadow⤶  # so we can skip the ＂just shadow＂ part, and we paint the widget as shadow.⤶  # If appliedShadow is NOT defined, then it means that we just have to paint the widget,⤶  # which might have a shadow. If it does have a shadow, then we first paint it⤶  # as shadow, then we paint it as non-shadow. If it doesn't have a shadow, then⤶  # we just paint it as non-shadow.⤶⤶  fullPaintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    # used to track which widget has been throwing⤶    # an error while painting⤶    world.paintingWidget = @⤶⤶    # if there is a shadow ＂property＂ object⤶    # then first draw the shadow of the tree⤶    # If appliedShadow is defined, then we just want to paint the⤶    # content as shadow, so we skip this paragrah because we don't have⤶    # to paint a shadow for a shadow.⤶    if !appliedShadow? and @shadowInfo?⤶      @fullPaintIntoAreaOrBlitFromBackBufferJustShadow aContext, clippingRectangle, @shadowInfo⤶⤶    # draw the proper contents of the tree. Potentially, draw them faintly as shadow.⤶    if !@preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      if aContext == world.worldCanvasContext⤶        @recordDrawnAreaForNextBrokenRects()⤶      @fullPaintIntoAreaOrBlitFromBackBufferContentPotentiallyAsShadow aContext, clippingRectangle, appliedShadow⤶⤶⤶  # to draw the shadow, most of the times you have to draw the whole⤶  # of the contents, but with a darker/fainter color, and with⤶  # transparency.⤶  #⤶  # The only variant is that if a Panel if fully opaque, then the shadow is just⤶  # a rectangle, we don't need to draw anything inside the panel to⤶  # contribute to the shadow of the panel⤶  #⤶  # In this function the parameter ＂appliedShadow＂ MUST contain a shadow info.⤶  # This parameter will cause the whole widget to be painted recursively as shadow.⤶  fullPaintIntoAreaOrBlitFromBackBufferJustShadow: (aContext, clippingRectangle, appliedShadow) ->⤶    clippingRectangle = clippingRectangle.translateBy -appliedShadow.offset.x, -appliedShadow.offset.y⤶⤶    if !@preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      aContext.save()⤶      aContext.translate appliedShadow.offset.x * ceilPixelRatio, appliedShadow.offset.y * ceilPixelRatio⤶⤶      @fullPaintIntoAreaOrBlitFromBackBufferContentPotentiallyAsShadow aContext, clippingRectangle, appliedShadow⤶⤶      aContext.restore()⤶  ⤶⤶  # this just draws the tree of the widgets recursively, potentially ＂normally＂ or⤶  # potentally more faintly to draw a shadow.⤶  # The only variant is that the Panel⤶  # draws its background, then its contents AND THEN its stroke⤶  # (because otherwise its content would paint over its stroke)⤶  fullPaintIntoAreaOrBlitFromBackBufferContentPotentiallyAsShadow: (aContext, clippingRectangle, appliedShadow) ->⤶    @paintIntoAreaOrBlitFromBackBuffer aContext, clippingRectangle, appliedShadow⤶    @children.forEach (child) ->⤶      child.fullPaintIntoAreaOrBlitFromBackBuffer aContext, clippingRectangle, appliedShadow⤶⤶  # ... when you want to hide something⤶  # but you don't want to generate any⤶  # broken rectangles⤶  silentHide: ->⤶    if !@isVisible⤶      return⤶    @isVisible = false⤶    WorldMorph.numberOfVisibilityFlagsChanges++⤶    @invalidateFullBoundsCache @⤶    @invalidateFullClippedBoundsCache @⤶⤶  hide: ->⤶    if !@isVisible⤶      return⤶⤶    @silentHide()⤶⤶    # TODO refactor this, it appears more than one time⤶    # if the morph contributes to a shadow, unfortunately⤶    # we have to walk towards the top to⤶    # break the morph that has the shadow.⤶    # ALSO there are many other ＂@fullChanged＂ that really⤶    # should do this instead.⤶    firstParentOwningMyShadow = @firstParentOwningMyShadow()⤶    if firstParentOwningMyShadow?⤶      firstParentOwningMyShadow.fullChanged()⤶    else⤶      @fullChanged()⤶⤶⤶  show: ->⤶    if @isVisible⤶      return⤶    if @visibleBasedOnIsVisibleProperty() == true⤶      return⤶    @isVisible = true⤶    WorldMorph.numberOfVisibilityFlagsChanges++⤶    @invalidateFullBoundsCache @⤶    @invalidateFullClippedBoundsCache @⤶⤶    firstParentOwningMyShadow = @firstParentOwningMyShadow()⤶    if firstParentOwningMyShadow?⤶      firstParentOwningMyShadow.fullChanged()⤶    else⤶      @fullChanged()⤶  ⤶  toggleVisibility: ->⤶    @isVisible = not @isVisible⤶    WorldMorph.numberOfVisibilityFlagsChanges++⤶    @invalidateFullBoundsCache @⤶    @invalidateFullClippedBoundsCache @⤶    @fullChanged()⤶⤶  collapse: ->⤶    if @collapsed⤶      return⤶    @parent?.childBeingCollapsed? @⤶    @collapsed = true⤶    WorldMorph.numberOfCollapseFlagsChanges++⤶    @invalidateFullBoundsCache @⤶    @invalidateFullClippedBoundsCache @⤶    @invalidateLayout()⤶    @fullChanged()⤶    @parent?.childCollapsed? @⤶⤶  unCollapse: ->⤶    if !@collapsed⤶      return⤶    if !@isCollapsed()⤶      return⤶    @parent?.childBeingUnCollapsed? @⤶    @collapsed = false⤶    WorldMorph.numberOfCollapseFlagsChanges++⤶    @invalidateFullBoundsCache @⤶    @invalidateFullClippedBoundsCache @⤶    @invalidateLayout()⤶    @fullChanged()⤶    @parent?.childUnCollapsed? @⤶⤶  ⤶  isCollapsed: ->⤶    if @collapsed⤶      return true⤶    else⤶      if @parent?⤶        return @parent.isCollapsed()⤶      else⤶        return false⤶  ⤶  removeFromTree: ->⤶    @parent?.invalidateLayout()⤶    @breakNumberOfRawMovesAndResizesCaches()⤶    WorldMorph.numberOfAddsAndRemoves++⤶    @parent.removeChild @⤶    @fullChanged()⤶⤶  colloquialName: ->⤶    ＂generic widget＂⤶⤶  representativeIcon: ->⤶    new WidgetIconWdgt⤶⤶  createPointerMorph: ->⤶    myPosition = @positionAmongSiblings()⤶    morphToAdd = new PointerMorph @⤶    @parent.add morphToAdd, myPosition⤶    morphToAdd.fullMoveTo @position()⤶    morphToAdd.setExtent new Point 150, 20⤶    morphToAdd.fullChanged()⤶    @removeFromTree()⤶⤶  createReference: (referenceName, placeToDropItIn = world) ->⤶    # this function can also be called as a callback⤶    # of a trigger, in which case the first parameter⤶    # here is a menuItem. We take that parameter away⤶    # in that case.⤶    if referenceName? and typeof(referenceName) != ＂string＂⤶      referenceName = nil⤶      placeToDropItIn = world⤶⤶    # don't create new reference if it exists already⤶    for w in placeToDropItIn.children⤶      if (w instanceof IconicDesktopSystemShortcutWdgt) and w.target == @⤶        return⤶⤶    morphToAdd = new IconicDesktopSystemDocumentShortcutWdgt @, referenceName⤶    # this ＂add＂ is going to try to position the⤶    # new icon into a grid⤶    placeToDropItIn.add morphToAdd⤶    morphToAdd.setExtent new Point 75, 75⤶    morphToAdd.fullChanged()⤶    @bringToForeground()⤶⤶  createReferenceAndClose: (referenceName, placeToDropItIn = world) ->⤶    @createReference referenceName, placeToDropItIn⤶    @close()⤶⤶⤶⤶  # the way we take a picture here is different⤶  # than the way we usually take a picture.⤶  # Usually we ask the morph and submorphs to⤶  # paint themselves anew into a new canvas.⤶  # This is different: we take the area of the⤶  # screen *as it is* and we crop the part of⤶  # interest where the extent of our selected⤶  # morph is. This means that the morph might⤶  # be occluded by other things.⤶  # The advantage here is that we capture⤶  # the screen absolutely as is, without⤶  # causing any repaints. If streaks are on the⤶  # screen due to bad painting, we capture them⤶  # exactly as the user sees them.⤶  fullImageAsItAppearsOnScreen: ->⤶    fullExtentOfMorph = @fullBounds()⤶    destCanvas = newCanvas fullExtentOfMorph.extent().scaleBy ceilPixelRatio⤶    destCtx = destCanvas.getContext '2d'⤶    destCtx.drawImage world.worldCanvas,⤶      fullExtentOfMorph.topLeft().x * ceilPixelRatio,⤶      fullExtentOfMorph.topLeft().y * ceilPixelRatio,⤶      fullExtentOfMorph.width() * ceilPixelRatio,⤶      fullExtentOfMorph.height() * ceilPixelRatio,⤶      0,⤶      0,⤶      fullExtentOfMorph.width() * ceilPixelRatio,⤶      fullExtentOfMorph.height() * ceilPixelRatio⤶⤶    return destCanvas.toDataURL ＂image/png＂⤶⤶⤶  ⤶  # shadow is added to a morph by⤶  # the ActivePointerWdgt while floatDragging⤶  addShadow: (offset = new Point(4, 4), alpha = 0.2) ->⤶    @silentAddShadow offset, alpha    ⤶    @fullChanged()⤶⤶  silentAddShadow: (offset, alpha) ->⤶    @shadowInfo = new ShadowInfo offset, alpha⤶  ⤶  hasShadow: ->⤶    @shadowInfo?⤶  ⤶  removeShadow: ->⤶    if @hasShadow()⤶      @shadowInfo = nil⤶      @fullChanged()⤶  ⤶  ⤶  ⤶  # Widget updating ///////////////////////////////////////////////////////////////⤶  changed: ->⤶    # tests should all pass even if you don't⤶    # use the trackChanges flag, perhaps things⤶    # should just be a bit slower (but probably not⤶    # significantly). This is because there is no⤶    # harm into changing children of a morph⤶    # that is fullChanged, the checks should⤶    # simplify the situation.⤶    # I tested this was OK in December 2017⤶    if trackChanges[trackChanges.length - 1]⤶⤶      # if the morph is attached to a hand then⤶      # there is also a shadow to change, so we⤶      # change everything that is attached⤶      # to the hand, which means we issue a⤶      # fullChanged()⤶      if @isBeingFloatDragged()⤶        world.hand.fullChanged()⤶        return⤶⤶      # you could check directly if it's in the array⤶      # but we use a flag because it's faster.⤶      if !@geometryOrPositionPossiblyChanged⤶        # if we already issued a fullChanged on this morph⤶        # then there is no point issuing a change too.⤶        if !@fullGeometryOrPositionPossiblyChanged⤶          window.morphsThatMaybeChangedGeometryOrPosition.push @⤶          @geometryOrPositionPossiblyChanged = true⤶⤶    @parent.childChanged @  if @parent⤶⤶  # to actually make sure if a morph has changed⤶  # position, you need to check it and all its⤶  # parents.⤶  # See comment on the fullGeometryOrPositionPossiblyChanged⤶  # property above for more info.⤶  hasMaybeChangedGeometryOrPosition: ->⤶    if @fullGeometryOrPositionPossiblyChanged or @geometryOrPositionPossiblyChanged⤶      return true⤶    else⤶      if @parent?⤶        return @parent.hasMaybeChangedGeometryOrPosition()⤶      else⤶        return false⤶  ⤶  # See comment on the fullGeometryOrPositionPossiblyChanged⤶  # property above for more info.⤶  fullChanged: ->⤶    # tests should all pass even if you don't⤶    # use the trackChanges flag, perhaps things⤶    # should just be a bit slower (but probably not⤶    # significantly). This is because there is no⤶    # harm into changing children of a morph⤶    # that is fullChanged, the checks should⤶    # simplify the situation.⤶    # I tested this was OK in December 2017⤶    if trackChanges[trackChanges.length - 1]⤶      # check if we already issued a fullChanged on this morph⤶      if !@fullGeometryOrPositionPossiblyChanged⤶        window.morphsThatMaybeChangedFullGeometryOrPosition.push @⤶        @fullGeometryOrPositionPossiblyChanged = true⤶  ⤶  childChanged: ->⤶    # react to a  change in one of my children,⤶    # default is to just pass this message on upwards⤶    # override this method for Widgets that need to adjust accordingly⤶    @parent.childChanged @  if @parent⤶  ⤶  ⤶  # Widget accessing - structure //////////////////////////////////////////////⤶⤶  # EXPLANATION of ＂silent＂ vs. ＂raw＂ vs. ＂normal＂ hierarchy/bounds change methods⤶  # ------------------------------------------------------------------------------⤶  # “normal”: these are the highest-level methods and take into account layouts.⤶  #           Should use these ones as much as possible. Call the ＂raw＂⤶  #           versions below⤶  # “raw”: lower level. This is what the re-layout routines use. Usually call the⤶  #        silent version below.⤶  # “silent”: doesn’t mark the morph as changed⤶  #⤶  # It's important that lower-level functions don't ever call the higher-level⤶  # functions, as that's architecturally incorrect and can cause infinite loops in⤶  # the invocations.⤶⤶  iHaveBeenAddedTo: (whereTo, beingDropped) ->⤶    @reLayout()⤶⤶  addAsSiblingAfterMe: (aWdgt, position = nil, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING) ->⤶    myPosition = @positionAmongSiblings()⤶    @parent.add aWdgt, (myPosition + 1), layoutSpec⤶⤶  addAsSiblingBeforeMe: (aWdgt, position = nil, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING) ->⤶    myPosition = @positionAmongSiblings()⤶    @parent.add aWdgt, myPosition, layoutSpec⤶⤶  # this level of indirection is needed because⤶  # you have a ＂raw＂ ＂tree＂ need of adding stuff⤶  # and a higher level way to ＂add＂.⤶  # For example, a ScrollPanelWdgt does a ＂high-level＂⤶  # add of things in a different way, as it actually adds⤶  # stuff to a Panel inside it. Hence a need to have⤶  # both a high-level and a low-level.⤶  # For most morphs the two things coincide, and the⤶  # high-level just calls the low-level.⤶  add: (aWdgt, position = nil, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING, beingDropped) ->⤶    if (aWdgt not instanceof HighlighterMorph) and (aWdgt not instanceof CaretMorph)⤶      if @ == world⤶        aWdgt.addShadow()⤶        # when any morph is added to the world, all scheduled tooltips⤶        # are cancelled. To avoid that a tooltip appears over what the⤶        # button has just opened. This would happen for example in the⤶        # ＂snippets＂ button in the Simple Document. You go over that⤶        # button, you click it, the snippets windows come up, then⤶        # the tooltip with ＂snippets windows＂ message pops up⤶        # over it.⤶        if !(aWdgt instanceof ToolTipWdgt)⤶          ToolTipWdgt.cancelAllScheduledToolTips()⤶      else⤶        aWdgt.removeShadow()⤶⤶    @addRaw arguments...⤶    if @ == world⤶      aWdgt.rememberFractionalPositionInHoldingPanel()⤶  ⤶  # attaches submorph on top⤶  # ??? TODO you should handle the case of Widget⤶  #     being added to itself and the case of⤶  # ??? TODO a Widget being added to one of its⤶  #     children⤶  addRaw: (aWdgt, position = nil, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING, beingDropped) ->⤶⤶    # let's check if we are trying to add⤶    # an ancestor of me below me.⤶    # That would be impossible to do,⤶    # so we return nil to signal the error.⤶    if aWdgt.isAncestorOf @⤶      return nil⤶⤶    previousParent = aWdgt.parent⤶    aWdgt.parent?.invalidateLayout()⤶⤶    # if the morph contributes to a shadow, unfortunately⤶    # we have to walk towards the top to⤶    # break the morph that has the shadow.⤶    firstParentOwningMyShadow = aWdgt.firstParentOwningMyShadow()⤶    if firstParentOwningMyShadow?⤶      firstParentOwningMyShadow.fullChanged()⤶    else⤶      aWdgt.fullChanged()⤶⤶    aWdgt.setLayoutSpec layoutSpec⤶    if layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING⤶      @invalidateLayout()⤶⤶    aWdgt.fullChanged()⤶    @silentAdd aWdgt, true, position⤶    aWdgt.iHaveBeenAddedTo @, beingDropped⤶    if previousParent?.childRemoved?⤶      previousParent.childRemoved @⤶⤶    if @childAdded?⤶      @childAdded aWdgt⤶⤶    return aWdgt⤶⤶  addInset: (aWdgt) ->⤶⤶    if aWdgt.parent?⤶      aWdgt.changed()⤶⤶    @insetMorph = aWdgt⤶    @add aWdgt, 0⤶    aWdgt.fullRawMoveTo @insetPosition()⤶    aWdgt.rawSetExtent @insetSpaceExtent(), @⤶⤶⤶  sourceChanged: ->⤶    @reLayout?() ⤶    @changed?()⤶⤶⤶  # this is done before the updating of the⤶  # backing store in some morphs that⤶  # need to figure out their whole⤶  # layout (which depends on the children)⤶  # before painting themselves⤶  # e.g. the MenuMorph⤶  reLayout: ->⤶⤶⤶  calculateAndUpdateExtent: ->⤶⤶  silentAdd: (aWdgt, avoidExtentCalculation, position = nil) ->⤶    # the morph that is being⤶    # attached might be attached to⤶    # a clipping morph. So we⤶    # need to do a ＂changed＂ here⤶    # to make sure that anything that⤶    # is outside the clipping Widget gets⤶    # painted over.⤶    owner = aWdgt.parent⤶    if owner?⤶      owner.removeChild aWdgt⤶    if aWdgt.isPopUpMarkedForClosure?⤶      aWdgt.isPopUpMarkedForClosure = false⤶    @addChild aWdgt, position⤶    if !avoidExtentCalculation⤶      aWdgt.calculateAndUpdateExtent()⤶    ⤶⤶  # Duplication and Serialization /////////////////////////////////////////⤶⤶⤶  duplicateMenuAction: ->⤶    aFullCopy = @fullCopy()⤶    aFullCopy.unlockFromPanels()⤶    world.add aFullCopy⤶    aFullCopy.fullRawMoveTo @position().add new Point 10, 10⤶    aFullCopy.rememberFractionalSituationInHoldingPanel()⤶⤶  duplicateMenuActionAndPickItUp: ->⤶    aFullCopy = @fullCopy()⤶    aFullCopy?.pickUp()⤶⤶  # in case we copy a morph, if the original was in some⤶  # data structures related to broken morphs, then⤶  # we have to add the copy too.⤶  alignCopiedMorphToBrokenInfoDataStructures: (copiedMorph) ->⤶    if window.morphsThatMaybeChangedGeometryOrPosition.includes(@) and⤶     !window.morphsThatMaybeChangedGeometryOrPosition.includes(copiedMorph)⤶      window.morphsThatMaybeChangedGeometryOrPosition.push copiedMorph⤶⤶    if window.morphsThatMaybeChangedFullGeometryOrPosition.includes(@) and⤶     !window.morphsThatMaybeChangedFullGeometryOrPosition.includes(copiedMorph)⤶      window.morphsThatMaybeChangedFullGeometryOrPosition.push copiedMorph⤶⤶  # in case we copy a morph, if the original was in some⤶  # stepping structures, then we have to add the copy too.⤶  alignCopiedMorphToSteppingStructures: (copiedMorph) ->⤶    if world.steppingWdgts.has @⤶      world.steppingWdgts.add copiedMorph⤶⤶  # note that the entire copying mechanism⤶  # should also take care of inserting the copied⤶  # morph in whatever other data structures where the⤶  # original morph was.⤶  # For example, if the Widget appeared in a data⤶  # structure related to the broken rectangles mechanism,⤶  # we should place the copied morph there.⤶  fullCopy: ->⤶    if @destroyed⤶      @inform ＂The item you are⧹ntrying to copy⧹nis dead!＂⤶      return nil⤶    allMorphsInStructure = @allChildrenBottomToTop()⤶    copiedMorph = @deepCopy false, [], [], allMorphsInStructure⤶    return copiedMorph⤶⤶  serialize: ->⤶    allMorphsInStructure = @allChildrenBottomToTop()⤶    arr1 = []⤶    arr2 = []⤶    @deepCopy true, arr1, arr2, allMorphsInStructure⤶    totalJSON = ＂＂⤶⤶    for element in arr2⤶      try⤶        console.log JSON.stringify(element) + ＂⧹n// --------------------------- ⧹n＂⤶      catch e⤶        debugger⤶⤶      totalJSON = totalJSON + JSON.stringify(element) + ＂⧹n// --------------------------- ⧹n＂⤶    return totalJSON⤶⤶⤶  # Deserialization -----------------------------------⤶⤶⤶  deserialize: (serializationString) ->⤶    # this is to ignore all the comment strings⤶    # that might be there for reading purposes⤶    objectsSerializations = serializationString.split /^⧹/⧹/.*$/gm⤶    # the serialization ends with a comment so⤶    # last element is empty, pop it⤶    objectsSerializations.pop()⤶⤶    createdObjects = []⤶    for eachSerialization in objectsSerializations⤶      createdObjects.push JSON.parse eachSerialization⤶⤶    clonedMorphs = []⤶    for eachObject in createdObjects⤶      # note that the constructor method is not run!⤶      #console.log ＂cloning:＂ + eachMorph.className⤶      #console.log ＂with:＂ + window[eachObject.className].prototype⤶      if eachObject.className == ＂Canvas＂⤶        theClone = newCanvas new Point eachObject.width, eachObject.height⤶        ctx = theClone.getContext ＂2d＂⤶⤶        image = new Image⤶        image.src = eachObject.data⤶        # if something doesn't get painted here,⤶        # it might be because the allocation of the image⤶        # would actually be asynchronous, in theory⤶        # you'd have to do the drawImage in a callback⤶        # on onLoad of the image...⤶        ctx.drawImage image, 0, 0⤶⤶      else if eachObject.constructor != Array⤶        theClone = Object.create window[eachObject.className].prototype⤶        if theClone.assignUniqueID?⤶          theClone.assignUniqueID()⤶      else⤶        theClone = []⤶      clonedMorphs.push theClone⤶      #theClone.constructor()⤶⤶    for i in [0... clonedMorphs.length]⤶      eachClonedMorph = clonedMorphs[i]⤶      if eachClonedMorph.constructor == HTMLCanvasElement⤶        # do nothing⤶      else if eachClonedMorph.constructor != Array⤶        for property of createdObjects[i]⤶          # also includes the ＂parent＂ property⤶          if createdObjects[i].hasOwnProperty property⤶            console.log ＂looking at property: ＂ + property⤶            clonedMorphs[i][property] = createdObjects[i][property]⤶            if typeof clonedMorphs[i][property] is ＂string＂⤶              if clonedMorphs[i][property].startsWith ＂$＂⤶                referenceNumberAsString = clonedMorphs[i][property].substring(1)⤶                referenceNumber = parseInt referenceNumberAsString⤶                clonedMorphs[i][property] = clonedMorphs[referenceNumber]⤶      else⤶        for j in [0... createdObjects[i].length]⤶          eachArrayElement = createdObjects[i][j]⤶          clonedMorphs[i][j] = createdObjects[i][j]⤶          if typeof eachArrayElement is ＂string＂⤶            if eachArrayElement.startsWith ＂$＂⤶              referenceNumberAsString = eachArrayElement.substring(1)⤶              referenceNumber = parseInt referenceNumberAsString⤶              clonedMorphs[i][j] = clonedMorphs[referenceNumber]⤶⤶⤶    return clonedMorphs[0]⤶⤶  # Injecting code /////////////////////////////////////////⤶⤶  # if a function, the txt must contain the parameters and⤶  # the arrow and the body⤶  injectProperty: (propertyName, txt) ->⤶    # this.target[propertyName] = evaluate txt⤶    @evaluateString ＂@＂ + propertyName + ＂ = ＂ + txt⤶    # if we are saving a function, we'd like to⤶    # keep the source code so we can edit Coffeescript⤶    # again.⤶    if isFunction @[propertyName]⤶      @[propertyName + ＂_source＂] = txt⤶    @sourceChanged()⤶⤶  injectProperties: (codeBlurb) ->⤶⤶    codeBlurb = codeBlurb.replace(/^[ ⧹t]*$/gm,＂⧹n＂)⤶    codeBlurb = codeBlurb + ＂⧹n# end injected code＂⤶⤶    # ([a-zA-Z_$][0-9a-zA-Z_$]*) is the variable name⤶    regex = /^([a-zA-Z_$][0-9a-zA-Z_$]*)[ ⧹t]*=[ ⧹t]*([^]*?)(?=^[⧹w#$])/gm⤶⤶    while (m = regex.exec(codeBlurb))?⤶      # This is necessary to avoid infinite loops with zero-width matches⤶      if m.index == regex.lastIndex⤶        regex.lastIndex++⤶      # The result can be accessed through the `m`-variable.⤶      #m.forEach (match, groupIndex) ->⤶      #  console.log ''⤶      @injectProperty m[1],m[2]⤶  ⤶  # Widget dragging (and dropping) /////////////////////////////////////////⤶  ⤶  # (In this comment section ＂non-float＂ dragging and ＂dragging＂ are⤶  # interchangeable unless made explicit)⤶  #⤶  # Usually when you ＂stick＂ a Widget A onto another B, it⤶  # remains ＂solid＂ to its parent, so A grabs to B when dragged.⤶  #⤶  # On the other hand, a SliderButton doesn't grab to the parent when⤶  # dragged, rather it's loose, as expected. (The fact that it⤶  # stays within the bounds of the parent when dragged is another matter).⤶  #⤶  # So via this method the system can determine what the⤶  # ＂top of the drag＂ is starting from any Widget.⤶  # The process of finding the top of the drag involves going up⤶  # the chain and finding the first Widget that is loose. Then that⤶  # will be the top of the drag, and the whole TREE under that morph⤶  # will be dragged.⤶  #⤶  # If the morphs grab each other up to the WorldMorph, then the World⤶  # can't be dragged, so there is no drag happening.⤶  #⤶  # Usually though at some point up the chain a morph won't⤶  # grab to its parent, so a dragging top is indeed found.⤶  #⤶  # Example chain: A grabs to parent B doesn't grab to parent C.⤶  # So A can be dragged: the whole tree under B is dragged (i.e. A B in⤶  # this case).⤶  #⤶  # If going up the chain of ＂grabbing＂ Widgets a Widget rejects being⤶  # dragged then the drag will be prevented. This rejection happens⤶  # via the ＂rejectDrags＂ method. In that way, for example⤶  # for the ColorPaletteMorph, you can avoid grabs (because drags on⤶  # a ColorPaletteMorph are expected to pick colors).⤶  #⤶  # So in the case above if B returns true in rejectDrags, then B⤶  # can be dragged and none of the children of B can be dragged either⤶  # (so: nor A nor B can't be dragged).⤶  #⤶  # Note that there is no away to prevent userts from ＂picking up＂⤶  # a Widget and then do a drag (which in that case would be a FLOATING drag).⤶⤶  grabsToParentWhenDragged: ->⤶    if @parent?⤶⤶      if @parent instanceof WorldMorph⤶        return @isLockingToPanels⤶⤶      if @amIDirectlyInsideScrollPanelWdgt()⤶        if @parent.parent.canScrollByDraggingForeground and @parent.parent.anyScrollBarShowing()⤶          return true⤶        else⤶          return @isLockingToPanels⤶⤶      if @parent instanceof PanelWdgt⤶        return @isLockingToPanels⤶⤶      # not attached to desktop, not inside a scrollable Panel⤶      # and not inside a Panel.⤶      # So, for example, when this morph is attached to another morph⤶      # attached to the world (because then it should remain solid⤶      # with the parent)⤶      return true⤶⤶    # doesn't have a parent⤶    return false⤶⤶  rejectDrags: ->⤶    @defaultRejectDrags⤶⤶  # finds the first morph (including this one)⤶  # that doesn't grab to its parent⤶  # returns nil if going up the grabbing chain⤶  # a morph rejects the drag⤶  findFirstLooseMorph: ->⤶    if @rejectDrags()⤶      return nil⤶⤶    if @nonFloatDragging?⤶      return @⤶⤶    if !@grabsToParentWhenDragged()⤶      return @⤶⤶    scanningMorphs = @⤶    while scanningMorphs.parent?⤶      scanningMorphs = scanningMorphs.parent⤶⤶      if scanningMorphs.rejectDrags()⤶        return nil⤶⤶      if scanningMorphs.nonFloatDragging?⤶        return scanningMorphs⤶⤶      if !scanningMorphs.grabsToParentWhenDragged()⤶        return scanningMorphs⤶⤶    return nil⤶⤶  findRootForGrab: ->⤶    return @findFirstLooseMorph()⤶⤶  amIDirectlyInsideScrollPanelWdgt: ->⤶    if @parent?⤶      if (@parent instanceof PanelWdgt) or (@parent instanceof SimpleVerticalStackPanelWdgt)⤶        if @parent.parent?⤶          if (@parent.parent instanceof ScrollPanelWdgt) and !(@parent.parent instanceof ListMorph)⤶            return true⤶    return false⤶⤶  amIPanelOfScrollPanelWdgt: ->⤶    if @parent?⤶      if (@parent instanceof ScrollPanelWdgt) and !(@parent instanceof ListMorph)⤶        return true⤶    return false⤶⤶  amIDirectlyInsideNonTextWrappingScrollPanelWdgt: ->⤶    if @amIDirectlyInsideScrollPanelWdgt()⤶      if !@parent.parent.isTextLineWrapping⤶        return true⤶    return false⤶⤶  # the only trick here is that we stop at the first⤶  # clipping morph, because if a morph is inside a clipping⤶  # morph, it doesn't contribute to any shadow.⤶  firstParentOwningMyShadow: ->⤶    if @hasShadow()⤶      return @⤶⤶    scanningMorphs = @⤶    while scanningMorphs.parent?⤶      scanningMorphs = scanningMorphs.parent⤶      # TODO actually stop at the first⤶      # CLIPPING morph (more generic), not⤶      # just a PanelWdgt⤶      if scanningMorphs.clipsAtRectangularBounds⤶        return nil⤶      if scanningMorphs.hasShadow()⤶        return scanningMorphs⤶⤶    return nil⤶⤶  # if true, then the drag will be a float drag⤶  # otherwise it will be a nonfloating drag⤶  detachesWhenDragged: ->⤶    true⤶  ⤶  isBeingFloatDragged: ->⤶⤶    if !world.hand?⤶      return false⤶⤶    # first check if the hand is floatdragging⤶    # anything, in that case if it's floatdragging⤶    # it can't be non-floatdragging⤶    if world.hand.nonFloatDraggedWdgt?⤶      return false⤶⤶    # then check if my root is the hand⤶    if @root() instanceof ActivePointerWdgt⤶      return true⤶⤶    # if we are here it means we are not being⤶    # nonfloatdragged⤶    return false⤶⤶  # Widget dragging (and dropping) /////////////////////////////////////////⤶⤶  # finds the first parent that is a PopUp⤶  firstParentThatIsAPopUp: ->⤶    if !@parent? then return @⤶    return @parent.firstParentThatIsAPopUp()⤶⤶  anyParentPopUpMarkedForClosure: ->⤶    if @isPopUpMarkedForClosure⤶      return true⤶    else if @parent?⤶      return @parent.anyParentPopUpMarkedForClosure() ⤶    return false⤶⤶  rootForFocus: ->⤶    if !@parent? or⤶      @parent instanceof WorldMorph⤶        return @  ⤶    @parent.rootForFocus()⤶⤶  moveInFrontOfSiblings: ->⤶    @moveAsLastChild()⤶    @fullChanged()⤶⤶  bringToForeground: ->⤶    @rootForFocus()?.moveAsLastChild()⤶    @rootForFocus()?.fullChanged()⤶⤶⤶  # note that ＂propagateKillPopUps＂ doesn't necessarily⤶  # go up the ＂parent＂ trail, for pop ups this method goes up⤶  # another trail of pop up ownership named via the⤶  # ＂morphOpeningThePopUp＂ property, that is⤶  # independent of the parent trail⤶  propagateKillPopUps: ->⤶    if @parent?⤶      @parent.propagateKillPopUps()⤶⤶  mouseDownLeft: (pos) ->⤶    @bringToForeground()⤶    @escalateEvent ＂mouseDownLeft＂, pos⤶⤶  mouseClickLeft: (pos) ->⤶    @escalateEvent ＂mouseClickLeft＂, pos⤶⤶  onClickOutsideMeOrAnyOfMyChildren: (functionName, arg1, arg2, arg3)->⤶    if functionName?⤶      @clickOutsideMeOrAnyOfMeChildrenCallback = [functionName, arg1, arg2, arg3]⤶      world.wdgtsDetectingClickOutsideMeOrAnyOfMeChildren.add @⤶    else⤶      #console.log ＂****** onClickOutsideMeOrAnyOfMyChildren removing element＂⤶      world.wdgtsDetectingClickOutsideMeOrAnyOfMeChildren.delete @⤶⤶  justDropped: (whereIn) ->⤶    @rememberFractionalSituationInHoldingPanel()⤶    ⤶  wantsDropOf: (aWdgt) ->⤶    return @_acceptsDrops⤶⤶  enableDrops: ->⤶    @_acceptsDrops = true⤶⤶  disableDrops: ->⤶    @_acceptsDrops = false⤶  ⤶  pickUp: ->⤶    oldParent = @parent⤶    oldParent?.childBeingPickedUp? @⤶    world.hand.grab @⤶    # if one uses the ＂deferred＂ API then we need to look⤶    # into the ＂desiredExtent＂ as the true extent has yet⤶    # to be settled⤶    if @desiredExtent?⤶      @fullRawMoveTo world.hand.position().subtract @desiredExtent.floorDivideBy 2⤶    else⤶      @fullRawMoveTo world.hand.position().subtract @fullBounds().extent().floorDivideBy 2⤶    oldParent?.childPickedUp? @⤶⤶  grabbedWidgetSwitcheroo: ->⤶    @⤶  ⤶⤶  ⤶  situation: ->⤶    # answer a dictionary specifying where I am right now, so⤶    # I can slide back to it if I'm dropped somewhere else⤶    if @parent⤶      return (⤶        origin: @parent⤶        position: @position().subtract @parent.position()⤶      )⤶    nil⤶  ⤶⤶  ⤶  ⤶  # Widget utilities ////////////////////////////////////////////////////////⤶  ⤶  showResizeAndMoveHandlesAndLayoutAdjusters: ->⤶    if @layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING⤶      world.temporaryHandlesAndLayoutAdjusters.add new HandleMorph(@, ＂resizeHorizontalHandle＂)⤶      world.temporaryHandlesAndLayoutAdjusters.add new HandleMorph(@, ＂resizeVerticalHandle＂)⤶      world.temporaryHandlesAndLayoutAdjusters.add new HandleMorph(@, ＂moveHandle＂)⤶      world.temporaryHandlesAndLayoutAdjusters.add new HandleMorph(@, ＂resizeBothDimensionsHandle＂)⤶    else⤶      if (@lastSiblingBeforeMeSuchThat((m) -> m.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED)?) and !@siblingBeforeMeIsA(StackElementsSizeAdjustingMorph)⤶        world.temporaryHandlesAndLayoutAdjusters.add ⧹⤶          @addAsSiblingBeforeMe ⧹⤶            new StackElementsSizeAdjustingMorph,⤶            nil,⤶            LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED⤶⤶      #console.log ＂@: ＂ + @.toString() + ＂ amITheLastSibling: ＂ + @amITheLastSibling()⤶⤶      if (@firstSiblingAfterMeSuchThat((m) -> m.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED)?) and !@siblingAfterMeIsA(StackElementsSizeAdjustingMorph)⤶        world.temporaryHandlesAndLayoutAdjusters.add ⧹⤶          @addAsSiblingAfterMe ⧹⤶            new StackElementsSizeAdjustingMorph,⤶            nil,⤶            LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED⤶      if @parent?⤶        @parent.showResizeAndMoveHandlesAndLayoutAdjusters()⤶  ⤶  showMoveHandle: ->⤶    world.temporaryHandlesAndLayoutAdjusters.add new HandleMorph @, ＂moveHandle＂⤶  ⤶  inform: (msg) ->⤶    text = msg⤶    if msg⤶      text = msg.toString()  if msg.toString⤶    else⤶      text = ＂NULL＂⤶    m = new MenuMorph @, false, @, true, true, text⤶    m.addMenuItem ＂Ok＂⤶    m.popUpCenteredAtHand world⤶⤶  prompt: (msg, target, callback, defaultContents, width, floorNum,⤶    ceilingNum, isRounded) ->⤶⤶    prompt = new PromptMorph(@, msg, target, callback, defaultContents, width, floorNum,⤶    ceilingNum, isRounded)⤶⤶    prompt.popUpAtHand()⤶    prompt.tempPromptEntryField.text.edit()⤶⤶  textPrompt: (msg, target, callback, defaultContents, width, floorNum,⤶    ceilingNum, isRounded) ->⤶⤶    prompt = new CodePromptMorph(msg, target, callback, defaultContents, width, floorNum,⤶    ceilingNum, isRounded)⤶    wm = new WindowWdgt nil, nil, prompt⤶    wm.setExtent new Point 460, 400⤶    wm.fullRawMoveTo world.hand.position().subtract new Point 50, 100⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶    wm.changed()⤶⤶⤶  ⤶  pickColor: (msg, callback, defaultContents) ->⤶    colorPicker = new ColorPickerMorph defaultContents⤶    menu = new MenuMorph @, false, @, true, true, msg or ＂＂, colorPicker⤶    menu.silentAdd colorPicker⤶    menu.addLine 2⤶⤶    menu.addMenuItem ＂Ok＂, true, @, callback⤶    # we name the button ＂Close＂ instead of ＂Cancel＂⤶    # because we are not undoing any change we made⤶    # that would be rather difficult in case of⤶    # multiple prompts being pinned down and changing⤶    # the property concurrently⤶    menu.addMenuItem ＂Close＂, true, menu, ＂close＂⤶⤶    menu.popUpAtHand()⤶⤶  inspect: (anotherObject) ->⤶    @spawnInspector @⤶⤶  inspect2: (anotherObject) ->⤶    @spawnInspector2 @⤶⤶  spawnInspector: (inspectee) ->⤶    inspector = new InspectorMorph inspectee⤶    inspector.fullRawMoveTo world.hand.position()⤶    inspector.fullRawMoveWithin world⤶    world.add inspector⤶    inspector.changed()⤶⤶  spawnInspector2: (inspectee) ->⤶    inspector = new InspectorMorph2 inspectee⤶    wm = new WindowWdgt nil, nil, inspector⤶    wm.setExtent new Point 560, 410⤶    wm.fullRawMoveTo world.hand.position().subtract new Point 50, 100⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶    wm.changed()⤶⤶  createConsole: ->⤶    inspector = new ConsoleWdgt @⤶    wm = new WindowWdgt nil, nil, inspector⤶    wm.setExtent new Point 285, 290⤶    wm.fullRawMoveTo world.hand.position().subtract new Point 50, 100⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶    wm.changed()⤶⤶  spawnNextTo: (morphToBeNextTo, whereToAddIt) ->⤶    if !whereToAddIt?⤶      whereToAddIt = morphToBeNextTo.parent⤶    whereToAddIt.add @⤶    @fullRawMoveTo morphToBeNextTo.center()⤶    @fullRawMoveWithin whereToAddIt⤶    ⤶  ⤶  # Widget menus ////////////////////////////////////////////////////////////////⤶  ⤶  # context Menus are whatever appears when one right-clicks⤶  # on something. It could be a custom menu, or the standard⤶  # menu on the desktop, or a menu to disambiguate which⤶  # morph it's being selected...⤶  buildContextMenu: ->⤶    # commented-out addendum for the implementation of 1):⤶    #show the normal menu in case there is text selected,⤶    #otherwise show the spacial multiplexing list⤶    #if !@world().caret⤶    #  if @world().hand.allWdgtsAtPointer().length > 2⤶    #    return @buildHierarchyMenu()⤶⤶    morphToAskMenuTo = @⤶⤶    # check if a parent wants to take over my menu (and hopefully⤶    # coalesce some of my entries!). In such case let it open the⤶    # menu. Used for example for scrollable text (which is text inside⤶    # a ScrollPanelWdgt).⤶    anyParentsTakingOverMyMenu = @allParentsTopToBottomSuchThat (m) ->⤶      (m instanceof ScrollPanelWdgt) and m.takesOverAndCoalescesChildrensMenus⤶    if anyParentsTakingOverMyMenu? and anyParentsTakingOverMyMenu.length > 0⤶      morphToAskMenuTo = anyParentsTakingOverMyMenu[0]⤶⤶    if morphToAskMenuTo.overridingContextMenu⤶      return morphToAskMenuTo.overridingContextMenu()⤶⤶    if world.isDevMode⤶      hierarchyMenuMorphs = morphToAskMenuTo.getHierarchyMenuMorphs()⤶      # if the morph is attached to the world then there is no⤶      # disambiguation to do, just build the context menu.⤶      # Same if there would be one only entry in the hierarchyMenu⤶      # then again just build the context menu for that entry.⤶      # Otherwise we actually have to build the spacial⤶      # demultiplexing menu.⤶      if morphToAskMenuTo.parent is world⤶        return morphToAskMenuTo.buildMorphContextMenu()⤶      else if hierarchyMenuMorphs.length < 2⤶        return hierarchyMenuMorphs[0].buildMorphContextMenu()⤶      else⤶        return morphToAskMenuTo.buildHierarchyMenu hierarchyMenuMorphs⤶⤶  getHierarchyMenuMorphs: ->⤶    hierarchyMenuMorphs = []⤶    # Spacial multiplexing⤶    # (search ＂multiplexing＂ for the other parts of⤶    # code where this matters)⤶    # There are two interpretations of what this⤶    # list should be:⤶    #   1) all morphs ＂pierced through＂ by the pointer⤶    #   2) all morphs parents of the topmost morph under the pointer⤶    # 2 is what is used in Cuis⤶    # commented-out addendum for the implementation of 1):⤶    # parents = @world().hand.allWdgtsAtPointer().reverse()⤶    parents = @allParentsTopToBottom()⤶    parents.forEach (each) ->⤶      # only add morphs that have a menu, and⤶      # leave out the world itself and the morphs that are about⤶      # to be destroyed⤶      if (each.buildMorphContextMenu) and (each isnt world) and (!each.anyParentPopUpMarkedForClosure())⤶        # * leave out SimpleVerticalStackPanelWdgt when⤶        #   inside a SimpleVerticalStackScrollPanelWdgt⤶        # * also leave out PanelWdgt when⤶        #   inside a ScrollPanelWdgt⤶        # * also leave out ScrollPanelWdgt when⤶        #   inside a FolderWindowWdgt⤶        # ...because they would be redundant - there is no need for the⤶        # user to know or have access to the internal structure of⤶        # those constructs⤶        if (!((each instanceof SimpleVerticalStackPanelWdgt) and (each.parent instanceof SimpleVerticalStackScrollPanelWdgt))) and⤶         (!((each instanceof PanelWdgt) and (each.parent instanceof ScrollPanelWdgt))) and⤶         (!((each instanceof ScrollPanelWdgt) and (each.parent instanceof FolderWindowWdgt)))⤶          hierarchyMenuMorphs.push each⤶⤶    hierarchyMenuMorphs⤶  ⤶  # When user right-clicks on a morph that is a child of other morphs,⤶  # then it's ambiguous which of the morphs she wants to operate on.⤶  # An example is right-clicking on a ToolTipWdgt: did she⤶  # mean to operate on the BubbleMorph or did she mean to operate on⤶  # the TextMorph contained in it?⤶  # This menu lets her disambiguate.⤶  buildHierarchyMenu: (morphsHierarchy) ->⤶    if !morphsHierarchy?⤶      morphsHierarchy = @getHierarchyMenuMorphs()⤶    menu = new MenuMorph @, false, @, true, true, nil⤶    morphsHierarchy.forEach (each) ->⤶      textLabelForMorph = each.toString().slice 0, 50⤶      textLabelForMorph = textLabelForMorph.replace ＂Wdgt＂, ＂＂⤶      menu.addMenuItem textLabelForMorph + ＂ ➜＂, false, each, ＂popupDeveloperMenu＂, nil, nil, nil, nil, nil, nil, nil, true⤶⤶    menu⤶⤶  popupDeveloperMenu: (morphOpeningThePopUp)->⤶    @buildMorphContextMenu(morphOpeningThePopUp).popUpAtHand()⤶⤶  popUpColorSetter: ->⤶    @pickColor ＂color:＂, ＂setColor＂, new Color 0,0,0⤶⤶⤶  transparencyPopout: (menuItem)->⤶    @prompt menuItem.parent.title + ＂⧹nalpha⧹nvalue:＂,⤶      @,⤶      ＂setAlphaScaled＂,⤶      (@alpha * 100).toString(),⤶      nil,⤶      1,⤶      100,⤶      true⤶⤶  createNewStringMorph2WithBackground: ->⤶    #newWdgt = new StringMorph2 ＂Hello World! ⎲ƒ⎳⎷ ⎸⎹ aaa＂,nil,nil,nil,nil,nil,nil,nil, new Color(255, 255, 54), 0.5⤶    newWdgt = new StringMorph2 ＂Hello World! ⎲ƒ⎳⎷ ⎸⎹ aaa＂,nil,nil,nil,nil,nil,nil,nil, new Color(230, 230, 130), 1⤶    newWdgt.isEditable = true⤶    world.create newWdgt⤶⤶  createNewStringMorph2WithoutBackground: ->⤶    newWdgt = new StringMorph2 ＂Hello World! ⎲ƒ⎳⎷ ⎸⎹ aaa＂⤶    newWdgt.isEditable = true⤶    world.create newWdgt⤶⤶  createNewTextMorph2WithBackground: ->⤶    newWdgt = new TextMorph2(⤶      ＂Lorem ipsum dolor sit amet, consectetur adipiscing ＂ +⤶      ＂elit. Integer rhoncus pharetra nulla, vel maximus ＂ +⤶      ＂lectus posuere a. Phasellus finibus blandit ex vitae ＂ +⤶      ＂varius. Vestibulum blandit velit elementum, ornare ＂ +⤶      ＂ipsum sollicitudin, blandit nunc. Mauris a sapien ＂ +⤶      ＂nibh. Nulla nec bibendum quam, eu condimentum nisl. ＂ +⤶      ＂Cras consequat efficitur nisi sed ornare. ＂ +⤶      ＂Pellentesque vitae urna vitae libero malesuada ＂ +⤶      ＂pharetra.＂ +⤶      ＂⧹n⧹n＂ +⤶      ＂Pellentesque commodo, nulla mattis vulputate ＂ +⤶      ＂porttitor, elit augue vestibulum est, nec congue ＂ +⤶      ＂ex dui a velit. Nullam lectus leo, lobortis eget ＂ +⤶      ＂erat ac, lobortis dignissim magna. Morbi ac odio ＂ +⤶      ＂in purus blandit dignissim. Maecenas at sagittis ＂ +⤶      ＂odio. Suspendisse tempus mattis erat id euismod. ＂ +⤶      ＂Duis semper mauris nec odio sagittis vulputate. ＂ +⤶      ＂Praesent varius ac erat id fringilla. Suspendisse ＂ +⤶      ＂porta sollicitudin bibendum. Pellentesque imperdiet ＂ +⤶      ＂at eros nec euismod. Etiam ac mattis odio, ac finibus ＂ +⤶      ＂nisi.＂,nil,nil,nil,nil,nil,new Color(230, 230, 130), 1)⤶    newWdgt.isEditable = true⤶    #newWdgt.maxTextWidth = 300⤶    world.create newWdgt⤶⤶  createNewWrappingSimplePlainTextWdgtWithBackground: ->⤶    newWdgt = new SimplePlainTextWdgt(⤶      ＂Lorem ipsum dolor sit amet, consectetur adipiscing ＂ +⤶      ＂elit. Integer rhoncus pharetra nulla, vel maximus ＂ +⤶      ＂lectus posuere a. Phasellus finibus blandit ex vitae ＂ +⤶      ＂varius. Vestibulum blandit velit elementum, ornare ＂ +⤶      ＂ipsum sollicitudin, blandit nunc. Mauris a sapien ＂ +⤶      ＂nibh. Nulla nec bibendum quam, eu condimentum nisl. ＂ +⤶      ＂Cras consequat efficitur nisi sed ornare. ＂ +⤶      ＂Pellentesque vitae urna vitae libero malesuada ＂ +⤶      ＂pharetra.＂ +⤶      ＂⧹n⧹n＂ +⤶      ＂Pellentesque commodo, nulla mattis vulputate ＂ +⤶      ＂porttitor, elit augue vestibulum est, nec congue ＂ +⤶      ＂ex dui a velit. Nullam lectus leo, lobortis eget ＂ +⤶      ＂erat ac, lobortis dignissim magna. Morbi ac odio ＂ +⤶      ＂in purus blandit dignissim. Maecenas at sagittis ＂ +⤶      ＂odio. Suspendisse tempus mattis erat id euismod. ＂ +⤶      ＂Duis semper mauris nec odio sagittis vulputate. ＂ +⤶      ＂Praesent varius ac erat id fringilla. Suspendisse ＂ +⤶      ＂porta sollicitudin bibendum. Pellentesque imperdiet ＂ +⤶      ＂at eros nec euismod. Etiam ac mattis odio, ac finibus ＂ +⤶      ＂nisi.＂,nil,nil,nil,nil,nil,new Color(230, 230, 130), 1)⤶    newWdgt.isEditable = true⤶    #newWdgt.maxTextWidth = 300⤶⤶    world.add newWdgt⤶    newWdgt.fullRawMoveTo new Point 25, 40⤶    newWdgt.rawSetExtent new Point 500, 300⤶⤶  createNewNonWrappingSimplePlainTextWdgtWithBackground: ->⤶    newWdgt = new SimplePlainTextWdgt(⤶      ＂Lorem ipsum dolor sit amet, consectetur adipiscing ＂ +⤶      ＂elit. Integer rhoncus pharetra nulla, vel maximus ＂ +⤶      ＂lectus posuere a. Phasellus finibus blandit ex vitae ＂ +⤶      ＂varius.＂ +⤶      ＂⧹n⧹n＂ +⤶      ＂Pellentesque commodo, nulla mattis vulputate ＂ +⤶      ＂porttitor, elit augue vestibulum est, nec congue ＂ +⤶      ＂ex dui a velit. Nullam lectus leo, lobortis eget ＂ +⤶      ＂erat ac, lobortis dignissim ＂ +⤶      ＂magna.＂,nil,nil,nil,nil,nil,new Color(230, 230, 130), 1)⤶    newWdgt.isEditable = true⤶    newWdgt.maxTextWidth = nil⤶    #newWdgt.maxTextWidth = 300⤶⤶    world.add newWdgt⤶    newWdgt.fullRawMoveTo new Point 540, 40⤶    newWdgt.rawSetExtent new Point 500, 300⤶⤶  createNewWrappingAndNonWrappingSimplePlainTextWdgtWithBackground: ->⤶    @createNewWrappingSimplePlainTextWdgtWithBackground()⤶    @createNewNonWrappingSimplePlainTextWdgtWithBackground()⤶⤶  createWrappingSimplePlainTextScrollPanelWdgt: ->⤶    SfA = new SimplePlainTextScrollPanelWdgt(⤶      ＂Lorem ipsum dolor sit amet, consectetur adipiscing ＂ +⤶      ＂elit. Integer rhoncus pharetra nulla, vel maximus ＂ +⤶      ＂lectus posuere a. Phasellus finibus blandit ex vitae ＂ +⤶      ＂varius. Vestibulum blandit velit elementum, ornare ＂ +⤶      ＂ipsum sollicitudin, blandit nunc. Mauris a sapien ＂ +⤶      ＂nibh. Nulla nec bibendum quam, eu condimentum nisl. ＂ +⤶      ＂Cras consequat efficitur nisi sed ornare. ＂ +⤶      ＂Pellentesque vitae urna vitae libero malesuada ＂ +⤶      ＂pharetra.＂ +⤶      ＂⧹n⧹n＂ +⤶      ＂Pellentesque commodo, nulla mattis vulputate ＂ +⤶      ＂porttitor, elit augue vestibulum est, nec congue ＂ +⤶      ＂ex dui a velit. Nullam lectus leo, lobortis eget ＂ +⤶      ＂erat ac, lobortis dignissim magna. Morbi ac odio ＂ +⤶      ＂in purus blandit dignissim. Maecenas at sagittis ＂ +⤶      ＂odio. Suspendisse tempus mattis erat id euismod. ＂ +⤶      ＂Duis semper mauris nec odio sagittis vulputate. ＂ +⤶      ＂Praesent varius ac erat id fringilla. Suspendisse ＂ +⤶      ＂porta sollicitudin bibendum. Pellentesque imperdiet ＂ +⤶      ＂at eros nec euismod. Etiam ac mattis odio, ac finibus ＂ +⤶      ＂nisi.＂,true, 10)⤶    world.add SfA⤶    SfA.fullRawMoveTo new Point 20, 25⤶    SfA.rawSetExtent new Point 390, 305⤶⤶  createNonWrappingSimplePlainTextScrollPanelWdgt: ->⤶    SfB = new SimplePlainTextScrollPanelWdgt(⤶      ＂Lorem ipsum dolor sit amet, consectetur adipiscing ＂ +⤶      ＂elit. Integer rhoncus pharetra nulla, vel maximus ＂ +⤶      ＂⧹n⧹n＂ +⤶      ＂Pellentesque commodo, nulla mattis vulputate ＂ +⤶      ＂porttitor, elit augue vestibulum est, nec congue ＂ +⤶      ＂nisi.＂,false, 10)⤶    world.add SfB⤶    SfB.fullRawMoveTo new Point 430, 25⤶    SfB.rawSetExtent new Point 390, 305⤶⤶  createWrappingAndNonWrappingSimplePlainTextScrollPanelWdgt: ->⤶    @createWrappingSimplePlainTextScrollPanelWdgt()⤶    @createNonWrappingSimplePlainTextScrollPanelWdgt()⤶⤶  # this is provided for completeness, however see the⤶  # note in SimplePlainTextPanelWdgt about how this is⤶  # incomplete and why this widget is not useful anyways⤶  createWrappingSimplePlainTextPanelWdgt: ->⤶    SfA = new SimplePlainTextPanelWdgt(⤶      ＂Lorem ipsum dolor sit amet, consectetur adipiscing ＂ +⤶      ＂elit. Integer rhoncus pharetra nulla, vel maximus ＂ +⤶      ＂lectus posuere a. Phasellus finibus blandit ex vitae ＂ +⤶      ＂varius. Vestibulum blandit velit elementum, ornare ＂ +⤶      ＂ipsum sollicitudin, blandit nunc. Mauris a sapien ＂ +⤶      ＂nibh. Nulla nec bibendum quam, eu condimentum nisl. ＂ +⤶      ＂Cras consequat efficitur nisi sed ornare. ＂ +⤶      ＂Pellentesque vitae urna vitae libero malesuada ＂ +⤶      ＂pharetra.＂ +⤶      ＂⧹n⧹n＂ +⤶      ＂Pellentesque commodo, nulla mattis vulputate ＂ +⤶      ＂porttitor, elit augue vestibulum est, nec congue ＂ +⤶      ＂ex dui a velit. Nullam lectus leo, lobortis eget ＂ +⤶      ＂erat ac, lobortis dignissim magna. Morbi ac odio ＂ +⤶      ＂in purus blandit dignissim. Maecenas at sagittis ＂ +⤶      ＂odio. Suspendisse tempus mattis erat id euismod. ＂ +⤶      ＂Duis semper mauris nec odio sagittis vulputate. ＂ +⤶      ＂Praesent varius ac erat id fringilla. Suspendisse ＂ +⤶      ＂porta sollicitudin bibendum. Pellentesque imperdiet ＂ +⤶      ＂at eros nec euismod. Etiam ac mattis odio, ac finibus ＂ +⤶      ＂nisi.＂,true, 10)⤶    world.add SfA⤶    SfA.fullRawMoveTo new Point 20, 25⤶    SfA.rawSetExtent new Point 390, 305⤶⤶  # this is provided for completeness, however see the⤶  # note in SimplePlainTextPanelWdgt about how this is⤶  # incomplete and why this widget is not useful anyways⤶  createNonWrappingSimplePlainTextPanelWdgt: ->⤶    SfB = new SimplePlainTextPanelWdgt(⤶      ＂Lorem ipsum dolor sit amet, consectetur adipiscing ＂ +⤶      ＂elit. Integer rhoncus pharetra nulla, vel maximus ＂ +⤶      ＂⧹n⧹n＂ +⤶      ＂Pellentesque commodo, nulla mattis vulputate ＂ +⤶      ＂porttitor, elit augue vestibulum est, nec congue ＂ +⤶      ＂nisi.＂,false, 10)⤶    world.add SfB⤶    SfB.fullRawMoveTo new Point 430, 25⤶    SfB.rawSetExtent new Point 390, 305⤶⤶  # this is provided for completeness, however see the⤶  # note in SimplePlainTextPanelWdgt about how this is⤶  # incomplete and why this widget is not useful anyways⤶  createWrappingAndNonWrappingSimplePlainTextPanelWdgt: ->⤶    @createWrappingSimplePlainTextPanelWdgt()⤶    @createNonWrappingSimplePlainTextPanelWdgt()⤶⤶⤶  createNewStringMorph3WithBackground: ->⤶    #newWdgt = new StringMorph2 ＂Hello World! ⎲ƒ⎳⎷ ⎸⎹ aaa＂,nil,nil,nil,nil,nil,nil,nil, new Color(255, 255, 54), 0.5⤶    newWdgt = new StringMorph3 ＂Hello World! ⎲ƒ⎳⎷ ⎸⎹ aaa＂,nil,nil,nil,nil,nil,nil,nil, new Color(230, 230, 130), 1⤶    newWdgt.isEditable = true⤶    world.create newWdgt⤶⤶  createNewTextMorph3WithBackground: ->⤶    newWdgt = new TextMorph3(⤶      ＂Lorem ipsum dolor sit amet, consectetur adipiscing ＂ +⤶      ＂elit. Integer rhoncus pharetra nulla, vel maximus ＂ +⤶      ＂lectus posuere a. Phasellus finibus blandit ex vitae ＂ +⤶      ＂varius. Vestibulum blandit velit elementum, ornare ＂ +⤶      ＂ipsum sollicitudin, blandit nunc. Mauris a sapien ＂ +⤶      ＂nibh. Nulla nec bibendum quam, eu condimentum nisl. ＂ +⤶      ＂Cras consequat efficitur nisi sed ornare. ＂ +⤶      ＂Pellentesque vitae urna vitae libero malesuada ＂ +⤶      ＂pharetra.＂ +⤶      ＂⧹n⧹n＂ +⤶      ＂Pellentesque commodo, nulla mattis vulputate ＂ +⤶      ＂porttitor, elit augue vestibulum est, nec congue ＂ +⤶      ＂ex dui a velit. Nullam lectus leo, lobortis eget ＂ +⤶      ＂erat ac, lobortis dignissim magna. Morbi ac odio ＂ +⤶      ＂in purus blandit dignissim. Maecenas at sagittis ＂ +⤶      ＂odio. Suspendisse tempus mattis erat id euismod. ＂ +⤶      ＂Duis semper mauris nec odio sagittis vulputate. ＂ +⤶      ＂Praesent varius ac erat id fringilla. Suspendisse ＂ +⤶      ＂porta sollicitudin bibendum. Pellentesque imperdiet ＂ +⤶      ＂at eros nec euismod. Etiam ac mattis odio, ac finibus ＂ +⤶      ＂nisi.＂,nil,nil,nil,nil,nil,new Color(255, 255, 54), 0.5)⤶    newWdgt.isEditable = true⤶    #newWdgt.maxTextWidth = 300⤶    world.create newWdgt⤶⤶  createSimpleVerticalStackPanelWdgt: ->⤶    svspw = new SimpleVerticalStackPanelWdgt⤶    world.add svspw⤶    svspw.fullRawMoveTo new Point 35, 30⤶    svspw.rawSetExtent new Point 370, 325⤶⤶  createSimpleVerticalStackScrollPanelWdgt: ->⤶    svsspw = new SimpleVerticalStackScrollPanelWdgt⤶    world.add svsspw⤶    svsspw.fullRawMoveTo new Point 430, 25⤶    svsspw.rawSetExtent new Point 370, 325⤶⤶  createSimpleVerticalStackPanelWdgtAndScrollPanel: ->⤶    @createSimpleVerticalStackPanelWdgt()⤶    @createSimpleVerticalStackScrollPanelWdgt()⤶⤶  createSimpleVerticalStackPanelWdgtFreeContentsWidth: ->⤶    svspw = new SimpleVerticalStackPanelWdgt null, null, null, false⤶    world.add svspw⤶    svspw.fullRawMoveTo new Point 35, 30⤶    svspw.rawSetExtent new Point 370, 325⤶⤶  createSimpleVerticalStackScrollPanelWdgtFreeContentsWidth: ->⤶    svsspw = new SimpleVerticalStackScrollPanelWdgt false⤶    world.add svsspw⤶    svsspw.fullRawMoveTo new Point 430, 25⤶    svsspw.rawSetExtent new Point 370, 325⤶⤶  createSimpleVerticalStackPanelWdgtAndScrollPanelFreeContentsWidth: ->⤶    @createSimpleVerticalStackPanelWdgt()⤶    @createSimpleVerticalStackScrollPanelWdgt()⤶⤶  createSimpleDocumentScrollPanelWdgt: ->⤶    sdspw = new SimpleDocumentScrollPanelWdgt⤶    world.add sdspw⤶    sdspw.fullRawMoveTo new Point 35, 30⤶    sdspw.rawSetExtent new Point 370, 325⤶⤶  showOutputPins: (a,b,c,d) ->⤶    world.morphsToBePinouted.add b⤶⤶  removeOutputPins: (a,b,c,d) ->⤶    world.morphsToBePinouted.delete b⤶⤶  testMenu: (morphOpeningThePopUp,targetMorph)->⤶    menu = new MenuMorph morphOpeningThePopUp,  false, targetMorph, true, true, nil⤶    menu.addMenuItem ＂serialise morph to memory＂, true, targetMorph, ＂serialiseToMemory＂⤶    menu.addMenuItem ＂deserialize from memory and attach to world＂, true, targetMorph, ＂deserialiseFromMemoryAndAttachToWorld＂⤶    menu.addMenuItem ＂deserialize from memory and attach to hand＂, true, targetMorph, ＂deserialiseFromMemoryAndAttachToHand＂⤶    menu.addMenuItem ＂attach with horizontal layout＂, true, @, ＂attachWithHorizLayout＂⤶    menu.addMenuItem ＂make spacers transparent＂, true, @, ＂makeSpacersTransparent＂⤶    menu.addMenuItem ＂make spacers opaque＂, true, @, ＂makeSpacersOpaque＂⤶    menu.addMenuItem ＂show adders＂, true, @, ＂showAdders＂⤶    menu.addMenuItem ＂remove adders＂, true, @, ＂removeAdders＂⤶    menu.addMenuItem ＂StringMorph2 without background＂, true, @, ＂createNewStringMorph2WithoutBackground＂⤶    menu.addMenuItem ＂StringMorph2 with background＂, true, @, ＂createNewStringMorph2WithBackground＂⤶    menu.addMenuItem ＂TextMorph2 with background＂, true, @, ＂createNewTextMorph2WithBackground＂⤶    menu.addMenuItem ＂StringMorph3 with background＂, true, @, ＂createNewStringMorph3WithBackground＂⤶    menu.addMenuItem ＂TextMorph3 with background＂, true, @, ＂createNewTextMorph3WithBackground＂⤶    if world.morphsToBePinouted.has targetMorph⤶      menu.addMenuItem ＂remove output pins＂, true, @, ＂removeOutputPins＂⤶    else⤶      menu.addMenuItem ＂show output pins＂, true, @, ＂showOutputPins＂⤶    ⤶    # unclear whether the ＂un-collapse＂ entry would ever be⤶    # visible.⤶    if targetMorph.collapsed⤶      menu.addMenuItem ＂un-collapse＂, true, @, ＂unCollapse＂⤶    else⤶      menu.addMenuItem ＂collapse＂, true, @, ＂collapse＂⤶⤶    menu.addMenuItem ＂others ➜＂, false, @, ＂popUpFirstMenu＂, ＂others＂⤶    menu.addMenuItem ＂others 2 ➜＂, false, @, ＂popUpSecondMenu＂, ＂others＂⤶⤶⤶    menu.popUpAtHand()⤶⤶  analogClock: ->⤶    world.create new AnalogClockWdgt⤶⤶  popUpIconsMenu: (morphOpeningThePopUp) ->⤶    menu = new MenuMorph morphOpeningThePopUp,  false, @, true, true, ＂icons＂⤶    menu.addMenuItem ＂Destroy icon＂, true, menusHelper, ＂createDestroyIconMorph＂⤶    menu.addMenuItem ＂Under the carpet icon＂, true, menusHelper, ＂createUnderCarpetIconMorph＂⤶    menu.addMenuItem ＂Collapsed state icon＂, true, menusHelper, ＂createCollapsedStateIconMorph＂⤶    menu.addMenuItem ＂Uncollapsed state icon＂, true, menusHelper, ＂createUncollapsedStateIconMorph＂⤶    menu.addMenuItem ＂Close icon＂, true, menusHelper, ＂createCloseIconButtonMorph＂⤶    menu.addMenuItem ＂Scratch area icon＂, true, menusHelper, ＂createScratchAreaIconMorph＂⤶    menu.addMenuItem ＂Flora icon＂, true, menusHelper, ＂createFloraIconMorph＂⤶    menu.addMenuItem ＂Scooter icon＂, true, menusHelper, ＂createScooterIconMorph＂⤶    menu.addMenuItem ＂Heart icon＂, true, menusHelper, ＂createHeartIconMorph＂⤶⤶    menu.addMenuItem ＂more 1 ➜＂, false, menusHelper, ＂popUpMore1IconsMenu＂, ＂others＂⤶    menu.addMenuItem ＂more 2 ➜＂, false, menusHelper, ＂popUpMore2IconsMenu＂, ＂others＂⤶    menu.addMenuItem ＂arrows ➜＂, false, menusHelper, ＂popUpArrowsIconsMenu＂, ＂others＂⤶    menu.addMenuItem ＂maps ➜＂, false, menusHelper, ＂popUpMapsMenu＂, ＂maps＂⤶    menu.addMenuItem ＂more 3 ➜＂, false, menusHelper, ＂popUpMore3IconsMenu＂, ＂maps＂⤶⤶    menu.popUpAtHand()⤶⤶  popUpVerticalStackMenu: (morphOpeningThePopUp) ->⤶    menu = new MenuMorph morphOpeningThePopUp,  false, @, true, true, ＂Vertical stack＂⤶    menu.addMenuItem ＂vertical stack constrained contents width＂, true, @, ＂createSimpleVerticalStackPanelWdgt＂⤶    menu.addMenuItem ＂vertical stack scrollpanel constrained contents width＂, true, @, ＂createSimpleVerticalStackScrollPanelWdgt＂⤶    menu.addMenuItem ＂vertical stack panel and scrollpanel constrained contents width＂, true, @, ＂createSimpleVerticalStackPanelWdgtAndScrollPanel＂⤶    menu.addMenuItem ＂vertical stack free contents width＂, true, @, ＂createSimpleVerticalStackPanelWdgtFreeContentsWidth＂⤶    menu.addMenuItem ＂vertical stack scrollpanel free contents width＂, true, @, ＂createSimpleVerticalStackScrollPanelWdgtFreeContentsWidth＂⤶    menu.addMenuItem ＂vertical stack panel and scrollpanel free contents width＂, true, @, ＂createSimpleVerticalStackPanelWdgtAndScrollPanelFreeContentsWidth＂⤶⤶    menu.popUpAtHand()⤶⤶  popUpDocumentMenu: (morphOpeningThePopUp) ->⤶    menu = new MenuMorph morphOpeningThePopUp,  false, @, true, true, ＂Document＂⤶    menu.addMenuItem ＂simple document scrollpanel＂, true, @, ＂createSimpleDocumentScrollPanelWdgt＂⤶    menu.addMenuItem ＂simple document＂, true, menusHelper, ＂createSimpleDocumentWdgt＂⤶    menu.popUpAtHand()⤶⤶  popUpWindowsMenu: (morphOpeningThePopUp) ->⤶    menu = new MenuMorph morphOpeningThePopUp,  false, @, true, true, ＂Windows＂⤶    menu.addMenuItem ＂empty window＂, true, @, ＂createEmptyWindow＂⤶    menu.addMenuItem ＂empty internal window＂, true, @, ＂createEmptyInternalWindow＂⤶⤶    menu.popUpAtHand()⤶⤶  popUpShortcutsAndScriptsMenu: (morphOpeningThePopUp) ->⤶    menu = new MenuMorph morphOpeningThePopUp,  false, @, true, true, ＂Shortcuts & Scripts＂⤶    menu.addMenuItem ＂basement shortcut＂, true, menusHelper, ＂basementIconAndText＂⤶    menu.addMenuItem ＂new script＂, true, menusHelper, ＂newScriptWindow＂⤶    menu.addMenuItem ＂Fizzypaint launcher＂, true, menusHelper, ＂createFizzyPaintLauncherAndItsIcon＂⤶    menu.addMenuItem ＂Simple doc launcher＂, true, menusHelper, ＂createSimpleDocumentLauncherAndItsIcon＂⤶    menu.addMenuItem ＂Simple slide launcher＂, true, menusHelper, ＂createSimpleSlideLauncherAndItsIcon＂⤶    menu.addMenuItem ＂Link＂, true, menusHelper, ＂createSimpleLinkWdgt＂⤶    menu.addMenuItem ＂Video link＂, true, menusHelper, ＂createSimpleVideoLinkWdgt＂⤶    menu.popUpAtHand()⤶⤶  popUpPatchProgrammingMenu: (morphOpeningThePopUp) ->⤶    menu = new MenuMorph morphOpeningThePopUp,  false, @, true, true, ＂Patch Programming＂⤶    menu.addMenuItem ＂fanout＂, true, menusHelper, ＂createFanout＂⤶    menu.addMenuItem ＂calculating node＂, true, menusHelper, ＂createCalculatingPatchNode＂⤶    menu.addMenuItem ＂diffing node＂, true, menusHelper, ＂createDiffingPatchNode＂⤶    menu.addMenuItem ＂slider＂, true, menusHelper, ＂createSliderWithSmallestValueAtBottomEnd＂⤶    menu.addMenuItem ＂regex subst. node＂, true, menusHelper, ＂createRegexSubstitutionPatchNodeWdgt＂⤶    menu.popUpAtHand()⤶⤶⤶  createEmptyInternalWindow: ->⤶    wm = new WindowWdgt nil, nil, nil, true⤶    wm.fullRawMoveTo world.hand.position()⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶    wm.changed()⤶⤶  createEmptyWindow: ->⤶    wm = new WindowWdgt nil, nil, nil⤶    wm.fullRawMoveTo world.hand.position()⤶    wm.fullRawMoveWithin world⤶    world.add wm⤶    wm.changed()⤶⤶⤶⤶  popUpSimplePlainTextWdgtMenu: (morphOpeningThePopUp) ->⤶    menu = new MenuMorph morphOpeningThePopUp,  false, @, true, true, ＂Simple plain text＂⤶    menu.addMenuItem ＂simple plain text wrapping＂, true, @, ＂createNewWrappingSimplePlainTextWdgtWithBackground＂⤶    menu.addMenuItem ＂simple plain text not wrapping＂, true, @, ＂createNewNonWrappingSimplePlainTextWdgtWithBackground＂    ⤶    menu.addMenuItem ＂simple plain text (wrapping / not wrapping)＂, true, @, ＂createNewWrappingAndNonWrappingSimplePlainTextWdgtWithBackground＂    ⤶    menu.addMenuItem ＂simple plain text panel wrapping＂, true, @, ＂createWrappingSimplePlainTextPanelWdgt＂⤶    menu.addMenuItem ＂simple plain text panel not wrapping＂, true, @, ＂createNonWrappingSimplePlainTextPanelWdgt＂⤶    menu.addMenuItem ＂simple plain text panel (wrapping / not wrapping)＂, true, @, ＂createWrappingAndNonWrappingSimplePlainTextPanelWdgt＂⤶    menu.addMenuItem ＂simple plain text scrollpanel wrapping＂, true, @, ＂createWrappingSimplePlainTextScrollPanelWdgt＂⤶    menu.addMenuItem ＂simple plain text scrollpanel not wrapping＂, true, @, ＂createNonWrappingSimplePlainTextScrollPanelWdgt＂⤶    menu.addMenuItem ＂simple plain text scrollpanel (wrapping / not wrapping)＂, true, @, ＂createWrappingAndNonWrappingSimplePlainTextScrollPanelWdgt＂⤶⤶    menu.popUpAtHand()⤶⤶⤶⤶  buildBaseMorphClassContextMenu: (morphOpeningThePopUp) ->⤶⤶    menu = new MenuMorph(morphOpeningThePopUp, false, ⤶      @,⤶      true,⤶      true,⤶      (@constructor.name.replace ＂Wdgt＂, ＂＂) or (@constructor.toString().replace ＂Wdgt＂, ＂＂).split(＂ ＂)[1].split(＂(＂)[0])⤶⤶    if world.isIndexPage⤶      menu.addMenuItem ＂color...＂, true, @, ＂popUpColorSetter＂ , ＂choose another color ⧹nfor this morph＂⤶      menu.addMenuItem ＂transparency...＂, true, @, ＂transparencyPopout＂, ＂set this morph's⧹nalpha value＂⤶      menu.addMenuItem ＂resize/move...＂, true, @, ＂showResizeAndMoveHandlesAndLayoutAdjusters＂, ＂show a handle⧹nwhich can be floatDragged⧹nto change this morph's＂ + ＂ extent＂⤶      menu.addLine()⤶      menu.addMenuItem ＂duplicate＂, true, @, ＂duplicateMenuAction＂ , ＂make a copy＂⤶      menu.addMenuItem ＂create shortcut＂, true, @, ＂createReference＂, ＂creates a reference to this wdgt and leaves it on the desktop＂⤶      menu.addMenuItem ＂pick up＂, true, @, ＂pickUp＂, ＂disattach and put ⧹ninto the hand＂⤶    else⤶      menu.addMenuItem ＂color...＂, true, @, ＂popUpColorSetter＂ , ＂choose another color ⧹nfor this morph＂⤶      menu.addMenuItem ＂transparency...＂, true, @, ＂transparencyPopout＂, ＂set this morph's⧹nalpha value＂⤶      menu.addMenuItem ＂resize/move...＂, true, @, ＂showResizeAndMoveHandlesAndLayoutAdjusters＂, ＂show a handle⧹nwhich can be floatDragged⧹nto change this morph's＂ + ＂ extent＂⤶      menu.addLine()⤶      menu.addMenuItem ＂duplicate＂, true, @, ＂duplicateMenuActionAndPickItUp＂ , ＂make a copy⧹nand pick it up＂⤶      menu.addMenuItem ＂pick up＂, true, @, ＂pickUp＂, ＂disattach and put ⧹ninto the hand＂⤶      menu.addMenuItem ＂attach...＂, true, @, ＂attach＂, ＂stick this morph⧹nto another one＂⤶      menu.addMenuItem ＂inspect＂, true, @, ＂inspect＂, ＂open a window⧹non all properties＂⤶      menu.addMenuItem ＂create shortcut＂, true, @, ＂createReference＂, ＂creates a reference to this wdgt and leaves it on the desktop＂⤶      menu.addMenuItem ＂test menu ➜＂, false, @, ＂testMenu＂, ＂debugging and testing operations＂⤶      menu.addLine()⤶⤶    if (@parent instanceof PanelWdgt) and !(@parent instanceof ScrollPanelWdgt)⤶      if @parent instanceof WorldMorph⤶        whereToOrFrom = ＂desktop＂⤶      else⤶        whereToOrFrom = ＂panel＂          ⤶      if @isLockingToPanels⤶        menu.addMenuItem ＂unlock from ＂ + whereToOrFrom, true, @, ＂toggleIsLockingToPanels＂, ＂make this morph⧹nunmovable＂⤶      else⤶        menu.addMenuItem ＂lock to ＂ + whereToOrFrom, true, @, ＂toggleIsLockingToPanels＂, ＂make this morph⧹nmovable＂⤶⤶    if !world.isIndexPage⤶      menu.addMenuItem ＂hide＂, true, @, ＂hide＂⤶⤶    if @ instanceof WindowWdgt⤶      menu.addMenuItem ＂close＂, true, @, ＂close＂⤶    else⤶      menu.addMenuItem ＂delete＂, true, @, ＂close＂⤶⤶    if !world.isIndexPage⤶      menu.addMenuItem ＂destroy＂, true, @, ＂fullDestroy＂⤶    else⤶      menu.addLine()⤶      menu.addMenuItem ＂dev ➜＂, false, menusHelper, ＂popUpDevToolsMenu＂, ＂dev tools＂⤶⤶    menu⤶⤶  # Widget-specific menu entries are basically the ones⤶  # beyond the generic entries above.⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    if @layoutSpec == LayoutSpec.ATTACHEDAS_VERTICAL_STACK_ELEMENT⤶      # it could be possible to figure out layouts when the vertical⤶      # stack doesn't contrain the content widths but it's rather⤶      # more complicated so we are not doing it for the time⤶      # being⤶      if @parent?.constrainContentWidth⤶        @layoutSpecDetails.addMorphSpecificMenuEntries morphOpeningThePopUp, menu⤶⤶  buildMorphContextMenu: (morphOpeningThePopUp) ->⤶    menu = @buildBaseMorphClassContextMenu morphOpeningThePopUp⤶    @addMorphSpecificMenuEntries morphOpeningThePopUp, menu⤶⤶    if @addShapeSpecificMenuItems?⤶      menu = @addShapeSpecificMenuItems menu⤶    menu⤶⤶  # Widget menu actions⤶  calculateAlphaScaled: (alpha) ->⤶    if typeof alpha is ＂number＂⤶      unscaled = alpha / 100⤶      return Math.min Math.max(unscaled, 0.1), 1⤶    else⤶      newAlpha = parseFloat alpha⤶      unless isNaN newAlpha⤶        unscaled = newAlpha / 100⤶        return Math.min Math.max(unscaled, 0.1), 1⤶⤶  setPadding: (paddingOrMorphGivingPadding, morphGivingPadding) ->⤶    if morphGivingPadding?.getValue?⤶      padding = morphGivingPadding.getValue()⤶    else⤶      padding = paddingOrMorphGivingPadding⤶⤶    #console.log ＂ >>>>>>>>>>>>> padding: ＂ + padding⤶    #if padding == 1⤶    #  debugger⤶    if @paddingTop != padding or @paddingBottom != padding or @paddingLeft != padding or @paddingRight != padding⤶      @paddingTop = padding⤶      @paddingBottom = padding⤶      @paddingLeft = padding⤶      @paddingRight = padding⤶      @changed()⤶⤶    return padding⤶⤶  setPaddingTop: (paddingOrMorphGivingPadding, morphGivingPadding) ->⤶    if morphGivingPadding?.getValue?⤶      padding = morphGivingPadding.getValue()⤶    else⤶      padding = paddingOrMorphGivingPadding⤶⤶    if padding⤶      unless @paddingTop == padding⤶        @paddingTop = padding⤶        @changed()⤶⤶    return padding⤶⤶  setPaddingBottom: (paddingOrMorphGivingPadding, morphGivingPadding) ->⤶    if morphGivingPadding?.getValue?⤶      padding = morphGivingPadding.getValue()⤶    else⤶      padding = paddingOrMorphGivingPadding⤶⤶    if padding⤶      unless @paddingBottom == padding⤶        @paddingBottom = padding⤶        @changed()⤶⤶    return padding⤶⤶  setPaddingLeft: (paddingOrMorphGivingPadding, morphGivingPadding) ->⤶    if morphGivingPadding?.getValue?⤶      padding = morphGivingPadding.getValue()⤶    else⤶      padding = paddingOrMorphGivingPadding⤶⤶    if padding⤶      unless @paddingLeft == padding⤶        @paddingLeft = padding⤶        @changed()⤶⤶    return padding⤶⤶  setPaddingRight: (paddingOrMorphGivingPadding, morphGivingPadding) ->⤶    if morphGivingPadding?.getValue?⤶      padding = morphGivingPadding.getValue()⤶    else⤶      padding = paddingOrMorphGivingPadding⤶⤶    if padding⤶      unless @paddingRight == padding⤶        @paddingRight = padding⤶        @changed()⤶⤶    return padding⤶⤶  setAlphaScaled: (alphaOrMorphGivingAlpha, morphGivingAlpha) ->⤶    if morphGivingAlpha?.getValue?⤶      alpha = morphGivingAlpha.getValue()⤶    else⤶      alpha = alphaOrMorphGivingAlpha⤶⤶    if alpha⤶      alpha = @calculateAlphaScaled alpha⤶      unless @alpha == alpha⤶        @alpha = alpha⤶        @changed()⤶⤶    return alpha⤶⤶  newParentChoice: (ignored, theMorphToBeAttached) ->⤶    # this is what happens when ＂each＂ is⤶    # selected: we attach the selected morph⤶    @add theMorphToBeAttached⤶    if @ instanceof ScrollPanelWdgt⤶      @adjustContentsBounds()⤶      @adjustScrollBars()⤶⤶  newParentChoiceWithHorizLayout: (ignored, theMorphToBeAttached) ->⤶    # this is what happens when ＂each＂ is⤶    # selected: we attach the selected morph⤶    @add theMorphToBeAttached, nil, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED⤶    if @ instanceof ScrollPanelWdgt⤶      @adjustContentsBounds()⤶      @adjustScrollBars()⤶⤶  attach: ->⤶    choices = world.plausibleTargetAndDestinationMorphs @⤶⤶    # my direct parent might be in the⤶    # options which is silly, leave that one out⤶    choicesExcludingParent = []⤶    choices.forEach (each) =>⤶      if each != @parent⤶        choicesExcludingParent.push each⤶⤶    if choicesExcludingParent.length > 0⤶      menu = new MenuMorph @, false, @, true, true, ＂choose new parent:＂⤶      choicesExcludingParent.forEach (each) =>⤶        menu.addMenuItem each.toString().slice(0, 50), true, each, ＂newParentChoice＂, nil, nil, nil, nil, nil, nil, nil, true⤶    else⤶      # the ideal would be to not show the⤶      # ＂attach＂ menu entry at all but for the⤶      # time being it's quite costly to⤶      # find the eligible morphs to attach⤶      # to, so for now let's just calculate⤶      # this list if the user invokes the⤶      # command, and if there are no good⤶      # morphs then show some kind of message.⤶      menu = new MenuMorph @, false, @, true, true, ＂no morphs to attach to＂⤶    menu.popUpAtHand()⤶⤶  attachWithHorizLayout: ->⤶    choices = world.plausibleTargetAndDestinationMorphs @⤶⤶    # my direct parent might be in the⤶    # options which is silly, leave that one out⤶    choicesExcludingParent = []⤶    choices.forEach (each) =>⤶      if each != @parent⤶        choicesExcludingParent.push each⤶⤶    if choicesExcludingParent.length > 0⤶      menu = new MenuMorph @, false, @, true, true, ＂choose new parent:＂⤶      choicesExcludingParent.forEach (each) =>⤶        menu.addMenuItem each.toString().slice(0, 50), true, each, ＂newParentChoiceWithHorizLayout＂, nil, nil, nil, nil, nil, nil, nil, true⤶    else⤶      # the ideal would be to not show the⤶      # ＂attach＂ menu entry at all but for the⤶      # time being it's quite costly to⤶      # find the eligible morphs to attach⤶      # to, so for now let's just calculate⤶      # this list if the user invokes the⤶      # command, and if there are no good⤶      # morphs then show some kind of message.⤶      menu = new MenuMorph @, false, @, true, true, ＂no morphs to attach to＂⤶    menu.popUpAtHand()⤶  ⤶  toggleIsLockingToPanels: ->⤶    @isLockingToPanels = not @isLockingToPanels⤶⤶  lockToPanels: ->⤶    @isLockingToPanels = true⤶⤶  unlockFromPanels: ->⤶    @isLockingToPanels = false⤶⤶  # ---------------------------------------------------------------------⤶  # locking of contents⤶⤶  enableDragsDropsAndEditing: ->⤶⤶    if @dragsDropsAndEditingEnabled⤶      return⤶    @dragsDropsAndEditingEnabled = true⤶⤶    if @contents?⤶      whereToAct = @contents⤶      if whereToAct.dragsDropsAndEditingEnabled⤶        return⤶      whereToAct.dragsDropsAndEditingEnabled = true⤶    else⤶      whereToAct = @⤶⤶⤶    @parent?.makePencilYellow?()⤶    whereToAct.dragsDropsAndEditingEnabled = true⤶⤶    whereToAct.enableDrops()⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets whereToAct⤶⤶    if childrenNotHandlesNorCarets?⤶      for each in childrenNotHandlesNorCarets⤶        each.unlockFromPanels()⤶        each.contrastOutFromPanelColor?()⤶        if each.isEditable?⤶          each.isEditable = true⤶⤶⤶  disableDragsDropsAndEditing: ->⤶    if !@dragsDropsAndEditingEnabled⤶      return⤶    @dragsDropsAndEditingEnabled = false⤶⤶    if @contents?⤶      whereToAct = @contents⤶      if !whereToAct.dragsDropsAndEditingEnabled⤶        return⤶      whereToAct.dragsDropsAndEditingEnabled = false⤶    else⤶      whereToAct = @⤶⤶⤶    @parent?.makePencilClear?()⤶    whereToAct.disableDrops()⤶⤶    whereToAct.dragsDropsAndEditingEnabled = false⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets whereToAct⤶⤶    if childrenNotHandlesNorCarets?⤶      for each in childrenNotHandlesNorCarets⤶        each.lockToPanels()⤶        each.blendInWithPanelColor?()⤶        if each.isEditable?⤶          each.isEditable = false⤶          if world.caret?.target == each⤶            world.stopEditing()⤶⤶⤶  # ---------------------------------------------------------------------⤶⤶  prepareToBeGrabbed: ->⤶    @userMovedThisFromComputedPosition = true⤶    @unlockFromPanels()⤶    @setLayoutSpec LayoutSpec.ATTACHEDAS_FREEFLOATING⤶⤶  deduplicateSettersAndSortByMenuEntryString: (menuEntriesStrings, functionNamesStrings) ->⤶    menuEntriesStrings = menuEntriesStrings.uniqueKeepOrder()⤶    functionNamesStrings = functionNamesStrings.uniqueKeepOrder()⤶⤶    #1) combine the arrays:⤶    list = []⤶    j = 0⤶    while j < menuEntriesStrings.length⤶      list.push⤶        'menuEntriesStrings': menuEntriesStrings[j]⤶        'functionNamesStrings': functionNamesStrings[j]⤶      j++⤶    #2) sort:⤶    list.sort (a, b) ->⤶      if a.menuEntriesStrings < b.menuEntriesStrings then -1 else if a.menuEntriesStrings == b.menuEntriesStrings then 0 else 1⤶      #Sort could be modified to, for example, sort on the age ⤶      # if the name is the same.⤶    #3) separate them back out:⤶    k = 0⤶    while k < list.length⤶      menuEntriesStrings[k] = list[k].menuEntriesStrings⤶      functionNamesStrings[k] = list[k].functionNamesStrings⤶      k++⤶⤶    return [menuEntriesStrings, functionNamesStrings]⤶⤶  colorSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    if !menuEntriesStrings? ⤶      menuEntriesStrings = []⤶      functionNamesStrings = []⤶    menuEntriesStrings.push ＂color＂, ＂background color＂⤶    functionNamesStrings.push ＂setColor＂, ＂setBackgroundColor＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  stringSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    if !menuEntriesStrings? ⤶      menuEntriesStrings = []⤶      functionNamesStrings = []⤶    # we don't add anything so no need to sort/deduplicate⤶    return [menuEntriesStrings, functionNamesStrings]⤶⤶  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    if !menuEntriesStrings? ⤶      menuEntriesStrings = []⤶      functionNamesStrings = []⤶    menuEntriesStrings.push ＂width＂, ＂height＂, ＂alpha 0-100＂, ＂padding＂, ＂padding top＂, ＂padding bottom＂, ＂padding left＂, ＂padding right＂⤶    functionNamesStrings.push ＂rawSetWidth＂, ＂rawSetHeight＂, ＂setAlphaScaled＂, ＂setPadding＂, ＂setPaddingTop＂, ＂setPaddingBottom＂, ＂setPaddingLeft＂, ＂setPaddingRight＂⤶⤶    if @addShapeSpecificNumericalSetters?⤶      [menuEntriesStrings, functionNamesStrings] = @addShapeSpecificNumericalSetters menuEntriesStrings, functionNamesStrings⤶⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  allSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    if !menuEntriesStrings? ⤶      menuEntriesStrings = []⤶      functionNamesStrings = []⤶⤶    [menuEntriesStrings, functionNamesStrings] = @colorSetters menuEntriesStrings, functionNamesStrings⤶    [menuEntriesStrings, functionNamesStrings] = @stringSetters menuEntriesStrings, functionNamesStrings⤶    [menuEntriesStrings, functionNamesStrings] = @numericalSetters menuEntriesStrings, functionNamesStrings⤶⤶    # already sorted and deduplicated by the last of the calls above⤶    return [menuEntriesStrings, functionNamesStrings]⤶  ⤶  # Widget entry field tabbing //////////////////////////////////////////////⤶  ⤶  allEntryFields: ->⤶    @collectAllChildrenBottomToTopSuchThat (each) ->⤶      each.isEditable and⤶      (each instanceof StringMorph or⤶        each instanceof StringMorph2 or⤶        each instanceof TextMorph or⤶        each instanceof SimplePlainTextWdgt⤶        )⤶  ⤶  ⤶  nextEntryField: (current) ->⤶    fields = @allEntryFields()⤶    idx = fields.indexOf current⤶    if idx isnt -1⤶      if fields.length > (idx + 1)⤶        return fields[idx + 1]⤶    return fields[0]⤶  ⤶  previousEntryField: (current) ->⤶    fields = @allEntryFields()⤶    idx = fields.indexOf current⤶    if idx isnt -1⤶      if idx > 0⤶        return fields[idx - 1]⤶      return fields[fields.length - 1]⤶    return fields[0]⤶  ⤶  tab: (editField) ->⤶    #⤶    #	the <tab> key was pressed in one of my edit fields.⤶    #	invoke my ＂nextTab()＂ function if it exists, else⤶    #	propagate it up my owner chain.⤶    #⤶    if @nextTab⤶      @nextTab editField⤶    else @parent.tab editField  if @parent⤶  ⤶  backTab: (editField) ->⤶    #⤶    #	the <back tab> key was pressed in one of my edit fields.⤶    #	invoke my ＂previousTab()＂ function if it exists, else⤶    #	propagate it up my owner chain.⤶    #⤶    if @previousTab⤶      @previousTab editField⤶    else @parent.backTab editField  if @parent⤶  ⤶  ⤶  #⤶  #	the following are examples of what the navigation methods should⤶  #	look like. Insert these at the World level for fallback, and at lower⤶  #	levels in the Widgetic tree (e.g. dialog boxes) for a more fine-grained⤶  #	control over the tabbing cycle.⤶  #⤶  # Widget::nextTab = function (editField) {⤶  #	var	next = this.nextEntryField(editField);⤶  #	editField.clearSelection();⤶  #	next.selectAll();⤶  #	next.edit();⤶  #};⤶  #⤶  # Widget::previousTab = function (editField) {⤶  #	var	prev = this.previousEntryField(editField);⤶  #	editField.clearSelection();⤶  #	prev.selectAll();⤶  #	prev.edit();⤶  #};⤶  #⤶  #⤶  ⤶  # Widget events --------------------------------------------⤶⤶  # TODO I'm sure there is a cleaner way to handle arbitrary⤶  # number of arguments here⤶  escalateEvent: (functionName, arg1, arg2, arg3, arg4, arg5, arg6) ->⤶    handler = @parent⤶    if handler?⤶      handler = handler.parent  while not handler[functionName] and handler.parent?⤶      handler[functionName] arg1, arg2, arg3, arg4, arg5, arg6  if handler[functionName]⤶  ⤶  ⤶  # Widget eval. Used by the Inspector and the TextMorph.⤶  evaluateString: (codeSource) ->⤶    result = eval compileFGCode codeSource, true⤶    @reLayout()⤶    @changed()⤶  ⤶  ⤶  # Widget collision detection - not used anywhere at the moment ////////////////////////⤶  ⤶  isTouching: (otherMorph) ->⤶    oImg = @overlappingImage otherMorph⤶    data = oImg.getContext(＂2d＂).getImageData(1, 1, oImg.width, oImg.height).data⤶    detect(data, (each) ->⤶      each isnt 0⤶    )?⤶  ⤶  overlappingImage: (otherMorph) ->⤶    fb = @fullBounds()⤶    otherFb = otherMorph.fullBounds()⤶    oRect = fb.intersect(otherFb)⤶    oImg = newCanvas oRect.extent().scaleBy ceilPixelRatio⤶    ctx = oImg.getContext ＂2d＂⤶    ctx.scale ceilPixelRatio, ceilPixelRatio⤶    if oRect.width() < 1 or oRect.height() < 1⤶      return newCanvas (new Point 1, 1).scaleBy ceilPixelRatio⤶    ctx.drawImage @fullImage(),⤶      Math.round(oRect.origin.x - fb.origin.x),⤶      Math.round(oRect.origin.y - fb.origin.y)⤶    ctx.globalCompositeOperation = ＂source-in＂⤶    ctx.drawImage otherMorph.fullImage(),⤶      Math.round(otherFb.origin.x - oRect.origin.x),⤶      Math.round(otherFb.origin.y - oRect.origin.y)⤶    oImg⤶⤶⤶  # ------------------------------------------------------------------------------------⤶  # Layouts⤶  # ------------------------------------------------------------------------------------⤶  # So layouts in Fizzygum work the following way:⤶  #  1) Any Widget can contain a number of other morphs⤶  #     according to a number of layouts *simultaneously*⤶  #     e.g. you can have two morphs being horizontally stacked⤶  #     and two other morphs being inset for example⤶  #  2) There is no need for an explicit special container. Any⤶  #     Widget can be a container when needed.⤶  #  3) The default attaching of Widgets to a Widget puts them⤶  #     under the effect of the most basic layout: the FREEFLOATING⤶  #     layout.⤶  #  3) A user can only do a high-level resize or move to a FREEFLOATING⤶  #     Widget. All other Widgets are under the effect of more complex⤶  #     layout strategies so they can't be moved willy nilly⤶  #     directly by the user via some high-level ＂resize＂ or ＂move＂⤶  #     Control of size and placement can be done, but indirectly via other⤶  #     means below.⤶  #  4) You CAN control the size and location of Widgets under the⤶  #     effect of complex layouts, but only indirectly: by programmatically⤶  #     changing their layout spec properties.⤶  #  5) You CAN also manually control the size and location of Widgets⤶  #     under the effect of complex layouts by using special Adjusting⤶  #     Widgets, which are provided by the container, and give handles⤶  #     to manually control the content. These manual controls⤶  #     under the courtains go and programmatically modify the layout⤶  #     spec properties of the content.⤶⤶⤶  minWidth: 10⤶  desiredWidth: 20⤶  maxWidth: 100⤶⤶  minHeight: 10⤶  desiredHeight: 20⤶  maxHeight: 100⤶⤶⤶⤶  invalidateLayout: ->⤶    if @layoutIsValid⤶      window.morphsThatMaybeChangedLayout.push @⤶    @layoutIsValid = false⤶    if @layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING and @parent?⤶      @parent.invalidateLayout()⤶⤶⤶⤶  # it's useful to know when a morph defers its layout⤶  # because it means that its current size is indicative⤶  # (particularly the children's sizes and position)⤶  implementsDeferredLayout: ->⤶    @doLayout != Widget::doLayout⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts⤶    #  debugger⤶⤶    if !newBoundsForThisLayout?⤶      if @desiredExtent?⤶        newBoundsForThisLayout = @desiredExtent⤶        @desiredExtent = nil⤶      else⤶        newBoundsForThisLayout = @extent()⤶⤶      if @desiredPosition?⤶        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout⤶        @desiredPosition = nil⤶      else⤶        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout⤶⤶    if @isCollapsed()⤶      @layoutIsValid = true⤶      @notifyChildrenThatParentHasReLayouted()⤶      return⤶⤶    #if (@ instanceof LayoutableMorph) and (newBoundsForThisLayout.eq @boundingBox())⤶    #  debugger⤶⤶    # freefloating layouts never need⤶    # adjusting. We marked the @layoutIsValid⤶    # to false because it's an important breadcrumb⤶    # for finding the morphs that actually have a⤶    # layout to be recalculated but this Widget⤶    # now needs to do nothing.⤶    #if @layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING⤶    #  @layoutIsValid = true⤶    #  return⤶    ⤶    # todo should we do a fullChanged here?⤶    # rather than breaking what could be many⤶    # rectangles?⤶⤶    # the fullRawMoveTo makes sure that all children⤶    # that are float-attached move together with the⤶    # morph.⤶    @fullRawMoveTo newBoundsForThisLayout.origin⤶    ⤶    # bad kludge here but I think there will be more⤶    # of these as we move over to the new layouts, we'll⤶    # probably have split Widgets for the new layouts mechanism⤶    if (@ instanceof TextMorph) or (@ instanceof SimplePlainTextWdgt)⤶      @rawSetBounds newBoundsForThisLayout⤶    else⤶      @rawSetExtent newBoundsForThisLayout.extent()⤶⤶⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶⤶⤶⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");