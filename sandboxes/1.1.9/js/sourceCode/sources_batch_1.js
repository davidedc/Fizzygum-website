

window.SimplePlainTextScrollPanelWdgt_coffeSource = "# this comment below is needed to figure out dependencies between classes⤶# REQUIRES globalFunctions⤶⤶# The SimplePlainTextScrollPanelWdgt allows you show/edit ONE⤶# text blurb only.⤶# It doesn't allow you to view/edit multiple text blurbs or⤶# other Widgets like the SimpleVerticalStackPanelWdgt/DocumentViewerOrEditor do.⤶#⤶# However, what the SimplePlainTextScrollPanelWdgt DOES⤶# in respect to the SimpleVerticalStackPanelWdgt/DocumentViewerOrEditor is to⤶# view/edit UNWRAPPED text, which is quite important for⤶# code, since really code must have the option of an⤶# unwrapped view.⤶⤶class SimplePlainTextScrollPanelWdgt extends ScrollPanelWdgt⤶⤶  textWdgt: nil⤶  modifiedTextTriangleAnnotation: nil⤶  widgetToBeNotifiedOfTextModificationChange: nil⤶⤶  constructor: (⤶    textAsString,⤶    wraps,⤶    padding⤶    ) ->⤶⤶    super()⤶    @takesOverAndCoalescesChildrensMenus = true⤶    @disableDrops()⤶    @contents.disableDrops()⤶    @isTextLineWrapping = wraps⤶    @color = new Color 255, 255, 255⤶    @textWdgt = new SimplePlainTextWdgt(⤶      textAsString,nil,nil,nil,nil,nil,new Color(230, 230, 130), 1)⤶    @textWdgt.isEditable = true⤶    if !wraps⤶      @textWdgt.maxTextWidth = 0⤶    @textWdgt.enableSelecting()⤶    @setContents @textWdgt, padding⤶    @textWdgt.lockToPanels()⤶    ⤶⤶  colloquialName: ->⤶    return ＂text＂⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    @layoutSpecDetails = new WindowContentLayoutSpec PreferredSize.DONT_MIND , PreferredSize.DONT_MIND, 1⤶⤶  checkIfTextContentWasModifiedFromTextAtStart: ->⤶    @textWdgt.checkIfTextContentWasModifiedFromTextAtStart()⤶⤶  addModifiedContentIndicator: ->⤶    @modifiedTextTriangleAnnotation = new ModifiedTextTriangleAnnotationWdgt @⤶    @textWdgt.widgetToBeNotifiedOfTextModificationChange = @⤶⤶    # just because we add the modified content indicator it⤶    # doesn't mean that we automatically ＂save＂ the content,⤶    # so removing this.⤶    # @textWdgt.considerCurrentTextAsReferenceText()⤶⤶    @textWdgt.checkIfTextContentWasModifiedFromTextAtStart()⤶⤶  textContentModified: ->⤶    @modifiedTextTriangleAnnotation?.show()⤶    @widgetToBeNotifiedOfTextModificationChange?.textContentModified()⤶⤶  textContentUnmodified: ->⤶    @modifiedTextTriangleAnnotation?.hide()⤶    @widgetToBeNotifiedOfTextModificationChange?.textContentUnmodified()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimplePlainTextWdgt_coffeSource = "# REQUIRES ControllerMixin⤶⤶# A multi-line, optionally word-wrapping string.⤶# It's not ＂contained＂: it will literally blurt itself out allover the⤶# screen. For ＂contained＂ text (the only practical solution for long⤶# text) use the SimplePlainTextWdgtScrollPanelWdgt, since that⤶# one... scrolls.⤶#⤶# SimplePlainTextWdgt is a compatibility layer that lets us use the new⤶# TextMorph2 with the current ScrollPanelWdgt and the current layout mechanism (which⤶# we'd want to change with a more generic one but it's a complex process).⤶#⤶# This Widget can do stuff that the TextMorph2 is not quite ready to do (i.e. can⤶# adjust its vertical size to fit its contents in the given width, which is what⤶# ＂normal＂ text editing looks like.⤶#⤶# TextMorph2 could also be used to do that, but it could do that within a larger⤶# layout rework that has not been done yet. Note that TextMorph2 can do a bunch more⤶# stuff (e.g. lets you edit in ＂centered＂ text, can fit the text to any given⤶# bound etc...)⤶⤶class SimplePlainTextWdgt extends TextMorph2⤶⤶  @augmentWith ControllerMixin⤶⤶  constructor: (⤶   @text = ＂SimplePlainText＂,⤶   @originallySetFontSize = 12,⤶   @fontName = @justArialFontStack,⤶   @isBold = false,⤶   @isItalic = false,⤶   #@isNumeric = false,⤶   @color = (new Color 0, 0, 0),⤶   @backgroundColor = nil,⤶   @backgroundTransparency = nil⤶   ) ->⤶⤶    super⤶    @silentRawSetBounds new Rectangle 0,0,400,40⤶    @fittingSpecWhenBoundsTooLarge = FittingSpecTextInLargerBounds.FLOAT⤶    @fittingSpecWhenBoundsTooSmall = FittingSpecTextInSmallerBounds.SCALEDOWN⤶    @maxTextWidth = true⤶    @reLayout()⤶⤶⤶  colloquialName: ->⤶    ＂text＂⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    super⤶    @layoutSpecDetails.canSetHeightFreely = false⤶⤶  openTargetPropertySelector: (ignored, ignored2, theTarget) ->⤶    [menuEntriesStrings, functionNamesStrings] = theTarget.stringSetters()⤶    menu = new MenuMorph @, false, @, true, true, ＂choose target property:＂⤶    for i in [0...menuEntriesStrings.length]⤶      menu.addMenuItem menuEntriesStrings[i], true, @, ＂setTargetAndActionWithOnesPickedFromMenu＂, nil, nil, nil, nil, nil, theTarget, functionNamesStrings[i]⤶    if menuEntriesStrings.length == 0⤶      menu = new MenuMorph @, false, @, true, true, ＂no target properties available＂⤶    menu.popUpAtHand()⤶⤶  stringSetters: (menuEntriesStrings, functionNamesStrings) ->⤶    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings⤶    menuEntriesStrings.push ＂bang!＂, ＂text＂⤶    functionNamesStrings.push ＂bang＂, ＂setText＂⤶    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings⤶⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    menu.removeMenuItem ＂soft wrap＂⤶    menu.removeMenuItem ＂soft wrap＂.tick()⤶    menu.removeMenuItem ＂soft wrap＂⤶⤶    menu.removeMenuItem ＂←☓→ don't expand to fill＂⤶    menu.removeMenuItem ＂←→ expand to fill＂⤶    menu.removeMenuItem ＂→← shrink to fit＂⤶    menu.removeMenuItem ＂→⋯← crop to fit＂⤶⤶    menu.removeMenuItem ＂header line＂⤶    menu.removeMenuItem ＂no header line＂⤶⤶    menu.removeMenuItem ＂↑ align top＂⤶    menu.removeMenuItem ＂⍿ align middle＂⤶    menu.removeMenuItem ＂↓ align bottom＂⤶⤶    menu.addLine()⤶    if world.isIndexPage⤶      menu.addMenuItem ＂connect to ➜＂, true, @, ＂openTargetSelector＂, ＂connect to⧹nanother widget＂⤶    else⤶      menu.addMenuItem ＂set target＂, true, @, ＂openTargetSelector＂, ＂choose another morph⧹nwhose numerical property⧹n will be＂ + ＂ controlled by this one＂⤶⤶    if @amIDirectlyInsideScrollPanelWdgt()⤶      childrenNotCarets = @parent.children.filter (m) ->⤶        !(m instanceof CaretMorph)⤶      if childrenNotCarets.length == 1⤶        menu.addLine()⤶        if @parent.parent.isTextLineWrapping⤶          menu.addMenuItem ＂☒ soft wrap＂, true, @, ＂softWrapOff＂⤶        else⤶          menu.addMenuItem ＂☐ soft wrap＂, true, @, ＂softWrapOn＂⤶⤶    menu.removeConsecutiveLines()⤶⤶⤶  softWrapOn: ->⤶    @parent.parent.isTextLineWrapping = true⤶    @maxTextWidth = true⤶⤶    @parent.fullRawMoveTo @parent.parent.position()⤶    @parent.rawSetExtent @parent.parent.extent()⤶    @refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  softWrapOff: ->⤶    @parent.parent.isTextLineWrapping = false⤶    @maxTextWidth = nil⤶⤶    @reLayout()⤶⤶    @refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  # the bang makes the node fire the current output value⤶  bang: (newvalue, ignored, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken⤶    @updateTarget()⤶⤶  # This is also invoked for example when you take a slider⤶  # and set it to target this.⤶  setText: (theTextContent, stringFieldMorph, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken⤶    super theTextContent, stringFieldMorph, connectionsCalculationToken, true⤶    @reLayout()⤶    @refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶    @updateTarget()⤶⤶  updateTarget: ->⤶    if @action and @action != ＂＂⤶      @target[@action].call @target, @text, nil, @connectionsCalculationToken⤶    return⤶⤶  reactToTargetConnection: ->⤶    @updateTarget()⤶⤶  toggleShowBlanks: ->⤶    super⤶    @reLayout()⤶    @refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶  ⤶  toggleWeight: ->⤶    super⤶    @reLayout()⤶    @refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶  ⤶  toggleItalic: ->⤶    super⤶    @reLayout()⤶    @refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  toggleIsPassword: ->⤶    super⤶    @reLayout()⤶    @refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  rawSetExtent: (aPoint) ->⤶    super⤶    @reLayout()⤶⤶  setFontSize: (sizeOrMorphGivingSize, morphGivingSize) ->⤶    super⤶    @reLayout()⤶    @refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  setFontName: (ignored1, ignored2, theNewFontName) ->⤶    super⤶    @reLayout()⤶    @refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  blendInWithPanelColor: ->⤶    if @backgroundColor.eq WorldMorph.preferencesAndSettings.editableItemBackgroundColor⤶      @setBackgroundColor new Color 249, 249, 249⤶⤶  contrastOutFromPanelColor: ->⤶    if @backgroundColor.eq new Color 249, 249, 249⤶      @setBackgroundColor WorldMorph.preferencesAndSettings.editableItemBackgroundColor⤶⤶  reLayout: ->⤶    super()⤶⤶    if @maxTextWidth? and @maxTextWidth != 0⤶      @softWrap = true⤶      [@wrappedLines,@wrappedLineSlots,@widthOfPossiblyCroppedText,@heightOfPossiblyCroppedText] =⤶        @breakTextIntoLines @text, @originallySetFontSize, @extent()⤶      width = @width()⤶    else⤶      @softWrap = false⤶      veryWideExtent = new Point 10000000, 10000000⤶      [@wrappedLines,@wrappedLineSlots,@widthOfPossiblyCroppedText,@heightOfPossiblyCroppedText] =⤶        @breakTextIntoLines @text, @originallySetFontSize, veryWideExtent⤶      width = @widthOfPossiblyCroppedText⤶⤶    height = @wrappedLines.length *  Math.ceil fontHeight @originallySetFontSize⤶    @silentRawSetExtent new Point width, height⤶⤶    @changed()⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleRectangularButtonMorph_coffeSource = "# sends a message to a target object when pressed.⤶# takes a rectangular shape, and can host⤶# a morph to be used as ＂face＂⤶⤶class SimpleRectangularButtonMorph extends EmptyButtonMorph⤶⤶  constructor: (⤶      @ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked = true,⤶      @target = nil,⤶      @action = nil,⤶⤶      @faceMorph = nil,⤶⤶      @dataSourceMorphForTarget = nil,⤶      @morphEnv,⤶      @toolTipMessage = nil,⤶⤶      @doubleClickAction = nil,⤶      @argumentToAction1 = nil,⤶      @argumentToAction2 = nil,⤶      @representsAMorph = false⤶      ) ->⤶⤶    # additional properties:⤶⤶    super⤶⤶    @appearance = new RectangularAppearance @⤶    @strokeColor = new Color 196,195,196⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleVerticalStackPanelWdgt_coffeSource = "# REQUIRES ClippingAtRectangularBoundsMixin⤶⤶⤶class SimpleVerticalStackPanelWdgt extends Widget⤶⤶  # stacks don't necessarily enforce a width on contents⤶  # so the contents could stick out, so we clip at the bounds⤶  @augmentWith ClippingAtRectangularBoundsMixin, @name⤶⤶  _acceptsDrops: true⤶  tight: true⤶  constrainContentWidth: true⤶  # used to avoid recursively re-entering the⤶  # adjustContentsBounds function⤶  _adjustingContentsBounds: false⤶⤶  colloquialName: ->⤶    ＂stack＂⤶⤶  add: (aWdgt, position = nil, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING, beingDropped, unused, positionOnScreen) ->⤶    aWdgt.rawResizeToWithoutSpacing()⤶⤶    # find out WHERE to add the widget. Find the existing widget in the⤶    # stack that is at the same height, and put the new⤶    # widget after it⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶    # The vertical stack just lays down⤶    # the children in the exact sibling order, so all we have to do⤶    # is to count up to the child at the same height, say it's⤶    # child ＂n＂, then are going to add the new widget in position⤶    # ＂n+1＂.⤶    # (conveniently, ＂add＂ supports an argument to insert a widget⤶    # in a specific order among the siblings.)⤶    positionNumberAmongSiblings = nil⤶    if (childrenNotHandlesNorCarets.length > 0) and (positionOnScreen instanceof Point)⤶      positionNumberAmongSiblings = 0⤶      for w in childrenNotHandlesNorCarets⤶        positionNumberAmongSiblings++⤶        if w.top() < positionOnScreen.y and w.bottom() > positionOnScreen.y⤶          break⤶⤶    if positionNumberAmongSiblings?⤶      super aWdgt, positionNumberAmongSiblings, layoutSpec, beingDropped⤶    else⤶      super⤶⤶  constructor: (extent, color, @padding, @constrainContentWidth = true) ->⤶    super()⤶    @appearance = new RectangularAppearance @⤶    @silentRawSetExtent(extent) if extent?⤶    @color = color if color?⤶⤶  childRemoved: ->⤶    if @amIPanelOfScrollPanelWdgt()⤶      @parent.adjustContentsBounds()⤶      @parent.adjustScrollBars()⤶      return⤶    @adjustContentsBounds()⤶⤶  reactToDropOf: ->⤶    if @amIPanelOfScrollPanelWdgt()⤶      @parent.adjustContentsBounds()⤶      @parent.adjustScrollBars()⤶      return⤶    @adjustContentsBounds()⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    super⤶    @layoutSpecDetails.canSetHeightFreely = false⤶⤶  availableWidthForContents: ->⤶    @width() - 2 * @padding⤶⤶  adjustContentsBounds: ->⤶    # avoid recursively re-entering this function⤶    if @_adjustingContentsBounds then return else @_adjustingContentsBounds = true⤶    @padding = 5⤶⤶    stackHeight = 0⤶    verticalPadding = 0⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶    childrenNotHandlesNorCarets.forEach (morph) =>⤶      if morph.layoutSpec != LayoutSpec.ATTACHEDAS_VERTICAL_STACK_ELEMENT⤶        morph.initialiseDefaultVerticalStackLayoutSpec()⤶        morph.layoutSpecDetails.rememberInitialDimensions morph, @⤶        morph.setLayoutSpec LayoutSpec.ATTACHEDAS_VERTICAL_STACK_ELEMENT⤶⤶    childrenNotHandlesNorCarets.forEach (morph) =>⤶      verticalPadding += @padding⤶⤶      if !@constrainContentWidth⤶        # if the stack doesn't contrain the positions of the⤶        # contents then it's much harder to right/left/center align⤶        # things, because for example imagine this case: you⤶        # remove an element from the stack. Now, something that was⤶        # centered ends up defining the new bounds of the Stack.⤶        # But hey, that shouldn't have happened because that element⤶        # was centered, so it could not possibly define the bounds...⤶        # So the determination of the bounds becomes rather more⤶        # complex, we are skipping that for the time being: if a stack⤶        # doesn't contrain the widths of the contents then everything in⤶        # it looks left-aligned⤶        leftPosition = @left() + @padding⤶      else⤶        recommendedElementWidth = morph.layoutSpecDetails.getWidthInStack()⤶⤶        # this re-layouts each widget to fit the width.⤶        morph.rawSetWidthSizeHeightAccordingly recommendedElementWidth⤶⤶        # the SimplePlainTextWdgt just needs this to be different from null⤶        # while the TextMorph actually uses this number⤶        if (morph instanceof TextMorph) or (morph instanceof SimplePlainTextWdgt)⤶          morph.maxTextWidth = recommendedElementWidth⤶⤶        if morph.layoutSpecDetails.alignment == 'right'⤶          leftPosition = @left() + @width() - @padding - recommendedElementWidth⤶        else if morph.layoutSpecDetails.alignment == 'center'⤶          leftPosition = @left() + Math.floor (@width() - recommendedElementWidth) / 2⤶        else⤶          # we hope here that  morph.layoutSpecDetails.alignment == 'left'⤶          leftPosition = @left() + @padding⤶⤶⤶      morph.fullRawMoveTo new Point leftPosition, @top() + verticalPadding + stackHeight⤶      stackHeight += morph.height()⤶⤶    newHeight = stackHeight + verticalPadding + @padding⤶⤶    if !@tight or childrenNotHandlesNorCarets.length == 0⤶      newHeight = Math.max newHeight, @height()⤶⤶    @rawSetHeight newHeight⤶    @_adjustingContentsBounds = false⤶⤶  rawSetExtent: (aPoint) ->⤶    unless aPoint.eq @extent()⤶      #console.log ＂move 15＂⤶      @breakNumberOfRawMovesAndResizesCaches()⤶      super aPoint⤶      @adjustContentsBounds()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleVerticalStackScrollPanelWdgt_coffeSource = "# this comment below is needed to figure out dependencies between classes⤶# REQUIRES globalFunctions⤶⤶class SimpleVerticalStackScrollPanelWdgt extends ScrollPanelWdgt⤶⤶  constructor: (@isTextLineWrapping = true) ->⤶    VS = new SimpleVerticalStackPanelWdgt⤶⤶    if !@isTextLineWrapping⤶      VS.constrainContentWidth = false⤶⤶    VS.tight = false⤶    VS.isLockingToPanels = true⤶    super VS⤶    @disableDrops()⤶⤶    ostmA = new SimplePlainTextWdgt(⤶      ＂A small string⧹n⧹n⧹nhere another.＂,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1)⤶    ostmA.isEditable = true⤶    ostmA.enableSelecting()⤶    @setContents ostmA, 5⤶    @setColor new Color 249, 249, 249⤶⤶  colloquialName: ->⤶    ＂stack＂⤶⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶    menu.removeMenuItem ＂move all inside＂⤶⤶    if @contents?⤶      childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets @contents⤶⤶    if childrenNotHandlesNorCarets? and childrenNotHandlesNorCarets.length > 0⤶      menu.addLine()⤶      if !@dragsDropsAndEditingEnabled⤶        menu.addMenuItem ＂enable editing＂, true, @, ＂enableDragsDropsAndEditing＂, ＂lets you drag content in and out＂⤶      else⤶        menu.addMenuItem ＂disable editing＂, true, @, ＂disableDragsDropsAndEditing＂, ＂prevents dragging content in and out＂⤶⤶    menu.removeConsecutiveLines()⤶⤶  enableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if @dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilYellow?()⤶    if @parent? and @parent != triggeringWidget and @parent instanceof SimpleDocumentWdgt⤶      @parent.enableDragsDropsAndEditing @⤶    else⤶      super @⤶⤶  disableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if !@dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilClear?()⤶    if @parent? and @parent != triggeringWidget and @parent instanceof SimpleDocumentWdgt⤶      @parent.disableDragsDropsAndEditing @⤶    else⤶      super @".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SimpleVideoLinkWdgt_coffeSource = "class SimpleVideoLinkWdgt extends SimpleLinkWdgt⤶⤶  constructor: (@descriptionString, @linkString = ＂https://goo.gl/9xZrmG＂) ->⤶    super @descriptionString, @linkString⤶⤶  createLinkIcon: ->⤶    @externalLinkIcon = new VideoPlayButtonWdgt⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SpeechBubbleWdgt_coffeSource = "# the speech bubble is similar to the Tooltip,⤶# however it's more like the callouts of some⤶# famous presentation software: you drop them⤶# somewhere and you type text in them. If you resize⤶# them, the text inside them is resized too.⤶# They don't pop up within a certain time.⤶⤶class SpeechBubbleWdgt extends Widget⤶⤶  contents: nil⤶  padding: nil # additional vertical pixels⤶  morphInvokingThis: nil⤶⤶  constructor: (@contents=＂hello＂) ->⤶    # console.log ＂bubble super＂⤶    super()⤶    @color = WorldMorph.preferencesAndSettings.menuBackgroundColor⤶    @padding = 0⤶    @strokeColor = WorldMorph.preferencesAndSettings.menuStrokeColor⤶    @cornerRadius = 6⤶    @appearance = new BubblyAppearance @⤶    @toolTipMessage = ＂speech bubble＂⤶    @buildAndConnectChildren()⤶    @minimumExtent = new Point 10,10⤶    @extentToGetWhenDraggedFromGlassBox = new Point 105,80⤶⤶    # console.log @color⤶⤶  colloquialName: ->⤶    ＂speech bubble＂⤶  ⤶  buildAndConnectChildren: ->⤶    @contentsMorph = new TextMorph2(⤶      @contents,⤶      WorldMorph.preferencesAndSettings.bubbleHelpFontSize,⤶      nil,⤶      false,⤶      true,⤶      ＂center＂)⤶⤶    @contentsMorph.fittingSpecWhenBoundsTooLarge = FittingSpecTextInLargerBounds.SCALEUP⤶    @contentsMorph.fittingSpecWhenBoundsTooSmall = FittingSpecTextInSmallerBounds.SCALEDOWN⤶    @contentsMorph.alignMiddle()⤶    @contentsMorph.alignCenter()⤶    @contentsMorph.isEditable = true⤶⤶⤶    @add @contentsMorph⤶    @invalidateLayout()⤶⤶  rawSetExtent: (aPoint) ->⤶    super⤶    @doLayout @bounds⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶⤶    #if !window.recalculatingLayouts⤶    #  debugger⤶⤶    if !newBoundsForThisLayout?⤶      if @desiredExtent?⤶        newBoundsForThisLayout = @desiredExtent⤶        @desiredExtent = nil⤶      else⤶        newBoundsForThisLayout = @extent()⤶⤶      if @desiredPosition?⤶        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout⤶        @desiredPosition = nil⤶      else⤶        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout⤶⤶    if @isCollapsed()⤶      @layoutIsValid = true⤶      @notifyChildrenThatParentHasReLayouted()⤶      return⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    # adjust my layout⤶    @silentRawSetWidth newBoundsForThisLayout.width()⤶    @silentRawSetHeight newBoundsForThisLayout.height()⤶⤶    @contentsMorph.rawSetWidth newBoundsForThisLayout.width() - (2 * @cornerRadius)⤶    @contentsMorph.rawSetHeight newBoundsForThisLayout.height() - (2 * @cornerRadius) - newBoundsForThisLayout.height()/5⤶⤶⤶    # position my contents⤶    @contentsMorph.fullRawMoveTo @position().add(⤶      new Point(@padding + @cornerRadius, @padding + @cornerRadius))⤶⤶    trackChanges.pop()⤶    @fullChanged()⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.StretchableCanvasWdgt_coffeSource = "# The difference between this and a Canvas is that once the⤶# user starts to paint on the StretchableCanvas, it locks the⤶# aspect ratio... and any further resizing keeps the original⤶# paiting and the user can keep painting at any new scale...⤶#⤶# This is achieved by keeping an extra canvas behind the scenes⤶# that keeps the original resolution of when the first paint⤶# action happened. The user keeps painting on that ＂behind⤶# the scenes canvas＂ with the original resolution, no matter⤶# what the scale of the ＂front facing＂ canvas is on screen.⤶# So any time the user resizes the front canvas or she paints⤶# on the ＂behind the scenes＂, the ＂behind the scenes＂⤶# is painted on the front one at the correct scale.⤶#⤶# Note that since the ＂behind the scenes＂ canvas⤶# keeps the same size... if the user starts painting⤶# when the size is small... then enlarging the canvas⤶# will just cause the smaller ＂behind the scenes＂ canvas⤶# to be painted on the smaller ＂front facing＂ canvas...⤶# so everything new will be painted blurry.⤶#⤶# You could enhance this so that if the user scales up⤶# the canvas, then the ＂behind the scenes＂ is also⤶# resized-up (previous content will be blurry but new⤶# content will be sharp).⤶⤶class StretchableCanvasWdgt extends CanvasMorph⤶⤶  anythingPaintedYet: false⤶  extentWhenCanvasGotDirty: nil⤶⤶  behindTheScenesBackBuffer: nil⤶  behindTheScenesBackBufferContext: nil⤶⤶⤶  # No changes of position or extent should be⤶  # performed in here.⤶  # There is really little hope to cache this buffer⤶  # cross-morph, unless you key the buffer with the⤶  # order of all the primitives and their⤶  # parameters. So if user wants a cache it will have to specify⤶  # a dedicated one in here. See textMorph for an example.⤶  createRefreshOrGetBackBuffer: ->⤶⤶    extent = @extent()⤶⤶    if !@backBuffer?⤶      @createNewFrontFacingBuffer extent⤶⤶    # little shortcut: if nothing has been painted yet then⤶    # we can omit painting the big canvas on the small one,⤶    # just clean up the small canvas⤶    if !@anythingPaintedYet and @color?⤶      @backBufferContext.fillStyle = @color.toString()⤶      @backBufferContext.fillRect 0, 0, extent.x * ceilPixelRatio, extent.y * ceilPixelRatio⤶⤶    # if something *has* been painted then⤶    # we need to paint the ＂behind the scenes＂ buffer into the⤶    # one we show on screen⤶    if @anythingPaintedYet⤶      @backBufferContext.setTransform 1, 0, 0, 1, 0, 0⤶      @backBufferContext.scale @width()/@extentWhenCanvasGotDirty.x, @height()/@extentWhenCanvasGotDirty.y⤶      @backBufferContext.drawImage @behindTheScenesBackBuffer, 0, 0⤶⤶    ⤶    # we leave the context with the correct pixel scaling.⤶    # ALWAYS leave the context with the correct pixel scaling.⤶    @backBufferContext.scale ceilPixelRatio, ceilPixelRatio⤶    return [@backBuffer, @backBufferContext]⤶⤶⤶  # don't need this at the moment, you'd need to⤶  # clear both backbuffers and invoke a @parent?.resetRatio?()⤶  # since once it's empty you can really let the user re-think⤶  # the aspect ratio of her painting⤶  clear: (color = @color) ->⤶    throw new Error ＂not implemented yet＂⤶⤶  createNewBehindTheScenesBuffer: (extent) ->⤶    @behindTheScenesBackBuffer = newCanvas extent.scaleBy ceilPixelRatio⤶    @behindTheScenesBackBufferContext = @behindTheScenesBackBuffer.getContext ＂2d＂⤶⤶    if @color?⤶      @behindTheScenesBackBufferContext.fillStyle = @color.toString()⤶      @behindTheScenesBackBufferContext.fillRect 0, 0, extent.x * ceilPixelRatio, extent.y * ceilPixelRatio⤶⤶    # we leave the context with the correct scaling.⤶    # ALWAYS leave the context with the correct pixel scaling.⤶    @behindTheScenesBackBufferContext.scale ceilPixelRatio, ceilPixelRatio⤶⤶  createNewFrontFacingBuffer: (extent) ->⤶    @backBuffer = newCanvas extent.scaleBy ceilPixelRatio⤶    @backBufferContext = @backBuffer.getContext ＂2d＂⤶⤶⤶    # we leave the context with the correct scaling.⤶    # ALWAYS leave the context with the correct pixel scaling.⤶    @backBufferContext.scale ceilPixelRatio, ceilPixelRatio⤶⤶⤶  rawSetExtent: (extent) ->⤶⤶    if extent.eq @extent()⤶      return⤶⤶    if !@behindTheScenesBackBuffer? or !@anythingPaintedYet⤶      @createNewBehindTheScenesBuffer extent⤶⤶    @createNewFrontFacingBuffer extent⤶⤶    super⤶    @doLayout @bounds⤶⤶⤶  getContextForPainting: ->⤶    # only set ratio with the first paint operation⤶    # the following ones don't change it⤶    if @parent?.setRatio? and !@parent.ratio?⤶      @parent.setRatio @width() / @height()⤶      @extentWhenCanvasGotDirty = @extent()⤶      @anythingPaintedYet = true⤶⤶    @behindTheScenesBackBufferContext.setTransform 1, 0, 0, 1, 0, 0⤶    @behindTheScenesBackBufferContext.scale ceilPixelRatio, ceilPixelRatio⤶⤶    @behindTheScenesBackBufferContext.scale @extentWhenCanvasGotDirty.x/@width(), @extentWhenCanvasGotDirty.y/@height()⤶⤶    @behindTheScenesBackBufferContext.translate -@bounds.origin.x, -@bounds.origin.y⤶    return @behindTheScenesBackBufferContext⤶⤶  # don't need this at the moment, you'd need to⤶  # paint on the ＂behind the scenes＂ backbuffer⤶  drawLine: (start, dest, lineWidth, color) ->⤶    throw new Error ＂not implemented yet＂⤶⤶  paintImage: (pos, image) ->⤶⤶    extent = @extent()⤶    if !@backBuffer?⤶      @createNewFrontFacingBuffer extent⤶⤶    if !@behindTheScenesBackBuffer?⤶      @createNewBehindTheScenesBuffer extent⤶⤶    contextForPainting = @getContextForPainting()⤶⤶    # OK now this needs an explanation: in a hi-dpi display we get⤶    # a widget image that is 2x the logical size.⤶    # BUT the position is indicated by the mouse which works in logical⤶    # coordinates.⤶    # SO we need to keep the positioning correctly scaled at 2x⤶    # BUT draw on the canvas at 1x⤶    # SO here we undo the 2x scaling, re-introduce it manually only⤶    # for the positioning, then draw.⤶    # Note that there could be another way, i.e. to pass the other arguments⤶    # to ＂drawImage＂ to specify the bounding box.⤶⤶    @behindTheScenesBackBufferContext.scale 1/ceilPixelRatio, 1/ceilPixelRatio⤶    contextForPainting.drawImage image, pos.x * ceilPixelRatio, pos.y * ceilPixelRatio⤶⤶    # put back the scaling so it's right again.⤶    # (always leave the scaling correct)⤶    # TODO: you could use a save() / restore() here to avoid⤶    # the anti-scaling followed by re-scaling introducing any artifacts⤶    # due to rounding errors⤶    @behindTheScenesBackBufferContext.scale ceilPixelRatio, ceilPixelRatio⤶⤶  reactToDropOf: (droppedWidget) ->⤶    @paintImage droppedWidget.position(), droppedWidget.fullImage(nil, false, true)⤶    world.add droppedWidget, nil, nil, true⤶  ⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts⤶    #  debugger⤶⤶    if !newBoundsForThisLayout?⤶      if @desiredExtent?⤶        newBoundsForThisLayout = @desiredExtent⤶        @desiredExtent = nil⤶      else⤶        newBoundsForThisLayout = @extent()⤶⤶      if @desiredPosition?⤶        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout⤶        @desiredPosition = nil⤶      else⤶        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout⤶⤶    if @isCollapsed()⤶      @layoutIsValid = true⤶      @notifyChildrenThatParentHasReLayouted()⤶      return⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    @rawSetBounds newBoundsForThisLayout⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶    for w in childrenNotHandlesNorCarets⤶      w.rawSetBounds @bounds⤶⤶⤶    trackChanges.pop()⤶    @fullChanged()⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.StretchableEditableWdgt_coffeSource = "# REQUIRES KeepsRatioWhenInVerticalStackMixin⤶⤶class StretchableEditableWdgt extends Widget⤶⤶  @augmentWith KeepsRatioWhenInVerticalStackMixin, @name⤶⤶  toolsPanel: nil⤶  stretchableWidgetContainer: nil⤶⤶  # the external padding is the space between the edges⤶  # of the container and all of its internals. The reason⤶  # you often set this to zero is because windows already put⤶  # contents inside themselves with a little padding, so this⤶  # external padding is not needed. Useful to keep it⤶  # separate and know that it's working though.⤶  externalPadding: 0⤶  # the internal padding is the space between the internal⤶  # components. It doesn't necessarily need to be equal to the⤶  # external padding⤶  internalPadding: 5⤶⤶  providesAmenitiesForEditing: true⤶⤶  constructor: ->⤶    super⤶    @buildAndConnectChildren()⤶    @invalidateLayout()⤶⤶  colloquialName: ->⤶    ＂Generic panel＂⤶⤶  representativeIcon: ->⤶    new GenericPanelIconWdgt⤶⤶⤶  createToolsPanel: ->⤶⤶  createNewStretchablePanel: ->⤶    @stretchableWidgetContainer = new StretchableWidgetContainerWdgt⤶    @add @stretchableWidgetContainer⤶⤶⤶  reLayout: ->⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    labelBottom = @top() + @externalPadding⤶⤶⤶    # stretchableWidgetContainer --------------------------⤶⤶    stretchableWidgetContainerWidth = @width() - 2*@externalPadding⤶    ⤶    stretchableWidgetContainerHeight =  @height() - 2 * @externalPadding⤶    stretchableWidgetContainerLeft = @left() + @externalPadding⤶⤶    if @stretchableWidgetContainer.parent == @⤶      @stretchableWidgetContainer.fullRawMoveTo new Point stretchableWidgetContainerLeft, labelBottom⤶      @stretchableWidgetContainer.setExtent new Point stretchableWidgetContainerWidth, stretchableWidgetContainerHeight⤶⤶    # ----------------------------------------------⤶⤶⤶    trackChanges.pop()⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶  rawSetExtent: (aPoint) ->⤶    super⤶    @reLayout()⤶⤶  hasStartingContentBeenChangedByUser: ->⤶    @stretchableWidgetContainer?.ratio?⤶⤶  closeFromContainerWindow: (containerWindow) ->⤶⤶    if !@hasStartingContentBeenChangedByUser() and !world.anyReferenceToWdgt containerWindow⤶      # there is no real contents to save⤶      containerWindow.fullDestroy()⤶    else if !world.anyReferenceToWdgt containerWindow⤶      prompt = new SaveShortcutPromptWdgt @, containerWindow⤶      prompt.popUpAtHand()⤶    else⤶      containerWindow.close()⤶⤶  editButtonPressedFromWindowBar: ->⤶    if @dragsDropsAndEditingEnabled⤶      @disableDragsDropsAndEditing @⤶    else⤶      @enableDragsDropsAndEditing @⤶⤶  constrainToRatio: ->⤶    if @layoutSpecDetails?⤶      @layoutSpecDetails.canSetHeightFreely = false⤶      # force a resize, so the slide and the window⤶      # it's in will take the right ratio, and hence⤶      # the content will take the whole window it's in.⤶      # Note that the height of 0 here is ignored since⤶      # ＂rawSetWidthSizeHeightAccordingly＂ will⤶      # calculate the height.⤶      if @stretchableWidgetContainer?.ratio?⤶        @rawSetExtent new Point @width(), 0⤶⤶  enableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if @dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilYellow?()⤶    @dragsDropsAndEditingEnabled = true⤶    @createToolsPanel()⤶    @stretchableWidgetContainer.enableDragsDropsAndEditing @⤶⤶⤶  # while in editing mode, the slide can take any dimension⤶  # and if the content has already a decided ratio then⤶  # the container will adjust the content within the given⤶  # space so that the content will keep ratio.⤶  #⤶  # However, when NOT in editing mode, then we⤶  # want the content to force the ratio of the window⤶  # it might be in, so that⤶  # 1) it takes the whole window rather than a⤶  #    a letterboxed part, so it looks neat⤶  # 2) if we drop the slide in⤶  #    a document then it will take a height proportional⤶  #    to the given width, which is what looks natural.⤶  rawSetWidthSizeHeightAccordingly: (newWidth) ->⤶    if @layoutSpecDetails?.canSetHeightFreely⤶     super⤶     return⤶⤶    if !@stretchableWidgetContainer?⤶     super⤶     return⤶⤶    if !@stretchableWidgetContainer.ratio?⤶     super⤶     return⤶⤶    @rawSetExtent new Point newWidth, Math.round(newWidth / @stretchableWidgetContainer.ratio)⤶⤶⤶  disableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if !@dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilClear?()⤶    @dragsDropsAndEditingEnabled = false⤶    if @toolsPanel?⤶      @toolsPanel.unselectAll?()⤶      @toolsPanel.destroy()⤶      @toolsPanel = nil⤶    @stretchableWidgetContainer.disableDragsDropsAndEditing @⤶    @invalidateLayout()⤶⤶  buildAndConnectChildren: ->⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶    @createNewStretchablePanel()⤶    @createToolsPanel()⤶⤶    @invalidateLayout()⤶⤶  childPickedUp: (childPickedUp) ->⤶    if childPickedUp == @stretchableWidgetContainer⤶      @createNewStretchablePanel()⤶      @invalidateLayout()⤶⤶  # same as simpledocumentscrollpanel, you can lock the contents.⤶  # worth factoring it out as a mixin?⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶    if childrenNotHandlesNorCarets? and childrenNotHandlesNorCarets.length > 0⤶      menu.addLine()⤶      if !@dragsDropsAndEditingEnabled⤶        menu.addMenuItem ＂enable editing＂, true, @, ＂enableDragsDropsAndEditing＂, ＂lets you drag content in and out＂⤶      else⤶        menu.addMenuItem ＂disable editing＂, true, @, ＂disableDragsDropsAndEditing＂, ＂prevents dragging content in and out＂⤶⤶    menu.removeConsecutiveLines()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.StretchablePanelWdgt_coffeSource = "# this is made to go inside the StretchablePanelContainer,⤶# it probably makes no sense on its own⤶⤶class StretchablePanelWdgt extends PanelWdgt⤶⤶  childRemoved: (child) ->⤶    super⤶    if @parent?.setRatio? and @parent.ratio?⤶      childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶      if childrenNotHandlesNorCarets.length == 0⤶        @parent.resetRatio()⤶⤶  childAdded: (child) ->⤶    super⤶    # only set ratio with the first added child⤶    # the following ones don't change it⤶    if @parent?.setRatio? and !@parent.ratio?⤶      childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶      if childrenNotHandlesNorCarets.length != 0⤶        @parent.setRatio @width() / @height()⤶⤶⤶  rawSetExtent: (extent) ->⤶    if extent.eq @extent()⤶      return⤶⤶    super⤶    @doLayout @bounds⤶⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts⤶    #  debugger⤶⤶    if !newBoundsForThisLayout?⤶      if @desiredExtent?⤶        newBoundsForThisLayout = @desiredExtent⤶        @desiredExtent = nil⤶      else⤶        newBoundsForThisLayout = @extent()⤶⤶      if @desiredPosition?⤶        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout⤶        @desiredPosition = nil⤶      else⤶        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout⤶⤶    if @isCollapsed()⤶      @layoutIsValid = true⤶      @notifyChildrenThatParentHasReLayouted()⤶      return⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶    for w in childrenNotHandlesNorCarets⤶      w.fullRawMoveInStretchablePanelToFractionalPosition newBoundsForThisLayout⤶      w.rawSetExtentToFractionalExtentInPaneUserHasSet newBoundsForThisLayout      ⤶⤶    @rawSetBounds newBoundsForThisLayout⤶⤶⤶⤶⤶    trackChanges.pop()⤶    @fullChanged()⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶    if childrenNotHandlesNorCarets? and childrenNotHandlesNorCarets.length > 0⤶      menu.addLine()⤶      if !@dragsDropsAndEditingEnabled⤶        menu.addMenuItem ＂enable editing＂, true, @, ＂enableDragsDropsAndEditing＂, ＂lets you drag content in and out＂⤶      else⤶        menu.addMenuItem ＂disable editing＂, true, @, ＂disableDragsDropsAndEditing＂, ＂prevents dragging content in and out＂⤶⤶    menu.removeConsecutiveLines()⤶⤶  enableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if @dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilYellow?()⤶    if @parent? and @parent != triggeringWidget and @parent instanceof StretchableWidgetContainerWdgt⤶      @parent.enableDragsDropsAndEditing @⤶    else⤶      super @⤶⤶  disableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if !@dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilClear?()⤶    if @parent? and @parent != triggeringWidget and @parent instanceof StretchableWidgetContainerWdgt⤶      @parent.disableDragsDropsAndEditing @⤶    else⤶      super @⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.StretchableWidgetContainerWdgt_coffeSource = "# REQUIRES StretchablePanelWdgt⤶⤶# We need this because we need a panel that keeps its content⤶# all in the same relative positions and sizes when its⤶# resized, so you can drag and drop it inside stacks⤶# and resizable windows and it doesn't mangle the contents⤶# when it's resized. The way to achieve that is to⤶# have a container and a type of panel that works together⤶# to ＂cristallize＂ a specific width/height ratio as soon⤶# as there is one element dropped/added in the panel.⤶# So when the panel is empty, you can give it any shape you⤶# want, but as soon as there is one element, it sticks⤶# to the ratio it has.⤶⤶class StretchableWidgetContainerWdgt extends Widget⤶⤶  ratio: nil⤶  contents: nil⤶⤶  constructor: (contents) ->⤶    super new Point 300, 300⤶    ⤶    if !contents?⤶      contents = new StretchablePanelWdgt⤶⤶    @add contents⤶    @contents = contents⤶⤶    @rawSetExtent new Point 300, 300⤶    @contents.rawSetExtent new Point @width(), @height()⤶    @invalidateLayout()⤶⤶  # actually⤶  # ends up in the Panel inside it⤶  add: (aWdgt, position = nil, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING, beingDropped) ->⤶    if !@contents? or (aWdgt instanceof ModifiedTextTriangleAnnotationWdgt) or⤶     (aWdgt instanceof HandleMorph)⤶      super⤶    else⤶      @contents.add aWdgt, position, layoutSpec, beingDropped⤶      @grandChildAdded?()⤶⤶  setRatio: (@ratio) ->⤶    @layoutSpecDetails?.canSetHeightFreely = false⤶⤶  resetRatio: ->⤶    if @ratio?⤶      @ratio = nil⤶      @layoutSpecDetails?.canSetHeightFreely = true⤶      @invalidateLayout()⤶⤶⤶  colloquialName: ->⤶    ＂stretchable panel＂⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    super⤶    @layoutSpecDetails.canSetHeightFreely = !@ratio?⤶⤶⤶  widthWithoutSpacing: ->⤶    height = @height()⤶    width = @width()⤶⤶    if @ratio?⤶      widthBasedOnHeight = height * @ratio⤶      heightBasedOnWidth = width / @ratio⤶⤶      if widthBasedOnHeight <= width⤶        return widthBasedOnHeight⤶⤶      else if heightBasedOnWidth <= height⤶        return width⤶⤶    else⤶        return width⤶⤶  rawResizeToWithoutSpacing: ->⤶    if @ratio?⤶      @rawSetExtent new Point @widthWithoutSpacing(), Math.round(@widthWithoutSpacing()/@ratio)⤶      @invalidateLayout()⤶⤶  rawSetWidthSizeHeightAccordingly: (newWidth) ->⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets @contents⤶⤶    if childrenNotHandlesNorCarets.length != 0⤶      if !@ratio?⤶        @ratio = @width() / @height()⤶        @layoutSpecDetails?.canSetHeightFreely = false⤶      @rawSetExtent new Point newWidth, Math.round(newWidth/@ratio)⤶      @invalidateLayout()⤶    else⤶      @rawSetExtent new Point newWidth, @height()⤶      @invalidateLayout()⤶⤶⤶  rawSetExtent: (extent) ->⤶⤶    if extent.eq @extent()⤶      return⤶⤶    super⤶    @doLayout @bounds⤶⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts⤶    #  debugger⤶⤶    #console.log ＂spanel @contents: ＂ + @contents + ＂ doLayout 1＂⤶⤶⤶    if !newBoundsForThisLayout?⤶      if @desiredExtent?⤶        newBoundsForThisLayout = @desiredExtent⤶        @desiredExtent = nil⤶      else⤶        newBoundsForThisLayout = @extent()⤶⤶      if @desiredPosition?⤶        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout⤶        @desiredPosition = nil⤶      else⤶        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout⤶⤶    if @isCollapsed()⤶      @layoutIsValid = true⤶      @notifyChildrenThatParentHasReLayouted()⤶      return⤶⤶    #console.log ＂spanel @contents: ＂ + @contents + ＂ doLayout 2＂⤶⤶    @rawSetBounds newBoundsForThisLayout⤶⤶    #console.log ＂spanel @contents: ＂ + @contents + ＂ doLayout 3＂⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    height = @height()⤶    width = @width()⤶⤶    if @ratio?⤶      widthBasedOnHeight = height * @ratio⤶      heightBasedOnWidth = width / @ratio⤶⤶       # p0 is the origin, the origin being in the top-left corner⤶      p0 = @topLeft()⤶⤶      if widthBasedOnHeight <= width⤶        p0 = p0.add new Point (width - widthBasedOnHeight) / 2 , 0⤶        newExtent = new Point widthBasedOnHeight, height⤶⤶      else if heightBasedOnWidth <= height⤶        p0 = p0.add new Point 0 , (height - heightBasedOnWidth) / 2⤶        newExtent = new Point width, heightBasedOnWidth⤶⤶      newBounds = (new Rectangle p0).setBoundsWidthAndHeight newExtent⤶      #console.log ＂spanel @contents: ＂ + @contents + ＂ bounds: ＂ + newBounds.round()⤶      @contents.doLayout newBounds.round()⤶⤶    else⤶      @contents.doLayout @bounds⤶⤶⤶⤶    trackChanges.pop()⤶    @fullChanged()⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()⤶⤶  # same as simpledocumentscrollpanel, you can lock the contents.⤶  # worth factoring it out as a mixin?⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    super⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶    if childrenNotHandlesNorCarets? and childrenNotHandlesNorCarets.length > 0⤶      menu.addLine()⤶      if !@dragsDropsAndEditingEnabled⤶        menu.addMenuItem ＂enable editing＂, true, @, ＂enableDragsDropsAndEditing＂, ＂lets you drag content in and out＂⤶      else⤶        menu.addMenuItem ＂disable editing＂, true, @, ＂disableDragsDropsAndEditing＂, ＂prevents dragging content in and out＂⤶⤶    menu.removeConsecutiveLines()⤶⤶  enableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if @dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilYellow?()⤶    if @parent? and @parent != triggeringWidget and @parent instanceof SimpleSlideWdgt⤶      @parent.enableDragsDropsAndEditing @⤶    else⤶      super @⤶⤶  disableDragsDropsAndEditing: (triggeringWidget) ->⤶    if !triggeringWidget? then triggeringWidget = @⤶    if !@dragsDropsAndEditingEnabled⤶      return⤶    @parent?.makePencilClear?()⤶    if @parent? and @parent != triggeringWidget and @parent instanceof SimpleSlideWdgt⤶      @parent.disableDragsDropsAndEditing @⤶    else⤶      super @⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.SwitchButtonMorph_coffeSource = "class SwitchButtonMorph extends Widget⤶⤶  buttons: nil⤶ ⤶  # careful: Objects are shared with all the instances of this class.⤶  # if you modify it, then all the objects will get the change⤶  # but if you replace it with a new Color, then that will only affect the⤶  # specific object instance. Same behaviour as with arrays.⤶  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333⤶  highlightColor: new Color 192, 192, 192⤶  # see note above about Colors and shared objects⤶  pressColor: new Color 128, 128, 128⤶ ⤶  ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked: true⤶  ⤶  buttonShown: 0⤶⤶  # overrides to superclass⤶  color: new Color 255, 255, 255⤶⤶  constructor: (@buttons) ->⤶⤶    # additional properties:⤶⤶    super()⤶⤶    #@color = new Color 255, 152, 152⤶    #@color = new Color 255, 255, 255⤶    for eachButton in @buttons⤶      @add eachButton⤶⤶    @invalidateLayout()⤶  ⤶  # so that when you duplicate a ＂selected＂ toggle⤶  # and you pick it up and you attach it somewhere else⤶  # it gets automatically unselected⤶  iHaveBeenAddedTo: (whereTo, beingDropped) ->⤶    @resetSwitchButton()⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts⤶    #  debugger⤶⤶    if !newBoundsForThisLayout?⤶      if @desiredExtent?⤶        newBoundsForThisLayout = @desiredExtent⤶        @desiredExtent = nil⤶      else⤶        newBoundsForThisLayout = @extent()⤶⤶      if @desiredPosition?⤶        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout⤶        @desiredPosition = nil⤶      else⤶        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout⤶⤶⤶    @rawSetBounds newBoundsForThisLayout⤶⤶    counter = 0⤶    for eachButton in @buttons⤶      if eachButton.parent == @⤶        eachButton.doLayout @bounds⤶        if counter % @buttons.length == @buttonShown⤶          eachButton.show()⤶        else⤶          eachButton.hide()⤶      counter++⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶⤶  # TODO⤶  getTextDescription: ->⤶⤶  # if one calls ＂isSelected＂ it probably means that this SwitchButton⤶  # has two buttons: a ＂selected＂ button and an ＂unselected＂ button⤶  isSelected: ->⤶    return @buttonShown != 0  ⤶⤶  mouseClickLeft: ->⤶    @buttonShown++⤶    @buttonShown = @buttonShown % @buttons.length⤶⤶    @invalidateLayout()⤶    @escalateEvent ＂mouseClickLeft＂, @⤶⤶  resetSwitchButton: ->⤶    @buttonShown = 0⤶    @invalidateLayout()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.TextEditingState_coffeSource = "# REQUIRES DeepCopierMixin⤶⤶class TextEditingState⤶⤶  @augmentWith DeepCopierMixin⤶⤶  selectionStart: nil⤶  selectionEnd: nil⤶  cursorPos: nil⤶  textContent: nil⤶  isJustFirstClickToPositionCursor: nil⤶⤶  constructor: (@selectionStart, @selectionEnd, @cursorPos, @textContent, @isJustFirstClickToPositionCursor) ->⤶  ⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ToggleButtonMorph_coffeSource = "class ToggleButtonMorph extends SwitchButtonMorph⤶⤶⤶  constructor: (button1, button2, startingButton = 0) ->⤶    if startingButton == 0⤶      super [button1, button2]⤶    else⤶      super [button2, button1]⤶⤶  mouseClickLeft: ->⤶    # can't ＂unselect＂ a radio button if it's attached to a radio⤶    # panel that mandates that at least one of the radio⤶    # buttons must be switched on.⤶    if @parent.wantsButtonsToBehaveLikeRadioButtons? and @parent.wantsButtonsToBehaveLikeRadioButtons⤶      unless @parent.allowsRadioButtonsToBeAllDisabled? and @parent.allowsRadioButtonsToBeAllDisabled⤶        if @buttonShown == 1⤶          return⤶⤶    super⤶⤶  select: (whichOne) ->⤶    if @buttonShown != whichOne⤶      @buttons[@buttonShown].mouseClickLeft()⤶⤶  toggle: ->⤶    @buttons[@buttonShown].mouseClickLeft()⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ToolPanelWdgt_coffeSource = "class ToolPanelWdgt extends PanelWdgt⤶⤶  # TODO pretty sure that we don't need numberOfIconsOnPanel⤶  numberOfIconsOnPanel: 0⤶  internalPadding: 5⤶  externalPadding: 10⤶  thumbnailSize: 30⤶⤶  addMany: (widgetsToBeAdded) ->⤶⤶    for eachWidget in widgetsToBeAdded⤶      @add eachWidget, nil, nil, nil, nil, nil, true⤶    @reLayout()⤶⤶  add: (aWdgt, position = nil, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING, beingDropped, unused, positionOnScreen, dontLayout) ->⤶⤶    if (aWdgt instanceof ModifiedTextTriangleAnnotationWdgt) or⤶     (aWdgt instanceof HandleMorph)⤶      super⤶    else⤶      # if aWdgt specifies a non-default switcharoo then it⤶      # means it's like the TextBoxCreatorButtonWdgt, which creates a textbox⤶      # when dragged. So in that case we DON'T set it as a template⤶      # otherwise we do.⤶      if aWdgt.grabbedWidgetSwitcheroo == Widget::grabbedWidgetSwitcheroo⤶        aWdgt.isTemplate = true⤶⤶      if !aWdgt.extentToGetWhenDraggedFromGlassBox?⤶        aWdgt.extentToGetWhenDraggedFromGlassBox = aWdgt.extent()⤶⤶      if !(aWdgt instanceof GlassBoxBottomWdgt)⤶        glassBoxBottom = new GlassBoxBottomWdgt⤶        glassBoxBottom.add aWdgt⤶⤶        if !aWdgt.actionableAsThumbnail⤶          glassBoxTop = new GlassBoxTopWdgt⤶          glassBoxTop.toolTipMessage = aWdgt.toolTipMessage⤶          glassBoxBottom.add glassBoxTop⤶⤶        glassBoxBottom.fullRawMoveTo @topLeft().add new Point @externalPadding, @externalPadding⤶        glassBoxBottom.rawSetExtent new Point @thumbnailSize, @thumbnailSize⤶        glassBoxBottom.reLayout()⤶⤶        aWdgt = glassBoxBottom⤶⤶⤶      childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶      foundDrop = false⤶⤶      if positionOnScreen? and childrenNotHandlesNorCarets.length > 0⤶        positionNumberAmongSiblings = 0⤶⤶        for w in childrenNotHandlesNorCarets⤶          if w.bounds.growBy(@internalPadding).containsPoint positionOnScreen⤶            foundDrop = true⤶            if w.bounds.growBy(@internalPadding).rightHalf().containsPoint positionOnScreen⤶              positionNumberAmongSiblings++⤶            break⤶          positionNumberAmongSiblings++⤶      ⤶      if foundDrop⤶        super aWdgt, positionNumberAmongSiblings, layoutSpec, beingDropped⤶      else⤶        super aWdgt, @numberOfIconsOnPanel, layoutSpec, beingDropped⤶⤶      @numberOfIconsOnPanel++⤶⤶      unless dontLayout⤶        @reLayout()⤶⤶⤶  rawSetExtent: (aPoint) ->⤶    super⤶    @reLayout()⤶⤶  reLayout: ->⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    childrenNotHandlesNorCarets = @childrenNotHandlesNorCarets()⤶⤶    scanningChildrenX = 0⤶    scanningChildrenY = 0⤶    numberOfEntries = 0⤶⤶    # The ToolPanel if often inside a scroll panel,⤶    # in which case the panel width stays the same as the scroll panel⤶    # is resized (because that's what scrollpanels do, they change⤶    # dimensions but the contents remain the same).⤶    # BUT we want the toolpanel to never scroll horizontally⤶    # (only vertically), i.e. we want it to fit the contents⤶    # of the scroll panel parent⤶    if @parent?⤶      if @parent instanceof ScrollPanelWdgt⤶        widthINeedToFitContentIn = @parent.width()⤶      else⤶        widthINeedToFitContentIn = @width()⤶⤶    for w in childrenNotHandlesNorCarets⤶⤶      xPos = scanningChildrenX * (@thumbnailSize + @internalPadding)⤶      yPos = scanningChildrenY * (@thumbnailSize + @internalPadding)⤶⤶      if @externalPadding + xPos + @thumbnailSize + @externalPadding > widthINeedToFitContentIn⤶        scanningChildrenX = 0⤶        if numberOfEntries != 0⤶          scanningChildrenY++⤶⤶        xPos = scanningChildrenX * (@thumbnailSize + @internalPadding)⤶        yPos = scanningChildrenY * (@thumbnailSize + @internalPadding)⤶⤶      horizAdj = (@thumbnailSize - w.width()) / 2⤶      vertAdj = (@thumbnailSize - w.height()) / 2⤶      w.fullRawMoveTo @position().add(new Point @externalPadding, @externalPadding).add(new Point xPos, yPos).add(new Point horizAdj, vertAdj).round()⤶      scanningChildrenX++⤶      numberOfEntries++⤶⤶    trackChanges.pop()⤶    @layoutIsValid = true⤶    @fullChanged()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.ToolTipWdgt_coffeSource = "# when invoked using...⤶#    createInAWhileIfHandStillContainedInMorph / openAt⤶#	... I can temporarily display any widget.⤶# (is you just use the default constructor it will just sit there⤶# and basically _not_ behave like a tool tip)⤶# Note that I'm not a PopUp, for example I can't be pinned.⤶# I'm always attached to the world, without any layout constraints.⤶⤶class ToolTipWdgt extends Widget⤶⤶  @ongoingTimeouts: new Set⤶⤶  contents: nil⤶  padding: nil # additional vertical pixels⤶  morphInvokingThis: nil⤶⤶  constructor: (⤶   @contents=＂text here＂,⤶   @morphInvokingThis,⤶   @color = WorldMorph.preferencesAndSettings.menuBackgroundColor,⤶   cornerRadius,⤶   @padding = 0) ->⤶    # console.log ＂bubble super＂⤶    super()⤶    @strokeColor = WorldMorph.preferencesAndSettings.menuStrokeColor⤶    @cornerRadius = cornerRadius or 6⤶    @appearance = new BubblyAppearance @⤶    # console.log @color⤶  ⤶  @createBubbleHelpIfHandStillOnMorph: (contents, morphInvokingThis) ->⤶    # console.log ＂bubble createBubbleHelpIfHandStillOnMorph＂⤶    # let's check that the item that the⤶    # bubble is about is still actually there⤶    # and the mouse is still over it, otherwise⤶    # do nothing.⤶    if morphInvokingThis.root() == world and morphInvokingThis.boundsContainPoint world.hand.position()⤶      theBubble = new @ contents, morphInvokingThis⤶      theBubble.openAt morphInvokingThis.topRight()⤶⤶  @cancelAllScheduledToolTips: ->⤶    @ongoingTimeouts.forEach (eachTimeout) =>⤶      clearTimeout eachTimeout⤶    @ongoingTimeouts.clear()⤶⤶  @createInAWhileIfHandStillContainedInMorph: (morphInvokingThis, contents, delay = 500) ->⤶    # console.log ＂bubble createInAWhileIfHandStillContainedInMorph＂⤶    if Automator? and Automator.animationsPacingControl and⤶     Automator.state != Automator.IDLE⤶        @createBubbleHelpIfHandStillOnMorph contents, morphInvokingThis⤶    else⤶      @ongoingTimeouts.add setTimeout (=>⤶        @createBubbleHelpIfHandStillOnMorph contents, morphInvokingThis⤶        )⤶        , delay⤶  ⤶  # ToolTipWdgt invoking:⤶  openAt: (pos) ->⤶    @buildAndConnectChildren()⤶    @fullRawMoveTo pos.subtract new Point 8, @height()⤶    @fullRawMoveWithin world⤶    world.add @⤶    @addShadow()⤶    @fullChanged()⤶    world.destroyToolTips()⤶    world.toolTipsList.add @⤶    ⤶  buildAndConnectChildren: ->⤶    # console.log ＂bubble buildAndConnectChildren＂⤶    # re-build my contents⤶    if @contentsMorph⤶      @contentsMorph = @contentsMorph.destroy()⤶    if @contents instanceof Widget⤶      @contentsMorph = @contents⤶    else if isString @contents⤶      @contentsMorph = new TextMorph(⤶        @contents,⤶        WorldMorph.preferencesAndSettings.bubbleHelpFontSize,⤶        nil,⤶        false,⤶        true,⤶        ＂center＂)⤶    else if @contents instanceof HTMLCanvasElement⤶      @contentsMorph = new Widget⤶      @contentsMorph.silentRawSetWidth @contents.width⤶      @contentsMorph.silentRawSetHeight @contents.height⤶      @contentsMorph.backBuffer = @contents⤶      @contentsMorph.backBufferContext = @contentsMorph.backBuffer.getContext ＂2d＂⤶    else⤶      @contentsMorph = new TextMorph(⤶        @contents.toString(),⤶        WorldMorph.preferencesAndSettings.bubbleHelpFontSize,⤶        nil,⤶        false,⤶        true,⤶        ＂center＂)⤶    @add @contentsMorph⤶⤶    # adjust my layout⤶    @silentRawSetWidth @contentsMorph.width() + ((if @padding then @padding * 2 else @cornerRadius * 2))⤶    @silentRawSetHeight @contentsMorph.height() + @cornerRadius + @padding * 2 + 2⤶⤶    # position my contents⤶    @contentsMorph.fullRawMoveTo @position().add(⤶      new Point(@padding or @cornerRadius, @padding + 1))⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.UpperRightTriangle_coffeSource = "# this comment below is needed to figure out dependencies between classes⤶⤶# REQUIRES globalFunctions⤶# REQUIRES UpperRightInternalHaloMixin⤶# REQUIRES HighlightableMixin⤶⤶class UpperRightTriangle extends Widget⤶⤶⤶  @augmentWith UpperRightInternalHaloMixin, @name⤶⤶  constructor: (parent = nil, @proportionOfParent = 4/8) ->⤶    super()⤶    @appearance = new UpperRightTriangleAppearance @⤶⤶    # this morph has triangular shape and we want it⤶    # to only react to pointer events happening⤶    # within tha shape⤶    @noticesTransparentClick = false⤶⤶    size = WorldMorph.preferencesAndSettings.handleSize⤶    @silentRawSetExtent new Point size, size⤶    if parent⤶      parent.add @⤶    @updateResizerPosition()⤶⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.UpperRightTriangleAppearance_coffeSource = "class UpperRightTriangleAppearance extends Appearance⤶⤶  positionWithinParent: nil⤶⤶  constructor: (morph, @positionWithinParent = ＂topRight＂) ->⤶    super morph⤶⤶  # This method only paints this very morph's ＂image＂,⤶  # it doesn't descend the children⤶  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which⤶  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.⤶  # Note that this morph might paint something on the screen even if⤶  # it's not a ＂leaf＂.⤶  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->⤶⤶    if @morph.preliminaryCheckNothingToDraw clippingRectangle, aContext⤶      return nil⤶⤶    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle⤶    return nil if w < 1 or h < 1 or area.isEmpty()⤶⤶    aContext.save()⤶⤶    # clip out the dirty rectangle as we are⤶    # going to paint the whole of the box⤶    aContext.clipToRectangle al,at,w,h⤶⤶    aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @morph.alpha⤶⤶    aContext.scale ceilPixelRatio, ceilPixelRatio⤶    morphPosition = @morph.position()⤶    aContext.translate morphPosition.x, morphPosition.y⤶⤶    @renderingHelper aContext, @morph.color⤶⤶    aContext.restore()⤶⤶    # paintHighlight is usually made to work with⤶    # al, at, w, h which are actual pixels⤶    # rather than logical pixels, so it's generally used⤶    # outside the effect of the scaling because⤶    # of the ceilPixelRatio (i.e. after the restore)⤶    @paintHighlight aContext, al, at, w, h⤶⤶  renderingHelper: (context, color) ->⤶    context.lineWidth = 1⤶    context.lineCap = ＂round＂⤶⤶    # give it a good shadow so that⤶    # it's visible also when on light⤶    # background. Do that by painting it⤶    # twice, slightly translated, in⤶    # darker color.⤶    context.save()⤶⤶    context.fillStyle = color.toString()⤶⤶    context.beginPath()⤶    if @positionWithinParent == ＂topRight＂⤶      context.moveTo 0, 0⤶      context.lineTo @morph.width(), @morph.height()⤶      context.lineTo @morph.width(), 0⤶    else if @positionWithinParent == ＂topLeft＂⤶      context.moveTo 0, 0⤶      context.lineTo 0, @morph.height()⤶      context.lineTo @morph.width(), 0⤶    context.closePath()⤶    context.fill()⤶⤶    context.restore()⤶⤶  isTransparentAt: (aPoint) ->⤶    # first quickly check if the point is even⤶    # within the bounding box⤶    if !@morph.boundsContainPoint aPoint⤶      return true⤶ ⤶    thisMorphPosition = @morph.position()⤶ ⤶    relativePoint = new Point aPoint.x - thisMorphPosition.x, aPoint.y - thisMorphPosition.y⤶⤶    if relativePoint.x / relativePoint.y < @morph.width()/@morph.height()⤶      return true⤶⤶⤶    return false⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.VerticalStackLayoutSpec_coffeSource = "# VerticalStackLayoutSpec⤶# REQUIRES DeepCopierMixin⤶⤶class VerticalStackLayoutSpec⤶⤶  @augmentWith DeepCopierMixin⤶⤶  stack: nil⤶  element: nil⤶⤶  widthOfStackWhenAdded: nil⤶  widthOfElementWhenAdded: nil⤶  elasticity: 1⤶  alignment: 'left'⤶⤶  constructor: (@elasticity) ->⤶    return nil⤶⤶  rememberInitialDimensions: (@element, @stack) ->⤶    ⤶    availableWidthInStack = @stack.availableWidthForContents()⤶    elementWidthWithoutSpacing = @element.widthWithoutSpacing()⤶    ⤶    if elementWidthWithoutSpacing > availableWidthInStack⤶      @widthOfElementWhenAdded = availableWidthInStack⤶      @elasticity = 1⤶    else⤶      @widthOfElementWhenAdded = elementWidthWithoutSpacing⤶⤶    @widthOfStackWhenAdded = availableWidthInStack⤶⤶  getWidthInStack: ->⤶    availableWidthInStack = @stack.availableWidthForContents()⤶    proportionalWidth = availableWidthInStack * @widthOfElementWhenAdded / @widthOfStackWhenAdded⤶    differenceWithFixedWidth = proportionalWidth - @widthOfElementWhenAdded⤶    ⤶    width = @widthOfElementWhenAdded + @elasticity * differenceWithFixedWidth⤶    width = Math.round width⤶⤶    return Math.min width, availableWidthInStack⤶⤶⤶  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->⤶    menu.addLine()⤶    menu.addMenuItem ＂layout in stack ➜＂, false, @, ＂vertStackMenu＂, ＂＂⤶⤶  vertStackMenu: (morphOpeningThePopUp,targetMorph,a,b,c)->⤶    menu = new MenuMorph morphOpeningThePopUp,  false, targetMorph, true, true, nil⤶    menu.addMenuItem ＂base width...＂, true, @, ＂baseWidthPopout＂, ＂＂⤶    menu.addMenuItem ＂elasticity...＂, true, @, ＂elasticityPopout＂, ＂＂⤶    menu.addMenuItem ＂align left＂, true, @, ＂setAlignmentToLeft＂  if @alignment isnt ＂left＂⤶    menu.addMenuItem ＂align right＂, true, @, ＂setAlignmentToRight＂  if @alignment isnt ＂right＂⤶    menu.addMenuItem ＂align center＂, true, @, ＂setAlignmentToCenter＂  if @alignment isnt ＂center＂⤶    menu.popUpAtHand()⤶⤶  setAlignmentToLeft: ->⤶    if @alignment isnt ＂left＂⤶      @alignment = ＂left＂⤶      @element.refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  setAlignmentToRight: ->⤶    if @alignment isnt ＂right＂⤶      @alignment = ＂right＂⤶      @element.refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  setAlignmentToCenter: ->⤶    if @alignment isnt ＂enter＂⤶      @alignment = ＂center＂⤶      @element.refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  elasticityPopout: (menuItem,a,b,c,d,e,f)->⤶    @element.prompt menuItem.parent.title + ＂⧹nelasticity:＂,⤶      @,⤶      ＂setElasticity＂,⤶      (@elasticity * 100).toString(),⤶      nil,⤶      0,⤶      100,⤶      true⤶⤶  setElasticity: (elasticityOrMorphGivingElasticity, morphGivingElasticity) ->⤶    if morphGivingElasticity?.getValue?⤶      elasticity = morphGivingElasticity.getValue()⤶    else⤶      elasticity = elasticityOrMorphGivingElasticity⤶⤶    elasticity = Number(elasticity)⤶⤶    elasticity = elasticity/100⤶    unless @elasticity == elasticity⤶      @elasticity = elasticity⤶      @element.refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  baseWidthPopout: (menuItem,a,b,c,d,e,f)->⤶    @element.prompt menuItem.parent.title + ＂⧹nbase width:＂,⤶      @,⤶      ＂setWidthOfElementWhenAdded＂,⤶      @widthOfElementWhenAdded.toString(),⤶      nil,⤶      10,⤶      1000,⤶      true⤶⤶  setWidthOfElementWhenAdded: (widthOfElementWhenAddedOrMorphGivingWidthOfElementWhenAdded, morphGivingWidthOfElementWhenAdded) ->⤶    if morphGivingWidthOfElementWhenAdded?.getValue?⤶      widthOfElementWhenAdded = morphGivingWidthOfElementWhenAdded.getValue()⤶    else⤶      widthOfElementWhenAdded = widthOfElementWhenAddedOrMorphGivingWidthOfElementWhenAdded⤶⤶    widthOfElementWhenAdded = Math.round(widthOfElementWhenAdded)⤶⤶    if widthOfElementWhenAdded⤶      unless @widthOfElementWhenAdded == widthOfElementWhenAdded⤶        @widthOfElementWhenAdded = widthOfElementWhenAdded⤶        @element.refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.WidgetHolderWithCaptionWdgt_coffeSource = "# This is what typically people refer to as ＂icons＂, however that's not⤶# quite precise. An icon is just a symbol, it doesn't have a caption per se.⤶# This widget has a caption instead. Also, since it can hold any widget, the⤶# final name is WidgetHolderWithCaptionWdgt.⤶⤶class WidgetHolderWithCaptionWdgt extends Widget⤶⤶  labl: nil⤶⤶  constructor: (@labelContent, @icon) ->⤶    super()⤶    if !@icon?⤶      @icon = new SimpleDropletWdgt ＂icon＂⤶    @rawSetExtent new Point 95, 95⤶    @add @icon⤶    @label = new StringMorph2 @labelContent, WorldMorph.preferencesAndSettings.shortcutsFontSize⤶    @label.fittingSpecWhenBoundsTooLarge = FittingSpecTextInLargerBounds.SCALEUP⤶    @label.color = new Color 255, 255, 255⤶    @label.hasDarkOutline = true⤶    @add @label, nil, nil, true⤶    @label.alignCenter()⤶    @label.alignMiddle()⤶    @label.isEditable = true⤶    # update layout⤶    @invalidateLayout()⤶⤶⤶  setColor: (theColor, ignored, connectionsCalculationToken, superCall) ->⤶    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken⤶⤶    @icon.setColor theColor⤶⤶  widthWithoutSpacing: ->⤶    Math.min @width(), @height()⤶⤶  rawResizeToWithoutSpacing: ->⤶    @rawSetExtent new Point @widthWithoutSpacing(), @widthWithoutSpacing()⤶    @invalidateLayout()⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    super⤶    @layoutSpecDetails.canSetHeightFreely = false⤶⤶  rawSetWidthSizeHeightAccordingly: (newWidth) ->⤶    @rawResizeToWithoutSpacing()⤶    @rawSetExtent new Point newWidth, newWidth⤶    @invalidateLayout()⤶⤶  doLayout: (newBoundsForThisLayout) ->⤶    #if !window.recalculatingLayouts⤶    #  debugger⤶⤶    if !newBoundsForThisLayout?⤶      if @desiredExtent?⤶        newBoundsForThisLayout = @desiredExtent⤶        @desiredExtent = nil⤶      else⤶        newBoundsForThisLayout = @extent()⤶⤶      if @desiredPosition?⤶        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout⤶        @desiredPosition = nil⤶      else⤶        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout⤶⤶    if @isCollapsed()⤶      @layoutIsValid = true⤶      @notifyChildrenThatParentHasReLayouted()⤶      return⤶⤶    @rawSetBounds newBoundsForThisLayout⤶⤶    # here we are disabling all the broken⤶    # rectangles. The reason is that all the⤶    # submorphs of the inspector are within the⤶    # bounds of the parent Widget. This means that⤶    # if only the parent morph breaks its rectangle⤶    # then everything is OK.⤶    # Also note that if you attach something else to its⤶    # boundary in a way that sticks out, that's still⤶    # going to be painted and moved OK.⤶    trackChanges.push false⤶⤶    height = @height()⤶    width = @width()⤶⤶    squareDim = Math.min width, height⤶⤶     # p0 is the origin, the origin being in the bottom-left corner⤶    p0 = @topLeft()⤶⤶    # now the origin if on the left edge, in the middle height of the morph⤶    p0 = p0.add new Point width/2, height/2⤶    ⤶    # now the origin is in the middle height of the morph,⤶    # on the left edge of the square incribed in the morph⤶    p0 = p0.subtract new Point squareDim/2, squareDim/2⤶⤶    @icon.setExtent (new Point squareDim, squareDim*8/10).round()⤶    @icon.fullRawMoveTo p0.round()⤶    @label.setExtent (new Point squareDim, squareDim*2/10).round()⤶    @label.fullRawMoveTo (p0.add new Point 0, squareDim*8/10).round()⤶⤶⤶    trackChanges.pop()⤶    @fullChanged()⤶⤶    @layoutIsValid = true⤶    @notifyChildrenThatParentHasReLayouted()⤶⤶    if Automator? and Automator.state != Automator.IDLE and Automator.alignmentOfMorphIDsMechanism⤶      world.alignIDsOfNextMorphsInSystemTests()".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.WindowContentLayoutSpec_coffeSource = "# WindowContentLayoutSpec⤶# REQUIRES DeepCopierMixin⤶⤶⤶class WindowContentLayoutSpec extends VerticalStackLayoutSpec⤶⤶  @augmentWith DeepCopierMixin⤶⤶  # when you drop something on a window, you⤶  # expect a couple of possible behaviours:⤶  # 1) the window takes the size of the dropped item⤶  # 2) the item takes the size of the window⤶  # You normally expect 1) with things that inherently have⤶  # a particular size and proportion, for example a slider⤶  # (which makes no sense when enlarged and deformed to a⤶  # different proportion)⤶  # You expect 2) with things that are ＂small＂, since you⤶  # want to ＂window＂ them you probably want to give them⤶  # more importance.⤶  # These two properties can define which behaviour is⤶  # going to take effect.⤶  preferredStartingWidth: nil⤶  preferredStartingHeight: nil⤶  ⤶  # if this is set, it means that the widget can⤶  # meaningfully have its height set to any value,⤶  # so the holding window can be stretched⤶  # vertically to any extent (if the window itself⤶  # is not constrained by a layout, that is)⤶  # This is true for example for vertical sliders, or⤶  # scrolling panels (scrolling stacks, or scrolling text⤶  # panels, or documents).⤶  # This is FALSE for icons (since they'd only show empty⤶  # vertical space which would not be meaningful)⤶  # or the clock (same reason) or vertical stacks or ＂naked＂⤶  # wrapping text (in those cases it's the content that dictates⤶  # what the height should be, there literally is nothing⤶  # boyond the height that they have).⤶  #⤶  # Note that we'll have to override this when we'll want⤶  # to maximise windows, we'll just have to⤶  # leave the empty vertical space.⤶  canSetHeightFreely: true⤶⤶  resizerCanOverlapContents: true⤶⤶  rememberInitialDimensions: (@element, @stack) ->⤶    super⤶    ⤶    availableWidthInStack = @stack.availableWidthForContents()⤶    if @preferredStartingWidth == PreferredSize.DONT_MIND⤶      @widthOfElementWhenAdded = availableWidthInStack⤶      @elasticity = 1⤶⤶  constructor: (@preferredStartingWidth, @preferredStartingHeight, elasticity) ->⤶    super elasticity⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.WindowContentsPlaceholderText_coffeSource = "class WindowContentsPlaceholderText extends TextMorph2⤶⤶  constructor: ->⤶⤶    super ＂Drop a widget in here＂,nil,nil,nil,nil,nil,WorldMorph.preferencesAndSettings.editableItemBackgroundColor, 1⤶⤶    @alignCenter()⤶    @alignMiddle()⤶    @fittingSpecWhenBoundsTooLarge = false⤶    @changed()⤶⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    @layoutSpecDetails = new WindowContentLayoutSpec PreferredSize.DONT_MIND , PreferredSize.DONT_MIND, 1⤶⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.WindowWdgt_coffeSource = "# REQUIRES WindowContentsPlaceholderText⤶⤶# TODO: when floating, windows should really be able to⤶# accommodate any extent always, because really windows should⤶# be stackable and dockable in any place...⤶# ...and that's now how we do it now, for example a window⤶# with a clock right now keeps ratio...⤶# Only when being part of other layouts e.g. stacks the⤶# windows should keep a ratio etc...⤶# So I'm inclined to think that a window should do what the⤶# StretchableWidgetContainerWdgt does...⤶⤶# TODO: this is such a special version of SimpleVerticalStackPanelWdgt⤶# that really it seems like this extension is misleading...⤶⤶class WindowWdgt extends SimpleVerticalStackPanelWdgt⤶⤶  # TODO we already have the concept of ＂droplet＂ widget⤶  # so probably we should re-use that. The current drop⤶  # area management seems a little byzantine...⤶⤶  label: nil⤶  closeButton: nil⤶  editButton: nil⤶  collapseUncollapseSwitchButton: nil⤶  labelContent: nil⤶  resizer: nil⤶  padding: nil⤶  contents: nil⤶  titlebarBackground: nil⤶  contentNeverSetInPlaceYet: true⤶  # used to avoid recursively re-entering the⤶  # adjustContentsBounds function⤶  _adjustingContentsBounds: false⤶  internal: false⤶  defaultContents: nil⤶  reInflating: false⤶⤶  internalExternalSwitchButton: nil⤶  alwaysShowInternalExternalButton: nil⤶⤶  # TODO passing the @labelContent doesn't quite work, when⤶  # you add a widget to the window it overwrites the⤶  # title which means that this one parameter passed in⤶  # the constructor has no effect⤶  constructor: (@labelContent = ＂my window＂, @closeButton, @contents, @internal = false, @alwaysShowInternalExternalButton = false) ->⤶    super nil, nil, 40, true⤶⤶    if @internal⤶      @appearance = new RectangularAppearance @⤶    else⤶      @appearance = new BoxyAppearance @⤶⤶    @strokeColor = new Color 125,125,125⤶    @tight = true⤶⤶    @defaultContents = new WindowContentsPlaceholderText⤶    if !@contents?⤶      @contents = @defaultContents⤶⤶    @padding = 5⤶    # TODO this looks better:⤶    #@padding = 10⤶    @color = new Color 248, 248, 248⤶    @buildAndConnectChildren()⤶⤶    if @contents == @defaultContents⤶      @setEmptyWindowLabel()⤶    else⤶      @disableDrops()⤶      # TODO there is a duplicate of this down below⤶      titleToBeSet = @contents.colloquialName()⤶      if titleToBeSet == ＂window＂⤶        titleToBeSet = ＂window with another ＂ + titleToBeSet⤶      if titleToBeSet == ＂internal window＂⤶        titleToBeSet = ＂window with an ＂ + titleToBeSet⤶      @label.setText titleToBeSet⤶⤶    @rawSetExtent new Point 300, 300⤶⤶⤶  # in general, windows just create a reference of themselves and⤶  # that is it. However, windows containing a ScriptWdgt create⤶  # a special type of reference that has a slightly different icon⤶  # and when double-clicked actually runs the script rather than⤶  # bringing up the script ⤶  createReference: (referenceName, placeToDropItIn) ->⤶    # this function can also be called as a callback⤶    # of a trigger, in which case the first parameter⤶    # here is a menuItem. We take that parameter away⤶    # in that case.⤶    if referenceName? and typeof(referenceName) != ＂string＂⤶      referenceName = nil⤶      placeToDropItIn = world⤶⤶    if @contents? and (@contents instanceof ScriptWdgt)⤶      morphToAdd = new IconicDesktopSystemScriptShortcutWdgt @, referenceName⤶      # this ＂add＂ is going to try to position the reference⤶      # in some smart way (i.e. according to a grid)⤶      placeToDropItIn.add morphToAdd⤶      morphToAdd.setExtent new Point 75, 75⤶      morphToAdd.fullChanged()⤶      @bringToForeground()⤶    else⤶      super⤶⤶⤶  makeInternal: ->⤶    if !@internal⤶      @internal = true⤶      @setAppearanceAndColorOfTitleBackground()⤶⤶  makeExternal: ->⤶    if @internal⤶      @internal = false⤶      # in case the internal window was part of an uneditable⤶      # document, then it was set to lock to the panel so it⤶      # couldn't be dragged. But we have to change that now since⤶      # we ought to be free on the desktop⤶      @unlockFromPanels()⤶      @setAppearanceAndColorOfTitleBackground()⤶⤶      previousParent = @parent⤶      world.add @⤶⤶      @contents?.holderWindowMadeIntoExternal?()⤶⤶      # make it jump out a little, but still, fit it⤶      # in the world⤶      if previousParent != world⤶        @fullRawMoveTo @position().add new Point 10, 10⤶        @fullRawMoveWithin world⤶        @rememberFractionalSituationInHoldingPanel()⤶⤶  setTitle: (newTitle) ->⤶    @label.setText @contents.colloquialName() + ＂: ＂ + newTitle⤶⤶  setTitleWithoutPrependedContentName: (newTitle) ->⤶    @label.setText newTitle⤶⤶  representativeIcon: ->⤶    if @contents == @defaultContents⤶      return super⤶    else⤶      return @contents.representativeIcon()⤶⤶  closeFromWindowBar: ->⤶    @contents?.closeFromContainerWindow @⤶⤶  contentsRecursivelyCanSetHeightFreely: ->⤶    if !(@contents instanceof WindowWdgt)⤶      return (@contents.layoutSpecDetails.canSetHeightFreely and !@contents.isCollapsed()) and !@reInflating⤶    return @contents.contentsRecursivelyCanSetHeightFreely()⤶⤶  recursivelyAttachedAsFreeFloating: ->⤶    if @layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING⤶      return true⤶⤶    if @parent?⤶      if @parent instanceof WindowWdgt⤶        return @parent.recursivelyAttachedAsFreeFloating()⤶⤶    return false⤶⤶⤶  rejectsBeingDropped: ->⤶    return !@internal⤶⤶  setEmptyWindowLabel: ->⤶    if @internal⤶      @label.setText ＂empty internal window＂⤶    else⤶      @label.setText ＂empty window＂⤶⤶  colloquialName: ->⤶    if @internal⤶      return ＂internal window＂⤶    else⤶      return ＂window＂⤶⤶  add: (aWdgt, position = nil, layoutSpec, beingDropped, notContent) ->⤶    unless notContent or (aWdgt instanceof CaretMorph) or (aWdgt instanceof HandleMorph)⤶      @contentNeverSetInPlaceYet = true⤶      titleToBeSet = aWdgt.colloquialName()⤶      if titleToBeSet == ＂window＂⤶        titleToBeSet = ＂window with another ＂ + titleToBeSet⤶      if titleToBeSet == ＂internal window＂⤶        titleToBeSet = ＂window with an ＂ + titleToBeSet⤶      @label.setText titleToBeSet⤶      @removeChild @contents⤶      @contents = aWdgt⤶      @adjustContentsBounds()⤶      super aWdgt, position, LayoutSpec.ATTACHEDAS_WINDOW_CONTENT, beingDropped⤶    else⤶      super aWdgt, position, LayoutSpec.ATTACHEDAS_FREEFLOATING, beingDropped⤶    @resizer?.moveInFrontOfSiblings()⤶⤶  childBeingDestroyed: (child) ->⤶    if child == @contents⤶      @resetToDefaultContents()⤶⤶  childBeingPickedUp: (child) ->⤶    if child == @contents⤶      @resetToDefaultContents()⤶⤶  childBeingClosed: (child) ->⤶    if child == @contents⤶      @resetToDefaultContents()⤶⤶  childBeingCollapsed: (child) ->⤶    if child == @contents⤶      @widthWhenUnCollapsed = @width()⤶      @contentsExtentWhenCollapsed = @contents.extent()⤶      @extentWhenCollapsed = @extent()⤶⤶      @editButton?.destroy()⤶      @editButton = nil⤶⤶      @internalExternalSwitchButton?.destroy()⤶      @internalExternalSwitchButton = nil⤶⤶  childBeingUnCollapsed: (child) ->⤶    if child == @contents⤶      @widthWhenCollapsed = @width()⤶⤶    @createAndAddEditButton()⤶    @createAndAddInternalExternalSwitchButton()⤶⤶  childCollapsed: (child) ->⤶    if child == @contents⤶      if @widthWhenCollapsed?⤶        @rawSetWidth @widthWhenCollapsed⤶      @adjustContentsBounds()⤶      @refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  childUnCollapsed: (child) ->⤶    if child == @contents⤶      @reInflating = true⤶      @rawSetExtent @extentWhenCollapsed⤶      @contents.rawSetExtent @contentsExtentWhenCollapsed⤶      if @widthWhenUnCollapsed?⤶        @rawSetWidth @widthWhenUnCollapsed⤶      @adjustContentsBounds()⤶      @reInflating = false⤶      @rememberFractionalSituationInHoldingPanel()⤶      @refreshScrollPanelWdgtOrVerticalStackIfIamInIt()⤶⤶  resetToDefaultContents: ->⤶    @enableDrops()⤶    @contents = @defaultContents⤶    @buildAndConnectChildren()⤶    @setEmptyWindowLabel()⤶    if @recursivelyAttachedAsFreeFloating()⤶      @rawSetExtent new Point 300, 300⤶⤶  aboutToDrop: ->⤶    @removeChild @contents⤶⤶  justDropped: (whereIn) ->⤶    super⤶    @contents?.holderWindowJustDropped? whereIn⤶⤶  justBeenGrabbed: (whereFrom) ->⤶    @contents?.holderWindowJustBeenGrabbed? whereFrom⤶⤶  reactToDropOf: (theWidget) ->⤶    @contents = theWidget⤶    super⤶    @disableDrops()⤶    @buildAndConnectChildren()⤶⤶  setAppearanceAndColorOfTitleBackground: ->⤶    if @internal⤶      @titlebarBackground.appearance = new RectangularAppearance @titlebarBackground⤶    else⤶      @titlebarBackground.appearance = new BoxyAppearance @titlebarBackground⤶⤶    if @internal⤶      @titlebarBackground.setColor WorldMorph.preferencesAndSettings.internalWindowBarBackgroundColor⤶      @titlebarBackground.strokeColor = WorldMorph.preferencesAndSettings.internalWindowBarStrokeColor⤶    else⤶      @titlebarBackground.setColor WorldMorph.preferencesAndSettings.externalWindowBarBackgroundColor⤶      @titlebarBackground.strokeColor = WorldMorph.preferencesAndSettings.externalWindowBarStrokeColor⤶⤶⤶  buildTitlebarBackground: ->⤶    if @titlebarBackground?⤶      @titlebarBackground.fullDestroy()⤶⤶    # TODO we should really just instantiate a Widget,⤶    # and give it the shape, there is no reason to create⤶    # the dedicated shape morph and then change the appearance⤶    # as the window changes from internal to external and vice versa⤶    # HOWEVER a bunch of tests would fail if I do the proper⤶    # thing so we are doing this for the time being.⤶    if @internal⤶      @titlebarBackground = new RectangleMorph⤶    else⤶      @titlebarBackground = new BoxMorph⤶⤶    @setAppearanceAndColorOfTitleBackground()⤶    @add @titlebarBackground, nil, nil, nil, true⤶  ⤶  buildAndConnectChildren: ->⤶⤶    if !@titlebarBackground?⤶      @buildTitlebarBackground()⤶⤶    # label⤶    @label?.fullDestroy()⤶    @label = new StringMorph2 @labelContent, WorldMorph.preferencesAndSettings.titleBarTextFontSize⤶⤶    # as of March 2018, Safari 10.1.1 on OSX 10.12.5 :⤶    # safari's rendering of bright text on dark background is atrocious⤶    # so we have to force bold style in the window bars⤶    if /^((?!chrome|android).)*safari/i.test navigator.userAgent⤶      @label.isBold = true⤶    else⤶      @label.isBold = WorldMorph.preferencesAndSettings.titleBarBoldText⤶⤶    @label.color = new Color 255, 255, 255⤶    @add @label, nil, nil, nil, true⤶⤶    # upper-left button, often a close button⤶    # but it can be anything⤶    if !@closeButton?⤶      @closeButton = new CloseIconButtonMorph⤶    @add @closeButton, nil, nil, nil, true⤶⤶⤶    if !@collapseUncollapseSwitchButton?⤶      collapseButton = new CollapseIconButtonMorph⤶      uncollapseButton = new UncollapseIconButtonMorph⤶      @collapseUncollapseSwitchButton = new SwitchButtonMorph [collapseButton, uncollapseButton]⤶    @add @collapseUncollapseSwitchButton, nil, nil, nil, true⤶⤶⤶    @createAndAddInternalExternalSwitchButton()⤶    @createAndAddEditButton()⤶⤶    @add @contents⤶⤶    if !@resizer?⤶      @resizer = new HandleMorph @⤶⤶  createAndAddInternalExternalSwitchButton: ->⤶    if (@contents?.providesAmenitiesForEditing or @alwaysShowInternalExternalButton) and !@internalExternalSwitchButton?⤶      externalButton = new ExternalIconButtonWdgt⤶      internalButton = new InternalIconButtonWdgt⤶      if @internal⤶        listOfButtons = [internalButton, externalButton]⤶      else⤶        listOfButtons = [externalButton, internalButton]⤶      @internalExternalSwitchButton = new SwitchButtonMorph listOfButtons⤶      @add @internalExternalSwitchButton, nil, nil, nil, true⤶⤶  makePencilYellow: ->⤶      # TODO assigning to color_normal is not enough⤶      # there should be a way to do these two lines with one line⤶      @editButton?.color_normal = new Color 248, 188, 58⤶      @editButton?.setColor new Color 248, 188, 58⤶      @editButton?.changed()⤶⤶  makePencilClear: ->⤶      # TODO assigning to color_normal is not enough⤶      # there should be a way to do these two lines with one line⤶      @editButton?.color_normal = new Color 245, 244, 245⤶      @editButton?.setColor new Color 245, 244, 245⤶      @editButton?.changed()⤶⤶  createAndAddEditButton: ->⤶    if @contents?.providesAmenitiesForEditing and !@editButton?⤶      @editButton = new EditIconButtonWdgt @⤶      @add @editButton, nil, nil, nil, true⤶⤶      if @contents.dragsDropsAndEditingEnabled⤶        @makePencilYellow()⤶      else⤶        @makePencilClear()⤶⤶  initialiseDefaultWindowContentLayoutSpec: ->⤶    super⤶    @layoutSpecDetails.canSetHeightFreely = false⤶⤶  adjustContentsBounds: ->⤶    # avoid recursively re-entering this function⤶    if @_adjustingContentsBounds then return else @_adjustingContentsBounds = true⤶⤶    closeIconSize = 16⤶⤶    # close button⤶    if @closeButton? and @closeButton.parent == @⤶      buttonBounds = new Rectangle new Point @left() + @padding, @top() + @padding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight closeIconSize, closeIconSize⤶      @closeButton.doLayout buttonBounds⤶⤶    # collapse/uncollapse button⤶    if @collapseUncollapseSwitchButton? and @collapseUncollapseSwitchButton.parent == @⤶      buttonBounds = new Rectangle new Point @left() + closeIconSize + 2 * @padding, @top() + @padding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight closeIconSize, closeIconSize⤶      @collapseUncollapseSwitchButton.doLayout buttonBounds⤶⤶    stackHeight = 0⤶⤶    if @contents? and !@contents.collapsed⤶      if @contents.layoutSpec != LayoutSpec.ATTACHEDAS_WINDOW_CONTENT⤶        @contents.initialiseDefaultWindowContentLayoutSpec()⤶        @contents.setLayoutSpec LayoutSpec.ATTACHEDAS_WINDOW_CONTENT⤶⤶      if @contentNeverSetInPlaceYet⤶        # in this case the contents has just been added⤶⤶        if @contents.layoutSpecDetails.preferredStartingWidth == PreferredSize.THIS_ONE_I_HAVE_NOW⤶          recommendedElementWidth = @contents.width()⤶          if @recursivelyAttachedAsFreeFloating()⤶            windowWidth = recommendedElementWidth + @padding * 2⤶          else⤶            windowWidth = Math.min @width(), recommendedElementWidth + @padding * 2⤶          @rawSetWidth windowWidth⤶        else if @contents.layoutSpecDetails.preferredStartingWidth == PreferredSize.DONT_MIND⤶          recommendedElementWidth = @width()  - 2 * @padding⤶        else⤶          recommendedElementWidth = @contents.layoutSpecDetails.preferredStartingWidth⤶          if @recursivelyAttachedAsFreeFloating()⤶            windowWidth = recommendedElementWidth + @padding * 2⤶          else⤶            windowWidth = Math.min @width(), recommendedElementWidth + @padding * 2⤶          @rawSetWidth windowWidth⤶⤶        @contents.layoutSpecDetails.rememberInitialDimensions @contents, @⤶⤶⤶      else⤶        # the content was already there⤶        recommendedElementWidth = @contents.layoutSpecDetails.getWidthInStack()⤶⤶      if @contents.layoutSpecDetails.resizerCanOverlapContents⤶        partOfHeightUsedUp = Math.round (closeIconSize + @padding + @padding) + 2 * @padding⤶      else⤶        partOfHeightUsedUp = Math.round (closeIconSize + @padding + @padding) + 3 * @padding + WorldMorph.preferencesAndSettings.handleSize⤶⤶      # this re-layouts each widget to fit the width.⤶      if @contentNeverSetInPlaceYet⤶        # in this case the contents has just been added⤶        if @contents.layoutSpecDetails.preferredStartingHeight == PreferredSize.THIS_ONE_I_HAVE_NOW⤶          desiredHeight = @contents.height()⤶          if !@recursivelyAttachedAsFreeFloating()⤶            desiredHeight = Math.min desiredHeight, @height() - partOfHeightUsedUp⤶          @contents.rawSetWidth recommendedElementWidth⤶          @rawSetWidth windowWidth⤶          @contents.rawSetHeight desiredHeight⤶        else if @contents.layoutSpecDetails.preferredStartingHeight == PreferredSize.DONT_MIND⤶          @contents.rawSetWidth recommendedElementWidth⤶          desiredHeight = Math.round @height() - partOfHeightUsedUp⤶          @contents.rawSetHeight desiredHeight⤶        else⤶          @contents.rawSetWidthSizeHeightAccordingly recommendedElementWidth⤶          desiredHeight = @contents.height()⤶⤶        @contentNeverSetInPlaceYet = false⤶      else⤶        # the content was already there⤶        @contents.rawSetWidthSizeHeightAccordingly recommendedElementWidth⤶        desiredHeight = @contents.height()⤶⤶        if @contentsRecursivelyCanSetHeightFreely()⤶          desiredHeight = Math.round @height() - partOfHeightUsedUp⤶          @contents.rawSetHeight desiredHeight⤶⤶      # the SimplePlainTextWdgt just needs this to be different from null⤶      # while the TextMorph actually uses this number⤶      if (@contents instanceof TextMorph) or (@contents instanceof SimplePlainTextWdgt)⤶        @contents.maxTextWidth = recommendedElementWidth⤶⤶      leftPosition = @left() + Math.floor (@width() - recommendedElementWidth) / 2⤶⤶      @contents.fullRawMoveTo new Point leftPosition, @top() + (closeIconSize + @padding + @padding) + @padding⤶      stackHeight += desiredHeight⤶⤶    if @contents? and @contents.collapsed⤶      partOfHeightUsedUp = Math.round closeIconSize + @padding + @padding⤶⤶⤶    newHeight = stackHeight + partOfHeightUsedUp⤶⤶    @rawSetHeight newHeight⤶⤶    @titlebarBackground.rawSetExtent (new Point @width(), closeIconSize + 2 * @padding).subtract new Point 2,2⤶    @titlebarBackground.fullRawMoveTo @position().add new Point 1,1⤶    # TODO this looks better:⤶    #@titlebarBackground.rawSetExtent (new Point @width(), closeIconSize + 2 * @padding).subtract new Point 4,4⤶    #@titlebarBackground.fullRawMoveTo @position().add new Point 2,2⤶⤶    if @width() < 4 * (closeIconSize + @padding) + @padding⤶      @editButton?.collapse()⤶    else⤶      @editButton?.unCollapse()⤶⤶    if @width() < 3 * (closeIconSize + @padding) + @padding⤶      @internalExternalSwitchButton?.collapse()⤶    else⤶      @internalExternalSwitchButton?.unCollapse()⤶⤶    # label⤶    if @label? and @label.parent == @⤶      labelLeft = @left() + @padding + 2 * (closeIconSize + @padding)⤶      labelTop = @top() + @padding⤶      labelRight = @right() - @padding⤶      if @editButton? and !@editButton.isCollapsed()⤶        labelRight -= 1 * (closeIconSize + @padding)⤶      if @internalExternalSwitchButton? and !@internalExternalSwitchButton.isCollapsed()⤶        labelRight -= 1 * (closeIconSize + @padding)⤶      labelWidth = labelRight - labelLeft⤶⤶      labelBounds = new Rectangle new Point labelLeft, labelTop⤶      labelBounds = labelBounds.setBoundsWidthAndHeight labelWidth, WorldMorph.preferencesAndSettings.titleBarTextHeight⤶      @label.rawSetBounds labelBounds⤶⤶    # edit button⤶    if @editButton? and !@editButton.isCollapsed() and @editButton.parent == @⤶      buttonBounds = new Rectangle new Point @right() - 2 * (closeIconSize + @padding), @top() + @padding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight closeIconSize, closeIconSize⤶      @editButton.doLayout buttonBounds⤶⤶    # internal/external button⤶    if @internalExternalSwitchButton? and !@internalExternalSwitchButton.isCollapsed() and @internalExternalSwitchButton.parent == @⤶      buttonBounds = new Rectangle new Point @right() - 1 * (closeIconSize + @padding), @top() + @padding⤶      buttonBounds = buttonBounds.setBoundsWidthAndHeight closeIconSize, closeIconSize⤶      @internalExternalSwitchButton.doLayout buttonBounds⤶⤶⤶⤶    @resizer?.silentUpdateResizerHandlePosition()⤶⤶    @_adjustingContentsBounds = false⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");

window.WorldMorph_coffeSource = "# these comments below needed to figure out dependencies between classes⤶# REQUIRES globalFunctions⤶# REQUIRES PreferencesAndSettings⤶# REQUIRES Color⤶# REQUIRES ProfilingDataCollector⤶# REQUIRES SystemTestsControlPanelUpdater⤶⤶# REQUIRES GridPositioningOfAddedShortcutsMixin⤶# REQUIRES KeepIconicDesktopSystemLinksBackMixin⤶⤶# REQUIRES DesktopAppearance⤶⤶# The WorldMorph takes over the canvas on the page⤶class WorldMorph extends PanelWdgt⤶⤶  @augmentWith GridPositioningOfAddedShortcutsMixin, @name⤶  @augmentWith KeepIconicDesktopSystemLinksBackMixin, @name⤶⤶  # We need to add and remove⤶  # the event listeners so we are⤶  # going to put them all in properties⤶  # here.⤶  # dblclickEventListener: nil⤶  mousedownBrowserEventListener: nil⤶  mouseupBrowserEventListener: nil⤶  mousemoveBrowserEventListener: nil⤶  contextmenuEventListener: nil⤶⤶  touchstartBrowserEventListener: nil⤶  touchendBrowserEventListener: nil⤶  touchmoveBrowserEventListener: nil⤶  gesturestartBrowserEventListener: nil⤶  gesturechangeBrowserEventListener: nil⤶⤶  # Note how there can be two handlers for⤶  # keyboard events.⤶  # This one is attached⤶  # to the canvas and reaches the currently⤶  # blinking caret if there is one.⤶  # See below for the other potential⤶  # handler. See ＂initVirtualKeyboard＂⤶  # method to see where and when this input and⤶  # these handlers are set up.⤶  keydownBrowserEventListener: nil⤶  keyupBrowserEventListener: nil⤶  keypressBrowserEventListener: nil⤶  wheelBrowserEventListener: nil⤶⤶  copyBrowserEventListener: nil⤶  pasteBrowserEventListener: nil⤶  clipboardTextIfTestRunning: nil⤶  errorConsole: nil⤶⤶  # the string for the last serialised morph⤶  # is kept in here, to make serialization⤶  # and deserialization tests easier.⤶  # The alternative would be to refresh and⤶  # re-start the tests from where they left...⤶  lastSerializationString: ＂＂⤶⤶  # Note how there can be two handlers⤶  # for keyboard events. This one is⤶  # attached to a hidden⤶  # ＂input＂ div which keeps track of the⤶  # text that is being input.⤶  inputDOMElementForVirtualKeyboardKeydownBrowserEventListener: nil⤶  inputDOMElementForVirtualKeyboardKeyupBrowserEventListener: nil⤶  inputDOMElementForVirtualKeyboardKeypressBrowserEventListener: nil⤶⤶  keyComboResetWorldEventListener: nil⤶  keyComboTurnOnAnimationsPacingControl: nil⤶  keyComboTurnOffAnimationsPacingControl: nil⤶  keyComboTakeScreenshotEventListener: nil⤶  keyComboStopTestRecordingEventListener: nil⤶  keyComboTakeScreenshotEventListener: nil⤶  keyComboCheckStringsOfItemsInMenuOrderImportant: nil⤶  keyComboCheckStringsOfItemsInMenuOrderUnimportant: nil⤶  keyComboAddTestCommentEventListener: nil⤶  keyComboCheckNumberOfMenuItemsEventListener: nil⤶⤶  dragoverEventListener: nil⤶  resizeBrowserEventListener: nil⤶  otherTasksToBeRunOnStep: []⤶⤶⤶  # these variables shouldn't be static to the WorldMorph, because⤶  # in pure theory you could have multiple worlds in the same⤶  # page with different settings⤶  # (but anyways, it was global before, so it's not any worse than before)⤶  @preferencesAndSettings: nil⤶  @currentTime: nil⤶  @currentDate: nil⤶  showRedraws: false⤶  doubleCheckCachedMethodsResults: false⤶⤶  automator: nil⤶⤶  # this is the actual reference to the canvas⤶  # on the html page, where the world is⤶  # finally painted to.⤶  worldCanvas: nil⤶  worldCanvasContext: nil⤶⤶  canvasForTextMeasurements: nil⤶  canvasContextForTextMeasurements: nil⤶  cacheForTextMeasurements: nil⤶  cacheForTextParagraphSplits: nil⤶  cacheForParagraphsWordsSplits: nil⤶  cacheForParagraphsWrappingData: nil⤶  cacheForTextWrappingData: nil⤶  cacheForTextBreakingIntoLinesTopLevel: nil⤶⤶  # By default the world will always fill⤶  # the entire page, also when browser window⤶  # is resized.⤶  # When this flag is set, the onResize callback⤶  # automatically adjusts the world size.⤶  automaticallyAdjustToFillEntireBrowserAlsoOnResize: true⤶⤶⤶⤶  wdgtsDetectingClickOutsideMeOrAnyOfMeChildren: new Set⤶  hierarchyOfClickedWdgts: new Set⤶  hierarchyOfClickedMenus: new Set⤶  popUpsMarkedForClosure: new Set⤶  freshlyCreatedPopUps: new Set⤶  openPopUps: new Set⤶  toolTipsList: new Set⤶⤶  @ongoingUrlActionNumber: 0⤶⤶  @frameCount: 0⤶  @numberOfAddsAndRemoves: 0⤶  @numberOfVisibilityFlagsChanges: 0⤶  @numberOfCollapseFlagsChanges: 0⤶  @numberOfRawMovesAndResizes: 0⤶⤶  broken: nil⤶  duplicatedBrokenRectsTracker: nil⤶  numberOfDuplicatedBrokenRects: 0⤶  numberOfMergedSourceAndDestination: 0⤶⤶  morphsToBeHighlighted: new Set⤶  currentHighlightingMorphs: new Set⤶  morphsBeingHighlighted: new Set⤶⤶  morphsToBePinouted: new Set⤶  currentPinoutingMorphs: new Set⤶  morphsBeingPinouted: new Set⤶⤶  steppingWdgts: new Set⤶⤶  basementWdgt: nil⤶⤶  # since the shadow is just a ＂rendering＂ effect⤶  # there is no morph for it, we need to just clean up⤶  # the shadow area ad-hoc. We do that by just growing any⤶  # broken rectangle by the maximum shadow offset.⤶  # We could be more surgical and remember the offset of the⤶  # shadow (if any) in the start and end location of the⤶  # morph, just like we do with the position, but it⤶  # would complicate things and probably be overkill.⤶  # The downside of this is that if we change the⤶  # shadow sizes, we have to check that this max size⤶  # still captures the biggest.⤶  maxShadowSize: 6⤶⤶  events: []⤶⤶  # Some operations are triggered by a callback⤶  # actioned via a timeout⤶  # e.g. see the cut and paste callbacks.⤶  # In such cases, we count how many outstanding⤶  # callbacks there are of this kind⤶  # (by adding elements to this stack when the⤶  # callback is scheduled, and popping them when⤶  # the callback is executed), so that⤶  # we can tell the automator player to PAUSE⤶  # execution of actions until the scheduled⤶  # callbacks are called. This is so turbo-mode macros⤶  # can be still run at maximum speed.⤶  # The alternative is to run at normal speed the⤶  # macros containing such cases, which⤶  # indeed would also take care of the problem⤶  # (as the callbacks are likely satisfied at running⤶  # time in the same span of time as when the macro⤶  # was recorded), but the ＂slow-play＂⤶  # solution is more ad-hoc and is much much slower.⤶  outstandingTimerTriggeredOperationsCounter: []⤶⤶  widgetsReferencingOtherWidgets: new Set⤶  incrementalGcSessionId: 0⤶  desktopSidesPadding: 10⤶⤶  # the desktop lays down icons vertically⤶  laysIconsHorizontallyInGrid: false⤶  iconsLayingInGridWrapCount: 5⤶⤶  errorsWhileRepainting: []⤶  paintingWidget: nil⤶  widgetsGivingErrorWhileRepainting: []⤶⤶  # this one is so we can left/center/right align in⤶  # a document editor the last widget that the user ＂touched＂⤶  # TODO this could be extended so we keep a ＂list＂ of⤶  # ＂selected＂ widgets (e.g. if the user ctrl-clicks on a widget⤶  # then it highlights in some manner and ends up in this list)⤶  # and then operations can be performed on the whole list⤶  # of widgets.⤶  lastNonTextPropertyChangerButtonClickedOrDropped: nil⤶⤶  patternName: nil⤶  pattern1: ＂plain＂⤶  pattern2: ＂circles＂⤶  pattern3: ＂vert. stripes＂⤶  pattern4: ＂oblique stripes＂⤶  pattern5: ＂dots＂⤶  pattern6: ＂zigzag＂⤶  pattern7: ＂bricks＂⤶⤶  howManyUntitledShortcuts: 0⤶  howManyUntitledFoldersShortcuts: 0⤶⤶  isIndexPage: nil⤶⤶⤶⤶  constructor: (⤶      @worldCanvas,⤶      @automaticallyAdjustToFillEntireBrowserAlsoOnResize = true⤶      ) ->⤶⤶    # The WorldMorph is the very first morph to⤶    # be created.⤶⤶    if window.location.href.includes ＂worldWithSystemTestHarness＂⤶      @isIndexPage = false⤶    else⤶      @isIndexPage = true⤶⤶    WorldMorph.preferencesAndSettings = new PreferencesAndSettings⤶⤶    super()⤶    @patternName = @pattern1⤶    @appearance = new DesktopAppearance @⤶⤶    #console.log WorldMorph.preferencesAndSettings.menuFontName⤶    @color = new Color 205, 205, 205 # (130, 130, 130)⤶    @strokeColor = nil⤶⤶    @alpha = 1⤶⤶    # additional properties:⤶    @stamp = Date.now() # reference in multi-world setups⤶    @isDevMode = false⤶    @hand = new ActivePointerWdgt @⤶    @keyboardEventsReceiver = nil⤶    @lastEditedText = nil⤶    @caret = nil⤶    @temporaryHandlesAndLayoutAdjusters = new Set⤶    @inputDOMElementForVirtualKeyboard = nil⤶⤶    if @automaticallyAdjustToFillEntireBrowserAlsoOnResize and @isIndexPage⤶      @stretchWorldToFillEntirePage()⤶    else⤶      @sizeCanvasToTestScreenResolution()⤶⤶    # @worldCanvas.width and height here are in phisical pixels⤶    # so we want to bring them back to logical pixels⤶    @setBounds new Rectangle 0, 0, @worldCanvas.width / ceilPixelRatio, @worldCanvas.height / ceilPixelRatio⤶⤶    @initEventListeners()⤶    if Automator?⤶      @automator = new Automator⤶⤶    @worldCanvasContext = @worldCanvas.getContext ＂2d＂⤶⤶    @canvasForTextMeasurements = newCanvas()⤶    @canvasContextForTextMeasurements = @canvasForTextMeasurements.getContext ＂2d＂⤶    @canvasContextForTextMeasurements.scale ceilPixelRatio, ceilPixelRatio⤶    @canvasContextForTextMeasurements.textAlign = ＂left＂⤶    @canvasContextForTextMeasurements.textBaseline = ＂bottom＂⤶⤶    # when using an inspector it's not uncommon to render⤶    # 400 labels just for the properties, so trying to size⤶    # the cache accordingly...⤶    @cacheForTextMeasurements = new LRUCache 1000, 1000*60*60*24⤶    @cacheForTextParagraphSplits = new LRUCache 300, 1000*60*60*24⤶    @cacheForParagraphsWordsSplits = new LRUCache 300, 1000*60*60*24⤶    @cacheForParagraphsWrappingData = new LRUCache 300, 1000*60*60*24⤶    @cacheForTextWrappingData = new LRUCache 300, 1000*60*60*24⤶    @cacheForImmutableBackBuffers = new LRUCache 1000, 1000*60*60*24⤶    @cacheForTextBreakingIntoLinesTopLevel = new LRUCache 10, 1000*60*60*24⤶⤶⤶    @changed()⤶⤶  colloquialName: ->⤶    ＂Desktop＂⤶⤶  makePrettier: ->⤶    WorldMorph.preferencesAndSettings.menuFontSize = 14⤶    WorldMorph.preferencesAndSettings.menuHeaderFontSize = 13⤶    WorldMorph.preferencesAndSettings.menuHeaderColor = new Color 125, 125, 125⤶    WorldMorph.preferencesAndSettings.menuHeaderBold = false⤶    WorldMorph.preferencesAndSettings.menuStrokeColor = new Color 186, 186, 186⤶    WorldMorph.preferencesAndSettings.menuBackgroundColor = new Color 250, 250, 250⤶    WorldMorph.preferencesAndSettings.menuButtonsLabelColor = new Color 50, 50, 50⤶⤶    WorldMorph.preferencesAndSettings.normalTextFontSize = 13⤶    WorldMorph.preferencesAndSettings.titleBarTextFontSize = 13⤶    WorldMorph.preferencesAndSettings.titleBarTextHeight = 16⤶    WorldMorph.preferencesAndSettings.titleBarBoldText = false⤶    WorldMorph.preferencesAndSettings.bubbleHelpFontSize = 12⤶⤶⤶    WorldMorph.preferencesAndSettings.iconDarkLineColor = new Color 37, 37, 37⤶⤶⤶    WorldMorph.preferencesAndSettings.defaultPanelsBackgroundColor = new Color 249, 249, 249⤶    WorldMorph.preferencesAndSettings.defaultPanelsStrokeColor = new Color 198, 198, 198⤶⤶    @setPattern nil, nil, ＂dots＂⤶⤶    @changed()⤶⤶  getNextUntitledShortcutName: ->⤶    name = ＂Untitled＂⤶    if @howManyUntitledShortcuts > 0⤶      name += ＂ ＂ + (@howManyUntitledShortcuts + 1)⤶⤶    @howManyUntitledShortcuts++⤶⤶    return name⤶⤶  getNextUntitledFolderShortcutName: ->⤶    name = ＂new folder＂⤶    if @howManyUntitledFoldersShortcuts > 0⤶      name += ＂ ＂ + (@howManyUntitledFoldersShortcuts + 1)⤶⤶    @howManyUntitledFoldersShortcuts++⤶⤶    return name⤶⤶⤶  wantsDropOf: (aWdgt) ->⤶    return @_acceptsDrops⤶⤶  createErrorConsole: ->⤶⤶    errorsLogViewerMorph = new ErrorsLogViewerMorph ＂Errors＂, @, ＂modifyCodeToBeInjected＂, ＂＂⤶    wm = new WindowWdgt nil, nil, errorsLogViewerMorph⤶    wm.setExtent new Point 460, 400⤶    world.add wm⤶    wm.changed()⤶⤶⤶    @errorConsole = wm⤶    @errorConsole.fullMoveTo new Point 190,10⤶    @errorConsole.setExtent new Point 550,415⤶    @errorConsole.hide()⤶⤶  removeSpinnerAndFakeDesktop: ->⤶    # remove the fake desktop for quick launch and the spinner⤶    spinner = document.getElementById 'spinner'⤶    spinner.parentNode.removeChild spinner⤶    splashScreenFakeDesktop = document.getElementById 'splashScreenFakeDesktop'⤶    splashScreenFakeDesktop.parentNode.removeChild splashScreenFakeDesktop⤶⤶  createDesktop: ->⤶    if @isIndexPage⤶      @setColor new Color 244,243,244⤶      @makePrettier()⤶⤶    if !@isIndexPage then console.log ＂booting＂⤶    @basementWdgt = new BasementWdgt⤶⤶⤶⤶    if @isIndexPage⤶      acm = new AnalogClockWdgt⤶      acm.rawSetExtent new Point 80, 80⤶      acm.fullRawMoveTo new Point @right()-80-@desktopSidesPadding, @top() + @desktopSidesPadding⤶      @add acm⤶⤶      menusHelper.createWelcomeMessageWindowAndShortcut()⤶      menusHelper.createHowToSaveMessageOpener()⤶      menusHelper.basementIconAndText()⤶      menusHelper.createSimpleDocumentLauncher()⤶      menusHelper.createFizzyPaintLauncher()⤶      menusHelper.createSimpleSlideLauncher()⤶      menusHelper.createDashboardsLauncher()⤶      menusHelper.createPatchProgrammingLauncher()⤶      menusHelper.createGenericPanelLauncher()⤶      menusHelper.createToolbarsOpener()⤶      exampleDocsFolder = @makeFolder nil, nil, ＂examples＂⤶      menusHelper.createDegreesConverterOpener exampleDocsFolder⤶      menusHelper.createSampleSlideOpener exampleDocsFolder⤶      menusHelper.createSampleDashboardOpener exampleDocsFolder⤶      menusHelper.createSampleDocOpener exampleDocsFolder⤶⤶⤶⤶  mostRecentlyCreatedPopUp: ->⤶    mostRecentPopUp = nil⤶    mostRecentPopUpID = -1⤶⤶    # we have to check which menus⤶    # are actually open, because⤶    # the destroy() function used⤶    # everywhere is not recursive and⤶    # that's where we update the @openPopUps⤶    # set so we have to doublecheck here⤶    @openPopUps.forEach (eachPopUp) =>⤶      if eachPopUp.isOrphan()⤶        @openPopUps.delete eachPopUp⤶      else if eachPopUp.instanceNumericID >= mostRecentPopUpID⤶        mostRecentPopUp = eachPopUp⤶⤶    return mostRecentPopUp⤶⤶⤶⤶  # used to close temporary menus⤶  closePopUpsMarkedForClosure: ->⤶    @popUpsMarkedForClosure.forEach (eachMorph) =>⤶      eachMorph.close()⤶    @popUpsMarkedForClosure.clear()⤶  ⤶⤶  ⤶  ⤶  # fullPaintIntoAreaOrBlitFromBackBuffer results into actual painting of pieces of⤶  # morphs done⤶  # by the paintIntoAreaOrBlitFromBackBuffer function.⤶  # The paintIntoAreaOrBlitFromBackBuffer function is defined in Widget.⤶  fullPaintIntoAreaOrBlitFromBackBuffer: (aContext, aRect) ->⤶    # invokes the Widget's fullPaintIntoAreaOrBlitFromBackBuffer, which has only three implementations:⤶    #  * the default one by Widget which just invokes the paintIntoAreaOrBlitFromBackBuffer of all children⤶    #  * the interesting one in PanelWdgt which a) narrows the dirty⤶    #    rectangle (intersecting it with its border⤶    #    since the PanelWdgt clips at its border) and b) stops recursion on all⤶    #    the children that are outside such intersection.⤶    #  * this implementation which just takes into account that the hand⤶    #    (which could contain a Widget being floatDragged)⤶    #    is painted on top of everything.⤶    super aContext, aRect⤶⤶    # the mouse cursor is always drawn on top of everything⤶    # and it's not attached to the WorldMorph.⤶    @hand.fullPaintIntoAreaOrBlitFromBackBuffer aContext, aRect⤶⤶  clippedThroughBounds: ->⤶    @checkClippedThroughBoundsCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶    @clippedThroughBoundsCache = @boundingBox()⤶    return @clippedThroughBoundsCache⤶⤶  # using the code coverage tool from Chrome, it⤶  # doesn't seem that this is ever used⤶  # TODO investigate and see whether this is needed⤶  clipThrough: ->⤶    @checkClipThroughCache = WorldMorph.numberOfAddsAndRemoves + ＂-＂ + WorldMorph.numberOfVisibilityFlagsChanges + ＂-＂ + WorldMorph.numberOfCollapseFlagsChanges + ＂-＂ + WorldMorph.numberOfRawMovesAndResizes⤶    @clipThroughCache = @boundingBox()⤶    return @clipThroughCache⤶⤶  pushBrokenRect: (brokenMorph, theRect, isSrc) ->⤶    if @duplicatedBrokenRectsTracker[theRect.toString()]?⤶      @numberOfDuplicatedBrokenRects++⤶    else⤶      if isSrc⤶        brokenMorph.srcBrokenRect = @broken.length⤶      else⤶        brokenMorph.dstBrokenRect = @broken.length⤶      if !theRect?⤶        debugger⤶      # if @broken.length == 0⤶      #  debugger⤶      @broken.push theRect⤶    @duplicatedBrokenRectsTracker[theRect.toString()] = true⤶⤶  # using the code coverage tool from Chrome, it⤶  # doesn't seem that this is ever used⤶  # TODO investigate and see whether this is needed⤶  mergeBrokenRectsIfCloseOrPushBoth: (brokenMorph, sourceBroken, destinationBroken) ->⤶    mergedBrokenRect = sourceBroken.merge destinationBroken⤶    mergedBrokenRectArea = mergedBrokenRect.area()⤶    sumArea = sourceBroken.area() + destinationBroken.area()⤶    #console.log ＂mergedBrokenRectArea: ＂ + mergedBrokenRectArea + ＂ (sumArea + sumArea/10): ＂ + (sumArea + sumArea/10)⤶    if mergedBrokenRectArea < sumArea + sumArea/10⤶      @pushBrokenRect brokenMorph, mergedBrokenRect, true⤶      @numberOfMergedSourceAndDestination++⤶    else⤶      @pushBrokenRect brokenMorph, sourceBroken, true⤶      @pushBrokenRect brokenMorph, destinationBroken, false⤶⤶⤶  checkARectWithHierarchy: (aRect, brokenMorph, isSrc) ->⤶    brokenMorphAncestor = brokenMorph⤶⤶    #if brokenMorph instanceof SliderMorph⤶    #  debugger⤶⤶    while brokenMorphAncestor.parent?⤶      brokenMorphAncestor = brokenMorphAncestor.parent⤶      if brokenMorphAncestor.srcBrokenRect?⤶        if !@broken[brokenMorphAncestor.srcBrokenRect]?⤶          debugger⤶        if @broken[brokenMorphAncestor.srcBrokenRect].containsRectangle aRect⤶          if isSrc⤶            @broken[brokenMorph.srcBrokenRect] = nil⤶            brokenMorph.srcBrokenRect = nil⤶          else⤶            @broken[brokenMorph.dstBrokenRect] = nil⤶            brokenMorph.dstBrokenRect = nil⤶        else if aRect.containsRectangle @broken[brokenMorphAncestor.srcBrokenRect]⤶          @broken[brokenMorphAncestor.srcBrokenRect] = nil⤶          brokenMorphAncestor.srcBrokenRect = nil⤶⤶      if brokenMorphAncestor.dstBrokenRect?⤶        if !@broken[brokenMorphAncestor.dstBrokenRect]?⤶          debugger⤶        if @broken[brokenMorphAncestor.dstBrokenRect].containsRectangle aRect⤶          if isSrc⤶            @broken[brokenMorph.srcBrokenRect] = nil⤶            brokenMorph.srcBrokenRect = nil⤶          else⤶            @broken[brokenMorph.dstBrokenRect] = nil⤶            brokenMorph.dstBrokenRect = nil⤶        else if aRect.containsRectangle @broken[brokenMorphAncestor.dstBrokenRect]⤶          @broken[brokenMorphAncestor.dstBrokenRect] = nil⤶          brokenMorphAncestor.dstBrokenRect = nil      ⤶⤶⤶  rectAlreadyIncludedInParentBrokenMorph: ->⤶    for brokenMorph in window.morphsThatMaybeChangedGeometryOrPosition⤶        if brokenMorph.srcBrokenRect?⤶          aRect = @broken[brokenMorph.srcBrokenRect]⤶          @checkARectWithHierarchy aRect, brokenMorph, true⤶        if brokenMorph.dstBrokenRect?⤶          aRect = @broken[brokenMorph.dstBrokenRect]⤶          @checkARectWithHierarchy aRect, brokenMorph, false⤶⤶    for brokenMorph in window.morphsThatMaybeChangedFullGeometryOrPosition⤶        if brokenMorph.srcBrokenRect?⤶          aRect = @broken[brokenMorph.srcBrokenRect]⤶          @checkARectWithHierarchy aRect, brokenMorph⤶        if brokenMorph.dstBrokenRect?⤶          aRect = @broken[brokenMorph.dstBrokenRect]⤶          @checkARectWithHierarchy aRect, brokenMorph⤶⤶  cleanupSrcAndDestRectsOfMorphs: ->⤶    for brokenMorph in window.morphsThatMaybeChangedGeometryOrPosition⤶      brokenMorph.srcBrokenRect = nil⤶      brokenMorph.dstBrokenRect = nil⤶    for brokenMorph in window.morphsThatMaybeChangedFullGeometryOrPosition⤶      brokenMorph.srcBrokenRect = nil⤶      brokenMorph.dstBrokenRect = nil⤶⤶⤶  fleshOutBroken: ->⤶    #if window.morphsThatMaybeChangedGeometryOrPosition.length > 0⤶    #  debugger⤶⤶    sourceBroken = nil⤶    destinationBroken = nil⤶⤶⤶    for brokenMorph in window.morphsThatMaybeChangedGeometryOrPosition⤶⤶      # let's see if this Widget that marked itself as broken⤶      # was actually painted in the past frame.⤶      # If it was then we have to clean up the ＂before＂ area⤶      # even if the Widget is not visible anymore⤶      if brokenMorph.clippedBoundsWhenLastPainted?⤶        if brokenMorph.clippedBoundsWhenLastPainted.isNotEmpty()⤶          sourceBroken = brokenMorph.clippedBoundsWhenLastPainted.expandBy(1).growBy @maxShadowSize⤶⤶        #if brokenMorph!= world and (brokenMorph.clippedBoundsWhenLastPainted.containsPoint (new Point(10,10)))⤶        #  debugger⤶⤶      # for the ＂destination＂ broken rectangle we can actually⤶      # check whether the Widget is still visible because we⤶      # can skip the destination rectangle in that case⤶      # (not the source one!)⤶      unless brokenMorph.surelyNotShowingUpOnScreenBasedOnVisibilityCollapseAndOrphanage()⤶        # @clippedThroughBounds() should be smaller area⤶        # than bounds because it clips⤶        # the bounds based on the clipping morphs up the⤶        # hierarchy⤶        boundsToBeChanged = brokenMorph.clippedThroughBounds()⤶⤶        if boundsToBeChanged.isNotEmpty()⤶          destinationBroken = boundsToBeChanged.spread().expandBy(1).growBy @maxShadowSize⤶          #if brokenMorph!= world and (boundsToBeChanged.spread().containsPoint new Point 10, 10)⤶          #  debugger⤶⤶⤶      if sourceBroken? and destinationBroken?⤶        @mergeBrokenRectsIfCloseOrPushBoth brokenMorph, sourceBroken, destinationBroken⤶      else if sourceBroken? or destinationBroken?⤶        if sourceBroken?⤶          @pushBrokenRect brokenMorph, sourceBroken, true⤶        else⤶          @pushBrokenRect brokenMorph, destinationBroken, true⤶⤶      brokenMorph.geometryOrPositionPossiblyChanged = false⤶      brokenMorph.clippedBoundsWhenLastPainted = nil⤶⤶    ⤶⤶  fleshOutFullBroken: ->⤶    #if window.morphsThatMaybeChangedFullGeometryOrPosition.length > 0⤶    #  debugger⤶⤶    sourceBroken = nil⤶    destinationBroken = nil⤶⤶    for brokenMorph in window.morphsThatMaybeChangedFullGeometryOrPosition⤶⤶      #console.log ＂fleshOutFullBroken: ＂ + brokenMorph⤶⤶      if brokenMorph.fullClippedBoundsWhenLastPainted?⤶        if brokenMorph.fullClippedBoundsWhenLastPainted.isNotEmpty()⤶          sourceBroken = brokenMorph.fullClippedBoundsWhenLastPainted.expandBy(1).growBy @maxShadowSize⤶⤶      # for the ＂destination＂ broken rectangle we can actually⤶      # check whether the Widget is still visible because we⤶      # can skip the destination rectangle in that case⤶      # (not the source one!)⤶      unless brokenMorph.surelyNotShowingUpOnScreenBasedOnVisibilityCollapseAndOrphanage()⤶⤶        boundsToBeChanged = brokenMorph.fullClippedBounds()⤶⤶        if boundsToBeChanged.isNotEmpty()⤶          destinationBroken = boundsToBeChanged.spread().expandBy(1).growBy @maxShadowSize⤶          #if brokenMorph!= world and (boundsToBeChanged.spread().containsPoint (new Point(10,10)))⤶          #  debugger⤶      ⤶   ⤶      if sourceBroken? and destinationBroken?⤶        @mergeBrokenRectsIfCloseOrPushBoth brokenMorph, sourceBroken, destinationBroken⤶      else if sourceBroken? or destinationBroken?⤶        if sourceBroken?⤶          @pushBrokenRect brokenMorph, sourceBroken, true⤶        else⤶          @pushBrokenRect brokenMorph, destinationBroken, true⤶⤶      brokenMorph.fullGeometryOrPositionPossiblyChanged = false⤶      brokenMorph.fullClippedBoundsWhenLastPainted = nil⤶⤶⤶⤶⤶⤶  # layouts are recalculated like so:⤶  # there will be several subtrees⤶  # that will need relayout.⤶  # So take the head of any subtree and re-layout it⤶  # The relayout might or might not visit all the subnodes⤶  # of the subtree, because you might have a subtree⤶  # that lives inside a floating morph, in which⤶  # case it's not re-layout.⤶  # So, a subtree might not be healed in one go,⤶  # rather we keep track of what's left to heal and⤶  # we apply the same process: we heal from the head node⤶  # and take out of the list what's healed in that step,⤶  # and we continue doing so until there is nothing else⤶  # to heal.⤶  recalculateLayouts: ->⤶⤶    until morphsThatMaybeChangedLayout.length == 0⤶⤶      # find the first Widget which has a broken layout,⤶      # take out of queue all the others⤶      loop⤶        tryThisMorph = morphsThatMaybeChangedLayout[morphsThatMaybeChangedLayout.length - 1]⤶        if tryThisMorph.layoutIsValid⤶          morphsThatMaybeChangedLayout.pop()⤶          if morphsThatMaybeChangedLayout.length == 0⤶            return⤶        else⤶          break⤶⤶      # now that you have a Widget with a broken layout⤶      # go up the chain of broken layouts as much as⤶      # possible⤶      # QUESTION: would it be safer instead to start from the⤶      # very top invalid morph, i.e. on the way to the top,⤶      # stop at the last morph with an invalid layout⤶      # instead of stopping at the first morph with a⤶      # valid layout...⤶      while tryThisMorph.parent?⤶        if tryThisMorph.layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING or tryThisMorph.parent.layoutIsValid⤶          break⤶        tryThisMorph = tryThisMorph.parent⤶⤶      try⤶        # so now you have a ＂top＂ element up a chain⤶        # of morphs with broken layout. Go do a⤶        # doLayout on it, so it might fix a bunch of those⤶        # on the chain (but not all)⤶        tryThisMorph.doLayout()⤶      catch err⤶        @softResetWorld()⤶        if !world.errorConsole? then world.createErrorConsole()⤶        @errorConsole.contents.showUpWithError err⤶⤶⤶  clearGeometryOrPositionPossiblyChangedFlags: ->⤶    for m in window.morphsThatMaybeChangedGeometryOrPosition⤶      m.geometryOrPositionPossiblyChanged = false⤶⤶  clearFullGeometryOrPositionPossiblyChangedFlags: ->⤶    for m in window.morphsThatMaybeChangedFullGeometryOrPosition⤶      m.fullGeometryOrPositionPossiblyChanged = false⤶⤶  updateBroken: ->⤶    #console.log ＂number of broken rectangles: ＂ + @broken.length⤶    @broken = []⤶    @duplicatedBrokenRectsTracker = {}⤶    @numberOfDuplicatedBrokenRects = 0⤶    @numberOfMergedSourceAndDestination = 0⤶⤶    @fleshOutFullBroken()⤶    @fleshOutBroken()⤶    @rectAlreadyIncludedInParentBrokenMorph()⤶    @cleanupSrcAndDestRectsOfMorphs()⤶⤶    @clearGeometryOrPositionPossiblyChangedFlags()⤶    @clearFullGeometryOrPositionPossiblyChangedFlags()⤶⤶    window.morphsThatMaybeChangedGeometryOrPosition = []⤶    window.morphsThatMaybeChangedFullGeometryOrPosition = []⤶⤶⤶    # each broken rectangle requires traversing the scenegraph to⤶    # redraw what's overlapping it. Not all Widgets are traversed⤶    # in particular the following can stop the recursion:⤶    #  - invisible Widgets⤶    #  - PanelWdgts that don't overlap the broken rectangle⤶    # Since potentially there is a lot of traversal ongoin for⤶    # each broken rectangle, one might want to consolidate overlapping⤶    # and nearby rectangles.⤶⤶    window.healingRectanglesPhase = true⤶⤶    @errorsWhileRepainting = []⤶⤶    @broken.forEach (rect) =>⤶      if !rect?⤶        return⤶      if rect.isNotEmpty()⤶        try⤶          @fullPaintIntoAreaOrBlitFromBackBuffer @worldCanvasContext, rect⤶        catch err⤶          @resetWorldCanvasContext()⤶          @queueErrorForLaterReporting err⤶          @hideOffendingWidget()⤶          @softResetWorld()⤶⤶    # IF we got errors while repainting, the⤶    # screen might be in a bad state (because everything in front of the⤶    # ＂bad＂ widget is not repainted since the offending widget has⤶    # thrown, so nothing in front of it could be painted properly)⤶    # SO do COMPLETE repaints of the screen and hide⤶    # further offending widgets until there are no more errors⤶    # (i.e. the offending widgets are progressively hidden so eventually⤶    # we should repaint the whole screen without errors, hopefully)⤶    if @errorsWhileRepainting.length != 0⤶      @findOutAllOtherOffendingWidgetsAndPaintWholeScreen()⤶⤶    if world.showRedraws⤶      @showBrokenRects @worldCanvasContext⤶⤶    @resetDataStructuresForBrokenRects()⤶⤶    window.healingRectanglesPhase = false⤶    if trackChanges.length != 1 and trackChanges[0] != true⤶      alert ＂trackChanges array should have only one element (true)＂⤶⤶  findOutAllOtherOffendingWidgetsAndPaintWholeScreen: ->⤶    # we keep repainting the whole screen until there are no⤶    # errors.⤶    # Why do we need multiple repaints and not just one?⤶    # Because remember that when a widget throws an error while⤶    # repainting, it bubble all the way up and stops any⤶    # further repainting of the other widgets, potentially⤶    # preventing the finding of errors in the other⤶    # widgets. Hence, we need to keep repainting until⤶    # there are no errors.⤶⤶    currentErrorsCount = @errorsWhileRepainting.length⤶    previousErrorsCount = nil⤶    numberOfTotalRepaints = 0⤶    until previousErrorsCount == currentErrorsCount⤶      numberOfTotalRepaints++⤶      try⤶        @fullPaintIntoAreaOrBlitFromBackBuffer @worldCanvasContext, @bounds⤶      catch err⤶        @resetWorldCanvasContext()⤶        @queueErrorForLaterReporting err⤶        @hideOffendingWidget()⤶        @softResetWorld()⤶⤶      previousErrorsCount = currentErrorsCount⤶      currentErrorsCount = @errorsWhileRepainting.length⤶⤶    #console.log ＂total repaints: ＂ + numberOfTotalRepaints⤶⤶  resetWorldCanvasContext: ->⤶    # when an error is thrown while painting, it's⤶    # possible that we are left with a context in a strange⤶    # mixed state, so try to bring it back to⤶    # normality as much as possible⤶    # We are doing this for ＂cleanliness＂ of the context⤶    # state, not because we care of the drawing being⤶    # perfect (we are eventually going to repaint the⤶    # whole screen without the offending widgets⤶    # widgets).⤶    @worldCanvasContext.closePath()⤶    @worldCanvasContext.resetClip?()⤶    @worldCanvasContext.resetTransform?()⤶    for j in [1...2000]⤶      @worldCanvasContext.restore()⤶⤶  queueErrorForLaterReporting: (err) ->⤶    # now record the error so we can report it in the⤶    # next cycle, and add the offending widget to a⤶    # ＂banned＂ list⤶    @errorsWhileRepainting.push err⤶    if !@widgetsGivingErrorWhileRepainting.includes @paintingWidget⤶      @widgetsGivingErrorWhileRepainting.push @paintingWidget⤶      @paintingWidget.silentHide()⤶⤶  hideOffendingWidget: ->⤶    if !@widgetsGivingErrorWhileRepainting.includes @paintingWidget⤶      @widgetsGivingErrorWhileRepainting.push @paintingWidget⤶      @paintingWidget.silentHide()⤶⤶  resetDataStructuresForBrokenRects: ->⤶    @broken = []⤶    @duplicatedBrokenRectsTracker = {}⤶    @numberOfDuplicatedBrokenRects = 0⤶    @numberOfMergedSourceAndDestination = 0⤶⤶⤶  ⤶  addHighlightingMorphs: ->⤶    @currentHighlightingMorphs.forEach (eachHighlightingMorph) =>⤶      if @morphsToBeHighlighted.has eachHighlightingMorph.wdgtThisWdgtIsHighlighting⤶        if eachHighlightingMorph.wdgtThisWdgtIsHighlighting.hasMaybeChangedGeometryOrPosition()⤶          eachHighlightingMorph.rawSetBounds eachHighlightingMorph.wdgtThisWdgtIsHighlighting.clippedThroughBounds()⤶      else⤶        @currentHighlightingMorphs.delete eachHighlightingMorph⤶        @morphsBeingHighlighted.delete eachHighlightingMorph.wdgtThisWdgtIsHighlighting⤶        eachHighlightingMorph.wdgtThisWdgtIsHighlighting = nil⤶        eachHighlightingMorph.fullDestroy()⤶⤶    @morphsToBeHighlighted.forEach (eachMorphNeedingHighlight) =>⤶      unless @morphsBeingHighlighted.has eachMorphNeedingHighlight ⤶        hM = new HighlighterMorph⤶        world.add hM⤶        hM.wdgtThisWdgtIsHighlighting = eachMorphNeedingHighlight⤶        hM.rawSetBounds eachMorphNeedingHighlight.clippedThroughBounds()⤶        hM.setColor new Color 0, 0, 255⤶        hM.setAlphaScaled 50⤶        @currentHighlightingMorphs.add hM⤶        @morphsBeingHighlighted.add eachMorphNeedingHighlight⤶⤶⤶  playQueuedEvents: ->⤶    try⤶⤶      for i in [0...@events.length] by 2⤶        eventType = @events[i]⤶        # note that these events are actually strings⤶        # in the case of clipboard events. Since⤶        # for security reasons clipboard access is not⤶        # allowed outside of the event listener, we⤶        # have to work with text here.⤶        event = @events[i+1]⤶⤶        switch eventType⤶⤶          # --------------------------------------⤶          # input DOM element for virtual keyboard⤶          # --------------------------------------⤶⤶          when ＂inputDOMElementForVirtualKeyboardKeydownBrowserEvent＂⤶            @keyboardEventsReceiver?.processKeyDown event⤶⤶            if event.keyIdentifier is ＂U+0009＂ or event.keyIdentifier is ＂Tab＂⤶              @keyboardEventsReceiver?.processKeyPress event⤶⤶          when ＂inputDOMElementForVirtualKeyboardKeyupBrowserEvent＂⤶            # dispatch to keyboard receiver⤶            # so far the caret is the only keyboard⤶            # event handler and it has no keyup⤶            # handler⤶            @keyboardEventsReceiver?.processKeyUp? event  ⤶⤶          when ＂inputDOMElementForVirtualKeyboardKeypressBrowserEvent＂⤶            @keyboardEventsReceiver?.processKeyPress event⤶⤶          # -----⤶          # mouse⤶          # -----⤶⤶          # TODO mouseup and mousedown currently don't take the pointer position⤶          # from the event - the idea being that the position is always changed⤶          # by a mousemove, so we only change the pointer position on move events⤶          # so we don't need it on mouseup or mousedown.⤶          # While this thinking is ＂parsimonious＂, it doesn't apply well to pointer events,⤶          # where there is no pointer update until the ＂down＂ happens.⤶          # So we'll need to correct this eventually⤶⤶          when ＂mousedownBrowserEvent＂⤶            @mousedownBrowserEventHandler event.button, event.buttons, event.ctrlKey, event.shiftKey, event.altKey, event.metaKey⤶            #console.log ＂mousedownBrowserEventHandler ＂ + event.button + ＂  ＂ + event.buttons⤶⤶          when ＂mouseupBrowserEvent＂⤶            @mouseupBrowserEventHandler  event.button, event.ctrlKey, event.buttons, event.shiftKey, event.altKey, event.metaKey⤶            #console.log ＂mouseupBrowserEventHandler ＂ + event.button + ＂  ＂ + event.buttons⤶⤶          when ＂mousemoveBrowserEvent＂⤶            @mousemoveBrowserEventHandler event.pageX, event.pageY, event.button, event.buttons, event.ctrlKey, event.shiftKey, event.altKey, event.metaKey⤶            #console.log ＂mousemoveBrowserEventHandler ＂ + event.button + ＂  ＂ + event.buttons + ＂  ＂ + event.pageX + ＂  ＂ + event.pageY⤶⤶          when ＂wheelBrowserEvent＂⤶            @wheelBrowserEventHandler event.deltaX, event.deltaY, event.deltaZ, event.altKey, event.button, event.buttons⤶⤶          # -----⤶          # touch⤶          # -----⤶⤶          when ＂touchstartBrowserEvent＂⤶            # note that the position can be non-integer, so rounding it⤶            # we have no real use for fractional input position and it's complicated⤶            # to handle for drawing, clipping etc., better stick to integer coords⤶            @mousemoveBrowserEventHandler Math.round(event.touches[0].pageX), Math.round(event.touches[0].pageY), 0, 0, false, false, false, false⤶            @mousedownBrowserEventHandler 0, 1, false, false, false, false⤶            #console.log ＂touchstartBrowserEvent＂⤶⤶          when ＂touchendBrowserEvent＂⤶            @mouseupBrowserEventHandler  0, false, 0, false, false, false⤶            #console.log ＂touchendBrowserEvent＂⤶⤶          when ＂touchmoveBrowserEvent＂⤶            # note that the position can be non-integer, so rounding it⤶            # we have no real use for fractional input position and it's complicated⤶            # to handle for drawing, clipping etc., better stick to integer coords⤶            @mousemoveBrowserEventHandler Math.round(event.touches[0].pageX), Math.round(event.touches[0].pageY), 0, 1, false, false, false, false⤶            #console.log ＂touchmoveBrowserEvent ＂ + event.touches[0].pageX + ＂  ＂ + event.touches[0].pageY⤶⤶          when ＂gesturestartBrowserEvent＂⤶            ＂doNothing＂⤶⤶          when ＂gesturechangeBrowserEvent＂⤶            ＂doNothing＂⤶⤶          # --------⤶          # keyboard⤶          # --------⤶⤶          when ＂keydownBrowserEvent＂⤶            @keydownBrowserEventHandler event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey⤶⤶          when ＂keyupBrowserEvent＂⤶            @keyupBrowserEventHandler event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey⤶⤶          when ＂keypressBrowserEvent＂⤶            @keypressBrowserEventHandler event.keyCode, @getChar(event), event.shiftKey, event.ctrlKey, event.altKey, event.metaKey⤶⤶          # ------------------⤶          # cut / copy / paste⤶          # ------------------⤶⤶          when ＂cutBrowserEvent＂⤶            # note that ＂event＂ here is actually a string,⤶            # for security reasons clipboard access is not⤶            # allowed outside of the event listener, we⤶            # have to work with text here.⤶            @cutBrowserEventHandler event⤶⤶          when ＂copyBrowserEvent＂⤶            # note that ＂event＂ here is actually a string,⤶            # for security reasons clipboard access is not⤶            # allowed outside of the event listener, we⤶            # have to work with text here.⤶            @copyBrowserEventHandler event⤶⤶          when ＂pasteBrowserEvent＂⤶            # note that ＂event＂ here is actually a string,⤶            # for security reasons clipboard access is not⤶            # allowed outside of the event listener, we⤶            # have to work with text here.⤶            @pasteBrowserEventHandler event⤶⤶          # ------⤶          # others⤶          # ------⤶⤶⤶⤶          when ＂resizeBrowserEvent＂⤶            @resizeBrowserEventHandler()⤶⤶    catch err⤶      @softResetWorld()⤶      if !world.errorConsole? then world.createErrorConsole()⤶      @errorConsole.contents.showUpWithError err⤶⤶    @events = []⤶⤶  # we keep the ＂pacing＂ promises in this⤶  # srcLoadsSteps array, (or, more precisely,⤶  # we keep their resolving functions) and each frame⤶  # we resolve one, so we don't cause gitter.⤶  loadAPartOfFizzyGumSourceIfNeeded: ->⤶    if window.srcLoadsSteps.length > 0⤶      resolvingFunction = window.srcLoadsSteps.shift()⤶      resolvingFunction.call()⤶⤶  showErrorsHappenedInRepaintingStepInPreviousCycle: ->⤶    for eachErr in @errorsWhileRepainting⤶      if !world.errorConsole? then world.createErrorConsole()⤶      @errorConsole.contents.showUpWithError eachErr⤶⤶  doOneCycle: ->⤶    WorldMorph.currentTime = Date.now()⤶    WorldMorph.currentDate = new Date⤶    #console.log TextMorph.instancesCounter + ＂ ＂ + StringMorph.instancesCounter⤶⤶    @showErrorsHappenedInRepaintingStepInPreviousCycle()⤶⤶    @playQueuedEvents()⤶⤶    # replays test actions at the right time⤶    if AutomatorPlayer? and Automator.state == Automator.PLAYING⤶      @automator.player.replayTestCommands()⤶    ⤶    # currently unused⤶    @runOtherTasksStepFunction()⤶    ⤶    @loadAPartOfFizzyGumSourceIfNeeded()⤶    ⤶    @runChildrensStepFunction()⤶    @hand.reCheckMouseEntersAndMouseLeavesAfterPotentialGeometryChanges()⤶    window.recalculatingLayouts = true⤶    @recalculateLayouts()⤶    window.recalculatingLayouts = false⤶⤶    @addHighlightingMorphs()⤶⤶    # here is where the repainting on screen happens⤶    @updateBroken()⤶⤶    WorldMorph.frameCount++⤶⤶  # Widget stepping:⤶  runChildrensStepFunction: ->⤶⤶⤶    # TODO all these set modifications should be immutable...⤶    @steppingWdgts.forEach (eachSteppingMorph) =>⤶⤶      #if eachSteppingMorph.isBeingFloatDragged()⤶      #  continue⤶⤶      # for objects where @fps is defined, check which ones are due to be stepped⤶      # and which ones want to wait.⤶      millisBetweenSteps = Math.round(1000 / eachSteppingMorph.fps)⤶      if eachSteppingMorph.fps <= 0⤶        # if fps 0 or negative, then just run as fast as possible,⤶        # so 0 milliseconds remaining to the next invokation⤶        millisecondsRemainingToWaitedFrame = 0⤶      else⤶        if eachSteppingMorph.synchronisedStepping⤶          millisecondsRemainingToWaitedFrame = millisBetweenSteps - (WorldMorph.currentTime % millisBetweenSteps)⤶          if eachSteppingMorph.previousMillisecondsRemainingToWaitedFrame != 0 and millisecondsRemainingToWaitedFrame > eachSteppingMorph.previousMillisecondsRemainingToWaitedFrame⤶            millisecondsRemainingToWaitedFrame = 0⤶          eachSteppingMorph.previousMillisecondsRemainingToWaitedFrame = millisecondsRemainingToWaitedFrame⤶          #console.log millisBetweenSteps + ＂ ＂ + millisecondsRemainingToWaitedFrame⤶        else⤶          elapsedMilliseconds = WorldMorph.currentTime - eachSteppingMorph.lastTime⤶          millisecondsRemainingToWaitedFrame = millisBetweenSteps - elapsedMilliseconds⤶      ⤶      # when the firing time comes (or as soon as it's past):⤶      if millisecondsRemainingToWaitedFrame <= 0⤶        @stepWidget eachSteppingMorph⤶⤶        # Increment ＂lastTime＂ by millisBetweenSteps. Two notes:⤶        # 1) We don't just set it to currentTime so that there is no drifting⤶        # in running it the next time: we run it the next time as if this time it⤶        # ran exactly on time.⤶        # 2) We are going to update ＂last time＂ with the loop⤶        # below. This is because in case the window is not in foreground,⤶        # requestAnimationFrame doesn't run, so we might skip a number of steps.⤶        # In such cases, just bring ＂lastTime＂ up to speed here.⤶        # If we don't do that, ＂skipped＂ steps would catch up on us and run all⤶        # in contigous frames when the window comes to foreground, so the⤶        # widgets would animate frantically (every frame) catching up on⤶        # all the steps they missed. We don't want that.⤶        #⤶        # while eachSteppingMorph.lastTime + millisBetweenSteps < WorldMorph.currentTime⤶        #   eachSteppingMorph.lastTime += millisBetweenSteps⤶        #⤶        # 3) and finally, here is the equivalent of the loop above, but done⤶        # in one shot using remainders.⤶        # Again: we are looking for the last ＂multiple＂ k such that⤶        #      lastTime + k * millisBetweenSteps⤶        # is less than currentTime.⤶⤶        eachSteppingMorph.lastTime = WorldMorph.currentTime - ((WorldMorph.currentTime - eachSteppingMorph.lastTime) % millisBetweenSteps)⤶⤶⤶⤶  stepWidget: (whichWidget) ->⤶    if whichWidget.onNextStep⤶      nxt = whichWidget.onNextStep⤶      whichWidget.onNextStep = nil⤶      nxt.call whichWidget⤶    if !whichWidget.step?⤶      debugger⤶    try⤶      whichWidget.step()⤶      #console.log ＂stepping ＂ + whichWidget⤶    catch err⤶      @softResetWorld()⤶      if !world.errorConsole? then world.createErrorConsole()⤶      @errorConsole.contents.showUpWithError err⤶⤶  ⤶  runOtherTasksStepFunction : ->⤶    for task in @otherTasksToBeRunOnStep⤶      #console.log ＂running a task: ＂ + task⤶      task()⤶⤶⤶⤶  stretchWorldToFillEntirePage: ->⤶    # once you call this, the world will forever take the whole page⤶    @automaticallyAdjustToFillEntireBrowserAlsoOnResize = true⤶    pos = getDocumentPositionOf @worldCanvas⤶    clientHeight = window.innerHeight⤶    clientWidth = window.innerWidth⤶    if pos.x > 0⤶      @worldCanvas.style.position = ＂absolute＂⤶      @worldCanvas.style.left = ＂0px＂⤶      pos.x = 0⤶    if pos.y > 0⤶      @worldCanvas.style.position = ＂absolute＂⤶      @worldCanvas.style.top = ＂0px＂⤶      pos.y = 0⤶    # scrolled down b/c of viewport scaling⤶    clientHeight = document.documentElement.clientHeight  if document.body.scrollTop⤶    # scrolled left b/c of viewport scaling⤶    clientWidth = document.documentElement.clientWidth  if document.body.scrollLeft⤶⤶    if (@worldCanvas.width isnt clientWidth) or (@worldCanvas.height isnt clientHeight)⤶      @fullChanged()⤶      @worldCanvas.width = (clientWidth * ceilPixelRatio)⤶      @worldCanvas.style.width = clientWidth + ＂px＂⤶      @worldCanvas.height = (clientHeight * ceilPixelRatio)⤶      @worldCanvas.style.height = clientHeight + ＂px＂⤶      @rawSetExtent new Point clientWidth, clientHeight⤶      @desktopReLayout()⤶  ⤶⤶  desktopReLayout: ->⤶    basementOpenerWdgt = @firstChildSuchThat (w) ->⤶      w instanceof BasementOpenerWdgt⤶    if basementOpenerWdgt?⤶      if basementOpenerWdgt.userMovedThisFromComputedPosition⤶        basementOpenerWdgt.fullRawMoveInDesktopToFractionalPosition()⤶        if !basementOpenerWdgt.wasPositionedSlightlyOutsidePanel⤶          basementOpenerWdgt.fullRawMoveWithin @⤶      else⤶        basementOpenerWdgt.fullMoveTo @bottomRight().subtract (new Point 75, 75).add @desktopSidesPadding⤶⤶    analogClockWdgt = @firstChildSuchThat (w) ->⤶      w instanceof AnalogClockWdgt⤶    if analogClockWdgt?⤶      if analogClockWdgt.userMovedThisFromComputedPosition⤶        analogClockWdgt.fullRawMoveInDesktopToFractionalPosition()⤶        if !analogClockWdgt.wasPositionedSlightlyOutsidePanel⤶          analogClockWdgt.fullRawMoveWithin @⤶      else⤶        analogClockWdgt.fullMoveTo new Point @right() - 80 - @desktopSidesPadding, @top() + @desktopSidesPadding ⤶⤶    @children.forEach (child) =>⤶      if child != basementOpenerWdgt and child != analogClockWdgt and  !(child instanceof WidgetHolderWithCaptionWdgt)⤶        if child.positionFractionalInHoldingPanel?⤶          child.fullRawMoveInDesktopToFractionalPosition()⤶        if !child.wasPositionedSlightlyOutsidePanel⤶          child.fullRawMoveWithin @⤶  ⤶  # WorldMorph events:⤶⤶⤶⤶  getPointerAndWdgtInfo:  (topWdgtUnderPointer = @hand.topWdgtUnderPointer()) ->⤶    # we might eliminate this command afterwards if⤶    # we find out user is clicking on a menu item⤶    # or right-clicking on a morph⤶    absoluteBoundsOfMorphRelativeToWorld = topWdgtUnderPointer.boundingBox().asArray_xywh()⤶    morphIdentifierViaTextLabel = topWdgtUnderPointer.identifyViaTextLabel()⤶    morphPathRelativeToWorld = topWdgtUnderPointer.pathOfChildrenPositionsRelativeToWorld()⤶    pointerPositionFractionalInMorph = @hand.positionFractionalInMorph topWdgtUnderPointer⤶    pointerPositionPixelsInMorph = @hand.positionPixelsInMorph topWdgtUnderPointer⤶    # note that this pointer position is in world⤶    # coordinates not in page coordinates⤶    pointerPositionPixelsInWorld = @hand.position()⤶    isPartOfListMorph = (topWdgtUnderPointer.parentThatIsA ListMorph)?⤶    return [ topWdgtUnderPointer.uniqueIDString(), morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph]⤶⤶⤶  addMouseChangeCommand: (upOrDown, button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->⤶    if Automator? and Automator.state == Automator.RECORDING⤶      pointerAndWdgtInfo = @getPointerAndWdgtInfo()⤶      @automator.recorder.addMouseChangeCommand upOrDown, button, buttons, ctrlKey, shiftKey, altKey, metaKey, pointerAndWdgtInfo...⤶⤶⤶  mousedownBrowserEventHandler: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->⤶    # the recording of the test command (in case we are⤶    # recording a test) is handled inside the function⤶    # here below.⤶    # This is different from the other methods similar⤶    # to this one but there is a little bit of⤶    # logic we apply in case there is a right-click,⤶    # or user left or right-clicks on a menu,⤶    # in which case we record a more specific test⤶    # commands.⤶    @addMouseChangeCommand ＂down＂, button, buttons, ctrlKey, shiftKey, altKey, metaKey⤶    @hand.processMouseDown button, buttons, ctrlKey, shiftKey, altKey, metaKey⤶⤶  mouseupBrowserEventHandler: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->⤶    @addMouseChangeCommand ＂up＂, button, buttons, ctrlKey, shiftKey, altKey, metaKey⤶    @hand.processMouseUp button, buttons, ctrlKey, shiftKey, altKey, metaKey⤶⤶  mousemoveBrowserEventHandler: (pageX, pageY, button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->⤶    posInDocument = getDocumentPositionOf @worldCanvas⤶    # events from JS arrive in page coordinates,⤶    # we turn those into world coordinates⤶    # instead.⤶    worldX = pageX - posInDocument.x⤶    worldY = pageY - posInDocument.y⤶⤶    @hand.processMouseMove worldX, worldY, button, buttons, ctrlKey, shiftKey, altKey, metaKey⤶    # ＂@hand.processMouseMove＂ could cause a Grab⤶    # command to be issued, so we want to⤶    # add the mouse move command here *after* the⤶    # potential grab command.⤶⤶    if @hand.isThisPointerFloatDraggingSomething()⤶      if Automator? and Automator.state == Automator.RECORDING⤶        action = ＂floatDrag＂⤶        arr = world.automator.tagsCollectedWhileRecordingTest⤶        if action not in arr⤶          arr.push action⤶    ⤶    if Automator? and Automator.state == Automator.RECORDING⤶      @automator.recorder.addMouseMoveCommand(worldX, worldY, @hand.isThisPointerFloatDraggingSomething(), button, buttons, ctrlKey, shiftKey, altKey, metaKey)⤶⤶⤶  wheelBrowserEventHandler: (deltaX, deltaY, deltaZ, altKey, button, buttons) ->⤶    if Automator? and Automator.state == Automator.RECORDING⤶      pointerAndWdgtInfo = @getPointerAndWdgtInfo()⤶      @automator.recorder.addWheelCommand deltaX, deltaY, deltaZ, altKey, button, buttons, pointerAndWdgtInfo...⤶⤶    @hand.processWheel deltaX, deltaY, deltaZ, altKey, button, buttons⤶⤶⤶  # event.type must be keypress⤶  getChar: (event) ->⤶    unless event.which?⤶      String.fromCharCode event.keyCode # IE⤶    else if event.which isnt 0 and event.charCode isnt 0⤶      String.fromCharCode event.which # the rest⤶    else⤶      nil # special key⤶⤶  keydownBrowserEventHandler: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->⤶    if Automator? and Automator.state == Automator.RECORDING⤶      @automator.recorder.addKeyDownCommand scanCode, shiftKey, ctrlKey, altKey, metaKey⤶    @keyboardEventsReceiver?.processKeyDown scanCode, shiftKey, ctrlKey, altKey, metaKey⤶⤶  keyupBrowserEventHandler: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->⤶    if Automator? and Automator.state == Automator.RECORDING⤶      @automator.recorder.addKeyUpCommand scanCode, shiftKey, ctrlKey, altKey, metaKey⤶    # dispatch to keyboard receiver⤶    # so far the caret is the only keyboard⤶    # event handler and it has no keyup⤶    # handler⤶    @keyboardEventsReceiver?.processKeyUp? scanCode, shiftKey, ctrlKey, altKey, metaKey⤶⤶  keypressBrowserEventHandler: (charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->⤶    if Automator? and Automator.state == Automator.RECORDING⤶      @automator.recorder.addKeyPressCommand charCode, symbol, shiftKey, ctrlKey, altKey, metaKey⤶⤶⤶⤶    @keyboardEventsReceiver?.processKeyPress charCode, symbol, shiftKey, ctrlKey, altKey, metaKey⤶⤶  # -----------------------------------------------------⤶  # clipboard events processing⤶  # -----------------------------------------------------⤶  # clipboard events take a text instead of the event,⤶  # the reason is that you can't access the clipboard⤶  # outside of the EventListener, I presume for⤶  # security reasons. So, since these process* methods⤶  # are executed outside of the listeners, we really can't use⤶  # the event and the clipboard object in the event, so⤶  # we have to work with text. The clipboard IS handled, but⤶  # it's handled in the listeners⤶⤶  cutBrowserEventHandler: (selectedText) ->⤶    #console.log ＂processing cut＂⤶    @caret?.processCut selectedText⤶⤶    if Automator? and Automator.state == Automator.RECORDING⤶      @automator.recorder.addCutCommand selectedText⤶⤶  copyBrowserEventHandler: (selectedText) ->⤶    #console.log ＂processing copy＂⤶    if Automator? and Automator.state == Automator.RECORDING⤶      @automator.recorder.addCopyCommand selectedText⤶⤶  pasteBrowserEventHandler: (clipboardText) ->⤶    #console.log ＂processing paste＂⤶    if @caret⤶      @caret.processPaste clipboardText⤶      if Automator? and Automator.state == Automator.RECORDING⤶        @automator.recorder.addPasteCommand selectedText⤶⤶⤶⤶  resizeBrowserEventHandler: ->⤶    #console.log ＂processing resize＂⤶    if @automaticallyAdjustToFillEntireBrowserAlsoOnResize⤶      @stretchWorldToFillEntirePage()⤶⤶  initMouseEventListeners: ->⤶    canvas = @worldCanvas⤶    # there is indeed a ＂dblclick＂ JS event⤶    # but we reproduce it internally.⤶    # The reason is that we do so for ＂click＂⤶    # because we want to check that the mouse⤶    # button was released in the same morph⤶    # where it was pressed (cause in the DOM you'd⤶    # be pressing and releasing on the same⤶    # element i.e. the canvas anyways⤶    # so we receive clicks even though they aren't⤶    # so we have to take care of the processing⤶    # ourselves).⤶    # So we also do the same internal⤶    # processing for dblclick.⤶    # Hence, don't register this event listener⤶    # below...⤶    #@dblclickEventListener = (event) =>⤶    #  event.preventDefault()⤶    #  @hand.processDoubleClick event⤶    #canvas.addEventListener ＂dblclick＂, @dblclickEventListener, false⤶⤶    @mousedownBrowserEventListener = (event) =>⤶      @events.push ＂mousedownBrowserEvent＂⤶      @events.push event⤶⤶    canvas.addEventListener ＂mousedown＂, @mousedownBrowserEventListener, false⤶⤶    ⤶    @mouseupBrowserEventListener = (event) =>⤶      @events.push ＂mouseupBrowserEvent＂⤶      @events.push event⤶⤶    canvas.addEventListener ＂mouseup＂, @mouseupBrowserEventListener, false⤶        ⤶    @mousemoveBrowserEventListener = (event) =>⤶      @events.push ＂mousemoveBrowserEvent＂⤶      @events.push event⤶⤶    canvas.addEventListener ＂mousemove＂, @mousemoveBrowserEventListener, false⤶⤶  initTouchEventListeners: ->⤶    canvas = @worldCanvas⤶    ⤶    @touchstartBrowserEventListener = (event) =>⤶      @events.push ＂touchstartBrowserEvent＂⤶      @events.push event⤶      event.preventDefault() # (unsure that this one is needed)⤶⤶    canvas.addEventListener ＂touchstart＂, @touchstartBrowserEventListener, false⤶⤶    @touchendBrowserEventListener = (event) =>⤶      @events.push ＂touchendBrowserEvent＂⤶      @events.push event⤶      event.preventDefault() # prevent mouse events emulation⤶⤶    canvas.addEventListener ＂touchend＂, @touchendBrowserEventListener, false⤶        ⤶    @touchmoveBrowserEventListener = (event) =>⤶      @events.push ＂touchmoveBrowserEvent＂⤶      @events.push event⤶      event.preventDefault() # (unsure that this one is needed)⤶⤶    canvas.addEventListener ＂touchmove＂, @touchmoveBrowserEventListener, false⤶⤶    @gesturestartBrowserEventListener = (event) =>⤶      @events.push ＂gesturestartBrowserEvent＂⤶      @events.push event⤶      event.preventDefault() # (unsure that this one is needed)⤶⤶    canvas.addEventListener ＂gesturestart＂, @gesturestartBrowserEventListener, false⤶⤶    @gesturechangeBrowserEventListener = (event) =>⤶      @events.push ＂gesturechangeBrowserEvent＂⤶      @events.push event⤶      event.preventDefault() # (unsure that this one is needed)⤶⤶    canvas.addEventListener ＂gesturechange＂, @gesturechangeBrowserEventListener, false⤶⤶⤶  initKeyboardEventListeners: ->⤶    canvas = @worldCanvas⤶    @keydownBrowserEventListener = (event) =>⤶      @events.push ＂keydownBrowserEvent＂⤶      @events.push event⤶⤶      # this paragraph is to prevent the browser going⤶      # ＂back button＂ when the user presses delete backspace.⤶      # taken from http://stackoverflow.com/a/2768256⤶      doPrevent = false⤶      if event.keyCode == 8⤶        d = event.srcElement or event.target⤶        if d.tagName.toUpperCase() == 'INPUT' and⤶        (d.type.toUpperCase() == 'TEXT' or⤶          d.type.toUpperCase() == 'PASSWORD' or⤶          d.type.toUpperCase() == 'FILE' or⤶          d.type.toUpperCase() == 'SEARCH' or⤶          d.type.toUpperCase() == 'EMAIL' or⤶          d.type.toUpperCase() == 'NUMBER' or⤶          d.type.toUpperCase() == 'DATE') or⤶        d.tagName.toUpperCase() == 'TEXTAREA'⤶          doPrevent = d.readOnly or d.disabled⤶        else⤶          doPrevent = true⤶⤶      # this paragraph is to prevent the browser scrolling when⤶      # user presses spacebar, see⤶      # https://stackoverflow.com/a/22559917⤶      if event.keyCode == 32 and event.target == @worldCanvas⤶        # Note that doing a preventDefault on the spacebar⤶        # causes it not to generate the keypress event⤶        # (just the keydown), so we had to modify the keydown⤶        # to also process the space.⤶        # (I tried to use stopPropagation instead/inaddition but⤶        # it didn't work).⤶        doPrevent = true⤶⤶      # also browsers tend to do special things when ＂tab＂⤶      # is pressed, so let's avoid that⤶      if event.keyCode == 9 and event.target == @worldCanvas⤶        doPrevent = true⤶⤶      if doPrevent⤶        event.preventDefault()⤶⤶    canvas.addEventListener ＂keydown＂, @keydownBrowserEventListener, false⤶⤶    @keyupBrowserEventListener = (event) =>⤶      @events.push ＂keyupBrowserEvent＂⤶      @events.push event⤶⤶    canvas.addEventListener ＂keyup＂, @keyupBrowserEventListener, false⤶    ⤶    @keypressBrowserEventListener = (event) =>⤶      @events.push ＂keypressBrowserEvent＂⤶      @events.push event⤶⤶    canvas.addEventListener ＂keypress＂, @keypressBrowserEventListener, false⤶⤶  initClipboardEventListeners: ->⤶    # snippets of clipboard-handling code taken from⤶    # http://codebits.glennjones.net/editing/setclipboarddata.htm⤶    # Note that this works only in Chrome. Firefox and Safari need a piece of⤶    # text to be selected in order to even trigger the copy event. Chrome does⤶    # enable clipboard access instead even if nothing is selected.⤶    # There are a couple of solutions to this - one is to keep a hidden textfield that⤶    # handles all copy/paste operations.⤶    # Another one is to not use a clipboard, but rather an internal string as⤶    # local memory. So the OS clipboard wouldn't be used, but at least there would⤶    # be some copy/paste working. Also one would need to intercept the copy/paste⤶    # key combinations manually instead of from the copy/paste events.⤶⤶    # -----------------------------------------------------⤶    # clipboard events listeners⤶    # -----------------------------------------------------⤶    # we deal with the clipboard here in the event listeners⤶    # because for security reasons the runtime is not allowed⤶    # access to the clipboards outside of here. So we do all⤶    # we have to do with the clipboard here, and in every⤶    # other place we work with text.⤶⤶    @cutBrowserEventListener = (event) =>⤶      selectedText = ＂＂⤶      if @caret⤶        selectedText = @caret.target.selection()⤶        if event?.clipboardData⤶          event.preventDefault()⤶          setStatus = event.clipboardData.setData ＂text/plain＂, selectedText⤶⤶        if window.clipboardData⤶          event.returnValue = false⤶          setStatus = window.clipboardData.setData ＂Text＂, selectedText⤶⤶      @events.push ＂cutBrowserEvent＂⤶      @events.push selectedText⤶⤶    document.body.addEventListener ＂cut＂, @cutBrowserEventListener, false⤶    ⤶    @copyBrowserEventListener = (event) =>⤶      selectedText = ＂＂⤶      if @caret⤶        if clipboardTextIfTestRunning?⤶          selectedText = clipboardTextIfTestRunning⤶        else⤶          selectedText = @caret.target.selection()⤶        if event?.clipboardData⤶          event.preventDefault()⤶          setStatus = event.clipboardData.setData ＂text/plain＂, selectedText⤶⤶        if window.clipboardData⤶          event.returnValue = false⤶          setStatus = window.clipboardData.setData ＂Text＂, selectedText⤶⤶      @events.push ＂copyBrowserEvent＂⤶      @events.push selectedText⤶⤶    document.body.addEventListener ＂copy＂, @copyBrowserEventListener, false⤶⤶    @pasteBrowserEventListener = (event) =>⤶      if @caret⤶        if event?⤶          if event.clipboardData⤶            # Look for access to data if types array is missing⤶            text = event.clipboardData.getData ＂text/plain＂⤶            #url = event.clipboardData.getData(＂text/uri-list＂)⤶            #html = event.clipboardData.getData(＂text/html＂)⤶            #custom = event.clipboardData.getData(＂text/xcustom＂)⤶          # IE event is attached to the window object⤶          if window.clipboardData⤶            # The schema is fixed⤶            text = window.clipboardData.getData ＂Text＂⤶            #url = window.clipboardData.getData ＂URL＂⤶⤶      @events.push ＂pasteBrowserEvent＂⤶      @events.push text⤶⤶    document.body.addEventListener ＂paste＂, @pasteBrowserEventListener, false⤶⤶  initKeyCombosEventListeners: ->⤶⤶⤶⤶  initOtherMiscEventListeners: ->⤶    canvas = @worldCanvas⤶⤶    @contextmenuEventListener = (event) ->⤶      # suppress context menu for Mac-Firefox⤶      event.preventDefault()⤶    canvas.addEventListener ＂contextmenu＂, @contextmenuEventListener, false⤶    ⤶⤶    # Safari, Chrome⤶    ⤶    @wheelBrowserEventListener = (event) =>⤶      @events.push ＂wheelBrowserEvent＂⤶      @events.push event⤶      event.preventDefault()⤶⤶    canvas.addEventListener ＂wheel＂, @wheelBrowserEventListener, false⤶⤶    # in theory there should be no scroll event on the page⤶    # window.addEventListener ＂scroll＂, ((event) =>⤶    #  nop # nothing to do, I just need this to set an interrupt point.⤶    # ), false⤶⤶⤶    @dragoverEventListener = (event) ->⤶      event.preventDefault()⤶    window.addEventListener ＂dragover＂, @dragoverEventListener, false⤶    ⤶⤶    ⤶    @resizeBrowserEventListener = =>⤶      @events.push ＂resizeBrowserEvent＂⤶      @events.push nil⤶⤶    # this is a DOM thing, little to do with other r e s i z e methods⤶    window.addEventListener ＂resize＂, @resizeBrowserEventListener, false⤶⤶  # note that we don't register the normal click,⤶  # we figure that out independently.⤶  initEventListeners: ->⤶    @initMouseEventListeners()⤶    @initTouchEventListeners()⤶    @initKeyboardEventListeners()⤶    @initClipboardEventListeners()⤶    @initKeyCombosEventListeners()⤶    @initOtherMiscEventListeners()⤶⤶⤶  ⤶  mouseDownLeft: ->⤶    noOperation⤶  ⤶  mouseClickLeft: ->⤶    noOperation⤶  ⤶  mouseDownRight: ->⤶    noOperation⤶      ⤶⤶⤶  # WorldMorph text field tabbing:⤶  nextTab: (editField) ->⤶    next = @nextEntryField editField⤶    if next⤶      @switchTextFieldFocus editField, next⤶  ⤶  previousTab: (editField) ->⤶    prev = @previousEntryField editField⤶    if prev⤶      @switchTextFieldFocus editField, prev⤶⤶  switchTextFieldFocus: (current, next) ->⤶    current.clearSelection()⤶    next.bringToForeground()⤶    next.selectAll()⤶    next.edit()⤶⤶  # if an error is thrown, the state of the world might⤶  # be messy, for example the pointer might be⤶  # dragging an invisible morph, etc.⤶  # So, try to clean-up things as much as possible.⤶  softResetWorld: ->⤶    @hand.drop()⤶    @hand.mouseOverList.clear()⤶    @hand.nonFloatDraggedWdgt = nil⤶    @wdgtsDetectingClickOutsideMeOrAnyOfMeChildren.clear()⤶    @lastNonTextPropertyChangerButtonClickedOrDropped = nil⤶⤶⤶  ⤶  # There is something special about the⤶  # ＂world＂ version of fullDestroyChildren:⤶  # it resets the counter used to count⤶  # how many morphs exist of each Widget class.⤶  # That counter is also used to determine the⤶  # unique ID of a Widget. So, destroying⤶  # all morphs from the world causes the⤶  # counts and IDs of all the subsequent⤶  # morphs to start from scratch again.⤶  fullDestroyChildren: ->⤶    # Check which objects end with the word Widget⤶    theWordMorph = ＂Morph＂⤶    theWordWdgt = ＂Wdgt＂⤶    theWordWidget = ＂Widget＂⤶    ListOfMorphs = (Object.keys(window)).filter (i) ->⤶      i.includes(theWordMorph, i.length - theWordMorph.length) or⤶      i.includes(theWordWdgt, i.length - theWordWdgt.length) or⤶      i.includes(theWordWidget, i.length - theWordWidget.length)⤶    for eachMorphClass in ListOfMorphs⤶      if eachMorphClass != ＂WorldMorph＂⤶        #console.log ＂resetting ＂ + eachMorphClass + ＂ from ＂ + window[eachMorphClass].instancesCounter⤶        # the actual count is in another variable ＂instancesCounter＂⤶        # but all labels are built using instanceNumericID⤶        # which is set based on lastBuiltInstanceNumericID⤶        window[eachMorphClass].lastBuiltInstanceNumericID = 0⤶⤶    if Automator?⤶      world.automator.recorder.turnOffAnimationsPacingControl()⤶      world.automator.recorder.turnOffAlignmentOfMorphIDsMechanism()⤶      world.automator.recorder.turnOffHidingOfMorphsContentExtractInLabels()⤶      world.automator.recorder.turnOffHidingOfMorphsNumberIDInLabels()⤶⤶    super()⤶⤶  destroyToolTips: ->⤶    # ＂toolTipsList＂ keeps the widgets to be deleted upon⤶    # the next mouse click, or whenever another temporary Widget decides⤶    # that it needs to remove them.⤶    # Note that we actually destroy toolTipsList because we are not expecting⤶    # anybody to revive them once they are gone (as opposed to menus)⤶⤶    @toolTipsList.forEach (tooltip) =>⤶      unless tooltip.boundsContainPoint @position()⤶        tooltip.fullDestroy()⤶        @toolTipsList.delete tooltip⤶  ⤶⤶  buildContextMenu: ->⤶⤶    if @isIndexPage⤶      menu = new MenuMorph @, false, @, true, true, ＂Desktop＂⤶      menu.addMenuItem ＂wallpapers ➜＂, false, @, ＂wallpapersMenu＂, ＂choose a wallpaper for the Desktop＂⤶      menu.addMenuItem ＂new folder＂, true, @, ＂makeFolder＂⤶      return menu⤶⤶    if @isDevMode⤶      menu = new MenuMorph(@, false, ⤶        @, true, true, @constructor.name or @constructor.toString().split(＂ ＂)[1].split(＂(＂)[0])⤶    else⤶      menu = new MenuMorph @, false, @, true, true, ＂Widgetic＂⤶    if @isDevMode⤶      menu.addMenuItem ＂demo ➜＂, false, @, ＂popUpDemoMenu＂, ＂sample morphs＂⤶      menu.addLine()⤶      menu.addMenuItem ＂show all＂, true, @, ＂showAllMinimised＂⤶      menu.addMenuItem ＂hide all＂, true, @, ＂minimiseAll＂⤶      menu.addMenuItem ＂delete all＂, true, @, ＂closeChildren＂⤶      menu.addMenuItem ＂move all inside＂, true, @, ＂keepAllSubmorphsWithin＂, ＂keep all submorphs⧹nwithin and visible＂⤶      menu.addMenuItem ＂inspect＂, true, @, ＂inspect＂, ＂open a window on⧹nall properties＂⤶      menu.addMenuItem ＂test menu ➜＂, false, @, ＂testMenu＂, ＂debugging and testing operations＂⤶      menu.addLine()⤶      menu.addMenuItem ＂restore display＂, true, @, ＂changed＂, ＂redraw the⧹nscreen once＂⤶      menu.addMenuItem ＂fit whole page＂, true, @, ＂stretchWorldToFillEntirePage＂, ＂let the World automatically⧹nadjust to browser resizings＂⤶      menu.addMenuItem ＂color...＂, true, @, ＂popUpColorSetter＂, ＂choose the World's⧹nbackground color＂⤶      menu.addMenuItem ＂wallpapers ➜＂, false, @, ＂wallpapersMenu＂, ＂choose a wallpaper for the Desktop＂⤶⤶      if WorldMorph.preferencesAndSettings.inputMode is PreferencesAndSettings.INPUT_MODE_MOUSE⤶        menu.addMenuItem ＂touch screen settings＂, true, WorldMorph.preferencesAndSettings, ＂toggleInputMode＂, ＂bigger menu fonts⧹nand sliders＂⤶      else⤶        menu.addMenuItem ＂standard settings＂, true, WorldMorph.preferencesAndSettings, ＂toggleInputMode＂, ＂smaller menu fonts⧹nand sliders＂⤶      menu.addLine()⤶    ⤶    if Automator?⤶      menu.addMenuItem ＂system tests ➜＂, false, @, ＂popUpSystemTestsMenu＂, ＂＂⤶    if @isDevMode⤶      menu.addMenuItem ＂switch to user mode＂, true, @, ＂toggleDevMode＂, ＂disable developers'⧹ncontext menus＂⤶    else⤶      menu.addMenuItem ＂switch to dev mode＂, true, @, ＂toggleDevMode＂⤶    menu.addMenuItem ＂new folder＂, true, @, ＂makeFolder＂⤶    menu.addMenuItem ＂about Fizzygum...＂, true, @, ＂about＂⤶    menu⤶⤶  wallpapersMenu: (a,targetMorph)->⤶    menu = new MenuMorph @, false, targetMorph, true, true, ＂Wallpapers＂⤶⤶    # we add the ＂untick＂ prefix to all entries⤶    # so we allocate the right amout of space for⤶    # the labels, we are going to put the⤶    # right ticks soon after⤶    menu.addMenuItem untick + @pattern1, true, @, ＂setPattern＂, nil, nil, nil, nil, nil, @pattern1⤶    menu.addMenuItem untick + @pattern2, true, @, ＂setPattern＂, nil, nil, nil, nil, nil, @pattern2⤶    menu.addMenuItem untick + @pattern3, true, @, ＂setPattern＂, nil, nil, nil, nil, nil, @pattern3⤶    menu.addMenuItem untick + @pattern4, true, @, ＂setPattern＂, nil, nil, nil, nil, nil, @pattern4⤶    menu.addMenuItem untick + @pattern5, true, @, ＂setPattern＂, nil, nil, nil, nil, nil, @pattern5⤶    menu.addMenuItem untick + @pattern6, true, @, ＂setPattern＂, nil, nil, nil, nil, nil, @pattern6⤶    menu.addMenuItem untick + @pattern7, true, @, ＂setPattern＂, nil, nil, nil, nil, nil, @pattern7⤶⤶    @updatePatternsMenuEntriesTicks menu⤶⤶    menu.popUpAtHand()⤶⤶  setPattern: (menuItem, ignored2, thePatternName) ->⤶    if @patternName == thePatternName⤶      return⤶⤶    @patternName = thePatternName⤶    @changed()⤶⤶    if menuItem?.parent? and (menuItem.parent instanceof MenuMorph)⤶      @updatePatternsMenuEntriesTicks menuItem.parent⤶⤶⤶  # cheap way to keep menu consistency when pinned⤶  # note that there is no consistency in case⤶  # there are multiple copies of this menu changing⤶  # the wallpaper, since there is no real subscription⤶  # of a menu to react to wallpaper change coming⤶  # from other menus or other means (e.g. API)...⤶  updatePatternsMenuEntriesTicks: (menu) ->⤶    pattern1Tick = pattern2Tick = pattern3Tick =⤶    pattern4Tick = pattern5Tick = pattern6Tick =⤶    pattern7Tick = untick⤶⤶    switch @patternName⤶      when @pattern1⤶        pattern1Tick = tick⤶      when @pattern2⤶        pattern2Tick = tick⤶      when @pattern3⤶        pattern3Tick = tick⤶      when @pattern4⤶        pattern4Tick = tick⤶      when @pattern5⤶        pattern5Tick = tick⤶      when @pattern6⤶        pattern6Tick = tick⤶      when @pattern7⤶        pattern7Tick = tick⤶⤶    menu.children[1].label.setText pattern1Tick + @pattern1⤶    menu.children[2].label.setText pattern2Tick + @pattern2⤶    menu.children[3].label.setText pattern3Tick + @pattern3⤶    menu.children[4].label.setText pattern4Tick + @pattern4⤶    menu.children[5].label.setText pattern5Tick + @pattern5⤶    menu.children[6].label.setText pattern6Tick + @pattern6⤶    menu.children[7].label.setText pattern7Tick + @pattern7⤶⤶⤶⤶⤶  create: (aWdgt) ->⤶    aWdgt.pickUp()⤶⤶⤶⤶  ⤶  # This method is obsolete. It assumes a different meaning⤶  # for ＂minimise＂ than what we have now.⤶  #minimiseAll: ->⤶  #  @children.forEach (child) ->⤶  #    child.minimise()⤶  ⤶  # This method is obsolete. It assumes a different meaning⤶  # for ＂minimise＂ than what we have now.⤶  #showAllMinimised: ->⤶  #  @forAllChildrenBottomToTop (child) ->⤶  #    if !child.visibleBasedOnIsVisibleProperty() or⤶  #    child.isCollapsed()⤶  #      child.unminimise()⤶  ⤶  edit: (aStringMorphOrTextMorph) ->⤶    # first off, if the Widget is not editable⤶    # then there is nothing to do⤶    # return nil  unless aStringMorphOrTextMorph.isEditable⤶⤶    # there is only one caret in the World, so destroy⤶    # the previous one if there was one.⤶    if @caret⤶      # empty the previously ongoing selection⤶      # if there was one.⤶      previouslyEditedText = @lastEditedText⤶      @lastEditedText = @caret.target⤶      if @lastEditedText != previouslyEditedText⤶        @lastEditedText.clearSelection()⤶      @caret = @caret.fullDestroy()⤶⤶    # create the new Caret⤶    @caret = new CaretMorph aStringMorphOrTextMorph⤶    aStringMorphOrTextMorph.parent.add @caret⤶    # this is the only place where the @keyboardEventsReceiver is set⤶    @keyboardEventsReceiver = @caret⤶⤶    if WorldMorph.preferencesAndSettings.isTouchDevice and WorldMorph.preferencesAndSettings.useVirtualKeyboard⤶      @initVirtualKeyboard()⤶      # For touch devices, giving focus on the textbox causes⤶      # the keyboard to slide up, and since the page viewport⤶      # shrinks, the page is scrolled to where the texbox is.⤶      # So, it is important to position the textbox around⤶      # where the caret is, so that the changed text is going to⤶      # be visible rather than out of the viewport.⤶      pos = getDocumentPositionOf @worldCanvas⤶      @inputDOMElementForVirtualKeyboard.style.top = @caret.top() + pos.y + ＂px＂⤶      @inputDOMElementForVirtualKeyboard.style.left = @caret.left() + pos.x + ＂px＂⤶      @inputDOMElementForVirtualKeyboard.focus()⤶    ⤶    # Widgetic.js provides the ＂slide＂ method but I must have lost it⤶    # in the way, so commenting this out for the time being⤶    #⤶    #if WorldMorph.preferencesAndSettings.useSliderForInput⤶    #  if !aStringMorphOrTextMorph.parentThatIsA MenuMorph⤶    #    @slide aStringMorphOrTextMorph⤶  ⤶  # Editing can stop because of three reasons:⤶  #   cancel (user hits ESC)⤶  #   accept (on stringmorph, user hits enter)⤶  #   user clicks/floatDrags another morph⤶  stopEditing: ->⤶    if @caret⤶      @lastEditedText = @caret.target⤶      @lastEditedText.clearSelection()⤶      @caret = @caret.fullDestroy()⤶⤶    # the only place where the @keyboardEventsReceiver is unset⤶    # (and the hidden input is removed)⤶    @keyboardEventsReceiver = nil⤶    if @inputDOMElementForVirtualKeyboard⤶      @inputDOMElementForVirtualKeyboard.blur()⤶      document.body.removeChild @inputDOMElementForVirtualKeyboard⤶      @inputDOMElementForVirtualKeyboard = nil⤶    @worldCanvas.focus()⤶⤶  anyReferenceToWdgt: (whichWdgt) ->⤶    # go through all the references and check whether they reference⤶    # the wanted widget. Note that the reference could be unreachable⤶    # in the basement, or even in the trash⤶    for eachReferencingWdgt from @widgetsReferencingOtherWidgets⤶      if eachReferencingWdgt.target == whichWdgt⤶        return true⤶    return false⤶".replace(/＂/g, "\"").replace(/⧹/g, "\\").replace(/⤶/g, "\n");