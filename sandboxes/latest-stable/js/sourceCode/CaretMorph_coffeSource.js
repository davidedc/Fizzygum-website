// Generated by CoffeeScript 1.12.7
window.CaretMorph_coffeSource = '# I mark where the caret is in a String/Text while editing\n\nclass CaretMorph extends BlinkerMorph\n\n  keyDownEventUsed: false\n  target: nil\n  slot: nil\n  viewPadding: 1\n  currentCaretFontSize: nil\n\n  constructor: (@target) ->\n    # additional properties:\n    @slot = @target.text.length\n    super()\n\n    # if the only thing in the undo history is the\n    # first positioning of the caret via click, we can clear\n    # that because we are going to set out own with\n    # the first click\n    if @target.undoHistory?.length == 1\n      onlyUndo = @target.undoHistory[@target.undoHistory.length - 1]\n      if onlyUndo.isJustFirstClickToPositionCursor\n        @target.undoHistory = []\n\n    # font could be really small I guess?\n    @minimumExtent = new Point 1,1\n\n    if (@target instanceof TextMorph) and (@target.alignment != \'left\')\n      @target.setAlignmentToLeft()\n    @adjustAccordingToTargetText()\n\n  adjustAccordingToTargetText: ->\n    @updateDimension()\n    @gotoSlot @slot\n\n  justBeforeBeingPainted: ->\n    @adjustAccordingToTargetText()\n\n  updateDimension: ->\n    ls = fontHeight @target.actualFontSizeUsedInRendering()\n    if ls != @currentCaretFontSize\n      @currentCaretFontSize = ls\n      @rawSetExtent new Point Math.max(Math.floor(ls / 20), 1), ls\n  \n  # CaretMorph event processing:\n  processKeyPress: (charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->\n    # @inspectKeyEvent event\n    if @keyDownEventUsed\n      @keyDownEventUsed = false\n      @updateDimension()\n      return nil\n    if ctrlKey\n      @ctrl charCode, shiftKey\n    # in Chrome/OSX cmd-a and cmd-z\n    # don\'t trigger a keypress so this\n    # function invocation here does\n    # nothing.\n    else if metaKey\n      @cmd charCode, shiftKey\n    else\n      @insert symbol, shiftKey\n    # notify target\'s parent of key event\n    @target.escalateEvent "reactToKeystroke", charCode, symbol, shiftKey, ctrlKey, altKey, metaKey\n    @updateDimension()\n  \n  # Some "keys" don\'t produce a keypress,\n  # they just produce a keydown/keyup,\n  # (see https://stackoverflow.com/q/1367700 )\n  # so we handle those here.\n  # Note that we use the keyDownEventUsed flag\n  # to absolutely make sure that we don\'t process\n  # the same thing twice just in case in some\n  # platforms some unexpected keys DO produce\n  # both the keydown + keypress ...\n  processKeyDown: (scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    # @inspectKeyEvent event\n    @keyDownEventUsed = false\n    if ctrlKey\n      @ctrl scanCode, shiftKey\n      # notify target\'s parent of key event\n      @target.escalateEvent "reactToKeystroke", scanCode, nil, shiftKey, ctrlKey, altKey, metaKey\n      @updateDimension()\n      return\n    else if metaKey\n      @cmd scanCode, shiftKey\n      # notify target\'s parent of key event\n      @target.escalateEvent "reactToKeystroke", scanCode, nil, shiftKey, ctrlKey, altKey, metaKey\n      @updateDimension()\n      return\n    switch scanCode\n      when 32\n        # when you do a preventDefault() on the spacebar,\n        # (to avoid the page to scroll), then the\n        # keypress event for the space doesn\'t happen\n        # (at least in Chrome/OSX),\n        # so we must process it in the keydown here instead!\n        @insert " "\n        @keyDownEventUsed = true\n      when 37\n        @goLeft shiftKey\n        @keyDownEventUsed = true\n      when 39\n        @goRight shiftKey\n        @keyDownEventUsed = true\n      when 38\n        @goUp shiftKey\n        @keyDownEventUsed = true\n      when 40\n        @goDown shiftKey\n        @keyDownEventUsed = true\n      when 36\n        @goHome shiftKey\n        @keyDownEventUsed = true\n      when 35\n        @goEnd shiftKey\n        @keyDownEventUsed = true\n      when 46\n        @deleteRight()\n        @keyDownEventUsed = true\n      when 8\n        @deleteLeft()\n        @keyDownEventUsed = true\n      when 9\n        # TAB is another key that doesn\'t\n        # produce a keypress in all browsers/OSs\n        @keyDownEventUsed = true\n        if @target?\n          if shiftKey\n            return @target.backTab @target\n          else\n            if @target instanceof SimplePlainTextWdgt\n              @insert "  "\n              @keyDownEventUsed = true\n            else\n              return @target.tab @target\n\n      when 13\n        # we can\'t check the class using instanceof\n        # because TextMorphs are instances of StringMorphs\n        # but they want the enter to insert a carriage return.\n        if @target.constructor.name == "StringMorph" or @target.constructor.name == "StringMorph2"\n          @accept()\n        else\n          @insert "\\n"\n        @keyDownEventUsed = true\n      when 27\n        @cancel()\n        @keyDownEventUsed = true\n      else\n    # @inspectKeyEvent event\n    # notify target\'s parent of key event\n    @target.escalateEvent "reactToKeystroke", scanCode, nil, shiftKey, ctrlKey, altKey, metaKey\n    @updateDimension()\n  \n  \n  gotoSlot: (slot, becauseOfMouseClick) ->\n    # check that slot is within the allowed boundaries of\n    # of zero and text length.\n    length = @target.text.length\n    @slot = (if slot < 0 then 0 else (if slot > length then length else slot))\n\n    pos = @target.slotCoordinates @slot\n    if pos?\n      if @parent and @target.isScrollable\n        right = @parent.right() - @viewPadding\n        left = @parent.left() + @viewPadding\n        if pos.x > right\n          @target.fullRawMoveLeftSideTo @target.left() + right - pos.x\n          pos.x = right\n        if pos.x < left\n          left = Math.min @parent.left(), left\n          @target.fullRawMoveLeftSideTo @target.left() + left - pos.x\n          pos.x = left\n        if @target.right() < right and right - @target.width() < left\n          pos.x += right - @target.right()\n          @target.fullRawMoveRightSideTo right\n      #console.log "moving caret to: " + pos\n      @show()\n      @fullRawMoveTo pos.floor()\n\n      if @amIDirectlyInsideScrollPanelWdgt() and @target.isScrollable\n        @parent.parent.scrollCaretIntoView @\n\n    if becauseOfMouseClick and @target.undoHistory?.length == 0\n      @target.pushUndoState? @slot, true\n\n  \n  goLeft: (shift) ->\n    if !shift and @target.firstSelectedSlot()?\n      @gotoSlot @target.firstSelectedSlot()\n      @updateSelection shift\n    else\n      @updateSelection shift\n      @gotoSlot @slot - 1\n      @updateSelection shift\n      @clearSelectionIfStartAndEndMeet shift\n    @target.caretHorizPositionForVertMovement = @slot\n  \n  goRight: (shift, howMany) ->\n    if !shift and @target.lastSelectedSlot()?\n      @gotoSlot @target.lastSelectedSlot()\n      @updateSelection shift\n    else\n      @updateSelection shift\n      @gotoSlot @slot + (howMany || 1)\n      @updateSelection shift\n      @clearSelectionIfStartAndEndMeet shift\n    @target.caretHorizPositionForVertMovement = @slot\n  \n  goUp: (shift) ->\n    if !shift and @target.lastSelectedSlot()?\n      @gotoSlot @target.firstSelectedSlot()\n      @updateSelection shift\n    else\n      @updateSelection shift\n      @gotoSlot @target.upFrom @slot\n      @updateSelection shift\n      @clearSelectionIfStartAndEndMeet shift\n  \n  goDown: (shift) ->\n    if !shift and @target.lastSelectedSlot()?\n      @gotoSlot @target.lastSelectedSlot()\n      @updateSelection shift\n    else\n      @updateSelection shift\n      @gotoSlot @target.downFrom @slot\n      @updateSelection shift\n      @clearSelectionIfStartAndEndMeet shift\n  \n  goHome: (shift) ->\n    @updateSelection shift\n    @gotoSlot @target.startOfLine @slot\n    @updateSelection shift\n    @clearSelectionIfStartAndEndMeet shift\n  \n  goEnd: (shift) ->\n    @updateSelection shift\n    @gotoSlot @target.endOfLine @slot\n    @updateSelection shift\n    @clearSelectionIfStartAndEndMeet shift\n  \n  gotoPos: (aPoint) ->\n    slotToGoTo = @target.slotAt aPoint\n    @gotoSlot slotToGoTo\n    @show()\n    return slotToGoTo\n\n  clearSelectionIfStartAndEndMeet: (shift) ->\n    if shift\n      #console.log "@target.startMark: " + @target.startMark + " @target.endMark: " + @target.endMark\n      if @target.startMark == @target.endMark\n        #console.log "clearSelectionIfStartAndEndMeet clearing selection"\n        @target.clearSelection()\n\n  updateSelection: (shift) ->\n    if shift\n      if (!@target.endMark?) and (!@target.startMark?)\n        @target.selectBetween @slot, @slot\n      else if @target.endMark isnt @slot\n        @target.setEndMark @slot\n    else\n      @target.clearSelection()\n  \n  # CaretMorph editing.\n\n  # User presses enter on a stringMorph\n  accept: ->\n    world.stopEditing()\n    @escalateEvent "accept", nil\n  \n  # User presses ESC\n  cancel: ->\n    world.stopEditing()\n    @escalateEvent \'cancel\', nil\n\n  # User presses CTRL-Z or CMD-Z, potentially with shift\n  undo: (shiftKey) ->\n    if !@target.undoHistory?\n      return\n\n    if !shiftKey\n      if @target.undoHistory.length > 1\n        @target.popUndoState()\n        undoState = @target.undoHistory[@target.undoHistory.length - 1]\n        @bringTextAndCaretToState undoState\n    else\n      redoState = @target.popRedoState()\n      if redoState?\n        @bringTextAndCaretToState redoState\n\n  bringTextAndCaretToState: (state) ->\n    @target.setText state.textContent, nil, nil\n    @gotoSlot state.cursorPos\n    if state.selectionStart? and state.selectionEnd?\n      @target.selectBetween state.selectionStart, state.selectionEnd\n    else\n      @target.clearSelection()\n  \n  insert: (symbol, shiftKey) ->    \n    # if the target "isNumeric", then only accept\n    # numbers and "-" and "." as input\n    if not @target.isNumeric or not isNaN(parseFloat(symbol)) or symbol in ["-", "."]\n      \n      # we push the state here before the change, then again\n      # after the change. This seems redundant, however\n      # it\'s needed because:\n      #\n      # 1) in case we are about to insert something that\n      #    replaces a selection, then it\'s actually\n      #    important to save the state before the selection\n      #    is touched so that the user can go back to it\n      # 2) in case of edit "far" from the previous edit,\n      #    this is going to be very very useful because\n      #    it\'s much *much* more natural\n      #    for the user to undo up to the position BEFORE an\n      #    edit. If you don\'t save that position before the\n      #    edit, you jump directly to the end of the edit before,\n      #    it\'s actually quite puzzling.\n      #    It\'s nominally "functional" to only jump to text changes,\n      #    but it\'s quite unnatural, it\'s not how undos work\n      #    in real editors.\n      # \n      # In the "normal" case of continuous typing this\n      # would be indeed redundant, HOWEVER we avoid such\n      # redundancy, because the sequences of:\n      #\n      #         position, text, position, text, ...\n      #\n      # actually are saved without the "position"\n      # changes (these is a check in "pushUndoState" that if there\n      # is only a change position of one then that state is not\n      # pushed)\n\n      @target.pushUndoState? @slot\n\n      if @target.selection() isnt ""\n        @gotoSlot @target.firstSelectedSlot()\n        @target.deleteSelection()\n      text = @target.text\n      text = text.slice(0, @slot) + symbol + text.slice(@slot)\n      # this is a setText that will trigger the text\n      # connections "from within", starting a new connections\n      # update round\n      @target.setText text, nil, nil\n      @goRight false, symbol.length\n      @updateDimension()\n      @target.pushUndoState? @slot\n  \n  ctrl: (scanCodeOrCharCode, shiftKey) ->\n    # ctrl-a apparently can come from either\n    # keypress or keydown\n    # 64 is for keydown\n    # 97 is for keypress\n    # in Chrome on OSX there is no keypress\n    switch scanCodeOrCharCode\n      when 97, 65\n        @target.selectAll()\n      # ctrl-z arrives both via keypress and\n      # keydown but 90 here matches the keydown only\n      when 90\n        @undo shiftKey\n      # unclear which keyboard needs ctrl\n      # to be pressed to give a keypressed\n      # event for {}[]@\n      # but this is what this catches\n      when 123\n        @insert "{"\n      when 125\n        @insert "}"\n      when 91\n        @insert "["\n      when 93\n        @insert "]"\n      when 64\n        @insert "@"\n  \n  # these two arrive only from\n  # keypressed, at least in Chrome/OSX\n  # 65 and 90 are both scan codes.\n  cmd: (scanCode, shiftKey) ->\n    # CMD-A\n    switch scanCode\n      when 65\n        @target.selectAll()\n      # CMD-Z\n      when 90\n        @undo shiftKey\n  \n  deleteRight: ->\n    if @target.selection() isnt ""\n      @gotoSlot @target.firstSelectedSlot()\n      @target.deleteSelection()\n    else\n      text = @target.text\n      text = text.slice(0, @slot) + text.slice(@slot + 1)\n      @target.setText text, nil, nil\n  \n  deleteLeft: ->\n    if @target.selection()\n      @gotoSlot @target.firstSelectedSlot()\n      @target.deleteSelection()\n    else\n      text = @target.text\n      @target.setText text.substring(0, @slot - 1) + text.substr(@slot), nil, nil\n      @goLeft()\n\n    @updateSelection false\n    @gotoSlot @slot\n    @updateSelection false\n    @clearSelectionIfStartAndEndMeet false\n  \n  # CaretMorph utilities:\n  inspectKeyEvent: (event) ->\n    # private\n    @inform "Key pressed: " + String.fromCharCode(event.charCode) + "\\n------------------------" + "\\ncharCode: " + event.charCode + "\\nkeyCode: " + event.keyCode + "\\naltKey: " + event.altKey + "\\nctrlKey: " + event.ctrlKey  + "\\ncmdKey: " + event.metaKey\n';
