// Generated by CoffeeScript 1.12.7
window.ScriptWdgt_coffeSource = 'class ScriptWdgt extends Widget\n\n  tempPromptEntryField: nil\n  textMorph: nil\n\n  runItButton: nil\n  saveButton: nil\n  saveTextWdgt: nil\n\n  savedScript: nil\n  functionFromCompiledCode: nil\n\n  # the external padding is the space between the edges\n  # of the container and all of its internals. The reason\n  # you often set this to zero is because windows already put\n  # contents inside themselves with a little padding, so this\n  # external padding is not needed. Useful to keep it\n  # separate and know that it\'s working though.\n  externalPadding: 0\n  # the internal padding is the space between the internal\n  # components. It doesn\'t necessarily need to be equal to the\n  # external padding\n  internalPadding: 5\n\n  constructor: (@savedScript = "") ->\n    super new Point 200,400\n    @buildAndConnectChildren()\n\n  colloquialName: ->\n    "script"\n\n  representativeIcon: ->\n    new ScriptIconWdgt()\n\n  closeFromContainerWindow: (containerWindow) ->\n    if !world.anyReferenceToWdgt containerWindow\n      prompt = new SaveShortcutPromptWdgt @, containerWindow\n      prompt.popUpAtHand()\n    else\n      containerWindow.close()\n\n  buildAndConnectChildren: ->\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n    @tempPromptEntryField = new SimplePlainTextScrollPanelWdgt @savedScript, false, 5\n    @tempPromptEntryField.disableDrops()\n    @tempPromptEntryField.contents.disableDrops()\n    @tempPromptEntryField.color = new Color 255, 255, 255\n    @tempPromptEntryField.addModifiedContentIndicator()\n\n    # register this wdgt as one to be notified when the text\n    # changes/unchanges from "reference" content\n    # so we can enable/disable the "save" button\n    @tempPromptEntryField.widgetToBeNotifiedOfTextModificationChange = @\n\n    @textMorph = @tempPromptEntryField.textWdgt\n    @textMorph.backgroundColor = new Color 0,0,0,0\n    @textMorph.setFontName nil, nil, @textMorph.monoFontStack\n    @textMorph.isEditable = true\n    @textMorph.enableSelecting()\n\n    @add @tempPromptEntryField\n\n    # buttons -------------------------------\n    @runItButton = new SimpleButtonMorph true, @, "tryIt", "try it"\n    @add @runItButton\n\n    @saveTextWdgt = new StringMorph2 "save + close", WorldMorph.preferencesAndSettings.textInButtonsFontSize\n    @saveTextWdgt.alignCenter()\n    @saveButton = new SimpleButtonMorph true, @, "saveScriptAndClose", @saveTextWdgt\n    @add @saveButton\n    # ---------------------------------------\n\n    # now that we added the buttons there is a "save" button\n    # to disable (because the reference text has not been\n    # changed yet), so trigger the content check now\n    @tempPromptEntryField.checkIfTextContentWasModifiedFromTextAtStart()\n\n    @invalidateLayout()\n\n  saveScript: ->\n    @savedScript = @textMorph.text\n    compiled = compileFGCode @savedScript, true\n    @functionFromCompiledCode = new Function compiled\n\n    @textMorph.considerCurrentTextAsReferenceText()\n    @tempPromptEntryField.checkIfTextContentWasModifiedFromTextAtStart()\n\n  saveScriptAndClose: ->\n    @saveScript()\n    @closeFromContainerWindow @parent\n\n  doAll: ->\n    @functionFromCompiledCode?.call world\n\n  tryIt: ->\n    world.evaluateString @textMorph.text\n\n  textContentModified: ->\n\n  textContentUnmodified: ->\n\n  doLayout: (newBoundsForThisLayout) ->\n    #if !window.recalculatingLayouts\n    #  debugger\n\n    if @isCollapsed()\n      @layoutIsValid = true\n      @notifyChildrenThatParentHasReLayouted()\n      return\n\n    super\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Widget. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    trackChanges.push false\n\n    textHeight = @height() - 2 * @externalPadding - @internalPadding - 15\n    textBottom = @top() + @externalPadding + textHeight\n    textWidth = @width() - 2 * @externalPadding\n    buttonsWidth = Math.round((textWidth - 2 * @internalPadding - WorldMorph.preferencesAndSettings.handleSize)/2)\n\n    if @tempPromptEntryField.parent == @\n      @tempPromptEntryField.fullRawMoveTo new Point @left() + @externalPadding, @top() + @externalPadding\n      @tempPromptEntryField.rawSetExtent new Point textWidth, textHeight\n\n\n    # buttons -------------------------------\n    \n\n    if @runItButton.parent == @\n      buttonBounds = new Rectangle new Point @left() + @externalPadding, textBottom + @internalPadding\n      buttonBounds = buttonBounds.setBoundsWidthAndHeight buttonsWidth, 15\n      @runItButton.doLayout buttonBounds \n\n    if @saveButton.parent == @\n      buttonBounds = new Rectangle new Point buttonBounds.right() + @internalPadding, textBottom + @internalPadding\n      buttonBounds = buttonBounds.setBoundsWidthAndHeight buttonsWidth, 15\n      @saveButton.doLayout buttonBounds \n\n\n    # ----------------------------------------------\n\n\n    trackChanges.pop()\n    @fullChanged()\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n    @layoutIsValid = true\n    @notifyChildrenThatParentHasReLayouted()\n\n';
