// Generated by CoffeeScript 1.12.7
window.SpeechBubbleWdgt_coffeSource = '# the speech bubble is similar to the Tooltip,\n# however it\'s more like the callouts of some\n# famous presentation software: you drop them\n# somewhere and you type text in them. If you resize\n# them, the text inside them is resized too.\n# They don\'t pop up within a certain time.\n\nclass SpeechBubbleWdgt extends Widget\n\n  @ongoingTimeouts: []\n\n  contents: nil\n  padding: nil # additional vertical pixels\n  morphInvokingThis: nil\n\n  constructor: (@contents="hello") ->\n    # console.log "bubble super"\n    super()\n    @color = WorldMorph.preferencesAndSettings.menuBackgroundColor\n    @padding = 0\n    @strokeColor = WorldMorph.preferencesAndSettings.menuStrokeColor\n    @cornerRadius = 6\n    @appearance = new BubblyAppearance @\n    @toolTipMessage = "speech bubble"\n    @buildAndConnectChildren()\n    @minimumExtent = new Point 10,10\n    @extentToGetWhenDraggedFromGlassBox = new Point 105,80\n\n    # console.log @color\n\n  colloquialName: ->\n    "speech bubble"\n  \n  buildAndConnectChildren: ->\n    @contentsMorph = new TextMorph2(\n      @contents,\n      WorldMorph.preferencesAndSettings.bubbleHelpFontSize,\n      nil,\n      false,\n      true,\n      "center")\n\n    @contentsMorph.fittingSpecWhenBoundsTooLarge = FittingSpecTextInLargerBounds.SCALEUP\n    @contentsMorph.fittingSpecWhenBoundsTooSmall = FittingSpecTextInSmallerBounds.SCALEDOWN\n    @contentsMorph.alignMiddle()\n    @contentsMorph.alignCenter()\n    @contentsMorph.isEditable = true\n\n\n    @add @contentsMorph\n    @invalidateLayout()\n\n  rawSetExtent: (aPoint) ->\n    super\n    @doLayout @bounds\n\n  doLayout: (newBoundsForThisLayout) ->\n\n    #if !window.recalculatingLayouts\n    #  debugger\n\n    if !newBoundsForThisLayout?\n      if @desiredExtent?\n        newBoundsForThisLayout = @desiredExtent\n        @desiredExtent = nil\n      else\n        newBoundsForThisLayout = @extent()\n\n      if @desiredPosition?\n        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout\n        @desiredPosition = nil\n      else\n        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout\n\n    if @isCollapsed()\n      @layoutIsValid = true\n      @notifyChildrenThatParentHasReLayouted()\n      return\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Widget. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    trackChanges.push false\n\n    # adjust my layout\n    @silentRawSetWidth newBoundsForThisLayout.width()\n    @silentRawSetHeight newBoundsForThisLayout.height()\n\n    @contentsMorph.rawSetWidth newBoundsForThisLayout.width() - (2 * @cornerRadius)\n    @contentsMorph.rawSetHeight newBoundsForThisLayout.height() - (2 * @cornerRadius) - newBoundsForThisLayout.height()/5\n\n\n    # position my contents\n    @contentsMorph.fullRawMoveTo @position().add(\n      new Point(@padding + @cornerRadius, @padding + @cornerRadius))\n\n    trackChanges.pop()\n    @fullChanged()\n\n    @layoutIsValid = true\n    @notifyChildrenThatParentHasReLayouted()\n\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n\n';
