// Generated by CoffeeScript 1.12.7
window.StretchableCanvasWdgt_coffeSource = '# The difference between this and a Canvas is that once the\n# user starts to paint on the StretchableCanvas, it locks the\n# aspect ratio... and any further resizing keeps the original\n# paiting and the user can keep painting at any new scale...\n#\n# This is achieved by keeping an extra canvas behind the scenes\n# that keeps the original resolution of when the first paint\n# action happened. The user keeps painting on that "behind\n# the scenes canvas" with the original resolution, no matter\n# what the scale of the "front facing" canvas is on screen.\n# So any time the user resizes the front canvas or she paints\n# on the "behind the scenes", the "behind the scenes"\n# is painted on the front one at the correct scale.\n#\n# Note that since the "behind the scenes" canvas\n# keeps the same size... if the user starts painting\n# when the size is small... then enlarging the canvas\n# will just cause the smaller "behind the scenes" canvas\n# to be painted on the smaller "front facing" canvas...\n# so everything new will be painted blurry.\n#\n# You could enhance this so that if the user scales up\n# the canvas, then the "behind the scenes" is also\n# resized-up (previous content will be blurry but new\n# content will be sharp).\n\nclass StretchableCanvasWdgt extends CanvasMorph\n\n  anythingPaintedYet: false\n  extentWhenCanvasGotDirty: nil\n\n  behindTheScenesBackBuffer: nil\n  behindTheScenesBackBufferContext: nil\n\n\n  # No changes of position or extent should be\n  # performed in here.\n  # There is really little hope to cache this buffer\n  # cross-morph, unless you key the buffer with the\n  # order of all the primitives and their\n  # parameters. So if user wants a cache it will have to specify\n  # a dedicated one in here. See textMorph for an example.\n  createRefreshOrGetBackBuffer: ->\n\n    extent = @extent()\n\n    if !@backBuffer?\n      @createNewFrontFacingBuffer extent\n\n    # little shortcut: if nothing has been painted yet then\n    # we can omit painting the big canvas on the small one,\n    # just clean up the small canvas\n    if !@anythingPaintedYet and @color?\n      @backBufferContext.fillStyle = @color.toString()\n      @backBufferContext.fillRect 0, 0, extent.x * pixelRatio, extent.y * pixelRatio\n\n    # if something *has* been painted then\n    # we need to paint the "behind the scenes" buffer into the\n    # one we show on screen\n    if @anythingPaintedYet\n      @backBufferContext.setTransform 1, 0, 0, 1, 0, 0\n      @backBufferContext.scale @width()/@extentWhenCanvasGotDirty.x, @height()/@extentWhenCanvasGotDirty.y\n      @backBufferContext.drawImage @behindTheScenesBackBuffer, 0, 0\n\n    \n    # we leave the context with the correct pixel scaling.\n    # ALWAYS leave the context with the correct pixel scaling.\n    @backBufferContext.scale pixelRatio, pixelRatio\n    return [@backBuffer, @backBufferContext]\n\n\n  # don\'t need this at the moment, you\'d need to\n  # clear both backbuffers and invoke a @parent?.resetRatio?()\n  # since once it\'s empty you can really let the user re-think\n  # the aspect ratio of her painting\n  clear: (color = @color) ->\n    throw new Error "not implemented yet"\n\n  createNewBehindTheScenesBuffer: (extent) ->\n    @behindTheScenesBackBuffer = newCanvas extent.scaleBy pixelRatio\n    @behindTheScenesBackBufferContext = @behindTheScenesBackBuffer.getContext "2d"\n\n    if @color?\n      @behindTheScenesBackBufferContext.fillStyle = @color.toString()\n      @behindTheScenesBackBufferContext.fillRect 0, 0, extent.x * pixelRatio, extent.y * pixelRatio\n\n    # we leave the context with the correct scaling.\n    # ALWAYS leave the context with the correct pixel scaling.\n    @behindTheScenesBackBufferContext.scale pixelRatio, pixelRatio\n\n  createNewFrontFacingBuffer: (extent) ->\n    @backBuffer = newCanvas extent.scaleBy pixelRatio\n    @backBufferContext = @backBuffer.getContext "2d"\n\n\n    # we leave the context with the correct scaling.\n    # ALWAYS leave the context with the correct pixel scaling.\n    @backBufferContext.scale pixelRatio, pixelRatio\n\n\n  rawSetExtent: (extent) ->\n\n    if extent.eq @extent()\n      return\n\n    if !@behindTheScenesBackBuffer? or !@anythingPaintedYet\n      @createNewBehindTheScenesBuffer extent\n\n    @createNewFrontFacingBuffer extent\n\n    super\n    @doLayout @bounds\n\n\n  getContextForPainting: ->\n    # only set ratio with the first paint operation\n    # the following ones don\'t change it\n    if @parent?.setRatio? and !@parent.ratio?\n      @parent.setRatio @width() / @height()\n      @extentWhenCanvasGotDirty = @extent()\n      @anythingPaintedYet = true\n\n    @behindTheScenesBackBufferContext.setTransform 1, 0, 0, 1, 0, 0\n    @behindTheScenesBackBufferContext.scale pixelRatio, pixelRatio\n\n    @behindTheScenesBackBufferContext.scale @extentWhenCanvasGotDirty.x/@width(), @extentWhenCanvasGotDirty.y/@height()\n\n    @behindTheScenesBackBufferContext.translate -@bounds.origin.x, -@bounds.origin.y\n    return @behindTheScenesBackBufferContext\n\n  # don\'t need this at the moment, you\'d need to\n  # paint on the "behind the scenes" backbuffer\n  drawLine: (start, dest, lineWidth, color) ->\n    throw new Error "not implemented yet"\n\n  paintImage: (pos, image) ->\n\n    extent = @extent()\n    if !@backBuffer?\n      @createNewFrontFacingBuffer extent\n\n    if !@behindTheScenesBackBuffer?\n      @createNewBehindTheScenesBuffer extent\n\n    contextForPainting = @getContextForPainting()\n\n    # OK now this needs an explanation: in a hi-dpi display we get\n    # a widget image that is 2x the logical size.\n    # BUT the position is indicated by the mouse which works in logical\n    # coordinates.\n    # SO we need to keep the positioning correctly scaled at 2x\n    # BUT draw on the canvas at 1x\n    # SO here we undo the 2x scaling, re-introduce it manually only\n    # for the positioning, then draw.\n    # Note that there could be another way, i.e. to pass the other arguments\n    # to "drawImage" to specify the bounding box.\n\n    @behindTheScenesBackBufferContext.scale 1/pixelRatio, 1/pixelRatio\n    contextForPainting.drawImage image, pos.x * pixelRatio, pos.y * pixelRatio\n\n    # put back the scaling so it\'s right again.\n    # (always leave the scaling correct)\n    @behindTheScenesBackBufferContext.scale pixelRatio, pixelRatio\n\n  reactToDropOf: (droppedWidget) ->\n    @paintImage droppedWidget.position(), droppedWidget.fullImage(nil, false, true)\n    world.add droppedWidget, nil, nil, true\n  \n  doLayout: (newBoundsForThisLayout) ->\n    #if !window.recalculatingLayouts\n    #  debugger\n\n    if !newBoundsForThisLayout?\n      if @desiredExtent?\n        newBoundsForThisLayout = @desiredExtent\n        @desiredExtent = nil\n      else\n        newBoundsForThisLayout = @extent()\n\n      if @desiredPosition?\n        newBoundsForThisLayout = (new Rectangle @desiredPosition).setBoundsWidthAndHeight newBoundsForThisLayout\n        @desiredPosition = nil\n      else\n        newBoundsForThisLayout = (new Rectangle @position()).setBoundsWidthAndHeight newBoundsForThisLayout\n\n    if @isCollapsed()\n      @layoutIsValid = true\n      @notifyChildrenThatParentHasReLayouted()\n      return\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Widget. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    trackChanges.push false\n\n    @rawSetBounds newBoundsForThisLayout\n\n    childrenNotHandlesNorCarets = @children.filter (m) ->\n      !((m instanceof HandleMorph) or (m instanceof CaretMorph))\n\n    for eachChild in childrenNotHandlesNorCarets\n      eachChild.rawSetBounds @bounds\n\n\n    trackChanges.pop()\n    @fullChanged()\n\n    @layoutIsValid = true\n    @notifyChildrenThatParentHasReLayouted()\n\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n';
