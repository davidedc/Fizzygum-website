// Generated by CoffeeScript 1.12.7
window.StringMorph2_coffeSource = '# It\'s a SINGLE line of text, i.e.\n# it doesn\'t represent line breaks as multiple lines\n# and there is no concept of soft-wrapping.\n# It\'s useful when you mean an "enter" from the user to mean\n# "accept the changes", and to represent things that are\n# necessarily on one line and one line only such as\n# numbers, booleans, method and property names, file names,\n# colors, passwords etc.\n# If there is a chance that the text might span more\n# than one line (e.g. most button captions) then do\n# use a TextMorph instead.\n# It\'s like StringMorph BUT it fits any given size, so to\n# behave well in layouts.\n#\n# REQUIRES WorldMorph\n# REQUIRES BackBufferMixin\n# REQUIRES ControllerMixin\n# REQUIRES AlignmentSpecHorizontal\n# REQUIRES AlignmentSpecVertical\n# REQUIRES LRUCache\n# REQUIRES FittingSpecTextInSmallerBounds\n# REQUIRES FittingSpecTextInLargerBounds\n# REQUIRES TextEditingState\n\nclass StringMorph2 extends Widget\n\n  @augmentWith BackBufferMixin\n  @augmentWith ControllerMixin\n\n  # clear unadulterated text\n  text: ""\n  # the text as it actually shows.\n  # It might have undergone transformations\n  # and cropping.\n  textPossiblyCroppedToFit: ""\n\n  fittingFontSize: nil\n  originallySetFontSize: nil\n\n  fontName: nil\n  isBold: nil\n  isItalic: nil\n  # TODO there is no API to toggle this properly yet,\n  # TODO?? ...and there is no menu entry for this\n  # TODO???? ...should we let users pick any color?\n  hasDarkOutline: false\n  isHeaderLine: nil\n  isEditable: false\n  # if "isNumeric", it rejects all inputs\n  # other than numbers and "-" and "."\n  isNumeric: nil\n  isPassword: false\n  isShowingBlanks: false\n  # careful: Objects are shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  blanksColor: new Color 180, 140, 140\n\n  # Used for when the cursor movement causes the\n  # text to scroll, so that the caret is in-view when\n  # used, say, on a text in a ScrollPanelWdgt.\n  isScrollable: true\n\n  # startMark and endMark contain the slot of the\n  # slot first selected IN TIME, not "in space".\n  # i.e. startMark might be higher than endMark if\n  # text had been selected starting from the\n  # right and "going left"\n  startMark: nil\n  endMark: nil\n\n  # see note above about Colors and shared objects\n  markedTextColor: new Color 255, 255, 255\n  # see note above about Colors and shared objects\n  markedBackgoundColor: new Color 60, 60, 120\n\n  horizontalAlignment: AlignmentSpecHorizontal.LEFT\n  verticalAlignment: AlignmentSpecVertical.TOP\n\n  fittingSpecWhenBoundsTooLarge: FittingSpecTextInLargerBounds.FLOAT\n  fittingSpecWhenBoundsTooSmall: FittingSpecTextInSmallerBounds.CROP\n\n  caretHorizPositionForVertMovement: nil\n\n  emptyCharacter: \'\\u2063\'\n\n  # Since we let the browser paint the text, we can\'t guarantee that\n  # a specific font will be available to the user.\n  # So we do what web designers do: we allow for a few families of\n  # very simialar fonts (at least in style in not in shape),\n  # each specifying a list of fallbacks that\n  # are chosen to be similar and, collectively, widely available.\n  # On top of that we also add a justArialFontStack, since Arial\n  # is actually available on all devices, it\'s useful for testing\n  # to have a font that is supposed to be identical across all\n  # devices.\n  # These stacks have been taken from\n  # http://www.sitepoint.com/eight-definitive-font-stacks/\n  justArialFontStack: \'Arial, sans-serif\'\n  timesFontStack: \'Cambria, "Hoefler Text", Utopia, "Liberation Serif", "Nimbus Roman No9 L Regular", Times, "Times New Roman", serif\'\n  georgiaFontStack: \'Constantia, "Lucida Bright", Lucidabright, "Lucida Serif", Lucida, "DejaVu Serif", "Bitstream Vera Serif", "Liberation Serif", Georgia, serif\'\n  garamoFontStack: \'"Palatino Linotype", Palatino, Palladio, "URW Palladio L", "Book Antiqua", Baskerville, "Bookman Old Style", "Bitstream Charter", "Nimbus Roman No9 L", Garamond, "Apple Garamond", "ITC Garamond Narrow", "New Century Schoolbook", "Century Schoolbook", "Century Schoolbook L", Georgia, serif\'\n  helveFontStack: \'Frutiger, "Frutiger Linotype", Univers, Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans Condensed", "Liberation Sans", "Nimbus Sans L", Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif\'\n  verdaFontStack: \'Corbel, "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "DejaVu Sans", "Bitstream Vera Sans", "Liberation Sans", Verdana, "Verdana Ref", sans-serif\'\n  trebuFontStack: \'"Segoe UI", Candara, "Bitstream Vera Sans", "DejaVu Sans", "Bitstream Vera Sans", "Trebuchet MS", Verdana, "Verdana Ref", sans-serif\'\n  heavyFontStack: \'Impact, Haettenschweiler, "Franklin Gothic Bold", Charcoal, "Helvetica Inserat", "Bitstream Vera Sans Bold", "Arial Black", sans-serif\'\n  monoFontStack: \'Consolas, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", Monaco, "Courier New", Courier, monospace\'\n\n  hashOfTextConsideredAsReference: nil\n  widgetToBeNotifiedOfTextModificationChange: nil\n\n  undoHistory: nil\n  redoHistory: nil\n\n  constructor: (\n      @text = (if text is "" then "" else "StringMorph2"),\n      @originallySetFontSize = WorldMorph.preferencesAndSettings.normalTextFontSize,\n      @fontName = @justArialFontStack,\n      @isBold = false,\n      @isItalic = false,\n      @isHeaderLine = false,\n      @isNumeric = false,\n      @color = (new Color 37, 37, 37),\n      backgroundColor,\n      backgroundTransparency\n      ) ->\n    # additional properties:\n    @textPossiblyCroppedToFit = @transformTextOneToOne @text\n\n    # properties that override existing ones only when passed\n    @backgroundColor = backgroundColor if backgroundColor?\n    @backgroundTransparency = backgroundTransparency if backgroundTransparency?      \n\n    @undoHistory = []\n    @redoHistory = []\n\n    super()\n\n    # override inherited properties:\n    @noticesTransparentClick = true\n    @changed()\n\n  # the actual font size used might be\n  # different than the one specified originally\n  # because this morph has to be able to fit\n  # any extent by shrinking.\n  actualFontSizeUsedInRendering: ->\n    @reflowText()\n    @fittingFontSize\n\n  pushUndoState: (slot, justFirstClickToPositionCursor) ->\n\n    # Little definition here: a "positional" change\n    # are pairs of states that only differ for the\n    # position.\n\n    # Since we push a:\n    #                  position, text\n    #\n    # pair for each insert (see comment in "insert" for why)\n    # we want to actually forget the "trivial" positional\n    # changes when the user is just typing, so discard the\n    # positional changes of one\n    if @undoHistory.length > 0\n      lastUndoState = @undoHistory[@undoHistory.length - 1]\n      if lastUndoState.selectionStart == @startMark and\n       lastUndoState.selectionEnd == @endMark and\n       lastUndoState.textContent == @text and\n       Math.abs(slot - lastUndoState.cursorPos) <= 1\n        return\n\n    # when the user clicks around, we never want to\n    # store three consecutive non-trivial positional\n    # changes. We just want two: the initial and the last\n    # one. So check the last two pushes, and if they are\n    # positional then we discard the second one, then we are going\n    # to add the new one after this check.\n    # All this is because it\'s much *much* more natural\n    # for the user to undo up to the position BEFORE an\n    # edit. If you don\'t save that position before the\n    # edit, you jump directly to the end of the edit before,\n    # it\'s actually quite puzzling.\n    # It\'s nominally "functional" to only jump to text changes,\n    # but it\'s quite unnatural, it\'s not how undos work\n    # in real editors.\n    if @undoHistory.length > 1\n      lastUndoState = @undoHistory[@undoHistory.length - 1]\n      beforeLastUndoState = @undoHistory[@undoHistory.length - 2]\n      if beforeLastUndoState.selectionStart == lastUndoState.selectionStart == @startMark and\n       beforeLastUndoState.selectionEnd == lastUndoState.selectionEnd == @endMark and\n       beforeLastUndoState.textContent == lastUndoState.textContent == @text\n        @undoHistory.pop()\n\n\n    @redoHistory = []\n\n    @undoHistory.push new TextEditingState @startMark, @endMark, slot, @text, justFirstClickToPositionCursor\n\n  popRedoState: (slot) ->\n    poppedElement = @redoHistory.pop()\n    if poppedElement?\n      @undoHistory.push poppedElement\n    return poppedElement\n\n  popUndoState: ->\n    poppedElement = @undoHistory.pop()\n    if poppedElement?\n      @redoHistory.push poppedElement\n    return poppedElement\n\n  setHorizontalAlignment: (newAlignment) ->\n    if @horizontalAlignment != newAlignment\n      @horizontalAlignment = newAlignment\n      @changed()\n\n  setVerticalAlignment: (newAlignment) ->\n    if @verticalAlignment != newAlignment\n      @verticalAlignment = newAlignment\n      @changed()\n\n  alignLeft: ->\n    @setHorizontalAlignment AlignmentSpecHorizontal.LEFT\n    @\n  alignCenter: ->\n    @setHorizontalAlignment AlignmentSpecHorizontal.CENTER\n    @\n  alignRight: ->\n    @setHorizontalAlignment AlignmentSpecHorizontal.RIGHT\n    @\n  alignTop: ->\n    @setVerticalAlignment AlignmentSpecVertical.TOP\n    @\n  alignMiddle: ->\n    @setVerticalAlignment AlignmentSpecVertical.MIDDLE\n    @\n  alignBottom: ->\n    @setVerticalAlignment AlignmentSpecVertical.BOTTOM\n    @\n  \n  toString: ->\n    # e.g. \'a StringMorph2("Hello World")\'\n    firstPart = super()\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and\n    AutomatorRecorderAndPlayer.hidingOfMorphsContentExtractInLabels\n      return firstPart\n    else\n      return firstPart + " (\\"" + @text.slice(0, 30).replace(/(?:\\r\\n|\\r|\\n)/g, \'↵\') + "...\\")"\n\n  # used to identify morphs in macros/tests.\n  # identifying morphs this way resists more\n  # to tampering such as adding/removing morphs and\n  # changing their locations.\n  getTextDescription: ->\n    if @textDescription?\n      return @textDescription + " (adhoc description of string)"\n    textWithoutLocationOrInstanceNo = @text.replace /#\\d*/, ""\n    return textWithoutLocationOrInstanceNo.slice(0, 30) + " (content of string)"\n  \n  obfuscateAsPassword: (letter, length) ->\n    # there is an alternative to this, using an idiom\n    # http://stackoverflow.com/a/19892144\n    # but it\'s clearer this way\n    ans = ""\n    for i in [0...length]\n      ans += letter\n    ans\n\n  buildCanvasFontProperty: (overrideFontSize = @fittingFontSize) ->\n    # answer a font string, e.g. \'bold italic 12px Arial\'\n    font = ""\n    font = font + "bold "  if @isBold\n    font = font + "italic "  if @isItalic\n    font + overrideFontSize + "px " + @fontName\n\n  # does a binary search to see which font size\n  # we need to apply to the text to fit to the\n  # current extent.\n  # If this gets slow: some optimisations can be done,\n  # for example trying to make a couple of preliminary guesses\n  # assuming that the user is just resizing something slightly,\n  # which means that the font size is gonna change only slightly\n  # from the current one, so you can try to narrow the bracket\n  # a lot at the very start.\n  searchLargestFittingFont: (textToFit) ->\n\n    # decimalFloatFiguresOfFontSizeGranularity allows you to go into sub-points\n    # in the font size. This is so the resizing of the\n    # text is less "jumpy".\n    # "1" seems to be perfect in terms of jumpiness,\n    # but obviously this routine gets quite a bit more\n    # expensive.\n    PreferencesAndSettings.decimalFloatFiguresOfFontSizeGranularity = 0\n\n    # minimum font size that we are gonna examine\n    start = 0\n    # maximum font size that we are gonna examine\n    stop  = Math.round 200 * Math.pow 10,\n            PreferencesAndSettings.decimalFloatFiguresOfFontSizeGranularity\n    \n    if !@doesTextFitInExtent textToFit, start\n      return -1\n\n\n    if @doesTextFitInExtent textToFit, stop\n      return stop / Math.pow 10, PreferencesAndSettings.decimalFloatFiguresOfFontSizeGranularity\n\n    # since we round the pivot to the floor, we\n    # always end up start and pivot coinciding\n    while start != (pivot = Math.floor (start + stop) / 2)\n\n      itFitsAtPivot = @doesTextFitInExtent textToFit, pivot / Math.pow 10, PreferencesAndSettings.decimalFloatFiguresOfFontSizeGranularity\n\n      if itFitsAtPivot\n        # bring forward the start since there are still\n        # zeroes at the pivot\n        start = pivot\n      else\n        # bring backwards the stop since there is already\n        # a one at the pivot\n        stop = pivot\n\n    return start / Math.pow 10, PreferencesAndSettings.decimalFloatFiguresOfFontSizeGranularity\n\n  generateTextWithEllipsis: (startingText) ->\n    if startingText != ""\n      return startingText + "…"\n    return ""\n\n  # what we are tyring to do here is to fit the text into\n  # a boundary that potentially is too small. We are not going\n  # to fit it by changing the font size, rather we are fitting\n  # it by cropping it.\n  # Note that the text could be set to wrap, so we also have\n  # to take that into account when measuring if it fits.\n  #\n  # Note that the resulting text might contain more than one\n  # crop, because several lines might be extending beyond the\n  # width of the boundary.\n  #\n  # See comment above for "searchLargestFittingFont" for some\n  # ideas on how to optimise this further.\n  searchLongestFittingTextByMultiCroppingIt: (textToFit) ->\n    textToFit = @transformTextOneToOne @text\n\n    # check if it fits as is, maybe we don\'t\n    # need to do any cropping.\n    if @doesTextFitInExtent(textToFit, @originallySetFontSize)\n       return textToFit\n\n\n    # split textToFit into lines i.e. into paragraphs\n    splitText = textToFit.split /\\n/\n    \n    fittingText = ""\n\n    for i in [0...splitText.length]\n\n      eachParagraph  = splitText[i]\n      fittingText += eachParagraph\n      \n      # also add the newline, except if it\'s\n      # the last element of the array, in which\n      # case there is no newline after it.\n      if i != splitText.length - 1\n        fittingText += "\\n"\n\n      #console.log "searchLongestFittingTextByMultiCroppingIt trying to fit one more paragraph:"\n      #console.log "   " + eachParagraph\n      #console.log " overal blurb we are fitting: " + fittingText\n\n      # add each new line of textToFit to the existing blurb to be tested\n      # (if we are done with adding lines of textToFit, then we have our\n      # successful blurb)\n\n      if !@doesTextFitInExtent(fittingText, @originallySetFontSize)\n\n        start = 0    # minimum string length that we are gonna examine\n        stop  = fittingText.length\n\n        # since we round the pivot to the floor, we\n        # always end up start and pivot coinciding\n        while start != (pivot = Math.floor (start + stop) / 2)\n\n          #console.log "start/stop/pivot: " + start + " / " + stop + " / " + pivot\n\n          textAtPivot = fittingText.substring 0, pivot\n          itFitsAtPivot = @doesTextFitInExtent textAtPivot, @originallySetFontSize\n          #console.log "  what fits: " + textAtPivot + " fits: " + valueAtPivot\n\n          if itFitsAtPivot\n            #console.log "fits at pivot of " + pivot + " : start = pivot now"\n            # bring forward the start since there are still\n            # zeroes at the pivot\n            start = pivot\n          else\n            #console.log "doesn\'t fit at pivot of " + pivot + " : start = pivot now"\n            # bring backwards the stop since there is already\n            # a one at the pivot\n            stop = pivot\n\n        #replace the blurb we just tested with the piece of it that actually\n        # fits, and that might have a crop in it.\n        if start != fittingText.length\n\n          # todo you should count the newlines\n          paragraphBeforeWithNewLineHasBeenCropped = false\n          if fittingText.substr(fittingText.length - 1) == "\\n"\n            paragraphBeforeWithNewLineHasBeenCropped = true\n\n          reducing = 0\n          while (start - reducing > 0) and !@doesTextFitInExtent(\n              @generateTextWithEllipsis(\n                fittingText.substring(0, start - reducing)\n                ),\n              @originallySetFontSize\n              )\n            reducing++\n\n          if (start - reducing == 0)\n            if @doesTextFitInExtent "…", @originallySetFontSize\n              fittingText = "…"\n            else\n              fittingText = ""\n          else\n            fittingText = @generateTextWithEllipsis(fittingText.substring 0, start - reducing)\n\n          if paragraphBeforeWithNewLineHasBeenCropped\n            if !@doesTextFitInExtent fittingText + "\\n", @originallySetFontSize\n              console.log "break 1"\n              break\n            else\n              fittingText += "\\n"\n\n          if !@doesTextFitInExtent fittingText, @originallySetFontSize\n            alert "something wrong, this really should have fit: >" + fittingText + "<"\n            debugger\n            @doesTextFitInExtent fittingText, @originallySetFontSize\n\n      #console.log "what fits: " + fittingText\n\n      # if there is no more space\n      # for even a single line with the smallest character, then it means\n      # that just there is no more vertical space, this is really the\n      # end, then exit the loop, we have the biggest\n      # possible blurb that we can fit.\n      #if i != splitText.length - 1\n      #  if !@doesTextFitInExtent fittingText + "\\n", @originallySetFontSize\n      #    console.log "break 2"\n      #    break\n\n    # we either found the fitting blurb or we are in the\n    # degenerate case where almost nothing fits\n\n    # check degenerate case where (almost) nothing fits\n    if fittingText.length == 0\n      if @doesTextFitInExtent "…", @originallySetFontSize\n        fittingText = "…"\n      else\n        fittingText = ""\n\n    #console.log "_________fittingText: " + fittingText\n\n\n    return fittingText\n\n\n  synchroniseTextAndActualText: ->\n    textToFit = @transformTextOneToOne @text\n    if @doesTextFitInExtent textToFit, @originallySetFontSize\n      @textPossiblyCroppedToFit = textToFit\n      #console.log "@textPossiblyCroppedToFit = textToFit 1"\n    else\n      if @fittingSpecWhenBoundsTooSmall == FittingSpecTextInSmallerBounds.SCALEDOWN\n        @textPossiblyCroppedToFit = textToFit\n        #console.log "@textPossiblyCroppedToFit = textToFit 2"\n\n  eliminateInvisibleCharacter: (string) ->\n    string.replace @emptyCharacter, \'\'\n\n  # there are many factors beyond the font size that affect\n  # the measuring, such as font style, but we only pass\n  # the font size here because is the one we are going to\n  # change when we do the binary search for trying to\n  # see the largest fitting size.\n  measureText: (overrideFontSize = @fittingFontSize, text) ->\n    cacheKey =  @buildCanvasFontProperty(overrideFontSize) + "-" + hashCode text\n    cacheHit = world.cacheForTextMeasurements.get cacheKey\n    if cacheHit? then return cacheHit\n    world.canvasContextForTextMeasurements.font = @buildCanvasFontProperty overrideFontSize\n    # you\'d think that we don\'t need to eliminate the invisible character\n    # to measure the text, as it\'s supposed to be of zero length.\n    # Unfortunately some fonts do draw it, so we indeed have to eliminate\n    # it.\n    cacheEntry = world.canvasContextForTextMeasurements.measureText(@eliminateInvisibleCharacter text).width\n    world.cacheForTextMeasurements.set cacheKey, cacheEntry\n    #if cacheHit?\n    #  if cacheHit != cacheEntry\n    #    alert "problem with cache on: " + overrideFontSize + "-" + text + " hit is: " + cacheHit + " should be: " + cacheEntry\n    return cacheEntry\n\n  visualisedText: ->\n    return @textPossiblyCroppedToFit\n\n  # this should be a 1-1 transformation.\n  # for example substitute any letter with "*" for passwords\n  # or turn everything to uppercase\n  transformTextOneToOne: (theText) ->\n    return (if @isPassword then @obfuscateAsPassword("*", theText.length) else theText)\n\n  # there are many factors beyond the font size that affect\n  # the measuring, such as font style, but we only pass\n  # the font size here because is the one we are going to\n  # change when we do the binary search for trying to\n  # see the largest fitting size.\n  doesTextFitInExtent: (text = (@transformTextOneToOne @text), overrideFontSize) ->\n    if !@measureText?\n      debugger\n    if text == ""\n      return true\n    extentOccupiedByText = new Point Math.ceil(@measureText overrideFontSize, text), fontHeight(overrideFontSize)\n\n    return extentOccupiedByText.le @extent()\n\n  fitToExtent: ->\n    # this if is just to check if the text fits in the\n    # current extent. If it does, we either leave the size\n    # as is or we try to\n    # make the font size bigger if that\'s the policy.\n    # If it doesn\'t fit, then we either crop it or make the\n    # font smaller.\n    \n    #if !window.globCounter? then window.globCounter = 0\n    #window.globCounter++\n    #console.log "fitting to extent " + window.globCounter\n\n    textToFit = @transformTextOneToOne @text\n\n    if @doesTextFitInExtent textToFit, @originallySetFontSize\n      @textPossiblyCroppedToFit = textToFit\n      #console.log "@textPossiblyCroppedToFit = textToFit 3"\n      if @fittingSpecWhenBoundsTooLarge == FittingSpecTextInLargerBounds.SCALEUP\n        largestFittingFontSize = @searchLargestFittingFont textToFit\n        return largestFittingFontSize\n      else\n        return @originallySetFontSize\n    else\n      if @fittingSpecWhenBoundsTooSmall == FittingSpecTextInSmallerBounds.CROP\n        @textPossiblyCroppedToFit = @searchLongestFittingTextByMultiCroppingIt textToFit\n        return @originallySetFontSize\n      else\n        @textPossiblyCroppedToFit = textToFit\n        #console.log "@textPossiblyCroppedToFit = textToFit 4"\n        largestFittingFontSize = @searchLargestFittingFont textToFit\n        return largestFittingFontSize\n\n  calculateTextWidth: (text, overrideFontSize) ->\n    return @measureText overrideFontSize, text\n\n  setFittingFontSize: (theValue) ->\n    if @fittingFontSize != theValue\n      @fittingFontSize = theValue\n      @changed()\n\n  createBufferCacheKey: ->\n    @extent().toString() + "-" +\n    @isPassword  + "-" +\n    @isShowingBlanks  + "-" +\n    @originallySetFontSize + "-" +\n    @buildCanvasFontProperty() + "-" +\n    @hasDarkOutline + "-" +\n    @isHeaderLine + "-" +\n    @color.toString()  + "-" +\n    (if @backgroundColor? then @backgroundColor.toString() else "transp") + "-" +\n    (if @backgroundTransparency? then @backgroundTransparency.toString() else "transp") + "-" +\n    hashCode(@text)  + "-" +\n    hashCode(@textPossiblyCroppedToFit)  + "-" +\n    @startMark  + "-" +\n    @endMark  + "-" +\n    @markedBackgoundColor.toString()  + "-" +\n    @horizontalAlignment  + "-" +\n    @verticalAlignment  + "-" +\n    @fittingSpecWhenBoundsTooLarge  + "-" +\n    @fittingSpecWhenBoundsTooSmall\n\n  textVerticalPosition: (heightOfText) -> \n    switch @verticalAlignment\n      when AlignmentSpecVertical.TOP\n        0\n      when AlignmentSpecVertical.MIDDLE\n        (@height() - heightOfText)/2\n      when AlignmentSpecVertical.BOTTOM\n        @height() - heightOfText\n\n  textHorizontalPosition: (widthOfText) ->\n    switch @horizontalAlignment\n      when AlignmentSpecHorizontal.LEFT\n        0\n      when AlignmentSpecHorizontal.CENTER\n        @width()/2 - widthOfText/2\n      when AlignmentSpecHorizontal.RIGHT\n        @width() - widthOfText\n\n\n  # no changes of position or extent should be\n  # performed in here\n  createRefreshOrGetBackBuffer: ->\n\n    cacheKey = @createBufferCacheKey @horizontalAlignment, @verticalAlignment\n    cacheHit = world.cacheForImmutableBackBuffers.get cacheKey\n    if cacheHit?\n      # we might have hit a previously cached\n      # backBuffer but here we are interested in\n      # knowing whether the buffer we are gonna paint\n      # is the same as the one being shown now. If\n      # not, then we mark the caret as broken.\n      if @backBuffer != cacheHit[0]\n        if world.caret?\n          world.caret.changed()      \n      return cacheHit\n\n    @reflowText()\n\n    # if we are calculating a new buffer then\n    # for sure we have to mark the caret as broken\n    if world.caret?\n      world.caret.changed()      \n\n    text = @textPossiblyCroppedToFit\n    # Initialize my surface property.\n    # If don\'t have to paint the background then the surface is just as\n    # big as the text - which is likely to be smaller than the whole morph\n    # (because it needs to fit in both height and width, it\'s likely that\n    # it\'s gonna be smaller in one of the two dimensions).\n    # If, on the other hand, we have to paint the background then the surface is\n    # as big as the whole morph,\n    # so potentially we could be wasting some space as the string might\n    # be really small so to fit, say, the width, while a lot of height of\n    # the morph could be "wasted" in memory.\n    widthOfText = @calculateTextWidth text\n    heightOfText = fontHeight @fittingFontSize\n    if @backgroundColor? or\n     @verticalAlignment != AlignmentSpecVertical.TOP or\n     @horizontalAlignment != AlignmentSpecHorizontal.LEFT or\n     @fittingSpecWhenBoundsTooLarge == FittingSpecTextInLargerBounds.FLOAT\n      width = @width()\n      height = @height()\n    else\n      width = widthOfText\n      height = heightOfText\n\n    backBuffer = newCanvas (new Point width, height).scaleBy pixelRatio\n\n    backBufferContext = backBuffer.getContext "2d"\n\n    backBufferContext.scale pixelRatio, pixelRatio\n    backBufferContext.font = @buildCanvasFontProperty()\n    backBufferContext.textAlign = "left"\n    backBufferContext.textBaseline = "bottom"\n\n    # paint the background so we have a better sense of\n    # where the text is fitting into.\n    # paintRectangle here is passed logical pixels\n    # rather than actual pixels, contrary to how it\'s used\n    # most other places. This is because it\'s inside\n    # the scope of the "scale pixelRatio, pixelRatio".\n    if @backgroundColor\n      backBufferContext.save()\n      backBufferContext.fillStyle = @backgroundColor.toString()\n      backBufferContext.globalAlpha = @backgroundTransparency\n      backBufferContext.fillRect  0,\n          0,\n          Math.round(@width()),\n          Math.round(@height())\n      backBufferContext.restore()\n\n\n    textVerticalPosition = @textVerticalPosition(fontHeight @fittingFontSize) + fontHeight(@fittingFontSize)\n    textHorizontalPosition = @textHorizontalPosition widthOfText\n\n    if @hasDarkOutline\n      backBufferContext.fillStyle = "black"\n      backBufferContext.fillText text, textHorizontalPosition+0, textVerticalPosition+0\n      backBufferContext.fillText text, textHorizontalPosition+1.5, textVerticalPosition+0\n      backBufferContext.fillText text, textHorizontalPosition-1.5, textVerticalPosition+0\n      backBufferContext.fillText text, textHorizontalPosition+0, textVerticalPosition+1.5\n      backBufferContext.fillText text, textHorizontalPosition+1.5, textVerticalPosition+1.5\n      backBufferContext.fillText text, textHorizontalPosition-1.5, textVerticalPosition+1.5\n      backBufferContext.fillText text, textHorizontalPosition+0, textVerticalPosition-1.5\n      backBufferContext.fillText text, textHorizontalPosition+1.5, textVerticalPosition-1.5\n      backBufferContext.fillText text, textHorizontalPosition-1.5, textVerticalPosition-1.5\n\n    backBufferContext.fillStyle = @color.toString()\n    backBufferContext.fillText text, textHorizontalPosition, textVerticalPosition\n\n    # header line\n    if @isHeaderLine\n      backBufferContext.strokeStyle = new Color 198, 198, 198\n      backBufferContext.beginPath()\n      backBufferContext.moveTo 0, textVerticalPosition - heightOfText / 2\n      backBufferContext.lineTo textHorizontalPosition - 5, textVerticalPosition - heightOfText / 2\n      backBufferContext.moveTo textHorizontalPosition + widthOfText + 5, textVerticalPosition - heightOfText / 2\n      backBufferContext.lineTo @width(), textVerticalPosition - heightOfText / 2\n      backBufferContext.stroke()\n\n\n\n\n    @drawSelection backBufferContext\n\n    cacheEntry = [backBuffer, backBufferContext]\n    world.cacheForImmutableBackBuffers.set cacheKey, cacheEntry\n    return cacheEntry\n\n  # Draw the selection. This is done by re-drawing the\n  # selected text, one character at the time, just with\n  # a background rectangle.\n  #\n  # TODO would really benefit from some batching, it\'s often the\n  # case that entire lines can be done in one shot instead of doing\n  # them char by char. It\'s not just the painting that is slow, it\'s\n  # also the slot coordinates calculations that become quite taxing done\n  # this way. I profiled this, just see how highlighting gets slower\n  # and slower as selection gets longer.\n  #\n  drawSelection: (backBufferContext) ->\n    startSlot = @firstSelectedSlot()\n    endSlot = @lastSelectedSlot()\n    for i in [startSlot...endSlot]\n      p = @slotCoordinates(i).subtract @position()\n      c = @textPossiblyCroppedToFit.charAt(i)\n      backBufferContext.fillStyle = @markedBackgoundColor.toString()\n      backBufferContext.fillRect p.x, p.y, Math.ceil(@measureText nil, c) + 1, Math.ceil fontHeight @fittingFontSize\n      backBufferContext.fillStyle = @markedTextColor.toString()\n      backBufferContext.fillText c, p.x, p.y + Math.ceil fontHeight @fittingFontSize\n    \n  \n  # StringMorph2 measuring:\n  slotCoordinates: (slot) ->\n    \n    # this makes it so when you type and the string becomes too big\n    # then the edit stops to be directly in the screen and the\n    # popout for editing takes over.\n    if (@transformTextOneToOne @text) != @textPossiblyCroppedToFit and @fittingSpecWhenBoundsTooSmall == FittingSpecTextInSmallerBounds.CROP\n      world.stopEditing()\n      @edit()\n      return nil\n\n    # answer the position point of the given index ("slot")\n    # where the caret should be placed\n    text = @text\n\n    # let\'s be defensive and check that the\n    # slot is in the right interval\n    checkedSlot = Math.min Math.max(slot, 0), text.length\n    if slot != checkedSlot\n      alert "something wrong - slot is out of range"\n    slot = checkedSlot\n\n    xOffset = Math.ceil @calculateTextWidth text.substring 0, slot\n    x = @left() + xOffset\n    y = @top()\n\n    widthOfText = @calculateTextWidth text\n\n    textVerticalPosition = @textVerticalPosition fontHeight @fittingFontSize\n    textHorizontalPosition = @textHorizontalPosition widthOfText\n\n    x += textHorizontalPosition\n    y += textVerticalPosition\n\n    new Point x, y\n\n  slotAtSingleLineString: (xPosition, text) ->\n\n    widthOfText = @calculateTextWidth text\n    textHorizontalPosition = @textHorizontalPosition widthOfText\n\n    xPosition = xPosition - textHorizontalPosition\n    if xPosition - @left() >= widthOfText\n      if text[text.length - 1] == \'\\u2063\'\n        return text.length - 1\n      else\n        return text.length\n\n    # answer the slot (index) closest to the given point\n    # so the caret can be moved accordingly\n    idx = 0\n    charX = 0\n\n    # This code to pick the correct slot works but it\'s\n    # way too convoluted, as I arrived to this\n    # tweaking it by trial and error rather than by smarts.\n    # TODO Probably need a little patience to rewrite, I got\n    # other parts to move on to now.\n    while true\n      if charX > xPosition - @left()\n        #console.log "xPosition - @left(): " + (xPosition - @left()) + " charXMinusOne " + charXMinusOne + "  charX " + charX \n        #console.log "Math.abs(xPosition - @left() - charXMinusOne) " + Math.abs(xPosition - @left() - charXMinusOne) + "  Math.abs(xPosition - @left() - charX) " + Math.abs(xPosition - @left() - charX) \n        if Math.abs(xPosition - @left() - charXMinusOne) < Math.abs(xPosition - @left() - charX)\n          return idx - 1\n        break\n\n      if charX?\n        charXMinusOne = charX\n      else\n        charXMinusOne = 0\n\n      charX += @calculateTextWidth text[idx]\n\n      idx += 1\n      if idx is text.length\n        if ((@calculateTextWidth(text)) - ((@calculateTextWidth(text[idx-1])) / 2)) < (xPosition - @left())  \n          return idx\n    idx\n\n  pointIsAboveFirstLine: (aPoint) ->\n    textVerticalPosition = @textVerticalPosition fontHeight @fittingFontSize\n\n    if aPoint.y - @top() < textVerticalPosition\n      return 0\n\n    return false\n\n  pointIsUnderLastLine: (aPoint) ->\n    textVerticalPosition = @textVerticalPosition(fontHeight @fittingFontSize) + fontHeight(@fittingFontSize)\n\n    # if pointer is below the line, the slot is at\n    # the last character.\n    if (aPoint.y - textVerticalPosition) - @top() > Math.ceil fontHeight @fittingFontSize\n      return @textPossiblyCroppedToFit.length\n\n    return false\n  \n  slotAt: (aPoint) ->\n    if (isPointBeforeFirstLine = @pointIsAboveFirstLine aPoint) != false\n      return isPointBeforeFirstLine\n\n    if (isPointUnderLastLine = @pointIsUnderLastLine aPoint) != false\n      return isPointUnderLastLine\n\n    return @slotAtSingleLineString aPoint.x, @textPossiblyCroppedToFit\n  \n  upFrom: (slot) ->\n    @startOfLine()\n  \n  downFrom: (slot) ->\n    @endOfLine()\n  \n  startOfLine: ->\n    # answer the first slot (index) of the line for the given slot\n    0\n  \n  endOfLine: ->\n    # answer the slot (index) indicating the EOL for the given slot\n    @textPossiblyCroppedToFit.length\n\n  fontSizePopup: (menuItem)->\n    @prompt menuItem.parent.title + "\\nfont\\nsize:",\n      @,\n      "setFontSize",\n      @originallySetFontSize.toString(),\n      nil, 6, 500, true\n\n  editPopup: (menuItem)->\n    if menuItem?\n      title = menuItem.parent.title + "\\nedit:"\n    else\n      title = "edit:"\n\n    @prompt title,\n      @,\n      "setText",\n      @text,\n      nil, 6, nil, true\n\n  setFontName: (menuItem, ignored2, theNewFontName) ->\n    if @fontName != theNewFontName\n      @fontName = theNewFontName\n      @changed()\n\n      if menuItem?.parent? and (menuItem.parent instanceof MenuMorph)\n        @updateFontsMenuEntriesTicks menuItem.parent\n\n\n  fontsMenu: (a,targetMorph)->\n    menu = new MenuMorph @, false, targetMorph, true, true, "Fonts"\n\n    menu.addMenuItem untick + "Arial", true, @, "setFontName", nil, nil, nil, nil, nil, @justArialFontStack\n    menu.addMenuItem untick + "Times", true, @, "setFontName", nil, nil, nil, nil, nil, @timesFontStack\n    menu.addMenuItem untick + "Georgia", true, @, "setFontName", nil, nil, nil, nil, nil, @georgiaFontStack\n    menu.addMenuItem untick + "Garamo", true, @, "setFontName", nil, nil, nil, nil, nil, @garamoFontStack\n    menu.addMenuItem untick + "Helve", true, @, "setFontName", nil, nil, nil, nil, nil, @helveFontStack\n    menu.addMenuItem untick + "Verda", true, @, "setFontName", nil, nil, nil, nil, nil, @verdaFontStack\n    menu.addMenuItem untick + "Treby", true, @, "setFontName", nil, nil, nil, nil, nil, @trebuFontStack\n    menu.addMenuItem untick + "Heavy", true, @, "setFontName", nil, nil, nil, nil, nil, @heavyFontStack\n    menu.addMenuItem untick + "Mono", true, @, "setFontName", nil, nil, nil, nil, nil, @monoFontStack\n\n    @updateFontsMenuEntriesTicks menu\n\n    menu.popUpAtHand()\n\n  # cheap way to keep menu consistency when pinned\n  # note that there is no consistency in case\n  # there are multiple copies of this menu changing\n  # the property, since there is no real subscription\n  # of a menu to react to property change coming\n  # from other menus or other means (e.g. API)...\n  updateFontsMenuEntriesTicks: (menu) ->\n    justArialFontStackTick = timesFontStackTick = georgiaFontStackTick =\n    garamoFontStackTick = helveFontStackTick = verdaFontStackTick =\n    trebuFontStackTick = heavyFontStackTick = monoFontStackTick = untick\n\n\n    switch @fontName\n      when @justArialFontStack\n        justArialFontStackTick = tick\n      when @timesFontStack\n        timesFontStackTick = tick\n      when @georgiaFontStack\n        georgiaFontStackTick = tick\n      when @garamoFontStack\n        garamoFontStackTick = tick\n      when @helveFontStack\n        helveFontStackTick = tick\n      when @verdaFontStack\n        verdaFontStackTick = tick\n      when @trebuFontStack\n        trebuFontStackTick = tick\n      when @heavyFontStack\n        heavyFontStackTick = tick\n      when @monoFontStack\n        monoFontStackTick = tick\n\n    menu.children[1].label.setText justArialFontStackTick + "Arial"\n    menu.children[2].label.setText timesFontStackTick + "Times"\n    menu.children[3].label.setText georgiaFontStackTick + "Georgia"\n    menu.children[4].label.setText garamoFontStackTick + "Garamo"\n    menu.children[5].label.setText helveFontStackTick + "Helve"\n    menu.children[6].label.setText verdaFontStackTick + "Verda"\n    menu.children[7].label.setText trebuFontStackTick + "Treby"\n    menu.children[8].label.setText heavyFontStackTick + "Heavy"\n    menu.children[9].label.setText monoFontStackTick + "Mono"\n\n\n  addMorphSpecificMenuEntries: (morphOpeningThePopUp, menu) ->\n    super\n    menu.addLine()\n    menu.addMenuItem "edit...", true, @, "editPopup", "set this String\'s\\ncontent"\n    menu.addMenuItem "font size...", true, @, "fontSizePopup", "set this String\'s\\nfont point size"\n\n    menu.addMenuItem "font ➜", false, @, "fontsMenu", "pick a font"\n\n    if @isBold\n      menu.addMenuItem "normal weight", true, @, "toggleWeight"\n    else\n      menu.addMenuItem "bold", true, @, "toggleWeight"\n\n    if @isItalic\n      menu.addMenuItem "non-italic", true, @, "toggleItalic"\n    else\n      menu.addMenuItem "italic", true, @, "toggleItalic"\n\n    if @isHeaderLine\n      menu.addMenuItem "no header line", true, @, "toggleHeaderLine"\n    else\n      menu.addMenuItem "header line", true, @, "toggleHeaderLine"\n\n\n    if @isPassword\n      menu.addMenuItem "show characters", true, @, "toggleIsPassword"\n    else\n      menu.addMenuItem "hide characters", true, @, "toggleIsPassword"\n\n    menu.addLine()\n    if @horizontalAlignment != AlignmentSpecHorizontal.LEFT\n      menu.addMenuItem "← align left", true, @, "alignLeft"\n    if @horizontalAlignment != AlignmentSpecHorizontal.CENTER\n      menu.addMenuItem "∸ align center", true, @, "alignCenter"\n    if @horizontalAlignment != AlignmentSpecHorizontal.RIGHT\n      menu.addMenuItem "→ align right", true, @, "alignRight"\n\n    menu.addLine()\n    if @verticalAlignment != AlignmentSpecVertical.TOP\n      menu.addMenuItem "↑ align top", true, @, "alignTop"\n    if @verticalAlignment != AlignmentSpecVertical.MIDDLE\n      menu.addMenuItem "⍿ align middle", true, @, "alignMiddle"\n    if @verticalAlignment != AlignmentSpecVertical.BOTTOM\n      menu.addMenuItem "↓ align bottom", true, @, "alignBottom"\n\n    menu.addLine()\n\n    if @fittingSpecWhenBoundsTooLarge == FittingSpecTextInLargerBounds.SCALEUP\n      menu.addMenuItem "←☓→ don\'t expand to fill", true, @, "togglefittingSpecWhenBoundsTooLarge"\n    else\n      menu.addMenuItem "←→ expand to fill", true, @, "togglefittingSpecWhenBoundsTooLarge"\n\n    if @fittingSpecWhenBoundsTooSmall == FittingSpecTextInSmallerBounds.CROP\n      menu.addMenuItem "→← shrink to fit", true, @, "togglefittingSpecWhenBoundsTooSmall"\n    else\n      menu.addMenuItem "→⋯← crop to fit", true, @, "togglefittingSpecWhenBoundsTooSmall"\n\n    if world.isIndexPage\n      menu.addLine()\n      if world.isIndexPage\n        menu.addMenuItem "connect to ➜", true, @, "openTargetSelector", "connect to\\nanother widget"\n      else\n        menu.addMenuItem "set target", true, @, "openTargetSelector", "choose another morph\\nwhose numerical property\\n will be" + " controlled by this one"\n\n\n  togglefittingSpecWhenBoundsTooSmall: ->\n    @fittingSpecWhenBoundsTooSmall = not @fittingSpecWhenBoundsTooSmall\n    @changed()\n    world.stopEditing()\n\n  togglefittingSpecWhenBoundsTooLarge: ->\n    world.stopEditing()\n    @fittingSpecWhenBoundsTooLarge = not @fittingSpecWhenBoundsTooLarge\n    @changed()\n\n  \n  toggleShowBlanks: ->\n    @isShowingBlanks = not @isShowingBlanks\n    @changed()\n  \n  toggleWeight: ->\n    @isBold = not @isBold\n    @changed()\n  \n  toggleItalic: ->\n    @isItalic = not @isItalic\n    @changed()\n\n  toggleHeaderLine: ->\n    @isHeaderLine = not @isHeaderLine\n    @changed()\n  \n  toggleIsPassword: ->\n    world.stopEditing()\n    @isPassword = not @isPassword\n    @changed()\n\n  changed: ->\n    super\n    if world.caret?\n      world.caret.changed()\n  \n  # adjust the data models behind the text. E.g.\n  # is it going to be shown as cropped? What size\n  # is it going to be? How is the text broken down\n  # into rows?\n  # this method doesn\'t draw anything.\n  reflowText: ->\n    @synchroniseTextAndActualText()\n    @setFittingFontSize @fitToExtent()\n\n  # This is also invoked for example when you take a slider\n  # and set it to target this.\n  setText: (theTextContent, stringFieldMorph, connectionsCalculationToken, superCall) ->\n    if !superCall and connectionsCalculationToken == @connectionsCalculationToken then return else if !connectionsCalculationToken? then @connectionsCalculationToken = getRandomInt -20000, 20000 else @connectionsCalculationToken = connectionsCalculationToken\n    if stringFieldMorph?\n      # in this case, the stringFieldMorph has a\n      # StringMorph in "text". The StringMorph has the\n      # "text" inside it.\n      theTextContent = stringFieldMorph.text.text\n\n    theNewText = theTextContent + ""\n    if @text != theNewText\n      # other morphs might send something like a\n      # number or a color so let\'s make sure we\n      # convert to a string.\n      @clearSelection()\n      @text = theNewText\n      @checkIfTextContentWasModifiedFromTextAtStart()\n      @synchroniseTextAndActualText()\n      @changed()\n\n    @updateTarget()\n\n  considerCurrentTextAsReferenceText: ->\n    @hashOfTextConsideredAsReference = hashCode @text\n\n  checkIfTextContentWasModifiedFromTextAtStart: ->\n    if @widgetToBeNotifiedOfTextModificationChange?\n      if @hashOfTextConsideredAsReference == hashCode @text\n        @widgetToBeNotifiedOfTextModificationChange.textContentUnmodified?()\n      else\n        @widgetToBeNotifiedOfTextModificationChange.textContentModified?()\n  \n  setFontSize: (sizeOrMorphGivingSize, morphGivingSize) ->\n    if morphGivingSize?.getValue?\n      size = morphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    if typeof size is "number"\n      newSize = Math.round Math.min Math.max(size, 4), 500\n    else\n      newSize = parseFloat size\n      newSize = Math.round Math.min Math.max(newSize, 4), 500  unless isNaN newSize\n\n    if newSize != @originallySetFontSize\n      @originallySetFontSize = newSize\n      @changed()\n  \n  openTargetPropertySelector: (ignored, ignored2, theTarget) ->\n    debugger\n    [menuEntriesStrings, functionNamesStrings] = theTarget.stringSetters()\n    menu = new MenuMorph @, false, @, true, true, "choose target property:"\n    for i in [0...menuEntriesStrings.length]\n      menu.addMenuItem menuEntriesStrings[i], true, @, "setTargetAndActionWithOnesPickedFromMenu", nil, nil, nil, nil, nil, theTarget, functionNamesStrings[i]\n    if menuEntriesStrings.length == 0\n      menu = new MenuMorph @, false, @, true, true, "no target properties available"\n    menu.popUpAtHand()\n  \n  numericalSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "alpha 0-100", "font size", "text"\n    functionNamesStrings.push "setAlphaScaled", "setFontSize", "setText"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n  \n  stringSetters: (menuEntriesStrings, functionNamesStrings) ->\n    [menuEntriesStrings, functionNamesStrings] = super menuEntriesStrings, functionNamesStrings\n    menuEntriesStrings.push "bang!", "text"\n    functionNamesStrings.push "bang", "setText"\n    return @deduplicateSettersAndSortByMenuEntryString menuEntriesStrings, functionNamesStrings\n\n  updateTarget: ->\n    if @action and @action != ""\n      @target[@action].call @target, @text, nil, @connectionsCalculationToken\n    return\n\n  reactToTargetConnection: ->\n    @updateTarget()\n\n  \n  # StringMorph2 editing:\n  edit: ->\n    if @textPossiblyCroppedToFit == @transformTextOneToOne @text\n      world.edit @\n      return true\n    else\n      @editPopup()\n      return nil\n\n  selection: ->\n    start = Math.min @startMark, @endMark\n    stop = Math.max @startMark, @endMark\n    @text.slice start, stop\n  \n  firstSelectedSlot: ->\n    if !@startMark? or !@endMark?\n      return nil\n    return Math.min @startMark, @endMark\n\n  lastSelectedSlot: ->\n    if !@startMark? or !@endMark?\n      return nil\n    return Math.max @startMark, @endMark\n\n  currentlySelecting: ->\n    if !@startMark? and !@endMark?\n     return false\n    return true\n  \n  clearSelection: ->\n    if !@startMark? and !@endMark?\n      return\n    @startMark = nil\n    @endMark = nil\n    @changed()\n\n  setEndMark: (slot) ->\n    @endMark = slot\n    @changed()\n  \n  selectBetween: (start, end) ->\n    @startMark = Math.min start, end\n    @endMark = Math.max start, end\n    @changed()\n  \n  deleteSelection: ->\n    start = Math.min @startMark, @endMark\n    stop = Math.max @startMark, @endMark\n    @setText @text.slice(0, start) + @text.slice(stop)\n\n  selectAll: ->\n    @startMark = 0\n    @endMark = @textPossiblyCroppedToFit.length    \n    @changed()\n\n  # used when shift-clicking somewhere when there is\n  # no selection ongoing\n  startSelectionUpToSlot: (previousCaretSlot, slotToExtendTo) ->\n    @startMark = previousCaretSlot\n    @endMark = slotToExtendTo\n    @changed()\n\n  # used when shift-clicking somewhere when there is\n  # already a selection ongoing\n  extendSelectionUpToSlot: (slotToExtendTo) ->\n    @endMark = slotToExtendTo\n    @changed()\n\n  mouseDoubleClick: ->\n    if @isEditable\n      previousCaretSlot = world.caret?.slot\n\n      extendRight = 0\n      while previousCaretSlot + extendRight < @text.length\n        if !@text[previousCaretSlot + extendRight].isLetter()\n          break\n        extendRight++\n\n      extendLeft = 0\n      while previousCaretSlot + extendLeft - 1 >= 0\n        if !@text[previousCaretSlot + extendLeft - 1].isLetter()\n          break\n        extendLeft--\n\n      @selectBetween (previousCaretSlot + extendLeft), (previousCaretSlot + extendRight)\n      world.caret?.gotoSlot (previousCaretSlot + extendRight)\n\n  mouseTripleClick: ->\n    if @isEditable\n      @selectAll()\n      world.caret?.gotoSlot @text.length\n\n\n  # Every time the user clicks on the text, a new edit()\n  # is triggered, which creates a new caret.\n  mouseClickLeft: (pos, ignored_button, ignored_buttons, ignored_ctrlKey, shiftKey, ignored_altKey, ignored_metaKey) ->\n    @bringToForeground()\n    world.caret?.bringToForeground()\n    if @isEditable\n      # doesn\'t matter what we set editResult to initially,\n      # just not undefined or nil cause that\'s\n      # going to be significant\n      editResult = true\n      previousCaretSlot = world.caret?.slot\n      if !@currentlySelecting()\n        editResult = @edit()\n      slotUserClickedOn = @slotAt pos\n\n      if shiftKey\n        if @currentlySelecting()\n          @extendSelectionUpToSlot slotUserClickedOn\n        else\n          if previousCaretSlot?\n            @startSelectionUpToSlot previousCaretSlot, slotUserClickedOn\n      else\n        @clearSelection()\n\n      if editResult?\n        world.caret.gotoSlot slotUserClickedOn, true\n        world.caret.show()\n        @caretHorizPositionForVertMovement = world.caret.slot\n\n    else\n      @escalateEvent "mouseClickLeft", pos\n  \n  enableSelecting: ->\n    @mouseDownLeft = (pos) ->\n      @clearSelection()\n      if @isEditable and !@grabsToParentWhenDragged()\n        @edit()\n        world.caret.gotoPos pos\n        @startMark = @slotAt pos\n        @endMark = @startMark\n    \n    @mouseMove = (pos) ->\n      if @isEditable and @currentlySelecting()\n        newMark = @slotAt pos\n        if newMark isnt @endMark\n          @endMark = newMark\n          @changed()\n      else\n        @disableSelecting()\n  \n  disableSelecting: ->\n    # re-establish the original definition of the method\n    @clearSelection()\n    @mouseDownLeft = StringMorph2::mouseDownLeft\n    delete @mouseMove\n\n\n  ';
