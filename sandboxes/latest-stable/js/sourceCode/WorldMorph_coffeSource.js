// Generated by CoffeeScript 1.12.7
window.WorldMorph_coffeSource = '# these comments below needed to figure out dependencies between classes\n# REQUIRES globalFunctions\n# REQUIRES PreferencesAndSettings\n# REQUIRES Color\n# REQUIRES ProfilingDataCollector\n# REQUIRES SystemTestsControlPanelUpdater\n\n# REQUIRES GridPositioningOfAddedShortcutsMixin\n# REQUIRES KeepIconicDesktopSystemLinksBackMixin\n\n# REQUIRES DesktopAppearance\n\n# The WorldMorph takes over the canvas on the page\nclass WorldMorph extends PanelWdgt\n\n  @augmentWith GridPositioningOfAddedShortcutsMixin, @name\n  @augmentWith KeepIconicDesktopSystemLinksBackMixin, @name\n\n  # We need to add and remove\n  # the event listeners so we are\n  # going to put them all in properties\n  # here.\n  # dblclickEventListener: nil\n  mousedownEventListener: nil\n  touchstartEventListener: nil\n  mouseupEventListener: nil\n  touchendEventListener: nil\n  mousemoveEventListener: nil\n  touchmoveEventListener: nil\n  gesturestartEventListener: nil\n  gesturechangeEventListener: nil\n  contextmenuEventListener: nil\n  # Note how there can be two handlers for\n  # keyboard events.\n  # This one is attached\n  # to the canvas and reaches the currently\n  # blinking caret if there is one.\n  # See below for the other potential\n  # handler. See "initVirtualKeyboard"\n  # method to see where and when this input and\n  # these handlers are set up.\n  keydownEventListener: nil\n  keyupEventListener: nil\n  keypressEventListener: nil\n  wheelEventListener: nil\n  copyEventListener: nil\n  pasteEventListener: nil\n  clipboardTextIfTestRunning: nil\n  errorConsole: nil\n\n  # the string for the last serialised morph\n  # is kept in here, to make serialization\n  # and deserialization tests easier.\n  # The alternative would be to refresh and\n  # re-start the tests from where they left...\n  lastSerializationString: ""\n\n  # Note how there can be two handlers\n  # for keyboard events. This one is\n  # attached to a hidden\n  # "input" div which keeps track of the\n  # text that is being input.\n  inputDOMElementForVirtualKeyboardKeydownEventListener: nil\n  inputDOMElementForVirtualKeyboardKeyupEventListener: nil\n  inputDOMElementForVirtualKeyboardKeypressEventListener: nil\n\n  keyComboResetWorldEventListener: nil\n  keyComboTurnOnAnimationsPacingControl: nil\n  keyComboTurnOffAnimationsPacingControl: nil\n  keyComboTakeScreenshotEventListener: nil\n  keyComboStopTestRecordingEventListener: nil\n  keyComboTakeScreenshotEventListener: nil\n  keyComboCheckStringsOfItemsInMenuOrderImportant: nil\n  keyComboCheckStringsOfItemsInMenuOrderUnimportant: nil\n  keyComboAddTestCommentEventListener: nil\n  keyComboCheckNumberOfMenuItemsEventListener: nil\n\n  dragoverEventListener: nil\n  dropEventListener: nil\n  resizeEventListener: nil\n  otherTasksToBeRunOnStep: []\n\n  # these variables shouldn\'t be static to the WorldMorph, because\n  # in pure theory you could have multiple worlds in the same\n  # page with different settings\n  # (but anyways, it was global before, so it\'s not any worse than before)\n  @preferencesAndSettings: nil\n  @currentTime: nil\n  @currentDate: nil\n  showRedraws: false\n  doubleCheckCachedMethodsResults: false\n  automatorRecorderAndPlayer: nil\n\n  # this is the actual reference to the canvas\n  # on the html page, where the world is\n  # finally painted to.\n  worldCanvas: nil\n  worldCanvasContext: nil\n\n  canvasForTextMeasurements: nil\n  canvasContextForTextMeasurements: nil\n  cacheForTextMeasurements: nil\n  cacheForTextParagraphSplits: nil\n  cacheForParagraphsWordsSplits: nil\n  cacheForParagraphsWrappingData: nil\n  cacheForTextWrappingData: nil\n  cacheForTextBreakingIntoLinesTopLevel: nil\n\n  # By default the world will always fill\n  # the entire page, also when browser window\n  # is resized.\n  # When this flag is set, the onResize callback\n  # automatically adjusts the world size.\n  automaticallyAdjustToFillEntireBrowserAlsoOnResize: true\n\n  # keypad keys map to special characters\n  # so we can trigger test actions\n  # see more comments below\n  @KEYPAD_TAB_mappedToThaiKeyboard_A: "ฟ"\n  @KEYPAD_SLASH_mappedToThaiKeyboard_B: "ิ"\n  @KEYPAD_MULTIPLY_mappedToThaiKeyboard_C: "แ"\n  @KEYPAD_DELETE_mappedToThaiKeyboard_D: "ก"\n  @KEYPAD_7_mappedToThaiKeyboard_E: "ำ"\n  @KEYPAD_8_mappedToThaiKeyboard_F: "ด"\n  @KEYPAD_9_mappedToThaiKeyboard_G: "เ"\n  @KEYPAD_MINUS_mappedToThaiKeyboard_H: "้"\n  @KEYPAD_4_mappedToThaiKeyboard_I: "ร"\n  @KEYPAD_5_mappedToThaiKeyboard_J: "่" # looks like empty string but isn\'t :-)\n  @KEYPAD_6_mappedToThaiKeyboard_K: "า"\n  @KEYPAD_PLUS_mappedToThaiKeyboard_L: "ส" \n  @KEYPAD_1_mappedToThaiKeyboard_M: "ท"\n  @KEYPAD_2_mappedToThaiKeyboard_N: "ท"\n  @KEYPAD_3_mappedToThaiKeyboard_O: "ื"\n  @KEYPAD_ENTER_mappedToThaiKeyboard_P: "น"\n  @KEYPAD_0_mappedToThaiKeyboard_Q: "ย"\n  @KEYPAD_DOT_mappedToThaiKeyboard_R: "พ"\n\n  morphsDetectingClickOutsideMeOrAnyOfMeChildren: []\n  hierarchyOfClickedMorphs: []\n  hierarchyOfClickedMenus: []\n  popUpsMarkedForClosure: []\n  freshlyCreatedPopUps: []\n  openPopUps: []\n\n  # boot-up state machine\n  @BOOT_COMPLETE: 2\n  @EXECUTING_URL_ACTIONS: 1\n  @JUST_STARTED: 0\n  @bootState: 0\n  @ongoingUrlActionNumber: 0\n\n  @frameCount: 0\n  @numberOfAddsAndRemoves: 0\n  @numberOfVisibilityFlagsChanges: 0\n  @numberOfCollapseFlagsChanges: 0\n  @numberOfRawMovesAndResizes: 0\n\n  broken: nil\n  duplicatedBrokenRectsTracker: nil\n  numberOfDuplicatedBrokenRects: 0\n  numberOfMergedSourceAndDestination: 0\n\n  morphsToBeHighlighted: []\n  currentHighlightingMorphs: []\n  morphsBeingHighlighted: []\n\n  morphsToBePinouted: []\n  currentPinoutingMorphs: []\n  morphsBeingPinouted: []\n\n  steppingMorphs: []\n\n  basementWdgt: nil\n\n  # since the shadow is just a "rendering" effect\n  # there is no morph for it, we need to just clean up\n  # the shadow area ad-hoc. We do that by just growing any\n  # broken rectangle by the maximum shadow offset.\n  # We could be more surgical and remember the offset of the\n  # shadow (if any) in the start and end location of the\n  # morph, just like we do with the position, but it\n  # would complicate things and probably be overkill.\n  # The downside of this is that if we change the\n  # shadow sizes, we have to check that this max size\n  # still captures the biggest.\n  maxShadowSize: 6\n\n  events: []\n\n  # Some operations are triggered by a callback\n  # actioned via a timeout\n  # e.g. see the cut and paste callbacks.\n  # In such cases, we count how many outstanding\n  # callbacks there are of this kind\n  # (by adding elements to this stack when the\n  # callback is scheduled, and popping them when\n  # the callback is executed), so that\n  # we can tell the automator player to PAUSE\n  # execution of actions until the scheduled\n  # callbacks are called. This is so turbo-mode macros\n  # can be still run at maximum speed.\n  # The alternative is to run at normal speed the\n  # macros containing such cases, which\n  # indeed would also take care of the problem\n  # (as the callbacks are likely satisfied at running\n  # time in the same span of time as when the macro\n  # was recorded), but the "slow-play"\n  # solution is more ad-hoc and is much much slower.\n  outstandingTimerTriggeredOperationsCounter: []\n\n  widgetsReferencingOtherWidgets: []\n  incrementalGcSessionId: 0\n  desktopSidesPadding: 10\n\n  # the desktop lays down icons vertically\n  laysIconsHorizontallyInGrid: false\n  iconsLayingInGridWrapCount: 5\n\n  errorsWhileRepainting: []\n  paintingWidget: nil\n  widgetsGivingErrorWhileRepainting: []\n\n  # this one is so we can left/center/right align in\n  # a document editor the last widget that the user "touched"\n  # TODO this could be extended so we keep a "list" of\n  # "selected" widgets (e.g. if the user ctrl-clicks on a widget\n  # then it highlights in some manner and ends up in this list)\n  # and then operations can be performed on the whole list\n  # of widgets.\n  lastNonTextPropertyChangerButtonClickedOrDropped: nil\n\n  patternName: nil\n  pattern1: "plain"\n  pattern2: "circles"\n  pattern3: "vert. stripes"\n  pattern4: "oblique stripes"\n  pattern5: "dots"\n  pattern6: "zigzag"\n  pattern7: "bricks"\n\n  howManyUntitledShortcuts: 0\n  howManyUntitledFoldersShortcuts: 0\n\n  isIndexPage: nil\n\n  constructor: (\n      @worldCanvas,\n      @automaticallyAdjustToFillEntireBrowserAlsoOnResize = true\n      ) ->\n\n    # The WorldMorph is the very first morph to\n    # be created.\n\n    if window.location.href.contains "worldWithSystemTestHarness"\n      @isIndexPage = false\n    else\n      @isIndexPage = true\n\n    WorldMorph.preferencesAndSettings = new PreferencesAndSettings()\n\n    super()\n    @patternName = @pattern1\n    @appearance = new DesktopAppearance @\n\n    #console.log WorldMorph.preferencesAndSettings.menuFontName\n    @color = new Color 205, 205, 205 # (130, 130, 130)\n    @strokeColor = nil\n\n    @alpha = 1\n\n    # additional properties:\n    @stamp = Date.now() # reference in multi-world setups\n    @isDevMode = false\n    @hand = new HandMorph @\n    @keyboardEventsReceiver = nil\n    @lastEditedText = nil\n    @caret = nil\n    @temporaryHandlesAndLayoutAdjusters = []\n    @inputDOMElementForVirtualKeyboard = nil\n\n    if @automaticallyAdjustToFillEntireBrowserAlsoOnResize and @isIndexPage\n      @stretchWorldToFillEntirePage()\n    else\n      @sizeCanvasToTestScreenResolution()\n\n    # @worldCanvas.width and height here are in phisical pixels\n    # so we want to bring them back to logical pixels\n    @setBounds new Rectangle 0, 0, @worldCanvas.width / pixelRatio, @worldCanvas.height / pixelRatio\n\n    @initEventListeners()\n    if AutomatorRecorderAndPlayer?\n      @automatorRecorderAndPlayer = new AutomatorRecorderAndPlayer @, @hand\n\n    @worldCanvasContext = @worldCanvas.getContext "2d"\n\n    @canvasForTextMeasurements = newCanvas()\n    @canvasContextForTextMeasurements = @canvasForTextMeasurements.getContext "2d"\n    @canvasContextForTextMeasurements.scale pixelRatio, pixelRatio\n    @canvasContextForTextMeasurements.textAlign = "left"\n    @canvasContextForTextMeasurements.textBaseline = "bottom"\n\n    # when using an inspector it\'s not uncommon to render\n    # 400 labels just for the properties, so trying to size\n    # the cache accordingly...\n    @cacheForTextMeasurements = new LRUCache 1000, 1000*60*60*24\n    @cacheForTextParagraphSplits = new LRUCache 300, 1000*60*60*24\n    @cacheForParagraphsWordsSplits = new LRUCache 300, 1000*60*60*24\n    @cacheForParagraphsWrappingData = new LRUCache 300, 1000*60*60*24\n    @cacheForTextWrappingData = new LRUCache 300, 1000*60*60*24\n    @cacheForImmutableBackBuffers = new LRUCache 1000, 1000*60*60*24\n    @cacheForTextBreakingIntoLinesTopLevel = new LRUCache 10, 1000*60*60*24\n\n\n    @changed()\n\n  colloquialName: ->\n    "Desktop"\n\n  makePrettier: ->\n    WorldMorph.preferencesAndSettings.menuFontSize = 14\n    WorldMorph.preferencesAndSettings.menuHeaderFontSize = 13\n    WorldMorph.preferencesAndSettings.menuHeaderColor = new Color 125, 125, 125\n    WorldMorph.preferencesAndSettings.menuHeaderBold = false\n    WorldMorph.preferencesAndSettings.menuStrokeColor = new Color 186, 186, 186\n    WorldMorph.preferencesAndSettings.menuBackgroundColor = new Color 250, 250, 250\n    WorldMorph.preferencesAndSettings.menuButtonsLabelColor = new Color 50, 50, 50\n\n    WorldMorph.preferencesAndSettings.normalTextFontSize = 13\n    WorldMorph.preferencesAndSettings.titleBarTextFontSize = 13\n    WorldMorph.preferencesAndSettings.titleBarTextHeight = 16\n    WorldMorph.preferencesAndSettings.titleBarBoldText = false\n    WorldMorph.preferencesAndSettings.bubbleHelpFontSize = 12\n\n\n    WorldMorph.preferencesAndSettings.iconDarkLineColor = new Color 37, 37, 37\n\n\n    WorldMorph.preferencesAndSettings.defaultPanelsBackgroundColor = new Color 249, 249, 249\n    WorldMorph.preferencesAndSettings.defaultPanelsStrokeColor = new Color 198, 198, 198\n\n    @changed()\n\n  getNextUntitledShortcutName: ->\n    name = "Untitled"\n    if @howManyUntitledShortcuts > 0\n      name += " " + (@howManyUntitledShortcuts + 1)\n\n    @howManyUntitledShortcuts++\n\n    return name\n\n  getNextUntitledFolderShortcutName: ->\n    name = "new folder"\n    if @howManyUntitledFoldersShortcuts > 0\n      name += " " + (@howManyUntitledFoldersShortcuts + 1)\n\n    @howManyUntitledFoldersShortcuts++\n\n    return name\n\n\n  wantsDropOf: (aMorph) ->\n    return @_acceptsDrops\n\n  createErrorConsole: ->\n\n    errorsLogViewerMorph = new ErrorsLogViewerMorph "Errors", @, "modifyCodeToBeInjected", ""\n    wm = new WindowWdgt nil, nil, errorsLogViewerMorph\n    wm.setExtent new Point 460, 400\n    world.add wm\n    wm.changed()\n\n\n    @errorConsole = wm\n    @errorConsole.fullMoveTo new Point 190,10\n    @errorConsole.setExtent new Point 550,415\n    @errorConsole.hide()\n\n  boot: ->\n\n    # prevent overscroll (and bounce) in iOS\n    document.body.addEventListener \'touchmove\', (evt) ->\n      #In this case, the default behavior is scrolling the body, which\n      #would result in an overflow.  Since we don\'t want that, we preventDefault.\n      if !evt._isScroller\n        evt.preventDefault()\n      return\n\n    # remove the fake desktop for quick launch and the spinner\n    spinner = document.getElementById \'spinner\'\n    spinner.parentNode.removeChild spinner\n    splashScreenFakeDesktop = document.getElementById \'splashScreenFakeDesktop\'\n    splashScreenFakeDesktop.parentNode.removeChild splashScreenFakeDesktop\n\n    if @isIndexPage\n      @setColor new Color 244,243,244\n      @makePrettier()\n\n\n    # boot-up state machine\n    console.log "booting"\n    @basementWdgt = new BasementWdgt()\n\n    WorldMorph.bootState = WorldMorph.JUST_STARTED\n\n    ProfilingDataCollector.enableProfiling()\n    ProfilingDataCollector.enableBrokenRectsProfiling()\n\n    WorldMorph.ongoingUrlActionNumber= 0\n\n    if @isIndexPage\n      acm = new AnalogClockWdgt()\n      acm.rawSetExtent new Point 80, 80\n      acm.fullRawMoveTo new Point @right()-80-@desktopSidesPadding, @top() + @desktopSidesPadding\n      @add acm\n\n      menusHelper.createWelcomeMessageWindowAndShortcut()\n      menusHelper.createHowToSaveMessageOpener()\n      menusHelper.basementIconAndText()\n      menusHelper.createSimpleDocumentLauncher()\n      menusHelper.createFizzyPaintLauncher()\n      menusHelper.createSimpleSlideLauncher()\n      menusHelper.createDashboardsLauncher()\n      menusHelper.createPatchProgrammingLauncher()\n      menusHelper.createGenericPanelLauncher()\n      menusHelper.createToolbarsOpener()\n      exampleDocsFolder = @makeFolder nil, nil, "examples"\n      menusHelper.createDegreesConverterOpener exampleDocsFolder\n      menusHelper.createSampleSlideOpener exampleDocsFolder\n      menusHelper.createSampleDashboardOpener exampleDocsFolder\n      menusHelper.createSampleDocOpener exampleDocsFolder\n\n  # some test urls:\n\n  # this one contains two actions, two tests each, but only\n  # the second test is run for the second group.\n  # file:///Users/daviddellacasa/Fizzygum/Fizzygum-builds/latest/worldWithSystemTestHarness.html?startupActions=%7B%0D%0A++%22paramsVersion%22%3A+0.1%2C%0D%0A++%22actions%22%3A+%5B%0D%0A++++%7B%0D%0A++++++%22name%22%3A+%22runTests%22%2C%0D%0A++++++%22testsToRun%22%3A+%5B%22bubble%22%5D%0D%0A++++%7D%2C%0D%0A++++%7B%0D%0A++++++%22name%22%3A+%22runTests%22%2C%0D%0A++++++%22testsToRun%22%3A+%5B%22shadow%22%2C+%22SystemTest_basicResize%22%5D%2C%0D%0A++++++%22numberOfGroups%22%3A+2%2C%0D%0A++++++%22groupToBeRun%22%3A+1%0D%0A++++%7D++%5D%0D%0A%7D\n  #\n  # just one simple quick test about shadows\n  #file:///Users/daviddellacasa/Fizzygum/Fizzygum-builds/latest/worldWithSystemTestHarness.html?startupActions=%7B%0A%20%20%22paramsVersion%22%3A%200.1%2C%0A%20%20%22actions%22%3A%20%5B%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%22name%22%3A%20%22runTests%22%2C%0A%20%20%20%20%20%20%22testsToRun%22%3A%20%5B%22shadow%22%5D%0A%20%20%20%20%7D%0A%20%20%5D%0A%7D\n\n  nextStartupAction: ->\n    startupActions = JSON.parse getParameterByName "startupActions"\n\n    if (!startupActions?) or (WorldMorph.ongoingUrlActionNumber == startupActions.actions.length)\n      WorldMorph.bootState = WorldMorph.BOOT_COMPLETE\n      WorldMorph.ongoingUrlActionNumber = 0\n      if AutomatorRecorderAndPlayer?\n        if window.location.href.indexOf("worldWithSystemTestHarness") != -1\n          if @automatorRecorderAndPlayer.atLeastOneTestHasBeenRun\n            if @automatorRecorderAndPlayer.allTestsPassedSoFar\n              document.getElementById("background").style.background = "green"\n\n    if WorldMorph.bootState == WorldMorph.BOOT_COMPLETE\n      return\n\n    console.log "nextStartupAction " + (WorldMorph.ongoingUrlActionNumber+1) + " / " + startupActions.actions.length\n\n    currentAction = startupActions.actions[WorldMorph.ongoingUrlActionNumber]\n    if AutomatorRecorderAndPlayer? and currentAction.name == "runTests"\n      @automatorRecorderAndPlayer.selectTestsFromTagsOrTestNames(currentAction.testsToRun)\n\n      if currentAction.numberOfGroups?\n        @automatorRecorderAndPlayer.numberOfGroups = currentAction.numberOfGroups\n      else\n        @automatorRecorderAndPlayer.numberOfGroups = 1\n      if currentAction.groupToBeRun?\n        @automatorRecorderAndPlayer.groupToBeRun = currentAction.groupToBeRun\n      else\n        @automatorRecorderAndPlayer.groupToBeRun = 0\n\n      if currentAction.forceSlowTestPlaying?\n        @automatorRecorderAndPlayer.forceSlowTestPlaying = true\n      if currentAction.forceTurbo?\n        @automatorRecorderAndPlayer.forceTurbo = true\n      if currentAction.forceSkippingInBetweenMouseMoves?\n        @automatorRecorderAndPlayer.forceSkippingInBetweenMouseMoves = true\n      if currentAction.forceRunningInBetweenMouseMoves?\n        @automatorRecorderAndPlayer.forceRunningInBetweenMouseMoves = true\n\n      @automatorRecorderAndPlayer.runAllSystemTests()\n    WorldMorph.ongoingUrlActionNumber++\n\n\n\n  mostRecentlyCreatedPopUp: ->\n    mostRecentPopUp = nil\n    mostRecentPopUpID = -1\n\n    # we have to check which menus\n    # are actually open, because\n    # the destroy() function used\n    # everywhere is not recursive and\n    # that\'s where we update the @openPopUps\n    # array so we have to doublecheck here\n    # note how we examine the array in reverse order\n    # because we might delete its elements\n    for i in [(@openPopUps.length-1).. 0] by -1\n      if @openPopUps[i].isOrphan()\n        @openPopUps.splice i, 1\n\n    for eachPopUp in @openPopUps\n      if eachPopUp.instanceNumericID >= mostRecentPopUpID\n        mostRecentPopUp = eachPopUp\n    return mostRecentPopUp\n\n  # see roundNumericIDsToNextThousand method in\n  # Widget for an explanation of why we need this\n  # method.\n  alignIDsOfNextMorphsInSystemTests: ->\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE\n      # Check which objects end with the word Widget\n      theWordMorph = "Morph"\n      theWordWdgt = "Wdgt"\n      theWordWidget = "Widget"\n      listOfMorphsClasses = (Object.keys(window)).filter (i) ->\n        (i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1) or\n        (i.indexOf(theWordWdgt, i.length - theWordWdgt.length) isnt -1) or\n        (i.indexOf(theWordWidget, i.length - theWordWidget.length) isnt -1)\n      for eachMorphClass in listOfMorphsClasses\n        #console.log "bumping up ID of class: " + eachMorphClass\n        window[eachMorphClass].roundNumericIDsToNextThousand?()\n\n  # used to close temporary menus\n  closePopUpsMarkedForClosure: ->\n    for eachMorph in @popUpsMarkedForClosure\n      eachMorph.close()\n    @popUpsMarkedForClosure = []\n  \n  # World Widget broken rects debugging\n  # not using it anywhere\n  brokenFor: (aMorph) ->\n    # private\n    fb = aMorph.fullBounds()\n    @broken.filter (rect) ->\n      rect.isIntersecting fb\n  \n  \n  # fullPaintIntoAreaOrBlitFromBackBuffer results into actual painting of pieces of\n  # morphs done\n  # by the paintIntoAreaOrBlitFromBackBuffer function.\n  # The paintIntoAreaOrBlitFromBackBuffer function is defined in Widget.\n  fullPaintIntoAreaOrBlitFromBackBuffer: (aContext, aRect) ->\n    # invokes the Widget\'s fullPaintIntoAreaOrBlitFromBackBuffer, which has only three implementations:\n    #  * the default one by Widget which just invokes the paintIntoAreaOrBlitFromBackBuffer of all children\n    #  * the interesting one in PanelWdgt which a) narrows the dirty\n    #    rectangle (intersecting it with its border\n    #    since the PanelWdgt clips at its border) and b) stops recursion on all\n    #    the children that are outside such intersection.\n    #  * this implementation which just takes into account that the hand\n    #    (which could contain a Widget being floatDragged)\n    #    is painted on top of everything.\n    super aContext, aRect\n\n    # the mouse cursor is always drawn on top of everything\n    # and it\'s not attached to the WorldMorph.\n    @hand.fullPaintIntoAreaOrBlitFromBackBuffer aContext, aRect\n\n  clippedThroughBounds: ->\n    @checkClippedThroughBoundsCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    @clippedThroughBoundsCache = @boundingBox()\n    return @clippedThroughBoundsCache\n\n  clipThrough: ->\n    @checkClipThroughCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    @clipThroughCache = @boundingBox()\n    return @clipThroughCache\n\n  pushBrokenRect: (brokenMorph, theRect, isSrc) ->\n    if @duplicatedBrokenRectsTracker[theRect.toString()]?\n      @numberOfDuplicatedBrokenRects++\n    else\n      if isSrc\n        brokenMorph.srcBrokenRect = @broken.length\n      else\n        brokenMorph.dstBrokenRect = @broken.length\n      if !theRect?\n        debugger\n      # if @broken.length == 0\n      #  debugger\n      @broken.push theRect\n    @duplicatedBrokenRectsTracker[theRect.toString()] = true\n\n  mergeBrokenRectsIfCloseOrPushBoth: (brokenMorph, sourceBroken, destinationBroken) ->\n    mergedBrokenRect = sourceBroken.merge destinationBroken\n    mergedBrokenRectArea = mergedBrokenRect.area()\n    sumArea = sourceBroken.area() + destinationBroken.area()\n    #console.log "mergedBrokenRectArea: " + mergedBrokenRectArea + " (sumArea + sumArea/10): " + (sumArea + sumArea/10)\n    if mergedBrokenRectArea < sumArea + sumArea/10\n      @pushBrokenRect brokenMorph, mergedBrokenRect, true\n      @numberOfMergedSourceAndDestination++\n    else\n      @pushBrokenRect brokenMorph, sourceBroken, true\n      @pushBrokenRect brokenMorph, destinationBroken, false\n\n\n  checkARectWithHierarchy: (aRect, brokenMorph, isSrc) ->\n    brokenMorphAncestor = brokenMorph\n\n    #if brokenMorph instanceof SliderMorph\n    #  debugger\n\n    while brokenMorphAncestor.parent?\n      brokenMorphAncestor = brokenMorphAncestor.parent\n      if brokenMorphAncestor.srcBrokenRect?\n        if !@broken[brokenMorphAncestor.srcBrokenRect]?\n          debugger\n        if @broken[brokenMorphAncestor.srcBrokenRect].containsRectangle aRect\n          if isSrc\n            @broken[brokenMorph.srcBrokenRect] = nil\n            brokenMorph.srcBrokenRect = nil\n          else\n            @broken[brokenMorph.dstBrokenRect] = nil\n            brokenMorph.dstBrokenRect = nil\n        else if aRect.containsRectangle @broken[brokenMorphAncestor.srcBrokenRect]\n          @broken[brokenMorphAncestor.srcBrokenRect] = nil\n          brokenMorphAncestor.srcBrokenRect = nil\n\n      if brokenMorphAncestor.dstBrokenRect?\n        if !@broken[brokenMorphAncestor.dstBrokenRect]?\n          debugger\n        if @broken[brokenMorphAncestor.dstBrokenRect].containsRectangle aRect\n          if isSrc\n            @broken[brokenMorph.srcBrokenRect] = nil\n            brokenMorph.srcBrokenRect = nil\n          else\n            @broken[brokenMorph.dstBrokenRect] = nil\n            brokenMorph.dstBrokenRect = nil\n        else if aRect.containsRectangle @broken[brokenMorphAncestor.dstBrokenRect]\n          @broken[brokenMorphAncestor.dstBrokenRect] = nil\n          brokenMorphAncestor.dstBrokenRect = nil      \n\n\n  rectAlreadyIncludedInParentBrokenMorph: ->\n    for brokenMorph in window.morphsThatMaybeChangedGeometryOrPosition\n        if brokenMorph.srcBrokenRect?\n          aRect = @broken[brokenMorph.srcBrokenRect]\n          @checkARectWithHierarchy aRect, brokenMorph, true\n        if brokenMorph.dstBrokenRect?\n          aRect = @broken[brokenMorph.dstBrokenRect]\n          @checkARectWithHierarchy aRect, brokenMorph, false\n\n    for brokenMorph in window.morphsThatMaybeChangedFullGeometryOrPosition\n        if brokenMorph.srcBrokenRect?\n          aRect = @broken[brokenMorph.srcBrokenRect]\n          @checkARectWithHierarchy aRect, brokenMorph\n        if brokenMorph.dstBrokenRect?\n          aRect = @broken[brokenMorph.dstBrokenRect]\n          @checkARectWithHierarchy aRect, brokenMorph\n\n  cleanupSrcAndDestRectsOfMorphs: ->\n    for brokenMorph in window.morphsThatMaybeChangedGeometryOrPosition\n      brokenMorph.srcBrokenRect = nil\n      brokenMorph.dstBrokenRect = nil\n    for brokenMorph in window.morphsThatMaybeChangedFullGeometryOrPosition\n      brokenMorph.srcBrokenRect = nil\n      brokenMorph.dstBrokenRect = nil\n\n\n  fleshOutBroken: ->\n    #if window.morphsThatMaybeChangedGeometryOrPosition.length > 0\n    #  debugger\n\n    sourceBroken = nil\n    destinationBroken = nil\n\n\n    for brokenMorph in window.morphsThatMaybeChangedGeometryOrPosition\n\n      # let\'s see if this Widget that marked itself as broken\n      # was actually painted in the past frame.\n      # If it was then we have to clean up the "before" area\n      # even if the Widget is not visible anymore\n      if brokenMorph.clippedBoundsWhenLastPainted?\n        if brokenMorph.clippedBoundsWhenLastPainted.isNotEmpty()\n          sourceBroken = brokenMorph.clippedBoundsWhenLastPainted.growBy @maxShadowSize\n\n        #if brokenMorph!= world and (brokenMorph.clippedBoundsWhenLastPainted.containsPoint (new Point(10,10)))\n        #  debugger\n\n      # for the "destination" broken rectangle we can actually\n      # check whether the Widget is still visible because we\n      # can skip the destination rectangle in that case\n      # (not the source one!)\n      unless brokenMorph.surelyNotShowingUpOnScreenBasedOnVisibilityCollapseAndOrphanage()\n        # @clippedThroughBounds() should be smaller area\n        # than bounds because it clips\n        # the bounds based on the clipping morphs up the\n        # hierarchy\n        boundsToBeChanged = brokenMorph.clippedThroughBounds()\n\n        if boundsToBeChanged.isNotEmpty()\n          destinationBroken = boundsToBeChanged.spread().growBy @maxShadowSize\n          #if brokenMorph!= world and (boundsToBeChanged.spread().containsPoint new Point 10, 10)\n          #  debugger\n\n\n      if sourceBroken? and destinationBroken?\n        @mergeBrokenRectsIfCloseOrPushBoth brokenMorph, sourceBroken, destinationBroken\n      else if sourceBroken? or destinationBroken?\n        if sourceBroken?\n          @pushBrokenRect brokenMorph, sourceBroken, true\n        else\n          @pushBrokenRect brokenMorph, destinationBroken, true\n\n      brokenMorph.geometryOrPositionPossiblyChanged = false\n      brokenMorph.clippedBoundsWhenLastPainted = nil\n\n    \n\n  fleshOutFullBroken: ->\n    #if window.morphsThatMaybeChangedFullGeometryOrPosition.length > 0\n    #  debugger\n\n    sourceBroken = nil\n    destinationBroken = nil\n\n    for brokenMorph in window.morphsThatMaybeChangedFullGeometryOrPosition\n\n      #console.log "fleshOutFullBroken: " + brokenMorph\n\n      if brokenMorph.fullClippedBoundsWhenLastPainted?\n        if brokenMorph.fullClippedBoundsWhenLastPainted.isNotEmpty()\n          sourceBroken = brokenMorph.fullClippedBoundsWhenLastPainted.growBy @maxShadowSize\n\n      # for the "destination" broken rectangle we can actually\n      # check whether the Widget is still visible because we\n      # can skip the destination rectangle in that case\n      # (not the source one!)\n      unless brokenMorph.surelyNotShowingUpOnScreenBasedOnVisibilityCollapseAndOrphanage()\n\n        boundsToBeChanged = brokenMorph.fullClippedBounds()\n\n        if boundsToBeChanged.isNotEmpty()\n          destinationBroken = boundsToBeChanged.spread().growBy @maxShadowSize\n          #if brokenMorph!= world and (boundsToBeChanged.spread().containsPoint (new Point(10,10)))\n          #  debugger\n      \n   \n      if sourceBroken? and destinationBroken?\n        @mergeBrokenRectsIfCloseOrPushBoth brokenMorph, sourceBroken, destinationBroken\n      else if sourceBroken? or destinationBroken?\n        if sourceBroken?\n          @pushBrokenRect brokenMorph, sourceBroken, true\n        else\n          @pushBrokenRect brokenMorph, destinationBroken, true\n\n      brokenMorph.fullGeometryOrPositionPossiblyChanged = false\n      brokenMorph.fullClippedBoundsWhenLastPainted = nil\n\n\n  showBrokenRects: (aContext) ->\n    aContext.save()\n    aContext.globalAlpha = 0.5\n    aContext.scale pixelRatio, pixelRatio\n \n    for eachBrokenRect in @broken\n      if eachBrokenRect?\n        randomR = Math.round Math.random() * 255\n        randomG = Math.round Math.random() * 255\n        randomB = Math.round Math.random() * 255\n\n        aContext.fillStyle = "rgb("+randomR+","+randomG+","+randomB+")"\n        aContext.fillRect  Math.round(eachBrokenRect.origin.x),\n            Math.round(eachBrokenRect.origin.y),\n            Math.round(eachBrokenRect.width()),\n            Math.round(eachBrokenRect.height())\n    aContext.restore()\n\n\n  # layouts are recalculated like so:\n  # there will be several subtrees\n  # that will need relayout.\n  # So take the head of any subtree and re-layout it\n  # The relayout might or might not visit all the subnodes\n  # of the subtree, because you might have a subtree\n  # that lives inside a floating morph, in which\n  # case it\'s not re-layout.\n  # So, a subtree might not be healed in one go,\n  # rather we keep track of what\'s left to heal and\n  # we apply the same process: we heal from the head node\n  # and take out of the list what\'s healed in that step,\n  # and we continue doing so until there is nothing else\n  # to heal.\n  recalculateLayouts: ->\n\n    until morphsThatMaybeChangedLayout.length == 0\n\n      # find the first Widget which has a broken layout,\n      # take out of queue all the others\n      loop\n        tryThisMorph = morphsThatMaybeChangedLayout[morphsThatMaybeChangedLayout.length - 1]\n        if tryThisMorph.layoutIsValid\n          morphsThatMaybeChangedLayout.pop()\n          if morphsThatMaybeChangedLayout.length == 0\n            return\n        else\n          break\n\n      # now that you have a Widget with a broken layout\n      # go up the chain of broken layouts as much as\n      # possible\n      # QUESTION: would it be safer instead to start from the\n      # very top invalid morph, i.e. on the way to the top,\n      # stop at the last morph with an invalid layout\n      # instead of stopping at the first morph with a\n      # valid layout...\n      while tryThisMorph.parent?\n        if tryThisMorph.layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING or tryThisMorph.parent.layoutIsValid\n          break\n        tryThisMorph = tryThisMorph.parent\n\n      try\n        # so now you have a "top" element up a chain\n        # of morphs with broken layout. Go do a\n        # doLayout on it, so it might fix a bunch of those\n        # on the chain (but not all)\n        tryThisMorph.doLayout()\n      catch err\n        @softResetWorld()\n        if !world.errorConsole? then world.createErrorConsole()\n        @errorConsole.contents.showUpWithError err\n\n\n  clearGeometryOrPositionPossiblyChangedFlags: ->\n    for m in window.morphsThatMaybeChangedGeometryOrPosition\n      m.geometryOrPositionPossiblyChanged = false\n\n  clearFullGeometryOrPositionPossiblyChangedFlags: ->\n    for m in window.morphsThatMaybeChangedFullGeometryOrPosition\n      m.fullGeometryOrPositionPossiblyChanged = false\n\n  updateBroken: ->\n    #console.log "number of broken rectangles: " + @broken.length\n    @broken = []\n    @duplicatedBrokenRectsTracker = {}\n    @numberOfDuplicatedBrokenRects = 0\n    @numberOfMergedSourceAndDestination = 0\n\n    @fleshOutFullBroken()\n    @fleshOutBroken()\n    @rectAlreadyIncludedInParentBrokenMorph()\n    @cleanupSrcAndDestRectsOfMorphs()\n\n    @clearGeometryOrPositionPossiblyChangedFlags()\n    @clearFullGeometryOrPositionPossiblyChangedFlags()\n\n    window.morphsThatMaybeChangedGeometryOrPosition = []\n    window.morphsThatMaybeChangedFullGeometryOrPosition = []\n    #ProfilingDataCollector.profileBrokenRects @broken, @numberOfDuplicatedBrokenRects, @numberOfMergedSourceAndDestination\n\n    # each broken rectangle requires traversing the scenegraph to\n    # redraw what\'s overlapping it. Not all Widgets are traversed\n    # in particular the following can stop the recursion:\n    #  - invisible Widgets\n    #  - PanelWdgts that don\'t overlap the broken rectangle\n    # Since potentially there is a lot of traversal ongoin for\n    # each broken rectangle, one might want to consolidate overlapping\n    # and nearby rectangles.\n\n    window.healingRectanglesPhase = true\n\n    @errorsWhileRepainting = []\n\n    @broken.forEach (rect) =>\n      if !rect?\n        return\n      if rect.isNotEmpty()\n        try\n          @fullPaintIntoAreaOrBlitFromBackBuffer @worldCanvasContext, rect\n        catch err\n          @resetWorldCanvasContext()\n          @queueErrorForLaterReporting err\n          @hideOffendingWidget()\n          @softResetWorld()\n\n    # IF we got errors while repainting, the\n    # screen might be in a bad state (because everything in front of the\n    # "bad" widget is not repainted since the offending widget has\n    # thrown, so nothing in front of it could be painted properly)\n    # SO do COMPLETE repaints of the screen and hide\n    # further offending widgets until there are no more errors\n    # (i.e. the offending widgets are progressively hidden so eventually\n    # we should repaint the whole screen without errors, hopefully)\n    if @errorsWhileRepainting.length != 0\n      @findOutAllOtherOffendingWidgetsAndPaintWholeScreen()\n\n    if world.showRedraws\n      @showBrokenRects @worldCanvasContext\n\n    @resetDataStructuresForBrokenRects()\n\n    window.healingRectanglesPhase = false\n    if trackChanges.length != 1 and trackChanges[0] != true\n      alert "trackChanges array should have only one element (true)"\n\n  findOutAllOtherOffendingWidgetsAndPaintWholeScreen: ->\n    # we keep repainting the whole screen until there are no\n    # errors.\n    # Why do we need multiple repaints and not just one?\n    # Because remember that when a widget throws an error while\n    # repainting, it bubble all the way up and stops any\n    # further repainting of the other widgets, potentially\n    # preventing the finding of errors in the other\n    # widgets. Hence, we need to keep repainting until\n    # there are no errors.\n\n    currentErrorsCount = @errorsWhileRepainting.length\n    previousErrorsCount = nil\n    numberOfTotalRepaints = 0\n    until previousErrorsCount == currentErrorsCount\n      numberOfTotalRepaints++\n      try\n        @fullPaintIntoAreaOrBlitFromBackBuffer @worldCanvasContext, @bounds\n      catch err\n        @resetWorldCanvasContext()\n        @queueErrorForLaterReporting err\n        @hideOffendingWidget()\n        @softResetWorld()\n\n      previousErrorsCount = currentErrorsCount\n      currentErrorsCount = @errorsWhileRepainting.length\n\n    #console.log "total repaints: " + numberOfTotalRepaints\n\n  resetWorldCanvasContext: ->\n    # when an error is thrown while painting, it\'s\n    # possible that we are left with a context in a strange\n    # mixed state, so try to bring it back to\n    # normality as much as possible\n    # We are doing this for "cleanliness" of the context\n    # state, not because we care of the drawing being\n    # perfect (we are eventually going to repaint the\n    # whole screen without the offending widgets\n    # widgets).\n    @worldCanvasContext.closePath()\n    @worldCanvasContext.resetClip?()\n    @worldCanvasContext.resetTransform?()\n    for j in [1...2000]\n      @worldCanvasContext.restore()\n\n  queueErrorForLaterReporting: (err) ->\n    # now record the error so we can report it in the\n    # next cycle, and add the offending widget to a\n    # "banned" list\n    @errorsWhileRepainting.push err\n    if (@widgetsGivingErrorWhileRepainting.indexOf @paintingWidget) == -1\n      @widgetsGivingErrorWhileRepainting.push @paintingWidget\n      @paintingWidget.silentHide()\n\n  hideOffendingWidget: ->\n    if (@widgetsGivingErrorWhileRepainting.indexOf @paintingWidget) == -1\n      @widgetsGivingErrorWhileRepainting.push @paintingWidget\n      @paintingWidget.silentHide()\n\n  resetDataStructuresForBrokenRects: ->\n    @broken = []\n    @duplicatedBrokenRectsTracker = {}\n    @numberOfDuplicatedBrokenRects = 0\n    @numberOfMergedSourceAndDestination = 0\n\n  addPinoutingMorphs: ->\n    for eachPinoutingMorph in @currentPinoutingMorphs.slice()\n      if eachPinoutingMorph.morphThisMorphIsPinouting in @morphsToBePinouted\n        if eachPinoutingMorph.morphThisMorphIsPinouting.hasMaybeChangedGeometryOrPosition()\n          # reposition the pinout morph if needed\n          peekThroughBox = eachPinoutingMorph.morphThisMorphIsPinouting.clippedThroughBounds()\n          eachPinoutingMorph.fullRawMoveTo new Point(peekThroughBox.right() + 10,peekThroughBox.top())\n\n      else\n        @currentPinoutingMorphs.remove eachPinoutingMorph\n        @morphsBeingPinouted.remove eachPinoutingMorph.morphThisMorphIsPinouting\n        eachPinoutingMorph.morphThisMorphIsPinouting = nil\n        eachPinoutingMorph.fullDestroy()\n\n    for eachMorphNeedingPinout in @morphsToBePinouted.slice()\n      if eachMorphNeedingPinout not in @morphsBeingPinouted\n        hM = new StringMorph2 eachMorphNeedingPinout.toString()\n        world.add hM\n        hM.morphThisMorphIsPinouting = eachMorphNeedingPinout\n        peekThroughBox = eachMorphNeedingPinout.clippedThroughBounds()\n        hM.fullRawMoveTo new Point(peekThroughBox.right() + 10,peekThroughBox.top())\n        hM.setColor new Color 0, 0, 255\n        hM.setWidth 400\n        @currentPinoutingMorphs.push hM\n        @morphsBeingPinouted.push eachMorphNeedingPinout\n  \n  addHighlightingMorphs: ->\n    for eachHighlightingMorph in @currentHighlightingMorphs.slice()\n      if eachHighlightingMorph.morphThisMorphIsHighlighting in @morphsToBeHighlighted\n        if eachHighlightingMorph.morphThisMorphIsHighlighting.hasMaybeChangedGeometryOrPosition()\n          eachHighlightingMorph.rawSetBounds eachHighlightingMorph.morphThisMorphIsHighlighting.clippedThroughBounds()\n      else\n        @currentHighlightingMorphs.remove eachHighlightingMorph\n        @morphsBeingHighlighted.remove eachHighlightingMorph.morphThisMorphIsHighlighting\n        eachHighlightingMorph.morphThisMorphIsHighlighting = nil\n        eachHighlightingMorph.fullDestroy()\n\n    for eachMorphNeedingHighlight in @morphsToBeHighlighted.slice()\n      if eachMorphNeedingHighlight not in @morphsBeingHighlighted\n        hM = new HighlighterMorph()\n        world.add hM\n        hM.morphThisMorphIsHighlighting = eachMorphNeedingHighlight\n        hM.rawSetBounds eachMorphNeedingHighlight.clippedThroughBounds()\n        hM.setColor new Color 0, 0, 255\n        hM.setAlphaScaled 50\n        @currentHighlightingMorphs.push hM\n        @morphsBeingHighlighted.push eachMorphNeedingHighlight\n\n\n  playQueuedEvents: ->\n    try\n\n      for i in [0...@events.length] by 2\n        eventType = @events[i]\n        # note that these events are actually strings\n        # in the case of clipboard events. Since\n        # for security reasons clipboard access is not\n        # allowed outside of the event listener, we\n        # have to work with text here.\n        event = @events[i+1]\n\n        switch eventType\n\n          when "inputDOMElementForVirtualKeyboardKeydownEventListener"\n            @keyboardEventsReceiver.processKeyDown event  if @keyboardEventsReceiver\n\n            if event.keyIdentifier is "U+0009" or event.keyIdentifier is "Tab"\n              @keyboardEventsReceiver.processKeyPress event  if @keyboardEventsReceiver\n\n          when "inputDOMElementForVirtualKeyboardKeyupEventListener"\n            # dispatch to keyboard receiver\n            if @keyboardEventsReceiver\n              # so far the caret is the only keyboard\n              # event handler and it has no keyup\n              # handler\n              if @keyboardEventsReceiver.processKeyUp\n                @keyboardEventsReceiver.processKeyUp event  \n\n          when "inputDOMElementForVirtualKeyboardKeypressEventListener"\n            @keyboardEventsReceiver.processKeyPress event  if @keyboardEventsReceiver\n\n          when "mousedownEventListener"\n            @processMouseDown event.button, event.buttons, event.ctrlKey, event.shiftKey, event.altKey, event.metaKey\n\n          when "touchstartEventListener"\n            @hand.processTouchStart event\n\n          when "mouseupEventListener"\n            @processMouseUp  event.button, event.ctrlKey, event.buttons, event.shiftKey, event.altKey, event.metaKey\n\n          when "touchendEventListener"\n            @hand.processTouchEnd event\n\n          when "mousemoveEventListener"\n            posInDocument = getDocumentPositionOf @worldCanvas\n            # events from JS arrive in page coordinates,\n            # we turn those into world coordinates\n            # instead.\n            worldX = event.pageX - posInDocument.x\n            worldY = event.pageY - posInDocument.y\n            @processMouseMove worldX, worldY, event.button, event.buttons, event.ctrlKey, event.shiftKey, event.altKey, event.metaKey\n\n          when "touchmoveEventListener"\n            @hand.processTouchMove event\n\n          when "keydownEventListener"\n            @processKeydown event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n\n          when "keyupEventListener"\n            @processKeyup event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n\n          when "keypressEventListener"\n            @processKeypress event, event.keyCode, @getChar(event), event.shiftKey, event.ctrlKey, event.altKey, event.metaKey\n\n          when "wheelEventListener"\n            @processWheel event.deltaX, event.deltaY, event.deltaZ, event.altKey, event.button, event.buttons\n\n          when "cutEventListener"\n            # note that "event" here is actually a string,\n            # for security reasons clipboard access is not\n            # allowed outside of the event listener, we\n            # have to work with text here.\n            @processCut event\n\n          when "copyEventListener"\n            # note that "event" here is actually a string,\n            # for security reasons clipboard access is not\n            # allowed outside of the event listener, we\n            # have to work with text here.\n            @processCopy event\n\n          when "pasteEventListener"\n            # note that "event" here is actually a string,\n            # for security reasons clipboard access is not\n            # allowed outside of the event listener, we\n            # have to work with text here.\n            @processPaste event\n\n          when "dropEventListener"\n            @hand.processDrop event\n\n          when "resizeEventListener"\n            if @automaticallyAdjustToFillEntireBrowserAlsoOnResize\n              @stretchWorldToFillEntirePage()\n\n    catch err\n      @softResetWorld()\n      if !world.errorConsole? then world.createErrorConsole()\n      @errorConsole.contents.showUpWithError err\n\n    @events = []\n\n  # we keep the "pacing" promises in this\n  # srcLoadsSteps array, (or, more precisely,\n  # we keep their resolving functions) and each frame\n  # we resolve one, so we don\'t cause gitter.\n  loadAPartOfFizzyGumSourceIfNeeded: ->\n    if window.srcLoadsSteps.length > 0\n      resolvingFunction = window.srcLoadsSteps.shift()\n      resolvingFunction.call()\n\n  showErrorsHappenedInRepaintingStepInPreviousCycle: ->\n    for eachErr in @errorsWhileRepainting\n      if !world.errorConsole? then world.createErrorConsole()\n      @errorConsole.contents.showUpWithError eachErr\n\n  doOneCycle: ->\n    WorldMorph.currentTime = Date.now()\n    WorldMorph.currentDate = new Date()\n    # console.log TextMorph.instancesCounter + " " + StringMorph.instancesCounter\n\n    @showErrorsHappenedInRepaintingStepInPreviousCycle()\n\n    @playQueuedEvents()\n\n    # most notably replays test actions at the right time\n    @runOtherTasksStepFunction()\n    @loadAPartOfFizzyGumSourceIfNeeded()\n    \n    @runChildrensStepFunction()\n    @hand.reCheckMouseEntersAndMouseLeavesAfterPotentialGeometryChanges()\n    window.recalculatingLayouts = true\n    @recalculateLayouts()\n    window.recalculatingLayouts = false\n    @addPinoutingMorphs()\n    @addHighlightingMorphs()\n\n    # here is where the repainting on screen happens\n    @updateBroken()\n\n    WorldMorph.frameCount++\n\n  addSteppingMorph: (theMorph) ->\n    if @steppingMorphs.indexOf(theMorph) == -1\n      @steppingMorphs.push theMorph\n\n  removeSteppingMorph: (theMorph) ->\n    if @steppingMorphs.indexOf(theMorph) != -1\n      @steppingMorphs.remove theMorph\n\n  # Widget stepping:\n  runChildrensStepFunction: ->\n\n\n    # make a shallow copy of the array before iterating over\n    # it in the case some morph destroys itself and takes itself\n    # out of the array thus changing it in place and mangling the\n    # stepping.\n    # TODO all these array modifications should be immutable...\n    steppingMorphs = arrayShallowCopy @steppingMorphs\n\n    for eachSteppingMorph in steppingMorphs\n\n      #if eachSteppingMorph.isBeingFloatDragged()\n      #  continue\n\n      # for objects where @fps is defined, check which ones are due to be stepped\n      # and which ones want to wait.\n      millisBetweenSteps = Math.round(1000 / eachSteppingMorph.fps)\n      if eachSteppingMorph.fps <= 0\n        # if fps 0 or negative, then just run as fast as possible,\n        # so 0 milliseconds remaining to the next invokation\n        millisecondsRemainingToWaitedFrame = 0\n      else\n        if eachSteppingMorph.synchronisedStepping\n          millisecondsRemainingToWaitedFrame = millisBetweenSteps - (WorldMorph.currentTime % millisBetweenSteps)\n          if eachSteppingMorph.previousMillisecondsRemainingToWaitedFrame != 0 and millisecondsRemainingToWaitedFrame > eachSteppingMorph.previousMillisecondsRemainingToWaitedFrame\n            millisecondsRemainingToWaitedFrame = 0\n          eachSteppingMorph.previousMillisecondsRemainingToWaitedFrame = millisecondsRemainingToWaitedFrame\n          #console.log millisBetweenSteps + " " + millisecondsRemainingToWaitedFrame\n        else\n          elapsedMilliseconds = WorldMorph.currentTime - eachSteppingMorph.lastTime\n          millisecondsRemainingToWaitedFrame = millisBetweenSteps - elapsedMilliseconds\n      \n      if millisecondsRemainingToWaitedFrame <= 0\n        @stepWidget eachSteppingMorph\n\n        # Increment "lastTime" by millisBetweenSteps. Two notes:\n        # 1) We don\'t just set it to currentTime so that there is no drifting\n        # in running it the next time: we run it the next time as if this time it\n        # ran exactly on time.\n        # 2) We are going to update "last time" with the loop\n        # below. This is because in case the window is not in foreground,\n        # requestAnimationFrame doesn\'t run, so we might skip a number of steps.\n        # In such cases, just bring "lastTime" up to speed here.\n        # If we don\'t do that, "skipped" steps would catch up on us and run all\n        # in contigous frames when the window comes to foreground, so the\n        # widgets would animate frantically (every frame) catching up on\n        # all the steps they missed. We don\'t want that.\n        #\n        # while eachSteppingMorph.lastTime + millisBetweenSteps < WorldMorph.currentTime\n        #   eachSteppingMorph.lastTime += millisBetweenSteps\n        #\n        # 3) and finally, here is the equivalent of the loop above, but done\n        # in one shot using remainders.\n        # Again: we are looking for the last "multiple" k such that\n        #      lastTime + k * millisBetweenSteps\n        # is less than currentTime.\n\n        eachSteppingMorph.lastTime = WorldMorph.currentTime - ((WorldMorph.currentTime - eachSteppingMorph.lastTime) % millisBetweenSteps)\n\n\n\n  stepWidget: (whichWidget) ->\n    if whichWidget.onNextStep\n      nxt = whichWidget.onNextStep\n      whichWidget.onNextStep = nil\n      nxt.call whichWidget\n    if !whichWidget.step?\n      debugger\n    try\n      whichWidget.step()\n      console.log "stepping " + whichWidget\n    catch err\n      @softResetWorld()\n      if !world.errorConsole? then world.createErrorConsole()\n      @errorConsole.contents.showUpWithError err\n\n  \n  runOtherTasksStepFunction : ->\n    for task in @otherTasksToBeRunOnStep\n      #console.log "running a task: " + task\n      task()\n\n  sizeCanvasToTestScreenResolution: ->\n    @worldCanvas.width = Math.round(960 * pixelRatio)\n    @worldCanvas.height = Math.round(440 * pixelRatio)\n    @worldCanvas.style.width = "960px"\n    @worldCanvas.style.height = "440px"\n\n    bkground = document.getElementById("background")\n    bkground.style.width = "960px"\n    bkground.style.height = "720px"\n    bkground.style.backgroundColor = "rgb(245, 245, 245)"\n\n  stretchWorldToFillEntirePage: ->\n    # once you call this, the world will forever take the whole page\n    @automaticallyAdjustToFillEntireBrowserAlsoOnResize = true\n    pos = getDocumentPositionOf @worldCanvas\n    clientHeight = window.innerHeight\n    clientWidth = window.innerWidth\n    if pos.x > 0\n      @worldCanvas.style.position = "absolute"\n      @worldCanvas.style.left = "0px"\n      pos.x = 0\n    if pos.y > 0\n      @worldCanvas.style.position = "absolute"\n      @worldCanvas.style.top = "0px"\n      pos.y = 0\n    # scrolled down b/c of viewport scaling\n    clientHeight = document.documentElement.clientHeight  if document.body.scrollTop\n    # scrolled left b/c of viewport scaling\n    clientWidth = document.documentElement.clientWidth  if document.body.scrollLeft\n\n    if (@worldCanvas.width isnt clientWidth) or (@worldCanvas.height isnt clientHeight)\n      @fullChanged()\n      @worldCanvas.width = (clientWidth * pixelRatio)\n      @worldCanvas.style.width = clientWidth + "px"\n      @worldCanvas.height = (clientHeight * pixelRatio)\n      @worldCanvas.style.height = clientHeight + "px"\n      @rawSetExtent new Point clientWidth, clientHeight\n      @desktopReLayout()\n  \n\n  desktopReLayout: ->\n    basementOpenerWdgt = @firstChildSuchThat (w) ->\n      w instanceof BasementOpenerWdgt\n    if basementOpenerWdgt?\n      if basementOpenerWdgt.userMovedThisFromComputedPosition\n        basementOpenerWdgt.fullRawMoveInDesktopToFractionalPosition()\n        if !basementOpenerWdgt.wasPositionedSlightlyOutsidePanel\n          basementOpenerWdgt.fullRawMoveWithin @\n      else\n        basementOpenerWdgt.fullMoveTo @bottomRight().subtract (new Point 75, 75).add @desktopSidesPadding\n\n    analogClockWdgt = @firstChildSuchThat (w) ->\n      w instanceof AnalogClockWdgt\n    if analogClockWdgt?\n      if analogClockWdgt.userMovedThisFromComputedPosition\n        analogClockWdgt.fullRawMoveInDesktopToFractionalPosition()\n        if !analogClockWdgt.wasPositionedSlightlyOutsidePanel\n          analogClockWdgt.fullRawMoveWithin @\n      else\n        analogClockWdgt.fullMoveTo new Point @right() - 80 - @desktopSidesPadding, @top() + @desktopSidesPadding \n\n    @children.forEach (child) =>\n      if child != basementOpenerWdgt and child != analogClockWdgt and  !(child instanceof WidgetHolderWithCaptionWdgt)\n        if child.positionFractionalInHoldingPanel?\n          child.fullRawMoveInDesktopToFractionalPosition()\n        if !child.wasPositionedSlightlyOutsidePanel\n          child.fullRawMoveWithin @\n  \n  # WorldMorph events:\n  initVirtualKeyboard: ->\n    if @inputDOMElementForVirtualKeyboard\n      document.body.removeChild @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard = nil\n    unless (WorldMorph.preferencesAndSettings.isTouchDevice and WorldMorph.preferencesAndSettings.useVirtualKeyboard)\n      return\n    @inputDOMElementForVirtualKeyboard = document.createElement "input"\n    @inputDOMElementForVirtualKeyboard.type = "text"\n    @inputDOMElementForVirtualKeyboard.style.color = "transparent"\n    @inputDOMElementForVirtualKeyboard.style.backgroundColor = "transparent"\n    @inputDOMElementForVirtualKeyboard.style.border = "none"\n    @inputDOMElementForVirtualKeyboard.style.outline = "none"\n    @inputDOMElementForVirtualKeyboard.style.position = "absolute"\n    @inputDOMElementForVirtualKeyboard.style.top = "0px"\n    @inputDOMElementForVirtualKeyboard.style.left = "0px"\n    @inputDOMElementForVirtualKeyboard.style.width = "0px"\n    @inputDOMElementForVirtualKeyboard.style.height = "0px"\n    @inputDOMElementForVirtualKeyboard.autocapitalize = "none" # iOS specific\n    document.body.appendChild @inputDOMElementForVirtualKeyboard\n\n    @inputDOMElementForVirtualKeyboardKeydownEventListener = (event) =>\n      @events.push "inputDOMElementForVirtualKeyboardKeydownEventListener"\n      @events.push event\n      # Default in several browsers\n      # is for the backspace button to trigger\n      # the "back button", so we prevent that\n      # default here.\n      if event.keyIdentifier is "U+0008" or event.keyIdentifier is "Backspace"\n        event.preventDefault()  \n\n      # suppress tab override and make sure tab gets\n      # received by all browsers\n      if event.keyIdentifier is "U+0009" or event.keyIdentifier is "Tab"\n        event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keydown",\n      @inputDOMElementForVirtualKeyboardKeydownEventListener, false\n\n    @inputDOMElementForVirtualKeyboardKeyupEventListener = (event) =>\n      @events.push "inputDOMElementForVirtualKeyboardKeyupEventListener"\n      @events.push event\n      event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keyup",\n      @inputDOMElementForVirtualKeyboardKeyupEventListener, false\n\n    @inputDOMElementForVirtualKeyboardKeypressEventListener = (event) =>\n      @events.push "inputDOMElementForVirtualKeyboardKeypressEventListener"\n      @events.push event\n      event.preventDefault()\n\n    @inputDOMElementForVirtualKeyboard.addEventListener "keypress",\n      @inputDOMElementForVirtualKeyboardKeypressEventListener, false\n\n  getPointerAndMorphInfo:  (topMorphUnderPointer = @hand.topMorphUnderPointer()) ->\n    # we might eliminate this command afterwards if\n    # we find out user is clicking on a menu item\n    # or right-clicking on a morph\n    absoluteBoundsOfMorphRelativeToWorld = topMorphUnderPointer.boundingBox().asArray_xywh()\n    morphIdentifierViaTextLabel = topMorphUnderPointer.identifyViaTextLabel()\n    morphPathRelativeToWorld = topMorphUnderPointer.pathOfChildrenPositionsRelativeToWorld()\n    pointerPositionFractionalInMorph = @hand.positionFractionalInMorph topMorphUnderPointer\n    pointerPositionPixelsInMorph = @hand.positionPixelsInMorph topMorphUnderPointer\n    # note that this pointer position is in world\n    # coordinates not in page coordinates\n    pointerPositionPixelsInWorld = @hand.position()\n    isPartOfListMorph = (topMorphUnderPointer.parentThatIsA ListMorph)?\n    return [ topMorphUnderPointer.uniqueIDString(), morphPathRelativeToWorld, morphIdentifierViaTextLabel, absoluteBoundsOfMorphRelativeToWorld, pointerPositionFractionalInMorph, pointerPositionPixelsInMorph, pointerPositionPixelsInWorld, isPartOfListMorph]\n\n\n  addMouseChangeCommand: (upOrDown, button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      pointerAndMorphInfo = @getPointerAndMorphInfo()\n      @automatorRecorderAndPlayer.addMouseChangeCommand upOrDown, button, buttons, ctrlKey, shiftKey, altKey, metaKey, pointerAndMorphInfo...\n\n\n  processMouseDown: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    # the recording of the test command (in case we are\n    # recording a test) is handled inside the function\n    # here below.\n    # This is different from the other methods similar\n    # to this one but there is a little bit of\n    # logic we apply in case there is a right-click,\n    # or user left or right-clicks on a menu,\n    # in which case we record a more specific test\n    # commands.\n    @addMouseChangeCommand "down", button, buttons, ctrlKey, shiftKey, altKey, metaKey\n    @hand.processMouseDown button, buttons, ctrlKey, shiftKey, altKey, metaKey\n\n  processMouseUp: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    @addMouseChangeCommand "up", button, buttons, ctrlKey, shiftKey, altKey, metaKey\n    @hand.processMouseUp button, buttons, ctrlKey, shiftKey, altKey, metaKey\n\n  processMouseMove: (pageX, pageY, button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    @hand.processMouseMove pageX, pageY, button, buttons, ctrlKey, shiftKey, altKey, metaKey\n    # "@hand.processMouseMove" could cause a Grab\n    # command to be issued, so we want to\n    # add the mouse move command here *after* the\n    # potential grab command.\n\n    if @hand.floatDraggingSomething()\n      if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n        action = "floatDrag"\n        arr = window.world.automatorRecorderAndPlayer.tagsCollectedWhileRecordingTest\n        if action not in arr\n          arr.push action\n    \n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      @automatorRecorderAndPlayer.addMouseMoveCommand(pageX, pageY, @hand.floatDraggingSomething(), button, buttons, ctrlKey, shiftKey, altKey, metaKey)\n\n\n  processWheel: (deltaX, deltaY, deltaZ, altKey, button, buttons) ->\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      pointerAndMorphInfo = @getPointerAndMorphInfo()\n      @automatorRecorderAndPlayer.addWheelCommand deltaX, deltaY, deltaZ, altKey, button, buttons, pointerAndMorphInfo...\n\n    @hand.processWheel deltaX, deltaY, deltaZ, altKey, button, buttons\n\n\n  # event.type must be keypress\n  getChar: (event) ->\n    unless event.which?\n      String.fromCharCode event.keyCode # IE\n    else if event.which isnt 0 and event.charCode isnt 0\n      String.fromCharCode event.which # the rest\n    else\n      nil # special key\n\n  processKeydown: (event, scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      @automatorRecorderAndPlayer.addKeyDownCommand scanCode, shiftKey, ctrlKey, altKey, metaKey\n    if @keyboardEventsReceiver\n      @keyboardEventsReceiver.processKeyDown scanCode, shiftKey, ctrlKey, altKey, metaKey\n\n    # suppress backspace override\n    if event? and scanCode is 8\n      event.preventDefault()\n\n    # suppress tab override and make sure tab gets\n    # received by all browsers\n    if event? and scanCode is 9\n      if @keyboardEventsReceiver\n        @keyboardEventsReceiver.processKeyPress scanCode, "\\t", shiftKey, ctrlKey, altKey, metaKey\n      event.preventDefault()\n\n  processKeyup: (event, scanCode, shiftKey, ctrlKey, altKey, metaKey) ->\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      @automatorRecorderAndPlayer.addKeyUpCommand scanCode, shiftKey, ctrlKey, altKey, metaKey\n    # dispatch to keyboard receiver\n    if @keyboardEventsReceiver\n      # so far the caret is the only keyboard\n      # event handler and it has no keyup\n      # handler\n      if @keyboardEventsReceiver.processKeyUp\n        @keyboardEventsReceiver.processKeyUp scanCode, shiftKey, ctrlKey, altKey, metaKey    \n    if event?\n      event.preventDefault()\n\n  processKeypress: (event, charCode, symbol, shiftKey, ctrlKey, altKey, metaKey) ->\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      @automatorRecorderAndPlayer.addKeyPressCommand charCode, symbol, shiftKey, ctrlKey, altKey, metaKey\n    # This if block adapted from:\n    # http://stackoverflow.com/a/16033129\n    # it rejects the\n    # characters from the special\n    # test-command-triggering external\n    # keypad. Also there is a "00" key\n    # in such keypads which is implemented\n    # buy just a double-press of the zero.\n    # We manage that case - if that key is\n    # pressed twice we understand that it\'s\n    # that particular key. Managing this\n    # special case within Fizzygum\n    # is not best, but there aren\'t any\n    # good alternatives.\n    if event?\n      # don\'t manage external keypad if we are playing back\n      # the tests (i.e. when event is nil)\n      if symbol == @constructor.KEYPAD_0_mappedToThaiKeyboard_Q\n        unless @doublePressOfZeroKeypadKey?\n          @doublePressOfZeroKeypadKey = 1\n          setTimeout (=>\n            if @doublePressOfZeroKeypadKey is 1\n              console.log "single keypress"\n            @doublePressOfZeroKeypadKey = nil\n            event.keyCode = 0\n            return false\n          ), 300\n        else\n          @doublePressOfZeroKeypadKey = nil\n          console.log "double keypress"\n          event.keyCode = 0\n        return false\n\n    if @keyboardEventsReceiver\n      @keyboardEventsReceiver.processKeyPress charCode, symbol, shiftKey, ctrlKey, altKey, metaKey\n    if event?\n      event.preventDefault()\n\n  # -----------------------------------------------------\n  # clipboard events processing\n  # -----------------------------------------------------\n  # clipboard events take a text instead of the event,\n  # the reason is that you can\'t access the clipboard\n  # outside of the EventListener, I presume for\n  # security reasons. So, since these process* methods\n  # are executed outside of the listeners, we really can\'t use\n  # the event and the clipboard object in the event, so\n  # we have to work with text. The clipboard IS handled, but\n  # it\'s handled in the listeners\n\n  processCut: (selectedText) ->\n    console.log "processing cut"\n    if @caret\n      # see comment on outstandingTimerTriggeredOperationsCounter\n      # above where the property is declared and initialised.\n      @outstandingTimerTriggeredOperationsCounter.push true\n      window.setTimeout ( =>\n       @caret.deleteLeft()\n       @outstandingTimerTriggeredOperationsCounter.pop()\n      ), 50, true\n\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      @automatorRecorderAndPlayer.addCutCommand selectedText\n\n  processCopy: (selectedText) ->\n    console.log "processing copy"\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      @automatorRecorderAndPlayer.addCopyCommand selectedText\n\n  processPaste: (clipboardText) ->\n    if @caret\n      # Needs a few msec to execute paste\n      console.log "about to insert text: " + clipboardText\n      if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n        @automatorRecorderAndPlayer.addPasteCommand clipboardText\n\n      # see comment on outstandingTimerTriggeredOperationsCounter\n      # above where the property is declared and initialised.\n      @outstandingTimerTriggeredOperationsCounter.push true\n      window.setTimeout ( =>\n       @caret.insert clipboardText\n       @outstandingTimerTriggeredOperationsCounter.pop()\n      ), 50, true\n\n\n  # note that we don\'t register the normal click,\n  # we figure that out independently.\n  initEventListeners: ->\n    canvas = @worldCanvas\n\n    # there is indeed a "dblclick" JS event\n    # but we reproduce it internally.\n    # The reason is that we do so for "click"\n    # because we want to check that the mouse\n    # button was released in the same morph\n    # where it was pressed (cause in the DOM you\'d\n    # be pressing and releasing on the same\n    # element i.e. the canvas anyways\n    # so we receive clicks even though they aren\'t\n    # so we have to take care of the processing\n    # ourselves).\n    # So we also do the same internal\n    # processing for dblclick.\n    # Hence, don\'t register this event listener\n    # below...\n    #@dblclickEventListener = (event) =>\n    #  event.preventDefault()\n    #  @hand.processDoubleClick event\n    #canvas.addEventListener "dblclick", @dblclickEventListener, false\n\n    @mousedownEventListener = (event) =>\n      @events.push "mousedownEventListener"\n      @events.push event\n\n    canvas.addEventListener "mousedown", @mousedownEventListener, false\n\n    \n    @mouseupEventListener = (event) =>\n      @events.push "mouseupEventListener"\n      @events.push event\n\n    canvas.addEventListener "mouseup", @mouseupEventListener, false\n        \n    @mousemoveEventListener = (event) =>\n      @events.push "mousemoveEventListener"\n      @events.push event\n\n    canvas.addEventListener "mousemove", @mousemoveEventListener, false\n    \n    @touchstartEventListener = (event) =>\n      @events.push "touchstartEventListener"\n      @events.push event\n      event.preventDefault()\n\n    canvas.addEventListener "touchstart", @touchstartEventListener , false\n\n    @touchendEventListener = (event) =>\n      @events.push "touchendEventListener"\n      @events.push event\n      event.preventDefault()\n\n    canvas.addEventListener "touchend", @touchendEventListener, false\n\n    @touchmoveEventListener = (event) =>\n      @events.push "touchmoveEventListener"\n      @events.push event\n      event.preventDefault()\n\n    canvas.addEventListener "touchmove", @touchmoveEventListener, false\n    \n    @gesturestartEventListener = (event) =>\n      # Disable browser zoom\n      event.preventDefault()\n    canvas.addEventListener "gesturestart", @gesturestartEventListener, false\n    \n    @gesturechangeEventListener = (event) =>\n      # Disable browser zoom\n      event.preventDefault()\n    canvas.addEventListener "gesturechange", @gesturechangeEventListener, false\n    \n    @contextmenuEventListener = (event) ->\n      # suppress context menu for Mac-Firefox\n      event.preventDefault()\n    canvas.addEventListener "contextmenu", @contextmenuEventListener, false\n    \n    @keydownEventListener = (event) =>\n      @events.push "keydownEventListener"\n      @events.push event\n\n      # this paragraph is to prevent the browser going\n      # "back button" when the user presses delete backspace.\n      # taken from http://stackoverflow.com/a/2768256\n      doPrevent = false\n      if event.keyCode == 8\n        d = event.srcElement or event.target\n        if d.tagName.toUpperCase() == \'INPUT\' and\n        (d.type.toUpperCase() == \'TEXT\' or\n          d.type.toUpperCase() == \'PASSWORD\' or\n          d.type.toUpperCase() == \'FILE\' or\n          d.type.toUpperCase() == \'SEARCH\' or\n          d.type.toUpperCase() == \'EMAIL\' or\n          d.type.toUpperCase() == \'NUMBER\' or\n          d.type.toUpperCase() == \'DATE\') or\n        d.tagName.toUpperCase() == \'TEXTAREA\'\n          doPrevent = d.readOnly or d.disabled\n        else\n          doPrevent = true\n\n      # this paragraph is to prevent the browser scrolling when\n      # user presses spacebar, see\n      # https://stackoverflow.com/a/22559917\n      if event.keyCode == 32 and event.target == @worldCanvas\n        # Note that doing a preventDefault on the spacebar\n        # causes it not to generate the keypress event\n        # (just the keydown), so we had to modify the keydown\n        # to also process the space.\n        # (I tried to use stopPropagation instead/inaddition but\n        # it didn\'t work).\n        doPrevent = true\n\n      if doPrevent\n        event.preventDefault()\n\n    canvas.addEventListener "keydown", @keydownEventListener, false\n\n    @keyupEventListener = (event) =>\n      @events.push "keyupEventListener"\n      @events.push event\n\n    canvas.addEventListener "keyup", @keyupEventListener, false\n\n    # This method also handles keypresses from a special\n    # external keypad which is used to\n    # record tests commands (such as capture screen, etc.).\n    # These external keypads are inexpensive\n    # so they are a good device for this kind\n    # of stuff.\n    # http://www.amazon.co.uk/Perixx-PERIPAD-201PLUS-Numeric-Keypad-Laptop/dp/B001R6FZLU/\n    # They keypad is mapped\n    # to Thai keyboard characters via an OSX app\n    # called keyremap4macbook (also one needs to add the\n    # Thai keyboard, which is just a click from System Preferences)\n    # Those Thai characters are used to trigger test\n    # commands. The only added complexity is about\n    # the "00" key of such keypads - see\n    # note below.\n    doublePressOfZeroKeypadKey: nil\n    \n    @keypressEventListener = (event) =>\n      @events.push "keypressEventListener"\n      @events.push event\n\n    canvas.addEventListener "keypress", @keypressEventListener, false\n\n    # Safari, Chrome\n    \n    @wheelEventListener = (event) =>\n      @events.push "wheelEventListener"\n      @events.push event\n      event.preventDefault()\n\n    canvas.addEventListener "wheel", @wheelEventListener, false\n\n    # in theory there should be no scroll event on the page\n    # window.addEventListener "scroll", ((event) =>\n    #  nop # nothing to do, I just need this to set an interrupt point.\n    # ), false\n\n    # snippets of clipboard-handling code taken from\n    # http://codebits.glennjones.net/editing/setclipboarddata.htm\n    # Note that this works only in Chrome. Firefox and Safari need a piece of\n    # text to be selected in order to even trigger the copy event. Chrome does\n    # enable clipboard access instead even if nothing is selected.\n    # There are a couple of solutions to this - one is to keep a hidden textfield that\n    # handles all copy/paste operations.\n    # Another one is to not use a clipboard, but rather an internal string as\n    # local memory. So the OS clipboard wouldn\'t be used, but at least there would\n    # be some copy/paste working. Also one would need to intercept the copy/paste\n    # key combinations manually instead of from the copy/paste events.\n\n    # -----------------------------------------------------\n    # clipboard events listeners\n    # -----------------------------------------------------\n    # we deal with the clipboard here in the event listeners\n    # because for security reasons the runtime is not allowed\n    # access to the clipboards outside of here. So we do all\n    # we have to do with the clipboard here, and in every\n    # other place we work with text.\n\n    @cutEventListener = (event) =>\n      selectedText = ""\n      if @caret\n        selectedText = @caret.target.selection()\n        if event?.clipboardData\n          event.preventDefault()\n          setStatus = event.clipboardData.setData "text/plain", selectedText\n\n        if window.clipboardData\n          event.returnValue = false\n          setStatus = window.clipboardData.setData "Text", selectedText\n\n      @events.push "cutEventListener"\n      @events.push selectedText\n\n    document.body.addEventListener "cut", @cutEventListener, false\n    \n    @copyEventListener = (event) =>\n      selectedText = ""\n      if @caret\n        if clipboardTextIfTestRunning?\n          selectedText = clipboardTextIfTestRunning\n        else\n          selectedText = @caret.target.selection()\n        if event?.clipboardData\n          event.preventDefault()\n          setStatus = event.clipboardData.setData "text/plain", selectedText\n\n        if window.clipboardData\n          event.returnValue = false\n          setStatus = window.clipboardData.setData "Text", selectedText\n\n      @events.push "copyEventListener"\n      @events.push selectedText\n\n    document.body.addEventListener "copy", @copyEventListener, false\n\n    @pasteEventListener = (event) =>\n      if @caret\n        if event?\n          if event.clipboardData\n            # Look for access to data if types array is missing\n            text = event.clipboardData.getData "text/plain"\n            #url = event.clipboardData.getData("text/uri-list")\n            #html = event.clipboardData.getData("text/html")\n            #custom = event.clipboardData.getData("text/xcustom")\n          # IE event is attached to the window object\n          if window.clipboardData\n            # The schema is fixed\n            text = window.clipboardData.getData "Text"\n            #url = window.clipboardData.getData "URL"\n\n      @events.push "pasteEventListener"\n      @events.push text\n\n    document.body.addEventListener "paste", @pasteEventListener, false\n\n    #console.log "binding via mousetrap"\n\n    @keyComboResetWorldEventListener = (event) =>\n      if AutomatorRecorderAndPlayer?\n        @automatorRecorderAndPlayer.resetWorld()\n      false\n    Mousetrap.bind ["alt+d"], @keyComboResetWorldEventListener\n\n    @keyComboTurnOnAnimationsPacingControl = (event) =>\n      if AutomatorRecorderAndPlayer?\n        @automatorRecorderAndPlayer.turnOnAnimationsPacingControl()\n      false\n    Mousetrap.bind ["alt+e"], @keyComboTurnOnAnimationsPacingControl\n\n    @keyComboTurnOffAnimationsPacingControl = (event) =>\n      if AutomatorRecorderAndPlayer?\n        @automatorRecorderAndPlayer.turnOffAnimationsPacingControl()\n      false\n    Mousetrap.bind ["alt+u"], @keyComboTurnOffAnimationsPacingControl\n\n    @keyComboTakeScreenshotEventListener = (event) =>\n      if AutomatorRecorderAndPlayer?\n        @automatorRecorderAndPlayer.takeScreenshot()\n      false\n    Mousetrap.bind ["alt+c"], @keyComboTakeScreenshotEventListener\n\n    @keyComboStopTestRecordingEventListener = (event) =>\n      if AutomatorRecorderAndPlayer?\n        @automatorRecorderAndPlayer.stopTestRecording()\n      false\n    Mousetrap.bind ["alt+t"], @keyComboStopTestRecordingEventListener\n\n    @keyComboAddTestCommentEventListener = (event) =>\n      if AutomatorRecorderAndPlayer?\n        @automatorRecorderAndPlayer.addTestComment()\n      false\n    Mousetrap.bind ["alt+m"], @keyComboAddTestCommentEventListener\n\n    @keyComboCheckNumberOfMenuItemsEventListener = (event) =>\n      if AutomatorRecorderAndPlayer?\n        @automatorRecorderAndPlayer.checkNumberOfItemsInMenu()\n      false\n    Mousetrap.bind ["alt+k"], @keyComboCheckNumberOfMenuItemsEventListener\n\n    @keyComboCheckStringsOfItemsInMenuOrderImportant = (event) =>\n      if AutomatorRecorderAndPlayer?\n        @automatorRecorderAndPlayer.checkStringsOfItemsInMenuOrderImportant()\n      false\n    Mousetrap.bind ["alt+a"], @keyComboCheckStringsOfItemsInMenuOrderImportant\n\n    @keyComboCheckStringsOfItemsInMenuOrderUnimportant = (event) =>\n      if AutomatorRecorderAndPlayer?\n        @automatorRecorderAndPlayer.checkStringsOfItemsInMenuOrderUnimportant()\n      false\n    Mousetrap.bind ["alt+z"], @keyComboCheckStringsOfItemsInMenuOrderUnimportant\n\n    @dragoverEventListener = (event) ->\n      event.preventDefault()\n    window.addEventListener "dragover", @dragoverEventListener, false\n    \n    @dropEventListener = (event) =>\n      @events.push "dropEventListener"\n      @events.push event\n      event.preventDefault()\n    window.addEventListener "drop", @dropEventListener, false\n    \n    @resizeEventListener = =>\n      @events.push "resizeEventListener"\n      @events.push nil\n\n    # this is a DOM thing, little to do with other r e s i z e methods\n    window.addEventListener "resize", @resizeEventListener, false\n    \n  \n  removeEventListeners: ->\n    canvas = @worldCanvas\n    # canvas.removeEventListener \'dblclick\', @dblclickEventListener\n    canvas.removeEventListener \'mousedown\', @mousedownEventListener\n    canvas.removeEventListener \'touchstart\', @touchstartEventListener\n    canvas.removeEventListener \'mouseup\', @mouseupEventListener\n    canvas.removeEventListener \'touchend\', @touchendEventListener\n    canvas.removeEventListener \'mousemove\', @mousemoveEventListener\n    canvas.removeEventListener \'touchmove\', @touchmoveEventListener\n    canvas.removeEventListener \'gesturestart\', @gesturestartEventListener\n    canvas.removeEventListener \'gesturechange\', @gesturechangeEventListener\n    canvas.removeEventListener \'contextmenu\', @contextmenuEventListener\n    canvas.removeEventListener \'keydown\', @keydownEventListener\n    canvas.removeEventListener \'keyup\', @keyupEventListener\n    canvas.removeEventListener \'keypress\', @keypressEventListener\n    canvas.removeEventListener \'wheel\', @wheelEventListener\n    canvas.removeEventListener \'cut\', @cutEventListener\n    canvas.removeEventListener \'copy\', @copyEventListener\n    canvas.removeEventListener \'paste\', @pasteEventListener\n    Mousetrap.reset()\n    canvas.removeEventListener \'dragover\', @dragoverEventListener\n    canvas.removeEventListener \'drop\', @dropEventListener\n    canvas.removeEventListener \'resize\', @resizeEventListener\n  \n  mouseDownLeft: ->\n    noOperation\n  \n  mouseClickLeft: ->\n    noOperation\n  \n  mouseDownRight: ->\n    noOperation\n      \n  droppedImage: ->\n    nil\n\n  droppedSVG: ->\n    nil  \n\n  # WorldMorph text field tabbing:\n  nextTab: (editField) ->\n    next = @nextEntryField editField\n    if next\n      @switchTextFieldFocus editField, next\n  \n  previousTab: (editField) ->\n    prev = @previousEntryField editField\n    if prev\n      @switchTextFieldFocus editField, prev\n\n  switchTextFieldFocus: (current, next) ->\n    current.clearSelection()\n    next.bringToForeground()\n    next.selectAll()\n    next.edit()\n\n  # if an error is thrown, the state of the world might\n  # be messy, for example the pointer might be\n  # dragging an invisible morph, etc.\n  # So, try to clean-up things as much as possible.\n  softResetWorld: ->\n    @hand.drop()\n    @hand.mouseOverList = []\n    @hand.nonFloatDraggedMorph = nil\n    @morphsDetectingClickOutsideMeOrAnyOfMeChildren = []\n    @lastNonTextPropertyChangerButtonClickedOrDropped = nil\n\n  resetWorld: ->\n    @softResetWorld()\n    @changed() # redraw the whole screen\n    @fullDestroyChildren()\n    # the "basementWdgt" is not attached to the\n    # world tree so it\'s not in the children,\n    # so we need to clean up separately\n    @basementWdgt?.empty()\n    # some tests might change the background\n    # color of the world so let\'s reset it.\n    @setColor new Color 205, 205, 205\n    SystemTestsControlPanelUpdater.blinkLink SystemTestsControlPanelUpdater.resetWorldLink\n    # make sure thw window is scrolled to top\n    # so we can see the test results while tests\n    # are running.\n    document.body.scrollTop = document.documentElement.scrollTop = 0    \n  \n  # There is something special about the\n  # "world" version of fullDestroyChildren:\n  # it resets the counter used to count\n  # how many morphs exist of each Widget class.\n  # That counter is also used to determine the\n  # unique ID of a Widget. So, destroying\n  # all morphs from the world causes the\n  # counts and IDs of all the subsequent\n  # morphs to start from scratch again.\n  fullDestroyChildren: ->\n    # Check which objects end with the word Widget\n    theWordMorph = "Morph"\n    theWordWdgt = "Wdgt"\n    theWordWidget = "Widget"\n    ListOfMorphs = (Object.keys(window)).filter (i) ->\n      (i.indexOf(theWordMorph, i.length - theWordMorph.length) isnt -1) or\n      (i.indexOf(theWordWdgt, i.length - theWordWdgt.length) isnt -1) or\n      (i.indexOf(theWordWidget, i.length - theWordWidget.length) isnt -1)\n    for eachMorphClass in ListOfMorphs\n      if eachMorphClass != "WorldMorph"\n        #console.log "resetting " + eachMorphClass + " from " + window[eachMorphClass].instancesCounter\n        # the actual count is in another variable "instancesCounter"\n        # but all labels are built using instanceNumericID\n        # which is set based on lastBuiltInstanceNumericID\n        window[eachMorphClass].lastBuiltInstanceNumericID = 0\n\n    if AutomatorRecorderAndPlayer?\n      window.world.automatorRecorderAndPlayer.turnOffAnimationsPacingControl()\n      window.world.automatorRecorderAndPlayer.turnOffAlignmentOfMorphIDsMechanism()\n      window.world.automatorRecorderAndPlayer.turnOffHidingOfMorphsContentExtractInLabels()\n      window.world.automatorRecorderAndPlayer.turnOffHidingOfMorphsNumberIDInLabels()\n\n    super()\n\n  buildContextMenu: ->\n\n    if @isIndexPage\n      menu = new MenuMorph @, false, @, true, true, "Desktop"\n      menu.addMenuItem "wallpapers ➜", false, @, "wallpapersMenu", "choose a wallpaper for the Desktop"\n      menu.addMenuItem "new folder", true, @, "makeFolder"\n      return menu\n\n    if @isDevMode\n      menu = new MenuMorph(@, false, \n        @, true, true, @constructor.name or @constructor.toString().split(" ")[1].split("(")[0])\n    else\n      menu = new MenuMorph @, false, @, true, true, "Widgetic"\n    if @isDevMode\n      menu.addMenuItem "demo ➜", false, @, "popUpDemoMenu", "sample morphs"\n      menu.addLine()\n      menu.addMenuItem "show all", true, @, "showAllMinimised"\n      menu.addMenuItem "hide all", true, @, "minimiseAll"\n      menu.addMenuItem "delete all", true, @, "closeChildren"\n      menu.addMenuItem "move all inside", true, @, "keepAllSubmorphsWithin", "keep all submorphs\\nwithin and visible"\n      menu.addMenuItem "inspect", true, @, "inspect", "open a window on\\nall properties"\n      menu.addMenuItem "test menu ➜", false, @, "testMenu", "debugging and testing operations"\n      menu.addLine()\n      menu.addMenuItem "restore display", true, @, "changed", "redraw the\\nscreen once"\n      menu.addMenuItem "fit whole page", true, @, "stretchWorldToFillEntirePage", "let the World automatically\\nadjust to browser resizings"\n      menu.addMenuItem "color...", true, @, "popUpColorSetter", "choose the World\'s\\nbackground color"\n      menu.addMenuItem "wallpapers ➜", false, @, "wallpapersMenu", "choose a wallpaper for the Desktop"\n\n      if WorldMorph.preferencesAndSettings.inputMode is PreferencesAndSettings.INPUT_MODE_MOUSE\n        menu.addMenuItem "touch screen settings", true, WorldMorph.preferencesAndSettings, "toggleInputMode", "bigger menu fonts\\nand sliders"\n      else\n        menu.addMenuItem "standard settings", true, WorldMorph.preferencesAndSettings, "toggleInputMode", "smaller menu fonts\\nand sliders"\n      menu.addLine()\n    \n    if AutomatorRecorderAndPlayer?\n      menu.addMenuItem "system tests ➜", false, @, "popUpSystemTestsMenu", ""\n    if @isDevMode\n      menu.addMenuItem "switch to user mode", true, @, "toggleDevMode", "disable developers\'\\ncontext menus"\n    else\n      menu.addMenuItem "switch to dev mode", true, @, "toggleDevMode"\n    menu.addMenuItem "new folder", true, @, "makeFolder"\n    menu.addMenuItem "about Fizzygum...", true, @, "about"\n    menu\n\n  wallpapersMenu: (a,targetMorph)->\n    menu = new MenuMorph @, false, targetMorph, true, true, "Wallpapers"\n\n    # we add the "untick" prefix to all entries\n    # so we allocate the right amout of space for\n    # the labels, we are going to put the\n    # right ticks soon after\n    menu.addMenuItem untick + @pattern1, true, @, "setPattern", nil, nil, nil, nil, nil, @pattern1\n    menu.addMenuItem untick + @pattern2, true, @, "setPattern", nil, nil, nil, nil, nil, @pattern2\n    menu.addMenuItem untick + @pattern3, true, @, "setPattern", nil, nil, nil, nil, nil, @pattern3\n    menu.addMenuItem untick + @pattern4, true, @, "setPattern", nil, nil, nil, nil, nil, @pattern4\n    menu.addMenuItem untick + @pattern5, true, @, "setPattern", nil, nil, nil, nil, nil, @pattern5\n    menu.addMenuItem untick + @pattern6, true, @, "setPattern", nil, nil, nil, nil, nil, @pattern6\n    menu.addMenuItem untick + @pattern7, true, @, "setPattern", nil, nil, nil, nil, nil, @pattern7\n\n    @updatePatternsMenuEntriesTicks menu\n\n    menu.popUpAtHand()\n\n  setPattern: (menuItem, ignored2, thePatternName) ->\n    debugger\n    if @patternName == thePatternName\n      return\n\n    @patternName = thePatternName\n    @changed()\n\n    if menuItem?.parent? and (menuItem.parent instanceof MenuMorph)\n      @updatePatternsMenuEntriesTicks menuItem.parent\n\n\n  # cheap way to keep menu consistency when pinned\n  # note that there is no consistency in case\n  # there are multiple copies of this menu changing\n  # the wallpaper, since there is no real subscription\n  # of a menu to react to wallpaper change coming\n  # from other menus or other means (e.g. API)...\n  updatePatternsMenuEntriesTicks: (menu) ->\n    pattern1Tick = pattern2Tick = pattern3Tick =\n    pattern4Tick = pattern5Tick = pattern6Tick =\n    pattern7Tick = untick\n\n    switch @patternName\n      when @pattern1\n        pattern1Tick = tick\n      when @pattern2\n        pattern2Tick = tick\n      when @pattern3\n        pattern3Tick = tick\n      when @pattern4\n        pattern4Tick = tick\n      when @pattern5\n        pattern5Tick = tick\n      when @pattern6\n        pattern6Tick = tick\n      when @pattern7\n        pattern7Tick = tick\n\n    menu.children[1].label.setText pattern1Tick + @pattern1\n    menu.children[2].label.setText pattern2Tick + @pattern2\n    menu.children[3].label.setText pattern3Tick + @pattern3\n    menu.children[4].label.setText pattern4Tick + @pattern4\n    menu.children[5].label.setText pattern5Tick + @pattern5\n    menu.children[6].label.setText pattern6Tick + @pattern6\n    menu.children[7].label.setText pattern7Tick + @pattern7\n\n\n  popUpSystemTestsMenu: ->\n    menu = new MenuMorph @, false, @, true, true, "system tests"\n\n    menu.addMenuItem "run system tests", true, @automatorRecorderAndPlayer, "runAllSystemTests", "runs all the system tests"\n    menu.addMenuItem "run system tests force slow", true, @automatorRecorderAndPlayer, "runAllSystemTestsForceSlow", "runs all the system tests"\n    menu.addMenuItem "run system tests force fast skip in-between mouse moves", true, @automatorRecorderAndPlayer, "runAllSystemTestsForceFastSkipInbetweenMouseMoves", "runs all the system tests"\n    menu.addMenuItem "run system tests force fast run in-between mouse moves", true, @automatorRecorderAndPlayer, "runAllSystemTestsForceFastRunInbetweenMouseMoves", "runs all the system tests"\n\n    menu.addMenuItem "start test recording", true, @automatorRecorderAndPlayer, "startTestRecording", "start recording a test"\n    menu.addMenuItem "stop test recording", true, @automatorRecorderAndPlayer, "stopTestRecording", "stop recording the test"\n\n    menu.addMenuItem "(re)play recorded test slow", true, @automatorRecorderAndPlayer, "startTestPlayingSlow", "start playing the test"\n    menu.addMenuItem "(re)play recorded test fast skip in-between mouse moves", true, @automatorRecorderAndPlayer, "startTestPlayingFastSkipInbetweenMouseMoves", "start playing the test"\n    menu.addMenuItem "(re)play recorded test  fast run in-between mouse moves", true, @automatorRecorderAndPlayer, "startTestPlayingFastRunInbetweenMouseMoves", "start playing the test"\n\n    menu.addMenuItem "show test source", true, @automatorRecorderAndPlayer, "showTestSource", "opens a window with the source of the latest test"\n    menu.addMenuItem "save recorded test", true, @automatorRecorderAndPlayer, "saveTest", "save the recorded test"\n    menu.addMenuItem "save failed screenshots", true, @automatorRecorderAndPlayer, "saveFailedScreenshots", "save failed screenshots"\n\n    menu.popUpAtHand()\n\n  create: (aMorph) ->\n    aMorph.pickUp()\n\n  createNewStackElementsSizeAdjustingMorph: ->\n    @create new StackElementsSizeAdjustingMorph()\n\n  createNewLayoutElementAdderOrDropletMorph: ->\n    @create new LayoutElementAdderOrDropletMorph()\n\n  createNewRectangleMorph: ->\n    @create new RectangleMorph()\n  createNewBoxMorph: ->\n    @create new BoxMorph()\n  createNewCircleBoxMorph: ->\n    @create new CircleBoxMorph()\n  createNewSliderMorph: ->\n    @create new SliderMorph()\n  createNewPanelWdgt: ->\n    newMorph = new PanelWdgt()\n    newMorph.rawSetExtent new Point 350, 250\n    @create newMorph\n  createNewScrollPanelWdgt: ->\n    newMorph = new ScrollPanelWdgt()\n    newMorph.adjustContentsBounds()\n    newMorph.adjustScrollBars()\n    newMorph.rawSetExtent new Point 350, 250\n    @create newMorph\n  createNewCanvas: ->\n    newMorph = new CanvasMorph()\n    newMorph.rawSetExtent new Point 350, 250\n    @create newMorph\n  createNewHandle: ->\n    @create new HandleMorph()\n  createNewString: ->\n    newMorph = new StringMorph "Hello, World!"\n    newMorph.isEditable = true\n    @create newMorph\n  createNewText: ->\n    newMorph = new TextMorph("Ich weiß nicht, was soll es bedeuten, dass ich so " +\n      "traurig bin, ein Märchen aus uralten Zeiten, das " +\n      "kommt mir nicht aus dem Sinn. Die Luft ist kühl " +\n      "und es dunkelt, und ruhig fließt der Rhein; der " +\n      "Gipfel des Berges funkelt im Abendsonnenschein. " +\n      "Die schönste Jungfrau sitzet dort oben wunderbar, " +\n      "ihr gold\'nes Geschmeide blitzet, sie kämmt ihr " +\n      "goldenes Haar, sie kämmt es mit goldenem Kamme, " +\n      "und singt ein Lied dabei; das hat eine wundersame, " +\n      "gewalt\'ge Melodei. Den Schiffer im kleinen " +\n      "Schiffe, ergreift es mit wildem Weh; er schaut " +\n      "nicht die Felsenriffe, er schaut nur hinauf in " +\n      "die Höh\'. Ich glaube, die Wellen verschlingen " +\n      "am Ende Schiffer und Kahn, und das hat mit ihrem " +\n      "Singen, die Loreley getan.")\n    newMorph.isEditable = true\n    newMorph.maxTextWidth = 300\n    @create newMorph\n  createNewSpeechBubbleWdgt: ->\n    newMorph = new SpeechBubbleWdgt()\n    @create newMorph\n  createNewToolTipWdgt: ->\n    newMorph = new ToolTipWdgt()\n    @create newMorph\n  createNewGrayPaletteMorph: ->\n    @create new GrayPaletteMorph()\n  createNewColorPaletteMorph: ->\n    @create new ColorPaletteMorph()\n  createNewGrayPaletteMorphInWindow: ->\n    gP = new GrayPaletteMorph()\n    wm = new WindowWdgt nil, nil, gP\n    world.add wm\n    wm.rawSetExtent new Point 130, 70\n    wm.fullRawMoveTo world.hand.position().subtract new Point 50, 100\n    wm.changed()\n  createNewColorPaletteMorphInWindow: ->\n    cP = new ColorPaletteMorph()\n    wm = new WindowWdgt nil, nil, cP\n    world.add wm\n    wm.rawSetExtent new Point 130, 100\n    wm.fullRawMoveTo world.hand.position().subtract new Point 50, 100\n    wm.changed()\n  createNewColorPickerMorph: ->\n    @create new ColorPickerMorph()\n  createNewSensorDemo: ->\n    newMorph = new MouseSensorMorph()\n    newMorph.setColor new Color 230, 200, 100\n    newMorph.cornerRadius = 35\n    newMorph.alpha = 0.2\n    newMorph.rawSetExtent new Point 100, 100\n    @create newMorph\n  createNewAnimationDemo: ->\n    foo = new BouncerMorph()\n    foo.fullRawMoveTo new Point 50, 20\n    foo.rawSetExtent new Point 300, 200\n    foo.alpha = 0.9\n    foo.speed = 3\n    bar = new BouncerMorph()\n    bar.setColor new Color 50, 50, 50\n    bar.fullRawMoveTo new Point 80, 80\n    bar.rawSetExtent new Point 80, 250\n    bar.type = "horizontal"\n    bar.direction = "right"\n    bar.alpha = 0.9\n    bar.speed = 5\n    baz = new BouncerMorph()\n    baz.setColor new Color 20, 20, 20\n    baz.fullRawMoveTo new Point 90, 140\n    baz.rawSetExtent new Point 40, 30\n    baz.type = "horizontal"\n    baz.direction = "right"\n    baz.speed = 3\n    garply = new BouncerMorph()\n    garply.setColor new Color 200, 20, 20\n    garply.fullRawMoveTo new Point 90, 140\n    garply.rawSetExtent new Point 20, 20\n    garply.type = "vertical"\n    garply.direction = "up"\n    garply.speed = 8\n    fred = new BouncerMorph()\n    fred.setColor new Color 20, 200, 20\n    fred.fullRawMoveTo new Point 120, 140\n    fred.rawSetExtent new Point 20, 20\n    fred.type = "vertical"\n    fred.direction = "down"\n    fred.speed = 4\n    bar.add garply\n    bar.add baz\n    foo.add fred\n    foo.add bar\n    @create foo\n  createNewPenMorph: ->\n    @create new PenMorph()\n  underTheCarpet: ->\n    newMorph = new BasementWdgt()\n    @create newMorph\n\n\n  popUpDemoMenu: (morphOpeningThePopUp,b,c,d) ->\n    if @isIndexPage\n      menu = new MenuMorph morphOpeningThePopUp,  false, @, true, true, "parts bin"\n      menu.addMenuItem "rectangle", true, @, "createNewRectangleMorph"\n      menu.addMenuItem "box", true, @, "createNewBoxMorph"\n      menu.addMenuItem "circle box", true, @, "createNewCircleBoxMorph"\n      menu.addMenuItem "slider", true, @, "createNewSliderMorph"\n      menu.addMenuItem "speech bubble", true, @, "createNewSpeechBubbleWdgt"\n      menu.addLine()\n      menu.addMenuItem "gray scale palette", true, @, "createNewGrayPaletteMorphInWindow"\n      menu.addMenuItem "color palette", true, @, "createNewColorPaletteMorphInWindow"\n      menu.addLine()\n      menu.addMenuItem "analog clock", true, @, "analogClock"\n    else\n      menu = new MenuMorph morphOpeningThePopUp,  false, @, true, true, "make a morph"\n      menu.addMenuItem "rectangle", true, @, "createNewRectangleMorph"\n      menu.addMenuItem "box", true, @, "createNewBoxMorph"\n      menu.addMenuItem "circle box", true, @, "createNewCircleBoxMorph"\n      menu.addLine()\n      menu.addMenuItem "slider", true, @, "createNewSliderMorph"\n      menu.addMenuItem "panel", true, @, "createNewPanelWdgt"\n      menu.addMenuItem "scrollable panel", true, @, "createNewScrollPanelWdgt"\n      menu.addMenuItem "canvas", true, @, "createNewCanvas"\n      menu.addMenuItem "handle", true, @, "createNewHandle"\n      menu.addLine()\n      menu.addMenuItem "string", true, @, "createNewString"\n      menu.addMenuItem "text", true, @, "createNewText"\n      menu.addMenuItem "tool tip", true, @, "createNewToolTipWdgt"\n      menu.addMenuItem "speech bubble", true, @, "createNewSpeechBubbleWdgt"\n      menu.addLine()\n      menu.addMenuItem "gray scale palette", true, @, "createNewGrayPaletteMorph"\n      menu.addMenuItem "color palette", true, @, "createNewColorPaletteMorph"\n      menu.addMenuItem "color picker", true, @, "createNewColorPickerMorph"\n      menu.addLine()\n      menu.addMenuItem "sensor demo", true, @, "createNewSensorDemo"\n      menu.addMenuItem "animation demo", true, @, "createNewAnimationDemo"\n      menu.addMenuItem "pen", true, @, "createNewPenMorph"\n        \n      menu.addLine()\n      menu.addMenuItem "layout tests ➜", false, @, "layoutTestsMenu", "sample morphs"\n      menu.addLine()\n      menu.addMenuItem "under the carpet", true, @, "underTheCarpet"\n\n    menu.popUpAtHand()\n\n  layoutTestsMenu: (morphOpeningThePopUp) ->\n    menu = new MenuMorph morphOpeningThePopUp,  false, @, true, true, "Layout tests"\n    menu.addMenuItem "adjuster morph", true, @, "createNewStackElementsSizeAdjustingMorph"\n    menu.addMenuItem "adder/droplet", true, @, "createNewLayoutElementAdderOrDropletMorph"\n    menu.addMenuItem "test screen 1", true, Widget, "setupTestScreen1"\n    menu.popUpAtHand()\n    \n  \n  toggleDevMode: ->\n    @isDevMode = not @isDevMode\n  \n  # This method is obsolete. It assumes a different meaning\n  # for "minimise" than what we have now.\n  #minimiseAll: ->\n  #  @children.forEach (child) ->\n  #    child.minimise()\n  \n  # This method is obsolete. It assumes a different meaning\n  # for "minimise" than what we have now.\n  #showAllMinimised: ->\n  #  @forAllChildrenBottomToTop (child) ->\n  #    if !child.visibleBasedOnIsVisibleProperty() or\n  #    child.isCollapsed()\n  #      child.unminimise()\n  \n  edit: (aStringMorphOrTextMorph) ->\n    # first off, if the Widget is not editable\n    # then there is nothing to do\n    # return nil  unless aStringMorphOrTextMorph.isEditable\n\n    # there is only one caret in the World, so destroy\n    # the previous one if there was one.\n    if @caret\n      # empty the previously ongoing selection\n      # if there was one.\n      previouslyEditedText = @lastEditedText\n      @lastEditedText = @caret.target\n      if @lastEditedText != previouslyEditedText\n        @lastEditedText.clearSelection()\n      @caret = @caret.fullDestroy()\n\n    # create the new Caret\n    @caret = new CaretMorph aStringMorphOrTextMorph\n    aStringMorphOrTextMorph.parent.add @caret\n    # this is the only place where the @keyboardEventsReceiver is set\n    @keyboardEventsReceiver = @caret\n\n    if WorldMorph.preferencesAndSettings.isTouchDevice and WorldMorph.preferencesAndSettings.useVirtualKeyboard\n      @initVirtualKeyboard()\n      # For touch devices, giving focus on the textbox causes\n      # the keyboard to slide up, and since the page viewport\n      # shrinks, the page is scrolled to where the texbox is.\n      # So, it is important to position the textbox around\n      # where the caret is, so that the changed text is going to\n      # be visible rather than out of the viewport.\n      pos = getDocumentPositionOf @worldCanvas\n      @inputDOMElementForVirtualKeyboard.style.top = @caret.top() + pos.y + "px"\n      @inputDOMElementForVirtualKeyboard.style.left = @caret.left() + pos.x + "px"\n      @inputDOMElementForVirtualKeyboard.focus()\n    \n    # Widgetic.js provides the "slide" method but I must have lost it\n    # in the way, so commenting this out for the time being\n    #\n    #if WorldMorph.preferencesAndSettings.useSliderForInput\n    #  if !aStringMorphOrTextMorph.parentThatIsA MenuMorph\n    #    @slide aStringMorphOrTextMorph\n  \n  # Editing can stop because of three reasons:\n  #   cancel (user hits ESC)\n  #   accept (on stringmorph, user hits enter)\n  #   user clicks/floatDrags another morph\n  stopEditing: ->\n    if @caret\n      @lastEditedText = @caret.target\n      @lastEditedText.clearSelection()\n      @lastEditedText.escalateEvent "reactToEdit", @lastEditedText\n      @caret = @caret.fullDestroy()\n\n    # the only place where the @keyboardEventsReceiver is unset\n    # (and the hidden input is removed)\n    @keyboardEventsReceiver = nil\n    if @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard.blur()\n      document.body.removeChild @inputDOMElementForVirtualKeyboard\n      @inputDOMElementForVirtualKeyboard = nil\n    @worldCanvas.focus()\n\n  anyReferenceToWdgt: (whichWdgt) ->\n    # go through all the references and check whether they reference\n    # the wanted widget. Note that the reference could be unreachable\n    # in the basement, or even in the trash\n    for eachReferencingMorph in @widgetsReferencingOtherWidgets\n      if eachReferencingMorph.target == whichWdgt\n        return true\n    return false\n';
