// Generated by CoffeeScript 1.10.0
window.Arg_coffeSource = '# an Arg wraps a Val that is an input to the\n# calculation of the current Val.\n# an Arg for example contains the signature that\n# the input val had when the Val was calculated.\n# The signature could be a custom signature that is\n# only relevant to this Val. So it contains several\n# pieces of information about each input val, that are\n# specific to the context of this Val (hence, we\n# can\'t put it in the input arg val, we need to\n# put this Arg which lives in the context of this\n# Val).\n\n# REQUIRES ProfilerData\n\nclass Arg\n  valWrappedByThisArg: null\n  maybeChangedSinceLastCalculation: true\n  \n  # an argument can either be\n  #  1. connected to a parent\n  #  2. connected to a child\n  #  3. connected to a local value\n  # and this is determined when the\n  # value that depends on this argument is created.\n  # (the parent/child is dynamic, but the nature of\n  # the argument is decided early)\n  directlyCalculatedFromParent: false\n  fromChild: false\n  fromLocal: false\n\n  # this flag tracks whether this argument\n  # directly or indirectly depends on a parent\n  # value. So if @directlyCalculatedFromParent is true\n  # then this is true as well. But this could be true\n  # even is @directlyCalculatedFromParent is false,\n  # because you could have an argument which\n  # is connected to a value in a child BUT\n  # that value might directly or indirectly\n  # depend on a parent value at some stage.\n  directlyOrIndirectlyCalculatedFromParent: false\n  \n  morphContainingThisArg: null\n  args: null\n  markedForRemoval: false\n  # we keep the vals of the args we\n  # used to calculate the last val. This is so\n  # we can keep an eye on how the args\n  # change. If they change back to the original\n  # vals we used then we can propagate this\n  # "OK our last calculation actually holds"\n  # information WITHOUT triggering a recalculation.\n  @signatureAtLastCalculation: ""\n  @id: ""\n\n  constructor: (@valWrappedByThisArg, @valContainingThisArg) ->\n    @morphContainingThisArg = @valContainingThisArg.ownerMorph\n    @args = @valContainingThisArg.args\n    @id = @valWrappedByThisArg.id\n    @args.argById[@id] = @\n\n  fetchVal: () ->\n    @valWrappedByThisArg.fetchVal()\n\n  ################################################\n  #  signature checking / calculation\n  ################################################\n\n  # we give the opportunity to specify a custom signature\n  # for args, in case we have a signature that\n  # is more efficient considering the type of\n  # calculation that we are going to do\n  getSignatureOrCustomSignatureOfWrappedVal: () ->\n    if @args.customSignatureMethod?\n      theValSignature = @args.customSignatureMethod @valWrappedByThisArg\n    else\n      theValSignature = @valWrappedByThisArg.lastCalculatedValContent.signature\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "fetching default signature of argument: " + @id + " : " + theValSignature\n    theValSignature = theValSignature + @markedForRemoval\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "calculated signature of argument: " + @id + " : " + theValSignature\n\n    return theValSignature\n\n  semanticallyChangedSinceLastValCalculation: () ->\n    if @getSignatureOrCustomSignatureOfWrappedVal() != @signatureAtLastCalculation\n      return true\n    else\n      return false\n\n  # an Argument of this value has notified its change\n  # but we want to check, based on either its default\n  # signature or a custom signature, whether its\n  # value changed from when we calculated this value\n  # the last time. Following this check, we might\n  # "heal"/break the value and potentially\n  # propagate the change\n  checkBasedOnSignature: () ->\n\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "checking signature of argument: " + @id\n\n    # the unique identifier of a val is given by\n    # its name as a string and the id of the Morph it\n    # belongs to. For localVals this is ever so slightly\n    # inefficient as you could always index them through\n    # an integer, which would be faster, but probably\n    # the improvement would be "in the noise".\n    signatureOfArgUsedInLastCalculation =\n      @signatureAtLastCalculation\n    # this is the case where a child has been added:\n    # the arg wasn\'t there before\n    if signatureOfArgUsedInLastCalculation == undefined\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "argument: " + @id + " is undefined, breaking and returning "\n      @break()\n      return undefined\n\n    # if the arg which has maybe changed doesn\'t know\n    # its val then we just mark the arg as broken\n    # and we do nothing else\n    if @valWrappedByThisArg.lastCalculatedValContentMaybeOutdated\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "argument: " + @id + " is broken on its own anyways, breaking this arg"\n      @break()\n    else\n      # if the val that asserts change claims that its val\n      # is actually correct then we proceed to check its\n      # signature to check whether it changed since the\n      # last time we calculated our val.\n      # We let the user provide her own signature calculation\n      # method for args: this is because for the purpose of\n      # the calculation of this val, there might be a better\n      # notion of equivalency of the args that lets us be\n      # more tolerant of changes (which means less invalidation which\n      # means less recalculations which means fewer invalidations further\n      # on). An example of such "wider" equivalency is for the HSV color\n      # values if we need to convert them to RGB. Every HSV value\n      # with V set to zero is equivalent in this respect because it\n      # always means black.\n      if @semanticallyChangedSinceLastValCalculation()\n        # argsMaybeChangedSinceLastCalculation is an object, we add\n        # a property to it for each dirty arg, so we delete\n        # such property when we verify it\'s actually healthy.\n        if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n          console.log "argument: " + @id + " has equal signature to one used for last calculation, healing"\n        @heal()\n      else\n        if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n          console.log "argument: " + @id + " has different signature to one used for last calculation, breaking"\n        @break()\n\n\n  updateSignature: () ->\n    oldSig = @signatureAtLastCalculation\n    newSig = @getSignatureOrCustomSignatureOfWrappedVal()\n    signatureChanged = false\n    if newSig != oldSig\n        signatureChanged = true\n    @signatureAtLastCalculation = newSig\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      if signatureChanged\n      	console.log "checked signature of argument: " + @id + " and it changed was: " + oldSig + " now is: " + newSig\n      else\n      	console.log "checked signature of argument: " + @id + " and it didn\'t change was: " + oldSig + " now is: " + newSig\n    return signatureChanged\n\n  updateSignatureAndHeal: () ->\n    signatureChanged = @updateSignature()\n    @heal()\n    return signatureChanged\n\n\n  ################################################\n  #  breaking / healing\n  ################################################\n\n  heal: () ->\n    @maybeChangedSinceLastCalculation = false\n    delete @args.argsMaybeChangedSinceLastCalculationById[@id]\n    @args.countOfDamaged--\n    # check implications of argument being healed: it\n    # might be that this means that the value heals as\n    # well and propagates healing\n    if !@valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal\n      @valContainingThisArg.checkAndPropagateChangeBasedOnArgChange()\n\n  break: () ->\n    @maybeChangedSinceLastCalculation = true\n    @args.argsMaybeChangedSinceLastCalculationById[@id] = true\n    @args.countOfDamaged++\n    # check implications of argument being broken: it\n    # might be that this means that the value breaks as\n    # well and propagates damage\n    if !@valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal\n      @valContainingThisArg.checkAndPropagateChangeBasedOnArgChange()\n\n\n  ################################################\n  #  removal\n  ################################################\n\n  # we don\'t completely destroy the argument\n  # (like removeFromArgs does)\n  # for the simple reason that we do need to\n  # remember its signature when the value\n  # was last calculated.\n  markForRemoval: () ->\n    @markedForRemoval = true\n    @turnIntoArgNotDirectlyNorIndirectlyDependingOnParent()\n    @morphContainingThisArg.argMightHaveChanged(@valWrappedByThisArg)\n\n  unmarkForRemoval: () ->\n    @markedForRemoval = false\n\n  removeArgIfMarkedForRemoval: () ->\n    if @markedForRemoval\n      @removeFromArgs()\n      return true\n    else\n      return false\n\n  removeFromArgs: () ->\n    #@turnIntoArgNotDirectlyNorIndirectlyDependingOnParent()\n    delete @args.argById[@id]\n    if @args.argsMaybeChangedSinceLastCalculationById[@id]?\n      delete @args.argsMaybeChangedSinceLastCalculationById[@id]\n      @args.countOfDamaged--\n\n\n\n  ################################################\n  #  disconnection\n  ################################################\n\n  disconnectChildArg: () ->\n    @fromChild = false\n    delete @args.childrenArgByName[@valContainingThisArg.valName]\n    @args.childrenArgByNameCount[@valContainingThisArg.valName]--\n    @markForRemoval()\n\n  disconnectParentArg: () ->\n    @directlyCalculatedFromParent = false\n    @directlyOrIndirectlyCalculatedFromParent = true\n    delete @args.parentArgByName[@valContainingThisArg.valName]\n    @markForRemoval()\n\n  ################################################\n  #  (un)turning into argument\n  #  directly or indirectly depending on parent\n  ################################################\n\n  turnIntoArgDirectlyOrIndirectlyDependingOnParent: () ->\n    @args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id] = true\n    if !@args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id]?\n        @args.calculatedDirectlyOfIndirectlyFromParentByIdCount++\n    @valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal = true\n    @directlyOrIndirectlyCalculatedFromParent = true\n\n    for cv in @valContainingThisArg.localValsAffectedByChangeOfThisVal\n      cv.stainValCalculatedFromParent @valContainingThisArg\n    if @ownerMorph.parent?\n      v = @morphContainingThisArg.parent.morphValsDependingOnChildrenVals[@valName]\n      for k in v\n        k.stainValCalculatedFromParent @valContainingThisArg\n\n\n\n  turnIntoArgNotDirectlyNorIndirectlyDependingOnParent: () ->\n    # note that we might turn also an Argument that we know\n    # directly depends on a parent. The reason is that\n    # we might be removing the parent, in which case\n    # this morph might cease to depend on parent values.\n    # we need to find out by doing the full works here.\n\n    # this changes @directlyOrIndirectlyDependsOnAParentVal if there are no\n    # more args depending on parent vals\n    if @args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id]?\n        @args.calculatedDirectlyOfIndirectlyFromParentByIdCount--\n    delete @args.calculatedDirectlyOfIndirectlyFromParentById[@valWrappedByThisArg.id]\n    @directlyOrIndirectlyCalculatedFromParent = false\n\n    if @args.calculatedDirectlyOfIndirectlyFromParentByIdCount > 0\n      @valContainingThisArg.directlyOrIndirectlyDependsOnAParentVal = false\n\n      # this means that the arg that has unstained itself\n      # was the last and only reason why this val was stained\n      # so we proceed to unstain ourselves\n      for cv in @valContainingThisArg.localValsAffectedByChangeOfThisVal\n        cv.unstainValCalculatedFromParent @valContainingThisArg\n      if @valContainingThisArg.ownerMorph.parent?\n        v = @morphContainingThisArg.parent.morphValsDependingOnChildrenVals[@valContainingThisArg.valName]\n        for k in v\n          k.unstainValCalculatedFromParent @valContainingThisArg\n';
