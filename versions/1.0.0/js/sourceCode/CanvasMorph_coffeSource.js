// Generated by CoffeeScript 1.10.0
window.CanvasMorph_coffeSource = '# CanvasMorph //////////////////////////////////////////////////////////\n# REQUIRES BackBufferMixin\n# \n# I clip my submorphs at my bounds. Which potentially saves a lot of redrawing\n# and event handling. \n# Also I always use a canvas to retain my graphical representation and respond\n# to the HTML5 commands.\n# \n# "container"/"contained" scenario going on.\n\nclass CanvasMorph extends FrameMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n  @augmentWith BackBufferMixin\n\n  \n  imBeingAddedTo: (newParentMorph) ->\n\n  # No changes of position or extent should be\n  # performed in here.\n  # There is really little hope to cache this buffer\n  # cross-morph, unless you key the buffer with the\n  # order of all the primitives and their\n  # parameters. So if user wants a cache it will have to specify\n  # a dedicated one in here. See textMorph for an example.\n  createRefreshOrGetBackBuffer: ->\n\n    extent = @extent()\n\n    if @backBuffer?\n      # @backBuffer.width and @backBuffer.height are already in\n      # physical coordinates so no need to adjust for pixelratio\n      backBufferExtent = new Point @backBuffer.width, @backBuffer.height\n      if backBufferExtent.eq extent.scaleBy pixelRatio\n        return [@backBuffer, @backBufferContext]\n      else\n\n        original_backBuffer = @backBuffer\n\n        # make a new canvas of the new size\n        @backBuffer = newCanvas extent.scaleBy pixelRatio\n        @backBufferContext = @backBuffer.getContext "2d"\n\n        # paint the background over it all so there are\n        # no holes in the new area (if the canvas is being\n        # enlarged).\n        if @color?\n          @backBufferContext.fillStyle = @color.toString()\n          @backBufferContext.fillRect 0, 0, extent.x * pixelRatio, extent.y * pixelRatio\n\n        # copy back the original canvas in the new one.\n        @backBufferContext.drawImage original_backBuffer, 0, 0\n        \n        # we leave the context with the correct pixel scaling.\n        # ALWAYS leave the context with the correct pixel scaling.\n        @backBufferContext.scale pixelRatio, pixelRatio\n        return [@backBuffer, @backBufferContext]\n\n    @backBuffer = newCanvas extent.scaleBy pixelRatio\n    @backBufferContext = @backBuffer.getContext "2d"\n\n    if @color?\n      @backBufferContext.fillStyle = @color.toString()\n      @backBufferContext.fillRect 0, 0, extent.x * pixelRatio, extent.y * pixelRatio\n\n    # we leave the context with the correct scaling.\n    # ALWAYS leave the context with the correct pixel scaling.\n    @backBufferContext.scale pixelRatio, pixelRatio\n    return [@backBuffer, @backBufferContext]\n\n\n  clear: (color = @color.toString()) ->\n    if !@backBuffer? then @createRefreshOrGetBackBuffer()\n    # @backBuffer.width and @backBuffer.height are already in\n    # physical coordinates so no need to adjust for pixelratio\n    backBufferExtent = new Point @backBuffer.width, @backBuffer.height\n    \n    # just in case we get a dirty transformation matrix:\n    # set it to the identity.\n    @backBufferContext.setTransform(1, 0, 0, 1, 0, 0)\n    # no need to scale here because we get the physical pixels\n    # in backBufferExtent \n    #@backBufferContext.scale pixelRatio, pixelRatio\n    \n    @backBufferContext.fillStyle = color\n    @backBufferContext.fillRect 0, 0, backBufferExtent.x, backBufferExtent.y\n\n    # we leave the context with the correct scaling.\n    # ALWAYS leave the context with the correct pixel scaling.\n    @backBufferContext.scale pixelRatio, pixelRatio\n    @changed()\n\n  drawLine: (start, dest, lineWidth, color) ->\n    if !@backBuffer? then @createRefreshOrGetBackBuffer()\n\n    context = @backBufferContext\n\n    from = start\n    to = dest\n    context.lineWidth = lineWidth\n    context.strokeStyle = color.toString()\n    context.lineCap = "round"\n    context.lineJoin = "round"\n    context.beginPath()\n    context.moveTo from.x, from.y\n    context.lineTo to.x, to.y\n    context.stroke()\n    @changed()\n  \n';
