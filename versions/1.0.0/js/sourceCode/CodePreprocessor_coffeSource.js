// Generated by CoffeeScript 1.10.0
window.CodePreprocessor_coffeSource = '###\n## CodePreprocessor takes care of translating the simplified syntax\n## of livecodelb to a coffeescript that is degestible by the\n## coffeescript compiler.\n## This pre-processing step can raise some errors - which are\n## returned in a dedicated variable.\n##\n## In order to run the tests just open the\n## console and type:\n##   testPreprocessor()\n## or, to run a subset (useful for bisection in case something goes wrong):\n##   testPreprocessor(rangeMin, rangeMax)\n###\n\ndetailedDebug = false\n\n\n# we want to have the following snippet to work:\n#   flickering = <if random > 0.5 then scale 0>\n#   flickering\n#     box\n#     peg\n# in order to do that, we need to have "scale 0" inside\n# that if to take a function (the box/peg block)\n# in order to do that, we transform the if into\n#    flickering = ifFunctional(random() > 0.5, scale function taking the block as argument)\n# so flickering is a function that can take the block as argument.\nifFunctional = (condition, thenCode, elseCode) ->\n  #console.log "outside: " + thenCode\n  (afterBlocks...) ->\n    #console.log "inside: " + thenCode\n    #console.log "afterBlocks: " + afterBlocks\n    #console.log "condition: " + condition\n    if condition\n      thenCode.apply this, afterBlocks\n    else\n      if elseCode?\n        elseCode.apply this, afterBlocks\n      else\n        # in the example above, flickering might be\n        # called without an argument and without\n        # a block, so check that case\n        if afterBlocks[0]?\n          afterBlocks[0]()\n\nwindow.ifFunctional = ifFunctional if window?\n\nclass CodePreprocessor\n\n  testCases: null\n\n  # We separate Commands from Expressions here.\n  # Expressions return a value that is potentially\n  # useful, while Stataments just change some sort\n  # of state but don\'t return anything useful.\n  # For example you can say\n  #   wave + 1; scale wave\n  # but not\n  #   box + 1; scale box\n  # hence, wave is an expression while box is\n  # a command.\n  # Note that actually in\n  # coffeescript everything returns a value,\n  # only in our case we really don\'t know what to\n  # do with return values of many functions.\n  # The explanation of why we need this separation\n  # is in the "implicit function" transformations\n  # code.\n  qualifyingCommands: [\n    # Matrix ops\n    "rotate"\n    "move"\n    "scale"\n    # Color and drawing styles\n    "fill"\n    "stroke"\n    "noFill"\n    "noStroke"\n  ]\n  primitives: [\n    # Geometry\n    "rect"\n    "line"\n    "box"\n    "ball"\n    "peg"\n    # Others\n    "run"\n  ]\n  commandsExcludingScaleRotateMove: [\n    # Geometry\n    "ballDetail"\n    # Matrix manipulation other than scale rotate move\n    "pushMatrix"\n    "popMatrix"\n    "resetMatrix"\n    # Sound\n    "bpm"\n    "play"\n    # Color and drawing styles\n    "strokeSize"\n    "animationStyle"\n    "background"\n    "simpleGradient"\n    "colorMode"\n    # Lighting\n    # "ambient""reflect" "refract"\n    "lights"\n    "noLights"\n    "ambientLight"\n    "pointLight"\n    # Server connections\n    "connect"\n  ]\n  colorCommands: [\n    "fill"\n    "stroke"      \n  ]\n\n  expressions: [\n    # Calculations\n    "abs"\n    "ceil"\n    "constrain"\n    "dist"\n    "exp"\n    "floor"\n    "lerp"\n    "log"\n    "mag"\n    "map"\n    "max"\n    "min"\n    "norm"\n    "pow"\n    "round"\n    "sq"\n    "sqrt"\n    # Trigonometry\n    "acos"\n    "asin"\n    "atan"\n    "atan2"\n    "cos"\n    "degrees"\n    "radians"\n    "sin"\n    "tan"\n    "wave"\n    "beat"\n    "pulse"\n    # Random\n    "random"\n    "randomSeed"\n    "noise"\n    "noiseDetail"\n    "noiseSeed"\n    # Color\n    "color"\n  ]\n\n\n  constructor: ->\n    @qualifyingCommandsRegex = @qualifyingCommands.join "|"\n    @primitivesRegex = @primitives.join "|"\n    @primitivesAndMatrixRegex = @qualifyingCommandsRegex + "|" + @primitivesRegex\n    @allCommandsRegex = (@commandsExcludingScaleRotateMove.join "|") +\n      "|" + @qualifyingCommandsRegex +\n      "|" + @primitivesRegex\n    @expressionsRegex = @expressions.join "|"\n\n    # build the regex for the colour literals\n    @colorsRegex = ""\n    colourLiterals = new ColourLiterals\n    for key of colourLiterals.colourNamesValues\n      if colourLiterals.colourNamesValues.hasOwnProperty key\n        @colorsRegex = @colorsRegex + "|"+key\n    # delete the pre-pended pipe character\n    @colorsRegex = @colorsRegex.substring(1, @colorsRegex.length)\n\n    @colorsCommandsRegex = @colorCommands.join "|"\n\n  ###\n  ## Stops ticked doOnce blocks from running\n  ##\n  ## doOnce statements which have a tick mark next to them\n  ## are not run. This is achieved by replacing the line with\n  ## the "doOnce" with "if false" or "//" depending on whether\n  ## the doOnce is a multiline or an inline one, like so:\n  ##\n  ##      ✓doOnce\n  ##        background 255\n  ##        fill 255,0,0\n  ##      ✓doOnce ball\n  ##      becomes:\n  ##      if false\n  ##        background 255\n  ##        fill 255,0,0\n  ##      //doOnce ball\n  ##\n  ## @param {string} code    the code to re-write\n  ##\n  ## @returns {string}\n  ###\n  removeTickedDoOnce: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    # doOnce multiline case\n    code = code.replace(/^(\\s*)✓[ ]*doOnce[ \\t]*$/gm, "$1if false")\n    # doOnce single-line case\n    # note that you can\'t just delete the line because it might be\n    # hanging below an if statement so you need a fake command\n    # there.\n    code = code.replace(/^(\\s*)✓[ ]*doOnce[ \\t]+.*$/gm, "$1noOperation")\n\n    if detailedDebug then console.log "removeTickedDoOnce\\n" + code + " error: " + error\n    if code.indexOf("✓") != -1\n      return [undefined,"✓ must be next to a doOnce"]\n    return [code, error]\n\n  # strings shouldn\'t undergo any transformation\n  # so we use replace all the strings with\n  # references to a table, which we\'ll replace back\n  # later with the original strings.\n  # This code is adapted from Processing.js\n  # (ref: "codeWoStrings" and "injectStrings")\n  removeStrings: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    stringsTable = []\n    codeWithoutStrings = code.replace(/("(?:[^"\\\\\\n]|\\\\.)*")|(\'(?:[^\'\\\\\\n]|\\\\.)*\')/g, (all, quoted, aposed) ->\n      index = stringsTable.length\n      stringsTable.push all\n      return "\'STRINGS_TABLE>" + index + "<STRINGS_TABLE\'"\n    )\n\n    return [codeWithoutStrings, stringsTable, error]\n\n  # replaces strings and regexs keyed by index with an array of strings\n  # see "removeStrings" function\n  injectStrings: (code, stringsTable, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    code = code.replace /\'STRINGS_TABLE>(\\d+)<STRINGS_TABLE\'/g, (all, index) ->\n      val = stringsTable[index]\n      return val\n\n    return [code, error]\n\n\n\n  addTracingInstructionsToDoOnceBlocks: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    # ADDING TRACING INSTRUCTION TO THE DOONCE BLOCKS\n    # each doOnce block is made to start with an instruction that traces whether\n    # the block has been run or not. This allows us to put back the tick where\n    # necessary, so the doOnce block is not run again.\n    # Example - let\'s say one pastes in this code:\n    #\n    #      doOnce\n    #        background 255\n    #        fill 255,0,0\n    #\n    #      doOnce ball\n    #\n    # it becomes:\n    #\n    #      1.times ->\n    #        addDoOnce(1); background 255\n    #        fill 255,0,0\n    #\n    #      ;addDoOnce(4);\n    #      1.times -> ball\n    #\n    # So: if there is at least one doOnce\n    #   split the source in lines\n    #   add line numbers tracing instructions so we can track which\n    #   ones have been run regroup the lines into a single string again\n    #\n    elaboratedSourceByLine = undefined\n    if code.indexOf("doOnce") > -1\n      \n      #alert("a doOnce is potentially executable")\n      elaboratedSourceByLine = code.split("\\n")\n      \n      #alert(\'splitting: \' + elaboratedSourceByLine.length )\n      for eachLine in [0...elaboratedSourceByLine.length]\n        \n        #alert(\'iterating: \' + eachLine )\n        \n        # add the line number tracing instruction to inline case\n        elaboratedSourceByLine[eachLine] =\n          elaboratedSourceByLine[eachLine].replace(\n            /(^|\\s+)doOnce[ \\t]+(.+)$/g,\n            "$1;addDoOnce(" + eachLine + "); 1.times -> $2")\n        \n        # add the line number tracing instruction to multiline case\n        if /(^|\\s+)doOnce[ \\t]*$/g.test(elaboratedSourceByLine[eachLine])\n          \n          #alert(\'doOnce multiline!\')\n          elaboratedSourceByLine[eachLine] =\n            elaboratedSourceByLine[eachLine].replace(\n              /(^|\\s+)doOnce[ \\t]*$/g, "$11.times ->")\n\n          elaboratedSourceByLine[eachLine + 1] =\n            elaboratedSourceByLine[eachLine + 1].replace(\n              /^(\\s*)(.*)$/g, "$1addDoOnce(" + eachLine + "); $2")\n      code = elaboratedSourceByLine.join "\\n"\n    \n    #alert(\'soon after replacing doOnces\'+code)\n    return [code, error]\n\n  doesProgramContainStringsOrComments: (code) ->\n    characterBeingExamined = undefined\n    nextCharacterBeingExamined = undefined\n    while code.length\n      characterBeingExamined = code.charAt(0)\n      nextCharacterBeingExamined = code.charAt(1)\n      if characterBeingExamined is "\'" or\n          characterBeingExamined is "\\"" or\n          (characterBeingExamined is "/" and\n            (nextCharacterBeingExamined is "*" or\n            nextCharacterBeingExamined is "/"))\n        return true\n      code = code.slice(1)\n\n  stripCommentsAndStrings: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, undefined, error] if error?\n\n    # for some strange reason the comments on the last line\n    # are not stripped, so adding a new line which we\'ll\n    # then strip off\n    code = code + "\\n"\n\n    codeWithoutComments = undefined\n    codeWithoutStringsOrComments = undefined\n    \n    # check whether the program potentially\n    # contains strings or comments\n    # if it doesn\'t then we can do some\n    # simple syntactic checks that are likely\n    # to be much faster than attempting a\n    # coffescript to javascript translation\n    \n    # let\'s do a quick check:\n    # these groups of characters should be in even number:\n    # ", \', (), {}, []\n    # Note that this doesn\'t check nesting, so for example\n    # [{]} does pass the test.\n    if @doesProgramContainStringsOrComments(code)\n      \n      # OK the program contains comments and/or strings\n      # so this is what we are going to do:\n      # first we remove all the comments for good\n      # then we create a version without the strings\n      # so we can perform some basic syntax checking.\n      # Note that when we remove the comments we also need to\n      # take into account strings because otherwise we mangle a line like\n      # print "frame/100 //"\n      # where we need to now that that single comment is actually the content\n      # of a string.\n      # modified from Processing.js (search for: "masks strings and regexs")\n      # this is useful to remove all comments but keeping all the strings\n      # the difference is that here I don\'t treat regular expressions.\n      # Note that string take precedence over comments i.e.\n      #   "lorem ipsum //"\n      # is a string, not half a string with a quote in a comment\n      # get rid of the comments for good.\n      # note the use of coffeescripts\' "block regular expressions" here,\n      # and note that there is no need to escape "/" with "\\/",\n      # see https://github.com/jashkenas/coffee-script/issues/2358\n      code = code.replace(\n        ///\n        ("(?:[^"\\\\\\n]|\\\\.)*")|\n        (\'(?:[^\'\\\\\\n]|\\\\.)*\')|\n        (//[^\\n]*\\n)|\n        (/\\*(?:(?!\\*/)(?:.|\\n))*\\*/)\n        ///g,\n          (all, quoted, aposed, singleComment, comment) ->\n            numberOfLinesInMultilineComment = undefined\n            rebuiltNewLines = undefined\n            cycleToRebuildNewLines = undefined\n            \n            # strings are kept as they are\n            return quoted  if quoted\n            return aposed  if aposed\n            \n            # preserve the line because\n            # the doOnce mechanism needs to retrieve\n            # the line where it was\n            return "\\n"  if singleComment\n            \n            # eliminate multiline comments preserving the lines\n            numberOfLinesInMultilineComment = comment.split("\\n").length - 1\n            rebuiltNewLines = ""\n            for cycleToRebuildNewLines in [0...numberOfLinesInMultilineComment]\n              rebuiltNewLines = rebuiltNewLines + "\\n"\n            rebuiltNewLines\n      )\n      codeWithoutComments = code\n      \n      # in the version we use for syntax checking we delete all the strings\n      codeWithoutStringsOrComments =\n        code.replace(/("(?:[^"\\\\\\n]|\\\\.)*")|(\'(?:[^\'\\\\\\n]|\\\\.)*\')/g, "")\n    else\n      codeWithoutStringsOrComments = code\n      codeWithoutComments = code\n\n    # taking away the new line we added to\n    # work around the fact that comments on the last\n    # line are not stripped\n    codeWithoutComments = code.substring(0, code.length - 1)\n\n    return [codeWithoutComments, codeWithoutStringsOrComments, error]\n\n  checkBasicSyntax: (code, codeWithoutStringsOrComments, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n\n    aposCount = 0\n    quoteCount = 0\n    roundBrackCount = 0\n    curlyBrackCount = 0\n    squareBrackCount = 0\n    characterBeingExamined = undefined\n    reasonOfBasicError = undefined\n    while codeWithoutStringsOrComments.length\n      characterBeingExamined = codeWithoutStringsOrComments.charAt(0)\n      if characterBeingExamined is "\'"\n        aposCount += 1\n      else if characterBeingExamined is "\\""\n        quoteCount += 1\n      else if characterBeingExamined is "(" or characterBeingExamined is ")"\n        roundBrackCount += 1\n      else if characterBeingExamined is "{" or characterBeingExamined is "}"\n        curlyBrackCount += 1\n      else if characterBeingExamined is "[" or characterBeingExamined is "]"\n        squareBrackCount += 1\n      else if characterBeingExamined is ";"\n        return [undefined,"break line instead of using \';\'"]\n      codeWithoutStringsOrComments = codeWithoutStringsOrComments.slice(1)\n    \n    # according to jsperf, the fastest way to check if number is even/odd\n    if aposCount & 1 or quoteCount & 1 or roundBrackCount & 1 or\n        curlyBrackCount & 1 or squareBrackCount & 1\n      programHasBasicError = true\n      reasonOfBasicError = \'\'\n\n      reasonOfBasicErrorMissing = \'\'\n      reasonOfBasicErrorMissing = reasonOfBasicErrorMissing + "\', "  if aposCount & 1\n      reasonOfBasicErrorMissing = reasonOfBasicErrorMissing + "\\", "  if quoteCount & 1\n\n      if (aposCount & 1) or (quoteCount & 1)\n        reasonOfBasicErrorMissing =  "Missing " + reasonOfBasicErrorMissing\n        reasonOfBasicErrorMissing = reasonOfBasicErrorMissing.substring(0, reasonOfBasicErrorMissing.length - 2)\n\n      reasonOfBasicErrorUnbalanced = \'\'\n      reasonOfBasicErrorUnbalanced = reasonOfBasicErrorUnbalanced + "(), "  if roundBrackCount & 1\n      reasonOfBasicErrorUnbalanced = reasonOfBasicErrorUnbalanced + "{}, "  if curlyBrackCount & 1\n      reasonOfBasicErrorUnbalanced = reasonOfBasicErrorUnbalanced + "[], "  if squareBrackCount & 1\n\n      if (roundBrackCount & 1) or (curlyBrackCount & 1) or (squareBrackCount & 1)\n        reasonOfBasicErrorUnbalanced = "Unbalanced " + reasonOfBasicErrorUnbalanced\n        reasonOfBasicErrorUnbalanced = reasonOfBasicErrorUnbalanced.substring(0, reasonOfBasicErrorUnbalanced.length - 2)\n\n      reasonOfBasicError = reasonOfBasicErrorMissing + " " + reasonOfBasicErrorUnbalanced\n      return [undefined,reasonOfBasicError]\n    \n    # no comments or strings were found, just return the same string\n    # that was passed\n    return [code, error]\n\n  ###\n  ## Some of the functions can be used with postfix notation\n  ##\n  ## e.g.\n  ##\n  ##      60 bpm\n  ##      red fill\n  ##      yellow stroke\n  ##      black background\n  ##\n  ## We need to switch this round before coffee script compilation\n  adjustPostfixNotations: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    # red background\n    # red fill;box\n\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    code = code.replace(/(\\d+)[ ]+bpm(\\s|$|;)/g, "bpm $1$2")\n    code = code.replace(/([a-zA-Z]+)[ ]+fill(\\s|$|;)/g, "fill $1$2")\n    code = code.replace(/([a-zA-Z]+)[ ]+stroke(\\s|$|;)/g, "stroke $1$2")\n    code = code.replace(/([a-zA-Z]+)[ ]+background(\\s|$|;)/g, "background $1$2")\n    return [code, error]\n  ###\n\n  normaliseCode:(code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    #code = code.replace(/;[ ]+/gm, "; ")\n    code = code.replace(/[ ];/gm, "; ")\n    if detailedDebug then console.log "normalise-1:\\n" + code + " error: " + error\n    code = code.replace(/;$/gm, "")\n    if detailedDebug then console.log "normalise-2:\\n" + code + " error: " + error\n    code = code.replace(/;([^ \\r\\n])/gm, "; $1")\n    if detailedDebug then console.log "normalise-3:\\n" + code + " error: " + error\n    return [code, error]\n\n  #   a -> b -> c()\n  # is just the same as\n  #   a -> b c\n  # and, similarly,\n  #   a -> b 2, -> c()\n  # is just the same as\n  #   a -> b 2, c\n  simplifyFunctionDoingSimpleInvocation:(code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    code = code.replace(/([\\w\\d]|,)[\\t ]*->[\\t ]*([\\w\\d]*)[\\t ]*\\([\\t ]*\\)/gm, "$1 $2")\n    if detailedDebug then console.log "simplifyFunctionDoingSimpleInvocation-1:\\n" + code + " error: " + error\n    return [code, error]\n\n  # sometimes you are left with something like\n  #   a = (F)\n  # where F is a function.\n  # simplify that to\n  #   a = F\n  simplifyFunctionsAloneInParens:(code, error, userDefinedFunctions, bracketsVariables) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    functionsRegex = @allCommandsRegex + userDefinedFunctions + bracketsVariables\n\n    rx = RegExp("\\\\([ \\\\t]*(" + functionsRegex + ")[ \\\\t]*\\\\)[ \\\\t]*$",\'gm\')\n    #console.log rx\n    code = code.replace(rx, "$1")\n\n\n    if detailedDebug then console.log "simplifyFunctionsAloneInParens-1:\\n" + code + " error: " + error\n    return [code, error]\n\n\n\n  # these transformations are supposed to take as input\n  # working coffeescript code and give as output\n  # beautified and "normalised" coffeescript code\n  # with the same exact meaning.\n  # TODO Some of these beautification that depend on the () being\n  # there are actually critical for the transformed code to work.\n  # so they should be moved out of this function.\n\n  beautifyCode:(code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    code = code.replace(/\\.times[\\\\t ]+/gm, ".times ")\n    if detailedDebug then console.log "beautifyCode--1:\\n" + code + " error: " + error\n    code = code.replace(/\\.times[\\\\t ]+with[\\\\t ]+/gm, ".times with ")\n    if detailedDebug then console.log "beautifyCode-0:\\n" + code + " error: " + error\n    code = code.replace(/->(?![ \\t])/gm, "-> ")\n    if detailedDebug then console.log "beautifyCode-1:\\n" + code + " error: " + error\n    code = code.replace(/->[\\t ;]+/gm, "-> ")\n    if detailedDebug then console.log "beautifyCode-2:\\n" + code + " error: " + error\n    code = code.replace(/->[\\t ]+$/gm, "->")\n    if detailedDebug then console.log "beautifyCode-3:\\n" + code + " error: " + error\n    code = code.replace(/if[\\t ;]+/gm, "if ")\n    if detailedDebug then console.log "beautifyCode-4:\\n" + code + " error: " + error\n    code = code.replace(/then[\\t ;]+/gm, "then ")\n    if detailedDebug then console.log "beautifyCode-5:\\n" + code + " error: " + error\n    code = code.replace(/else[\\t ;]+/gm, "else ")\n    if detailedDebug then console.log "beautifyCode-6:\\n" + code + " error: " + error\n    code = code.replace(/;[\\t ]+/gm, "; ")\n    if detailedDebug then console.log "beautifyCode-7:\\n" + code + " error: " + error\n    code = code.replace(/([\\w\\d;\\)])[\\t ]*then/g, "$1 then")\n    if detailedDebug then console.log "beautifyCode-8:\\n" + code + " error: " + error\n    code = code.replace(/([\\w\\d;\\)])[\\t ]*else/g, "$1 else")\n    if detailedDebug then console.log "beautifyCode-9:\\n" + code + " error: " + error\n    code = code.replace(/;$/gm, "")\n    if detailedDebug then console.log "beautifyCode-10:\\n" + code + " error: " + error\n    code = code.replace(/([\\w\\d;\\)])[\\t ]*->/g, "$1 ->")\n    if detailedDebug then console.log "beautifyCode-11:\\n" + code + " error: " + error\n    code = code.replace(/([\\w\\d;\\)])[\\t ]*!=/g, "$1 !=")\n    if detailedDebug then console.log "beautifyCode-12:\\n" + code + " error: " + error\n    code = code.replace(/([\\w\\d;\\)])[\\t ]*>=/g, "$1 >=")\n    if detailedDebug then console.log "beautifyCode-13:\\n" + code + " error: " + error\n    code = code.replace(/([\\w\\d;\\)])[\\t ]*<=/g, "$1 <=")\n    if detailedDebug then console.log "beautifyCode-14:\\n" + code + " error: " + error\n    code = code.replace(/([\\w\\d;\\)])[\\t ]*=/g, "$1 =")\n    if detailedDebug then console.log "beautifyCode-15:\\n" + code + " error: " + error\n    code = code.replace(/\\=([\\w\\d\\(])/g, "= $1")\n    if detailedDebug then console.log "beautifyCode-16:\\n" + code + " error: " + error\n    #code = code.replace(/\\)([\\t ]+\\d)/g, ");$1")\n    #if detailedDebug then console.log "beautifyCode-17:\\n" + code + " error: " + error\n    code = code.replace(/\\)[\\t ]*if/g, "); if")\n    if detailedDebug then console.log "beautifyCode-18:\\n" + code + " error: " + error\n    code = code.replace(/,[\\t ]*->/gm, ", ->")\n    if detailedDebug then console.log "beautifyCode-18.5:\\n" + code + " error: " + error\n    code = code.replace(/;[\\t ]+$/gm, "")\n    if detailedDebug then console.log "beautifyCode-19:\\n" + code + " error: " + error\n    code = code.replace(/♠/g, "")\n    if detailedDebug then console.log "beautifyCode-20:\\n" + code + " error: " + error\n\n    # transform stuff like (3).times and (n).times\n    # into 3.times and n.times\n    code = code.replace(/\\(\\s*(\\d+|[$A-Z_][0-9A-Z_$]*)\\s*\\)\\.times/gi, "$1.times")\n    if detailedDebug then console.log "beautifyCode-21:\\n" + code + " error: " + error\n\n    code = code.replace(/\\=[\\t ]+-/g, "= -")\n    if detailedDebug then console.log "beautifyCode-22:\\n" + code + " error: " + error\n\n    allFunctionsRegex = @allCommandsRegex + "|" + @expressionsRegex\n    rx = RegExp("\\\\( *("+allFunctionsRegex+") *\\\\)",\'g\')\n    code = code.replace(rx, "$1")\n    if detailedDebug then console.log "beautifyCode-23:\\n" + code + " error: " + error\n\n    code = code.replace(/[ ]*then/g, " then")\n    if detailedDebug then console.log "beautifyCode-24:\\n" + code + " error: " + error\n\n\n    return [code, error]\n\n\n  # we receive the times command\n  # in all sorts of ways. With binding, without\n  # binding, with colons, with extra arrows,\n  # with a dot before times...\n  # here we normalise to the following forms:\n  #   x times\n  # or\n  #   x times with var:\n\n  normaliseTimesNotationFromInput:(code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    # remove dot and extra arrow in case of\n    # non-binding notation\n    code = code.replace(/\\.times([^\\w\\d])/gm, " times$1")\n    code = code.replace(/(^[\\t ]*|[\\t ]+)times[\\t .]*->/gm, "$1times ")\n\n    # normalise the binding syntax\n    code = code.replace(/(^[\\t ]*|[\\t ]+)times[\\t .]*\\([\\t .]*([\\w]*)[\\t .]*\\)[\\t .]*->/gm, "$1times with $2:")\n\n    # remove the arrow in the case of binding\n    code = code.replace(/(^[\\t ]*|[\\t ]+)times[\\t .]*with[\\t .]*([\\w]*)[\\t .]*:?[\\t .]*->/gm, "$1times with $2:")\n\n    if detailedDebug then console.log "normaliseTimesNotationFromInput-1:\\n" + code + " error: " + error\n\n    return [code, error]\n\n\n  checkBasicErrorsWithTimes:(code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    # if what we transform makes any sense *at all*, then\n    # coffeescript will translate it to js and run it, which\n    # in some cases we don\'t want.\n    # We want to simply rule out some common cases here\n    # so we don\'t need to make the regexpes too complicated\n    # For example we want to avoid:\n    #\n    #   peg; times rotate box 2* wave\n    # to become\n    #   (peg()).times ->  rotate box 2* wave()\n    # or\n    #   peg times rotate box 2* wave\n    # to become\n    #   peg.times ->  rotate box 2* wave()\n    #\n    # and run simply because we forgot a number in front\n    # of \'times\'\n\n    rx = RegExp("("+@allCommandsRegex+")\\\\s+times(?![\\\\w\\\\d])",\'g\')\n\n    if /^\\s*times/gm.test(code) or\n      /;\\s*times/g.test(code) or\n      /else\\s+times/g.test(code) or\n      /then\\s+times/g.test(code) or\n      rx.test(code)\n        programHasBasicError = true\n        return [undefined, "how many times?"]\n    return [code, error]\n\n  unbindFunctionsToArguments: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n    # put back in place "sin⨁a,b" into "sin a,b" \n    code = code.replace(/⨁/g, "")\n    return @normaliseCode(code, error)\n\n  # in order to proper recognise where expressions\n  # start and end, we need to tie the functions with their\n  # arguments. For example "sin a" has to becomde\n  # sin⨁ a.\n  # The regexp for isolating expressions stops capturing\n  # when there are two tokens not tied by an operator,\n  # so this is why adding that special operator is needed\n  bindFunctionsToArguments: (code, error, userDefinedFunctionsWithArguments) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    # we don\'t want "sin times" to be considered an expression\n    # so introduce a blocker character to avoid "sin times"\n    # to becomde "sin⨁ times"\n    rx = RegExp("([^\\\\w\\\\d\\\\r\\\\n])("+(@allCommandsRegex+"|times")+")(?![\\w\\d])",\'g\')\n    code = code.replace(rx, "$1⧻$2")\n    if detailedDebug then console.log "transformTimesSyntax-1\\n" + code + " error: " + error\n\n\n    # "expression" functions such as in "sin a,b" need to become\n    # "sin⨁a,b" \n    # the for is needed for example for cases like round(pulse 15) times\n    expsAndUserFunctionsWithArgs =  @expressionsRegex + userDefinedFunctionsWithArguments\n    rx = RegExp("(^|[^\\\\w\\\\d\\\\r\\\\n])("+expsAndUserFunctionsWithArgs+")([ \\\\(]+)(?![⧻\\\\+\\\\-*/%,⨁])",\'gm\')\n    for i in [0...5]\n      code = code.replace(rx, "$1$2$3⨁")\n      if detailedDebug then console.log "transformTimesSyntax-2\\n" + code + " error: " + error\n\n    # remove blocker character to avoid "sin times"\n    # to becomde "sin⨁ times"\n    code = code.replace(/⧻/g, "")\n\n    return @normaliseCode(code, error)\n\n  transformTimesSyntax: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n\n    if detailedDebug then console.log "transformTimesSyntax-0\\n" + code + " error: " + error\n    #code = code.replace(/(else)\\s+([a-zA-Z1-9])([^;\\r\\n]*) times[:]?([^a-zA-Z0-9])/g, "$1 ($2$3).times -> $4")\n    #if detailedDebug then console.log "transformTimesSyntax-1\\n" + code + " error: " + error\n    #code = code.replace(/(then)\\s+([a-zA-Z1-9])([^;\\r\\n]*) times[:]?([^a-zA-Z0-9])/g, "$1 ($2$3).times -> $4")\n    #if detailedDebug then console.log "transformTimesSyntax-2\\n" + code + " error: " + error\n    # without the following, "if 2 times a" becomes "(if 2).times a"\n    #code = code.replace(/(if)\\s+([a-zA-Z1-9])([^;\\r\\n]*) times[:]?([^a-zA-Z0-9])/g, "$1 ($2$3).times -> $4")\n    #if detailedDebug then console.log "transformTimesSyntax-3\\n" + code + " error: " + error\n\n    code = code.replace(/then/g, "then;")\n    code = code.replace(/else/g, ";else;")\n\n    # the diamond (♦) will be in front of the "times"\n    # argument. This is needed to make it so\n    # the qualifiers will be able to be fleshed out\n    # correctly\n    \n\n    # simple mathematical expressions\n    # e.g. rotate 2,a+1+3*(a*2.32+Math.PI) 2 times box\n    code = code.replace(/(([\\d\\w\\.\\(\\)]+([\\t ]*[\\+\\-*\\/⨁%,][\\t ]*))+[\\d\\w\\.\\(\\)]+|[\\d\\w\\.\\(\\)]+) times[:]?(?![\\w\\d])/g, "♦ ($1).times ->")\n    if detailedDebug then console.log "transformTimesSyntax-3\\n" + code + " error: " + error\n\n    # strip the out parens if there is one too many\n    code = code.replace(/\\(\\((([\\d\\w\\.\\(\\)]+([\\t ]*[\\+\\-*\\/⨁%,][\\t ]*))+[\\d\\w\\.\\(\\)]+|[\\d\\w\\.\\(\\)]+)\\)\\)\\.times /g, "($1).times ")\n    if detailedDebug then console.log "transformTimesSyntax-3.2\\n" + code + " error: " + error\n\n    allFunctionsRegex = @allCommandsRegex + "|" + @expressionsRegex\n\n    # ([\\d\\w\\(\\)]+([ ]*[-+/*][ ]*[\\d\\w\\(\\)]+(\\.[\\d\\w\\(\\)]+)?)+)+ captures\n    # simple mathematical expressions\n    # e.g. rotate 2,a+1+3*(a*2.32+Math.PI) 2 times box\n    rx = RegExp("("+allFunctionsRegex+")[\\\\t ]*;[; ]*\\\\(?(([\\\\d\\\\w\\\\.\\\\(\\\\)]+([\\\\t ]*[\\\\+\\\\-*/⨁%,][\\\\t ]*))+[\\\\d\\\\w\\\\.\\\\(\\\\)]+|[\\\\d\\\\w\\\\.\\\\(\\\\)]+)\\\\)\\\\.times ->",\'g\')\n    code = code.replace(rx, "$1()♦ ($2).times ->")\n    if detailedDebug then console.log "transformTimesSyntax-3.5\\n" + code + " error: " + error\n\n    # whatever is remaining should be turned into a normal form with semicolon before it.\n    code = code.replace(/\\((([\\d\\w\\.\\(\\)]+([\\t ]*[\\+\\-*\\/⨁%,][\\t ]*))+[\\d\\w\\.\\(\\)]+|[\\d\\w\\.\\(\\)]+)\\)[ \\.]*times[\\\\t ]*[:]?[\\\\t ]*(?![\\w\\d])/g, ";($1).times ")\n    if detailedDebug then console.log "transformTimesSyntax-3.55\\n" + code + " error: " + error\n\n    # whatever is remaining should be turned into a normal form with semicolon before it.\n    code = code.replace(/[ ](([\\d\\w\\.\\(\\)]+([\\t ]*[\\+\\-*\\/⨁%,][\\t ]*))+[\\d\\w\\.\\(\\)]+|[\\d\\w\\.\\(\\)]+)\\.times[\\t ]*[:]?[\\t ]*(?![\\w\\d])/g, "; $1.times ")\n    if detailedDebug then console.log "transformTimesSyntax-3.56\\n" + code + " error: " + error\n\n    # transformation above transforms ;(sin ⨁ 5).times  ->  into ;(sin ⨁; 5).times   ->\n    # so fixing that\n    code = code.replace(/⨁;/g, "")\n\n\n    # repairs myFunc = -> ; 20.times -> rotate -> box()\n    code = code.replace(/->[\\t ]*[♦;\\t ]*[\\t ]*\\(/g, "-> (")\n    if detailedDebug then console.log "transformTimesSyntax-3.57\\n" + code + " error: " + error\n\n    code = code.replace(/then[\\t ]*[♦;\\t ]*[\\t ]*\\(/g, "then (")\n    if detailedDebug then console.log "transformTimesSyntax-3.57\\n" + code + " error: " + error\n\n    # the transformation above generates stuff like\n    #   peg(); ;  (2).times ->\n    # and\n    #   ; (1+1).times ->...\n    # so fixing these cases\n    # but careful not to destroy the indentations\n    code = code.replace(/->\\s*;/g, "->")\n    if detailedDebug then console.log "transformTimesSyntax-3.6\\n" + code + " error: " + error\n    code = code.replace(/([\\w\\d;])[\\t ]?;[; ]+\\(/g, "$1; (")\n    if detailedDebug then console.log "transformTimesSyntax-3.7\\n" + code + " error: " + error\n    code = code.replace(/\\)[ ]*;[; ]+\\(/g, "); (")\n    if detailedDebug then console.log "transformTimesSyntax-3.75\\n" + code + " error: " + error\n    code = code.replace(/^([\\t ]*);[; ]+\\(/gm, "$1(")\n    if detailedDebug then console.log "transformTimesSyntax-3.8\\n" + code + " error: " + error\n    code = code.replace(/^([\\t ]*)[♦;][;♦ ]*/gm, "$1")\n    if detailedDebug then console.log "transformTimesSyntax-3.9\\n" + code + " error: " + error\n    \n    # It\'s unclear whether the cases catered by the two \n    # transformatione below ever make sense.\n    # without the following, "a = (2 times box)" becomes "(a = 2.times -> box())"\n    code = code.replace(/(\\()\\s*([\\w\\d])([^;\\r\\n]*) times[:]?([^\\w\\d])/g, "$1 ($2$3).times -> $4")\n    if detailedDebug then console.log "transformTimesSyntax-4\\n" + code + " error: " + error\n    # without the following, "a = 2 times box" becomes "(a = 2).times -> box()"\n    code = code.replace(/(=)\\s*([\\w\\d])([^;\\r\\n]*) times[:]?([^\\w\\d])/g, "$1 ($2$3).times -> $4")\n    if detailedDebug then console.log "transformTimesSyntax-4\\n" + code + " error: " + error\n\n    # the [^;\\r\\n]*? is to make sure that we don\'t take ; within the times argument\n    # example:\n    #  box; box ;  2 times: peg\n    # if we don\'t exclude the semicolon form the times argument then we transform into\n    #  box; (box ;  2).times ->  peg\n    # which is not correct\n    code = code.replace(/;[ \\t]*([\\w\\d])([^;\\r\\n]*?) times[:]?([^\\w\\d])/g, "♦ ($1$2).times -> $3")\n    if detailedDebug then console.log "transformTimesSyntax-5\\n" + code + " error: " + error\n\n    # the transformation above generates stuff like\n    #   if true then; (2).times ->\n    # so fixing that\n    code = code.replace(/if\\s*;/g, "if")\n    code = code.replace(/then\\s*;/g, "then")\n    code = code.replace(/else\\s*;/g, "else")\n    if detailedDebug then console.log "transformTimesSyntax-5.5\\n" + code + " error: " + error\n\n\n    # takes care of cases like myFunc = -> 20 times rotate box\n    code = code.replace(/(->)\\s+([\\w\\d])(.*?) times[:]?([^\\w\\d])/g, "$1 ($2$3).times -> $4")\n    if detailedDebug then console.log "transformTimesSyntax-6\\n" + code + " error: " + error\n\n\n    # last (catch all other cases where it captures everything\n    # since the start of the line,\n    # which is why you need to handle the other cases before):\n    # the ^; is to avoid this matching:\n    #   peg; times rotate box 2* wave (group1: p group2: eg; group3: rot...wave)\n    code = code.replace(/([\\w\\d])(.*?) times[:]?([^\\w\\d])/g, "($1$2).times -> $3")\n    if detailedDebug then console.log "transformTimesSyntax-7\\n" + code + " error: " + error\n\n    code = code.replace(/;+[\\t ]*else/g, " else")\n    if detailedDebug then console.log "transformTimesSyntax-8\\n" + code + " error: " + error\n\n    code = code.replace(/^(\\t*) else/gm, "$1else")\n    if detailedDebug then console.log "transformTimesSyntax-9\\n" + code + " error: " + error\n\n    return @normaliseCode(code, error)\n\n  # transforms the case where we are binding a variable\n  # e.g.\n  #   3 times with i box i\n  # first bring to intermediate form\n  #   3.timesWithVariable -> (i) -> box i\n  # then just to \n  #   3.times (i) -> box i\n  # which is then handled correctly by\n  # coffeescript\n  # note that the parentheses around the i\n  # are needed!\n  #   3.times i -> box i\n  # is transformed by coffeescript in something\n  # that doesn\'t make sense.\n\n  transformTimesWithVariableSyntax: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    # first to intermediate form\n\n    code = code.replace(/\\.times[\\t ]*with[\\t ]*(\\w+)[\\t ]*(:|;|,[\\t ]*->)?/g, ".timesWithVariable -> ($1) $2")\n\n    if detailedDebug then console.log "transformTimesWithVariableSyntax-1\\n" + code + " error: " + error\n\n    code = code.replace(/\\.times[\\t ]*->[\\t ]*with[\\t ]*(\\w+)[\\t ]*(:|;|,[\\t ]*->)?/g, ".timesWithVariable -> ($1) ->")\n\n    if detailedDebug then console.log "transformTimesWithVariableSyntax-2\\n" + code + " error: " + error\n\n    # now from intermediate form to the form with just "times"\n\n    #code = code.replace(/\\.timesWithVariable[\\t ]*->[\\t ]*/g, ".times ")\n    code = code.replace(/\\.timesWithVariable[\\t ]*->[\\t ]*/g, ".timesWithVariable ")\n\n    if detailedDebug then console.log "transformTimesWithVariableSyntax-3\\n" + code + " error: " + error\n\n    return @normaliseCode(code, error)\n\n  # the need for "parametersForBracketedFunctions" is so that\n  # code such as\n  #    a = <fill red>\n  #    b= <box>\n  #    a b\n  # can work. Basically the function inside a needs to\n  # be able to accept further functions to be chained.\n\n  adjustFunctionalReferences: (code, error, userDefinedFunctions, bracketsVariables) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    # this one is so that arrow is not mistaken\n    # for a closed bracket\n    code = code.replace(/->/g, "→")\n\n    # turns things like\n    #  either <rotate -> box>, <peg>\n    #  either <box 2>, <peg 2>\n    # into\n    #  either (-> rotate -> box), (->peg)\n    #  either (-> box 2), (->peg 2)\n    expressionsAndUserDefinedFunctionsRegex = @expressionsRegex + userDefinedFunctions + bracketsVariables\n    allFunctionsRegex = @allCommandsRegex + "|" + expressionsAndUserDefinedFunctionsRegex\n\n    rx = RegExp("<[\\\\s]*(("+allFunctionsRegex+")[\\\\t ]*)>",\'gm\')\n    code = code.replace(rx, "($1♠)")\n\n    rx = RegExp("<[\\\\s]*(("+allFunctionsRegex+")[^\\\\r\\\\n]*?)>",\'gm\')\n    code = code.replace(rx, "((parametersForBracketedFunctions)->($1, -> (if parametersForBracketedFunctions? then parametersForBracketedFunctions() else null)))")\n\n    code = code.replace(/→/g, "->")\n\n    if detailedDebug then console.log "adjustFunctionalReferences-1\\n" + code + " error: " + error\n\n    return [code, error]\n\n\n\n  fixParamPassingInBracketedFunctions: (code, error, userDefinedFunctions) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    code = code.replace(/\\(\\),? -> \\(if parametersForBracketedFunctions/g, " -> (if parametersForBracketedFunctions")\n\n    if detailedDebug then console.log "fixParamPassingInBracketedFunctions-1\\n" + code + " error: " + error\n\n    return [code, error]\n\n  adjustImplicitCalls: (code, error, userDefinedFunctions, userDefinedFunctionsWithArguments, bracketsVariables) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    expressionsAndUserDefinedFunctionsRegex = @expressionsRegex + userDefinedFunctions + bracketsVariables\n    allFunctionsRegex = @allCommandsRegex + "|" + expressionsAndUserDefinedFunctionsRegex + bracketsVariables\n\n    \n    # adding () to single tokens on their own at the start of a line\n    # ball\n    if detailedDebug then console.log "adjustImplicitCalls-1\\n" + code + " error: " + error\n    rx = RegExp("^([ \\\\t]*)("+allFunctionsRegex+")[ ]*$",\'gm\')\n    code = code.replace(rx, "$1$2();")\n    if detailedDebug then console.log "adjustImplicitCalls-2\\n" + code + " error: " + error\n\n\n    # adding () to single tokens at the start of the line\n    # followed by a semicolon (might be followed by more instructions)\n    # ball;\n    # ball; somethingelse\n    rx = RegExp("^([ \\\\t]*)("+allFunctionsRegex+")[ ]*;",\'gm\')\n    code = code.replace(rx, "$1$2();")\n    if detailedDebug then console.log "adjustImplicitCalls-3\\n" + code + " error: " + error\n\n    # adding () to any functions not at the beginning of a line\n    # and followed by a anything that might end the command\n    # eg semicolon, closing parenthesis, math sign, etc.\n    #   something;ball\n    #   something;ball;\n    #   something;ball;ball\n    #   something;ball;ball;\n    #   ✓doOnce ball; background red\n    #   if ball then ball else something\n    #   box wave\n    #   box wave(wave)\n    # Why do we handle Commands differently from expressions?\n    # cause they have different delimiters\n    # I expect\n    #   wave -1\n    # to be transformed into\n    #   wave() -1\n    # but I don\'t want\n    #   box -1\n    # to turn into box() -1\n    delimitersForCommands = ":|;|\\\\,|\\\\?|\\\\)|//|\\\\#|\\\\s+if|\\\\s+else|\\\\s+then"\n    # note how + and - need a space afterwards. This is because\n    # "wave +1" is different from "wave + 1" (and same with -)\n    delimitersForExpressionsWithSpaces = delimitersForCommands + "|" + "\\\\+[\\\\s|;]|-[\\\\s|;]|\\\\*|/|%|&|]|<|>|==|!=|>=|<=|!(?![=])|\\\\s+and\\\\s+|\\\\s+or\\\\s+|\\\\s+not\\\\s+|\\\\|"\n\n    # [todo] you should ideally derive this coming regexp\n    # from the one above\n    delimitersForExpressionsWithoutSpaces = delimitersForCommands + "|" + "\\\\+|-|\\\\*|/|%|&|]|<|>|==|!=|>=|<=|!(?![=])|\\\\s+and\\\\s+|\\\\s+or\\\\s+|\\\\s+not\\\\s+|\\\\|"\n\n    #we don\'t want the dash of the arrow to count as a minus, so\n    #replacing the arrow with one char\n    code = code.replace(/->/g, "→")\n\n    if detailedDebug then console.log "adjustImplicitCalls-4 brackets vars:" + bracketsVariables\n    rx = RegExp("([^\\\\w\\\\d\\\\r\\\\n])("+@allCommandsRegex+bracketsVariables+")[ \\\\t]*("+delimitersForCommands+")",\'g\')\n    for i in [1..2]\n      code = code.replace(rx, "$1$2()$3")\n    if detailedDebug then console.log "adjustImplicitCalls-4\\n" + code + " error: " + error\n\n    rx = RegExp("([^\\\\w\\\\d\\\\r\\\\n])("+expressionsAndUserDefinedFunctionsRegex+")([ \\\\t]*)("+delimitersForExpressionsWithSpaces+")",\'g\')\n    if detailedDebug then console.log rx\n    for i in [1..2]\n      code = code.replace(rx, "$1$2()$3$4")\n    if detailedDebug then console.log "adjustImplicitCalls-5\\n" + code + " error: " + error\n\n    # handles case of tightly-packed keywords such as in\n    # a = wave+wave+wave\n    rx = RegExp("([^\\\\w\\\\d\\\\r\\\\n])("+expressionsAndUserDefinedFunctionsRegex+")("+delimitersForExpressionsWithoutSpaces+")",\'g\')\n    if detailedDebug then console.log rx\n    for i in [1..2]\n      code = code.replace(rx, "$1$2()$3")\n    if detailedDebug then console.log "adjustImplicitCalls-5.5\\n" + code + " error: " + error\n\n\n    #box 0.5,2\n    #box; rotate; box\n    #if random() > 0.5 then box 0.2,3; ball; background red\n    #if ball then ball if true then 0 else 1\n    #ball if true then 0 else 1\n    \n    # tokens at the end of the line (without final semicolon,\n    # if there is a final semicolon it\'s handled by previous case)\n    # doOnce frame = 0; box\n    # if random() > 0.5 then box\n    # 2 times -> box\n    # 2 times -> rotate; box\n    rx = RegExp("([^\\\\w\\\\d\\\\r\\\\n])("+allFunctionsRegex+")[ \\\\t]*$",\'gm\')\n    code = code.replace(rx, "$1$2()")\n\n    code = code.replace(/→/g, "->")\n\n    if detailedDebug then console.log "adjustImplicitCalls-7\\n" + code + " error: " + error\n    return [code, error]\n\n  addCommandsSeparations: (code, error, userDefinedFunctions) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    expressionsAndUserDefinedFunctionsRegex = @expressionsRegex + userDefinedFunctions\n    allFunctionsRegex = @allCommandsRegex + "|" + expressionsAndUserDefinedFunctionsRegex\n    \n    rx = RegExp("("+@allCommandsRegex+")([ \\\\t]*)("+@allCommandsRegex+")([ ]*)($)?",\'gm\')\n    code = code.replace(rx, "$1();$2$3$4$5")\n    if detailedDebug then console.log "addCommandsSeparations 1: " + code\n\n    return [code, error]\n\n  # Qualifiers are special keywords that make\n  # it easy to change qualities of some\n  # primitives without affecting the\n  # primitives that come afterwards.\n  findQualifiers: (code, error, bracketsVariables) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    # this is to avoid transformations to span\n    # the else, since all transformations stop\n    # at semicolon. This is transformed back\n    # at the end of the method.\n    code = code.replace(/([^\\w\\d;])then(?![\\w\\d])/g, "$1;then")\n    code = code.replace(/([^\\w\\d;])else(?![\\w\\d])/g, "$1;else")\n\n    # we don\'t want the qualifiers\n    # to span across ">, <" in this case:\n    #   either <box 2>, <peg 2>\n    # otherwise box would become a qualifier\n    # and cause\n    #   either <box 2>, < ->peg 2>\n    code = code.replace(/\\s*>\\s*,/g, "♠")\n\n    # already transformer stuff like\n    #    rotate (-> box())\n    # can\'t be transformed again, so\n    # making sure that the qualifiers can\'t span\n    # a function definition\n\n    primitivesAndMatrixAndDiamondRegex = @primitivesAndMatrixRegex + bracketsVariables + \'|♦\'\n\n    previousCodeTransformations = \'\'\n    code = code.replace(/->/g, "→")\n    while code != previousCodeTransformations\n      previousCodeTransformations = code\n\n      rx = RegExp("(^|[^\\\\w\\\\d\\\\r\\\\n])("+@primitivesAndMatrixRegex+bracketsVariables+")(?![\\\\w\\\\d\\\\(])([^\\\\r\\\\n;\'♠→]*?)("+primitivesAndMatrixAndDiamondRegex+")([^\\\\w\\\\d\\\\r\\\\n]*)",\'gm\')\n      replacement = \'$1$2ing❤QUALIFIER$3$4$5\'\n      code = code.replace(rx,replacement)\n\n    code = code.replace(/→/g, "->")\n    code = code.replace(/♠/g, ">,")\n\n    if detailedDebug then console.log "findQualifiers 4: " + code\n\n    return [code, error]\n\n  fleshOutQualifiers: (code, error, bracketsVariables, bracketsVariablesArray) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n\n    # we need to consider things like rotateQUALIFIER\n    # as a keyword beause we want\n    #   rotateQUALIFIER rotateQUALIFIER box\n    # to first expand the first rotateQUALIFIER into\n    #   rotate (→ rotateQUALIFIER box)\n    # and not,\n    #   rotate rotateQUALIFIER (→ box)\n    # similar reason for adding rotate\n    primtvsAndQualsRegex = \'\'\n    for i in [0...@qualifyingCommands.length]\n      primtvsAndQualsRegex = primtvsAndQualsRegex + @qualifyingCommands[i] + \'|\' + @qualifyingCommands[i]+"ing❤QUALIFIER|"\n    for i in [0...@primitives.length]\n      primtvsAndQualsRegex = primtvsAndQualsRegex + @primitives[i] + \'|\' + @primitives[i]+"ing❤QUALIFIER|"\n    for i in [0...bracketsVariablesArray.length]\n      primtvsAndQualsRegex = primtvsAndQualsRegex + bracketsVariablesArray[i] + \'|\' + bracketsVariablesArray[i]+"ing❤QUALIFIER|"\n\n\n    primtvsAndQualsRegex = primtvsAndQualsRegex + \'♦\'\n\n    previousCodeTransformations = \'\'\n\n    # the (→ $4$5); is to make sure that\n    #   rotate line;  rotate  box\n    # becomes\n    #   rotate (-> line());  rotate  (-> box())\n    # instead of\n    #   rotate -> line();  rotate -> box()\n    # i.e. there is no chaining across semicolon\n\n    while code != previousCodeTransformations\n      previousCodeTransformations = code\n\n      if detailedDebug then console.log "fleshOutQualifiers 0: @primitivesAndMatrixRegex: " + @primitivesAndMatrixRegex + " bracketsVariables: " + bracketsVariables + " primtvsAndQualsRegex: " + primtvsAndQualsRegex\n\n      rx = RegExp("(^|[^\\\\w\\\\d\\\\r\\\\n])(("+@primitivesAndMatrixRegex+bracketsVariables+")ing❤QUALIFIER)(?![\\\\w\\\\d\\\\(])([^\\\\r\\\\n;→]*?)("+primtvsAndQualsRegex+")([^;\\\\r\\\\n]*)(.*)",\'gm\')\n      replacement = \'$1$3$4→ $5$6;$7\'\n      code = code.replace(rx,replacement)\n      if detailedDebug then console.log "fleshOutQualifiers 1: " + code\n\n      rx = RegExp("(^|[^\\\\w\\\\d\\\\r\\\\n])(("+@primitivesAndMatrixRegex+bracketsVariables+")ing❤QUALIFIER)(?![\\\\w\\\\d\\\\(])([^\\\\r\\\\n;→♦❤]*?)♦",\'g\')\n      replacement = \'$1$3$4 →\'\n      code = code.replace(rx,replacement)\n\n      if detailedDebug then console.log "fleshOutQualifiers 2: " + code\n\n    # the trasformations above creates\n    # stuff like:\n    #    run <→ box> 2;\n    # so fixing that\n    code = code.replace(/<→/g, "→ <")\n\n    # we don\'t need the diamond anymore\n    code = code.replace(/♦[♦\\t ]*/g, "; ")\n\n    code = code.replace(/;+[\\t ]*else/gm, " else")\n    code = code.replace(/^(\\t*) else/gm, "$1else")\n\n    # the trasformations above add lots of redundant\n    # semicolons and spaces like so:\n    #    ...tate (-> rotate (-> box())))))))))); ;  ;   \n    # so fixing that\n    code = code.replace(/\\);([; ]*)/g, "); ")\n\n    # these two are to satisfy idempotency\n    code = code.replace(/->\\s*→/g, "->")\n    code = code.replace(/→\\s*->/g, "->")\n    if detailedDebug then console.log "fleshOutQualifiers 7: " + code\n\n    rx = RegExp("(^|[^\\\\w\\\\d\\\\r\\\\n])("+@primitivesAndMatrixRegex+bracketsVariables+")(?![\\\\w\\\\d\\\\(])(\\\\s*\\\\(?→)",\'gm\')\n    replacement = \'$1$2 ->\'\n    code = code.replace(rx,replacement)\n    if detailedDebug then console.log "fleshOutQualifiers 9: " + code\n    \n    # replace all the → that *do* need to be prepended\n    # with a comma\n    code = code.replace(/([^,])\\s+([\\(]?)→/g, "$1, $2->")\n    if detailedDebug then console.log "fleshOutQualifiers 10: " + code\n\n    # replace all the remaining arrows\n    code = code.replace(/→/g, "->")\n    if detailedDebug then console.log "fleshOutQualifiers 11: " + code\n\n    code = code.replace(/;+[\\t ]*else/g, " else")\n    code = code.replace(/^(\\t*) else/gm, "$1else")\n    code = code.replace(/;*[\\t ]*then/g, " then")\n\n    return [code, error]\n\n  wasFunctionNameAlreadyFound: (str, strArray) ->\n    j = 0\n    while j < strArray.length\n      if strArray[j].match(str) then return true\n      j++\n    false\n\n  # what we are trying to do here is to figure\n  # out which other keywords besides the LCL ones\n  # we need to automatically invoke as functions.\n  # Findind user functions is an ill-posed problem\n  # because the same variable might be a function\n  # in one place and a number in another. And yet\n  # once we find that there is a function definition\n  # with that name *anywhere* in the code, for us\n  # it\'s a function everywhere, so we force the\n  # function call. Note that this can\n  # be mitigated by wrapping the supposed user\n  # functions with a special function that invokes\n  # the supposed user function if it actually is\n  # a function, or otherwise returns\n  # the content of the variable if it is not a function.\n  # That way we would always make the right thing,\n  # although at some sort of performance penalty.\n  #\n  # Also we keep a separate list of names of functions\n  # that need a parameter. This is because expressions\n  # containing these functions consume an argument,\n  # so we need to be aware of that to correctly\n  # consume the argument, as for example\n  # "myFunc a" is an expression even though there\n  # is no operator between the two tokens.\n  # also in automatic parentheses explicitation,\n  # stuff like "myFunc() a" should actually be\n  # "myFunc a".\n\n  findUserDefinedFunctions: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    userDefinedFunctions = []\n    userDefinedFunctionsWithArguments = []\n\n    # form a = -> ...\n    rx = RegExp("([a-zA-Z\\\\d]+)([ \\\\t]*)=[ \\\\t]*->",\'gm\')\n    while match = rx.exec code\n      userDefinedFunctions.push(match[1])\n    if detailedDebug then console.log "findUserDefinedFunctions-1\\n" + code + " error: " + error\n\n    # form a = () -> ...\n    rx = RegExp("([a-zA-Z\\\\d]+)([ \\\\t]*)=[ \\\\t]*\\\\([ \\\\t]*\\\\)[ \\\\t]*->",\'gm\')\n    while match = rx.exec code\n      userDefinedFunctions.push(match[1])\n    if detailedDebug then console.log "findUserDefinedFunctions-2\\n" + code + " error: " + error\n\n    # all other forms. Finds all forms so just check whether\n    # we didn\'t get this function name already\n    rx = RegExp("([a-zA-Z\\\\d]+)([ \\\\t]*)=[ \\\\t]*[\\\\(-]([^>\\\\r\\\\n]*)>",\'gm\')\n    while match = rx.exec code\n      functionName = match[1]\n      if not @wasFunctionNameAlreadyFound functionName, userDefinedFunctions\n        userDefinedFunctions.push(functionName)\n        userDefinedFunctionsWithArguments.push(functionName)\n    if detailedDebug then console.log "findUserDefinedFunctions-3\\n" + code + " error: " + error\n\n    userDefinedFunctions = userDefinedFunctions.join "|"\n    if userDefinedFunctions != ""\n      userDefinedFunctions = "|"+userDefinedFunctions\n\n    userDefinedFunctionsWithArguments = userDefinedFunctionsWithArguments.join "|"\n    if userDefinedFunctionsWithArguments != ""\n      userDefinedFunctionsWithArguments = "|"+userDefinedFunctionsWithArguments\n\n    #console.log "*****" + userDefinedFunctions\n    return [code, error, userDefinedFunctions, userDefinedFunctionsWithArguments]\n\n  findBracketVariables: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    bracketsVariablesArray = []\n\n    # form a = <...\n    rx = RegExp("([a-zA-Z\\\\d]+)([ \\\\t]*)=[ \\\\t]*<",\'gm\')\n    while match = rx.exec code\n      bracketsVariablesArray.push(match[1])\n      #@primitives.push(match[1])\n      if detailedDebug then console.log "findbracketsVariables-1 pushing " + match[1]\n    if detailedDebug then console.log "findbracketsVariables-2\\n" + code + " error: " + error\n\n\n    bracketsVariables = bracketsVariablesArray.join "|"\n    if bracketsVariables != ""\n      bracketsVariables = "|"+bracketsVariables\n\n    if detailedDebug then console.log "bracketsVariables: >" + bracketsVariables + "<"\n\n    rx = RegExp("([a-zA-Z\\\\d]+)([ \\\\t]*)=[ \\\\t]*<",\'gm\')\n    code = code.replace(rx, "BRACKETVAR$1BRACKETVAR = <")\n    if detailedDebug then console.log "findbracketsVariables-3\\n" + code + " error: " + error\n\n    return [code, error, bracketsVariables, bracketsVariablesArray]\n\n  putBackBracketVarOriginalName: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n\n    rx = RegExp("BRACKETVAR([a-zA-Z\\\\d]+)BRACKETVAR",\'gm\')\n    code = code.replace(rx, "$1")\n    if detailedDebug then console.log "putBackBracketVarOriginalName-1\\n" + code + " error: " + error\n\n    return [code, error]\n\n\n  evaluateAllExpressions: (code, error, userDefinedFunctions) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    expressionsAndUserDefinedFunctionsRegex = @expressionsRegex + userDefinedFunctions\n    allFunctionsRegex = @allCommandsRegex + "|" + expressionsAndUserDefinedFunctionsRegex\n\n    rx = RegExp("("+expressionsAndUserDefinedFunctionsRegex+")([ \\\\t]*)times",\'g\')\n    code = code.replace(rx, "$1()$2times")\n    \n    rx = RegExp("([^;>\\\\( \\\\t\\\\r\\\\n])([ ])("+@allCommandsRegex+")([^\\\\w\\\\d\\\\r\\\\n])",\'gm\')\n    code = code.replace(rx, "$1;$2$3$4")\n    if detailedDebug then console.log "evaluateAllExpressions-1\\n" + code + " error: " + error\n\n    # the transformation above can add a semicolon\n    # after an else, fixing that\n    code = code.replace(/else;/g, "else")\n\n    rx = RegExp("([^\\\\w\\\\d\\\\r\\\\n])("+allFunctionsRegex+")([ \\\\t]*);",\'g\')\n    code = code.replace(rx, "$1$2();")\n    if detailedDebug then console.log "evaluateAllExpressions-2\\n" + code + " error: " + error\n    rx = RegExp("([^\\\\w\\\\d\\\\r\\\\n])("+allFunctionsRegex+")([ \\\\t]*)$",\'gm\')\n    code = code.replace(rx, "$1$2();")\n    if detailedDebug then console.log "evaluateAllExpressions-3\\n" + code + " error: " + error\n\n\n    delimitersForCommandsMod = ":|;|\\\\,|\\\\?|//|\\\\#|\\\\selse|\\\\sthen"\n    delimitersForExpressions = delimitersForCommandsMod + "|if|" + "\\\\+|-|\\\\*|/|%|&|]|<|>|=|\\\\|"\n    delimitersForExpressions = delimitersForExpressions + userDefinedFunctions\n    rx = RegExp("("+delimitersForExpressions+")([ \\\\t]*);",\'g\')\n    code = code.replace(rx, "$1$2")\n    if detailedDebug then console.log "evaluateAllExpressions-4\\n" + code + " error: " + error\n\n    #rx = RegExp("([^a-zA-Z0-9;>\\\\(])([ \\\\t]*)("+@allCommandsRegex+")([^a-zA-Z0-9])",\'g\')\n    #code = code.replace(rx, "$1;$2$3$4")\n    #code = code.replace(/[>][ ]*;/g, "> ")\n    #code = code.replace(/[=][ ]*;/g, "= ")\n\n    return @normaliseCode(code, error)\n\n\n  adjustDoubleSlashSyntaxForComments: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    # allows // for comments\n    # the hash is more difficult to write\n    code = code.replace(/\\/\\//g, "#")\n    return [code, error]\n\n\n  # The specs proposed to have the double\n  # chevrons so to make the user\n  # life easier separating the\n  # commands.\n  # I suspect there is no need for them\n  # so this function removes them\n  removeDoubleChevrons: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    code = code.replace(/>>/g, " ")\n    return [code, error]\n\n  ###\n  Errors cases, subdivided by number of colors involved\n\n  --- 0 colors\n  stroke stroke -> redundant stroke\n  fill fill -> redundant fill\n\n  --- 1 color\n  stroke color1 stroke -> redundant stroke\n  fill color1 fill -> redundant fill\n  noColor fill color stroke noColor -> missing color\n\n  ---2 colors\n  noFill/Stroke color color noFill/Stroke -> redundant color\n  fill color color noFill/Stroke -> redundant color\n  noFill/Stroke color color fill -> redundant color\n  noFill/Stroke color fill colour noFill/Stroke\n\n  ----3 colors\n  color stroke/fill color color\n  color color stroke/fill color\n  color color color\n  ###\n\n  rearrangeColorCommands: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    # --- 0 colors error cases\n    if /(^[\\\\t ]*|[^\\w\\d\\r\\n])stroke[\\t ]+stroke([^\\w\\d\\r\\n]|$)/gm.test code\n      return [undefined, "redundant stroke"]\n    if /(^[\\\\t ]*|[^\\w\\d\\r\\n])fill[\\t ]+fill([^\\w\\d\\r\\n]|$)/gm.test code\n      return [undefined, "redundant fill"]\n\n\n    rx = RegExp("(^[\\\\t ]*|;| )([\\\\t ]*)("+@colorsRegex+")(?![\\\\w\\\\d])",\'gm\')\n    code = code.replace(rx, "$1$2♦$3♦")\n    if detailedDebug then console.log "rearrangeColorCommands-1\\n" + code + " error: " + error\n\n    # --- 1 color error cases\n    rx = RegExp("(^[\\\\t ]*|[^\\\\w\\\\d\\\\r\\\\n])stroke[\\\\t ]+♦([^♦]*)♦[\\\\t ]+stroke([^\\\\w\\\\d\\\\r\\\\n]|$)",\'gm\')\n    if rx.test code\n      return [undefined, "redundant stroke"]\n\n    rx = RegExp("(^[\\\\t ]*|[^\\\\w\\\\d\\\\r\\\\n])fill[\\\\t ]+♦([^♦]*)♦[\\\\t ]+fill([^\\\\w\\\\d\\\\r\\\\n]|$)",\'gm\')\n    if rx.test code\n      return [undefined, "redundant fill"]\n\n    # --- 2 color error cases\n    rx = RegExp("(^[\\\\t ]*| )♦([^♦]*)♦[\\\\t ]+("+@colorsCommandsRegex+")[\\\\t ]+♦([^♦]*)♦[\\\\t ]+♦([^♦]*)♦([^\\\\w\\\\d\\\\r\\\\n]|$)",\'gm\')\n    if rx.test code\n      return [undefined, "redundant color"]\n\n    rx = RegExp("(^[\\\\t ]*| )♦([^♦]*)♦[\\\\t ]+♦([^♦]*)♦[\\\\t ]+("+@colorsCommandsRegex+")[\\\\t ]+♦([^♦]*)♦([^\\\\w\\\\d\\\\r\\\\n]|$)",\'gm\')\n    if rx.test code\n      return [undefined, "redundant color"]\n\n    rx = RegExp("(^[\\\\t ]*| )♦([^♦]*)♦[\\\\t ]+♦([^♦]*)♦[\\\\t ]+♦([^♦]*)♦( |$)",\'gm\')\n    if rx.test code\n      return [undefined, "redundant color"]\n\n    rx = RegExp("(^[\\\\t ]*|[^♦\\\\r\\\\n][\\\\t ]+)("+@colorsCommandsRegex+")[\\\\t ]+♦([^♦]*)♦[\\\\t ]+("+@colorsCommandsRegex+")[\\\\t ]+([^♦\\\\r\\\\n]|$)",\'gm\')\n    if rx.test code\n      return [undefined, "missing color"]\n\n    rx = RegExp("(^|;| )([\\\\t ]*)("+@colorsCommandsRegex+")(?![\\\\w\\\\d])",\'gm\')\n    code = code.replace(rx, "$1$2♠$3♠")\n    if detailedDebug then console.log "rearrangeColorCommands-2\\n" + code + " error: " + error\n\n    #rx = RegExp("(^[\\\\t ]*|[^♠\\\\r\\\\n][\\\\t ]+)♦([^♦]*)♦[\\\\t ]+♦([^♦]*)♦[\\\\t ]+([^♦♠\\\\r\\\\n]|$)",\'gm\')\n    #if rx.test code\n    #  if detailedDebug then console.log "missing color command - 1"\n    #  return [undefined, "missing color command"]\n\n    # fill red red box\n    # stroke red red box\n    #rx = RegExp("(^[\\\\t ]*|[^♦\\\\r\\\\n][\\\\t ]+)♠("+@colorsCommandsRegex+")♠[\\\\t ]+♦([^♦]*)♦[\\\\t ]+♦([^♦]*)♦[\\\\t ]+([^♠\\\\r\\\\n]|$)",\'gm\')\n    #if rx.test code\n    #  return [undefined, "redundant color"]\n\n    # stroke green red box\n    # fill red red box which is kind of silly\n    rx = RegExp("(^[\\\\t ]*|[^♦\\\\r\\\\n][\\\\t ]+)♠("+@colorsCommandsRegex+")♠[\\\\t ]+♦([^♦]*)♦[\\\\t ]+♦([^♦]*)♦[\\\\t ]+([^♠\\\\r\\\\n]*|$)",\'gm\')\n    code = code.replace(rx, "$1♠$2♠ ♦$3♦ fill ♦$4♦ $5")\n    if detailedDebug then console.log "rearrangeColorCommands-2.5\\n" + code + " error: " + error\n\n    #rx = RegExp("(^[\\\\t ]*|[^♠\\\\r\\\\n][\\\\t ]+)♦([^♦]*)♦[\\\\t ]+♦([^♦]*)♦[\\\\t ]+♠("+@colorsCommandsRegex+")♠(?![\\\\w\\\\d])",\'gm\')\n    #if rx.test code\n    #  if detailedDebug then console.log "missing color command - 2"\n    #  return [undefined, "missing color command"]\n\n    rx = RegExp("(^[\\\\t ]*|[^♠\\\\r\\\\n][\\\\t ]+)♦([^♦]*)♦[\\\\t ]+♠("+@colorsCommandsRegex+")♠[\\\\t ]+♦([^♦]*)♦[\\\\t ]+([^♠\\\\r\\\\n]|$)",\'gm\')\n    if rx.test code\n      if detailedDebug then console.log "missing color command - 3"\n      return [undefined, "missing color command"]\n\n    # to avoid stuff like\n    # box red red box\n    rx = RegExp("(^[\\\\t ]*|[^♠\\\\r\\\\n][\\\\t ]+)♦([^♦]*)♦[\\\\t ]+♦([^♦]*)♦[\\\\t ]+([^♠\\\\r\\\\n]|$)",\'gm\')\n    if rx.test code\n      if detailedDebug then console.log "redundant color"\n      return [undefined, "redundant color"]\n\n    # 0.5)\n    # color on its own in a line -> fill color\n    rx = RegExp("^([\\\\t ]*)♦([^♦]*)♦([ \\\\t]*)$",\'gm\')\n    code = code.replace(rx, "$1♠fill♠ ♦$2♦ $3")\n    if detailedDebug then console.log "rearrangeColorCommands-3\\n" + code + " error: " + error\n\n    # 0.5)\n    # noFill/noStroke/noColor color noFill/noStroke/noColor -> fill color\n    rx = RegExp("(^[\\\\t ]*|; |([\\\\w\\\\d] *))♦([^♦]*)♦[ \\\\t]+([^♠\\\\r\\\\n])",\'gm\')\n    code = code.replace(rx, "$1♠fill♠ ♦$3♦ $4")\n    if detailedDebug then console.log "rearrangeColorCommands-3\\n" + code + " error: " + error\n\n    \n    # 1)\n    # color1,exp color2 stroke/fill nocolor -> color1,exp stroke/fill color2 nocolor\n    rx = RegExp("([\\\\t ]*)♦([^♦]*)♦[\\\\t ]+([,][\\\\t ]*)(([\\\\d\\\\w\\\\.\\\\(\\\\),]+([\\\\t ]*[\\\\+\\\\-*\\\\/⨁%,][\\\\t ]*))+[\\\\d\\\\w\\\\.\\\\(\\\\)]+|[\\\\d\\\\w\\\\.\\\\(\\\\)]+)*[\\\\t ]+♦([^♦]*)♦[\\\\t ]+♠("+@colorsCommandsRegex+")♠[\\\\t ]+(?!♦)",\'gm\')\n    code = code.replace(rx, "$1♦$2♦$3$4 ♠$7♠ ♦$6♦")\n    if detailedDebug then console.log "rearrangeColorCommands-4\\n" + code + " error: " + error\n\n\n\n\n    # 2)\n    # noFill/noStroke color stroke/fill nocolor -> stroke/fill colour\n    rx = RegExp("(^[\\\\t ]*|[^♠\\\\r\\\\n][\\\\t ]*)♦([^♦]*)♦[\\\\t ]*♠("+@colorsCommandsRegex+")♠([\\\\t ]+(?!♦)|$)",\'gm\')\n    code = code.replace(rx, "$1♠$3♠ ♦$2♦ $4")\n    if detailedDebug then console.log "rearrangeColorCommands-5\\n" + code + " error: " + error\n\n    # 2)\n    # noFill/noStroke color stroke/fill1 stroke/fill2 -> stroke/fill1 colour stroke/fill2\n    rx = RegExp("(^[\\\\t ]*|[^♠\\\\r\\\\n][\\\\t ]*)♦([^♦]*)♦[\\\\t ]*♠("+@colorsCommandsRegex+")♠[\\\\t ]*♠",\'gm\')\n    code = code.replace(rx, "$1♠$3♠ ♦$2♦ ")\n    if detailedDebug then console.log "rearrangeColorCommands-6\\n" + code + " error: " + error\n\n    code = code.replace(/[♠♦]/g, "")\n\n    return [code, error]\n\n  # the last argument of any qualifier, if it\'s\n  # a function call, might capture the following\n  # function chaining, like so:\n  #   a = (val) -> val * 2\n  #   rotate 3, a 1 box 3, 4, a 1\n  # might become, incorrectly:\n  #   a = (val) -> val * 2\n  #   rotate 3, a(1, -> box 3, 4, a 1)\n  #\n  # handles the following examples\n  #   a = (val) -> val * 2\n  #   rotate 3, a 1 box 3, 4, a 1\n  # so it\'s translated in\n  #   a = (val) -> val * 2\n  #   rotate 3, (a 1), -> box 3, 4, a 1 \n  # same for\n  #   rotate 3, wave wave 2 box 3, 4\n  # ...turned into\n  #   rotate 3, wave(wave(2)), -> box 3, 4\n  # and also\n  #   rotate 3, wave pulse / 10 box 3, 4\n  # ...turned into\n  #   rotate 3, wave(pulse() / 10), -> box 3, 4\n  #\n  # HOW DOES IT WORK?\n  # Example: in\n  #   rotate 3, wave pulse / 10, -> box 3, 4\n  # 1) the part between the qualifiers and the function chaining\n  # is isolated:\n  #   3, wave pulse / 10\n  # then a count is made of the expressions and\n  # user functions accepting arguments followed by\n  # a space, which\n  # in this case is 1 (wave)\n  # 2) then 1 closing parens is added before the chaining:\n  #   rotate 3, wave pulse / 10), -> box 3, 4\n  # 3) then an open parens replaces each\n  # expression or user function followed by a space:\n  #   rotate 3, wave(pulse / 10), -> box 3, 4\n  avoidLastArgumentInvocationOverflowing: (code, error, userDefinedFunctionsWithArguments) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    expsAndUserFunctionsWithArgs =  @expressionsRegex + userDefinedFunctionsWithArguments\n    qualifyingFunctionsRegex = @qualifyingCommandsRegex + userDefinedFunctionsWithArguments\n\n    # this transformation is to handle the case\n    #   f = (a,b)-> rotate a run b\n    #   f 2 * sin time, <ball>\n    # where the second line is transformed into\n    #   f 2 * sin(time), ball\n    rx = RegExp(",\\\\s*(\\\\()("+@primitivesRegex+")",\'g\')\n    code = code.replace(rx, ", ->★$2")\n\n    rx = RegExp(", *->",\'g\')\n    code = code.replace(rx, "☆")\n\n    while code != previousCodeTransformations\n      previousCodeTransformations = code\n\n\n      # find the code between the qualifier and the\n      # arrow\n      rx = RegExp("("+qualifyingFunctionsRegex+")([^☆\\\\r\\\\n]*)(☆)",\'\')\n      match = rx.exec code\n      \n      if not match\n        code = code.replace(rx, "$1$2, →")\n        continue\n\n      match2 = match[2]\n\n      # within that snippet of code, search for\n      # qualifiers and user functions followed by a space\n      # so to determine how many parens need to be added\n      rx2 = RegExp("(("+expsAndUserFunctionsWithArgs+") +)",\'g\')\n      match3 = match2.match(rx2)\n      \n      if not match3\n        code = code.replace(rx, "$1$2, →")\n        continue\n\n      numOfExpr = match3.length\n\n      if detailedDebug then console.log "avoidLastArgumentInvocationOverflowing--1 number of matches: " + match3.length\n      if detailedDebug then console.log "avoidLastArgumentInvocationOverflowing--1 finding qualifiers in: " + match2\n      if detailedDebug then console.log "avoidLastArgumentInvocationOverflowing--1 finding using regex: " + rx2\n      if detailedDebug then console.log "avoidLastArgumentInvocationOverflowing--1 number of parens to add: " + numOfExpr\n\n      # add the closing parens\n      code = code.replace(rx, "$1$2"+(Array(numOfExpr+1).join(")"))+"$3")\n\n      # now add all the opening parens.\n      # Note that there might be more than one parens to be\n      # added for example in\n      #   rotate 3, wave wave 2 box 3, 4\n      for i in [0...numOfExpr]\n        rx = RegExp("("+qualifyingFunctionsRegex+")([^☆]*)(("+expsAndUserFunctionsWithArgs+") +)([^☆\\\\r\\\\n]*)(☆)",\'\')\n        if detailedDebug then console.log "avoidLastArgumentInvocationOverflowing-0 regex: " + rx\n        if detailedDebug then console.log "avoidLastArgumentInvocationOverflowing-0 on: " + code\n        \n        code = code.replace(rx, "$1$2$4($5☆")\n\n      rx = RegExp("("+qualifyingFunctionsRegex+")([^☆]*)(("+expsAndUserFunctionsWithArgs+") *)([^☆\\\\r\\\\n]*)(☆)",\'\')\n      if detailedDebug then console.log "avoidLastArgumentInvocationOverflowing-0.5 regex: " + rx\n      if detailedDebug then console.log "avoidLastArgumentInvocationOverflowing-0.5 on: " + code\n      # finally, we change the arrow so that\n      # we don\'t come back to this snippet of code again\n      code = code.replace(rx, "$1$2$4$5, →")\n\n      if detailedDebug then console.log "avoidLastArgumentInvocationOverflowing-1\\n" + code + " error: " + error\n      #alert match2 + " num of expr " + numOfExpr + " code: " + code\n\n    code = code.replace(/☆/g, ", ->")\n    code = code.replace(/→/g, "->")\n    code = code.replace(/, ->★/g, ", (")\n\n    while code != previousCodeTransformations\n      previousCodeTransformations = code\n      code = code.replace(/\\(\\(\\)\\)/g, "()")\n\n    return [code, error]\n\n\n  # see the comment next to ifFunctional definition\n  # to see what we are trying to achieve here.\n  substituteIfsInBracketsWithFunctionalVersion: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    code = code.replace(/(\\w+\\s*=\\s*<\\s*if\\s*.*)>(.*>)/g, "$1›$2")\n    code = code.replace(/(\\w+)\\s*=\\s*<\\s*if\\s*(.*)(>)/g, "$1 = ifFunctional($2>)")\n    code = code.replace(/(\\w+\\s*=\\s*ifFunctional\\s*.*)then(.*>\\))/g, "$1,<$2")\n    code = code.replace(/(\\w+\\s*=\\s*ifFunctional\\s*.*)else(.*>\\))/g, "$1>, <$2")\n    code = code.replace(/›/g, ">")\n\n    if detailedDebug then console.log "substituteIfsInBracketsWithFunctionalVersion-1\\n" + code + " error: " + error\n\n    return [code, error]\n\n  preprocessAndBindFunctionsToThis: (code, bracketsVariables) ->\n\n    [code, error] = @preprocess code, bracketsVariables\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    rx = RegExp("(|[^\\w\\d\\r\\n])("+(@allCommandsRegex)+")(|[^\\w\\d\\r\\n])",\'g\')\n\n    code = code.replace(rx, "$1@$2$3")\n    if detailedDebug then console.log "preprocessAndBindFunctionsToThis\\n" + code + " error: " + error\n\n    return [code, error]\n\n\n  preprocess: (code, bracketsVariables) ->\n    # we\'ll keep any errors in here as we transform the code\n    # as soon as there is any error, all next stages of\n    # transformation do nothing\n    error = undefined\n\n    if detailedDebug then console.log "preprocess-0\\n" + code + " error: " + error\n\n    [code, stringsTable, error] = @removeStrings(code, error)\n    if detailedDebug then console.log "preprocess-1\\n" + code + " error: " + error\n\n    [code, error, userDefinedFunctions, userDefinedFunctionsWithArguments] = @findUserDefinedFunctions(code, error)\n    if detailedDebug then console.log "preprocess-2\\n" + code + " error: " + error\n\n    [code, error, bracketsVariables, bracketsVariablesArray] = @findBracketVariables(code, error)\n    if detailedDebug then console.log "preprocess-3\\n" + code + " error: " + error\n\n    #@qualifyingCommandsRegex = @qualifyingCommands + bracketsVariables\n    #console.log "all commands plus bracket variables BEFORE: " + @primitivesAndMatrixRegex + bracketsVariables\n    #@allCommandsRegex = @allCommandsRegex + bracketsVariables\n    #console.log "all commands plus bracket variables: " + @primitivesAndMatrixRegex + bracketsVariables\n\n    [code, codeWithoutStringsOrComments, error] = @stripCommentsAndStrings(code, error)\n    if detailedDebug then console.log "preprocess-4\\n" + code + " error: " + error\n    [code, error] = @removeTickedDoOnce(code, error)\n    if detailedDebug then console.log "preprocess-5\\n" + code + " error: " + error\n    [code, error] = @checkBasicSyntax(code, codeWithoutStringsOrComments, error)\n    if detailedDebug then console.log "preprocess-6\\n" + code + " error: " + error\n\n    [code, error] = @substituteIfsInBracketsWithFunctionalVersion(code, error)\n    if detailedDebug then console.log "preprocess-6.5\\n" + code + " error: " + error\n\n    [code, error] = @removeDoubleChevrons(code, error)\n    if detailedDebug then console.log "preprocess-7\\n" + code + " error: " + error\n\n    [code, error] = @rearrangeColorCommands(code, error)\n    if detailedDebug then console.log "preprocess-8\\n" + code + " error: " + error\n\n    # allow some common command forms can be used in postfix notation, e.g.\n    #   60 bpm\n    #   red fill\n    #   yellow stroke\n    #   black background\n    #[code, error] = @adjustPostfixNotations(code, error)\n    #if detailedDebug then console.log "preprocess-9\\n" + code + " error: " + error\n\n\n    [code, error] = @normaliseTimesNotationFromInput(code, error)\n    if detailedDebug then console.log "preprocess-10\\n" + code + " error: " + error\n\n    [code, error] = @checkBasicErrorsWithTimes(code, error)\n    if detailedDebug then console.log "preprocess-11\\n" + code + " error: " + error\n    \n\n\n    # Note that coffeescript allows you to split arguments\n    # over multiple lines.\n    # So if you have:\n    #   rotate 0,0,1\n    #   box\n    # and you want to add a scale like so:\n    #   scale 2,2,2\n    #   rotate 0,0,1\n    #   box\n    # What happens is that as you are in the middle of typing:\n    #   scale 2,\n    #   rotate 0,0,1\n    #   box\n    # coffeescript takes the rotate as the second argument of scale\n    # This doesn\'t seem to be a problem, but worth noting.\n\n\n    # Each doOnce block, when run, pushes its own line number to a particular\n    # array. It leaves traces of which doOnce block has been run and\n    # where exactly it is so that we can go back and mark it with a tick\n    # (which prevents a second run to happen, as the tickmarks expand into\n    # line comments).\n    if detailedDebug then console.log "preprocess-12\\n" + code + " error: " + error\n    [code, error] = @addTracingInstructionsToDoOnceBlocks(code, error)\n\n    [ignore,a,ignore] = @identifyBlockStarts code, error\n    [code, error] = @completeImplicitFunctionPasses code, a, error, userDefinedFunctionsWithArguments, bracketsVariables\n    if detailedDebug then console.log "completeImplicitFunctionPasses:\\n" + code + " error: " + error\n\n    [code, error] = @bindFunctionsToArguments(code, error, userDefinedFunctionsWithArguments)\n    if detailedDebug then console.log "preprocess-13\\n" + code + " error: " + error\n    [code, error] = @transformTimesSyntax(code, error)\n    if detailedDebug then console.log "preprocess-14\\n" + code + " error: " + error\n    [code, error] = @transformTimesWithVariableSyntax(code, error)\n    if detailedDebug then console.log "preprocess-15\\n" + code + " error: " + error\n    [code, error] = @unbindFunctionsToArguments(code, error)\n    if detailedDebug then console.log "preprocess-16\\n" + code + " error: " + error\n    [code, error] = @findQualifiers(code, error,bracketsVariables)\n    if detailedDebug then console.log "preprocess-17\\n" + code + " error: " + error\n    [code, error] = @fleshOutQualifiers(code, error,bracketsVariables, bracketsVariablesArray)\n    if detailedDebug then console.log "preprocess-18\\n" + code + " error: " + error\n    [code, error] = @adjustFunctionalReferences(code, error, userDefinedFunctions, bracketsVariables)\n    if detailedDebug then console.log "preprocess-19\\n" + code + " error: " + error\n    [code, error] = @addCommandsSeparations(code, error, userDefinedFunctions)\n    if detailedDebug then console.log "preprocess-20\\n" + code + " error: " + error\n    [code, error] = @adjustImplicitCalls(code, error, userDefinedFunctions, userDefinedFunctionsWithArguments, bracketsVariables)\n    if detailedDebug then console.log "preprocess-21\\n" + code + " error: " + error\n    [code, error] = @adjustDoubleSlashSyntaxForComments(code, error)\n    if detailedDebug then console.log "preprocess-22\\n" + code + " error: " + error\n    [code, error] = @evaluateAllExpressions(code, error, userDefinedFunctions)\n    if detailedDebug then console.log "preprocess-23\\n" + code + " error: " + error\n    [code, error] = @avoidLastArgumentInvocationOverflowing(code, error, userDefinedFunctionsWithArguments)\n    if detailedDebug then console.log "preprocess-24\\n" + code + " error: " + error\n    [code, error] = @fixParamPassingInBracketedFunctions(code, error, userDefinedFunctions)\n    if detailedDebug then console.log "preprocess-25\\n" + code + " error: " + error\n    [code, error] = @putBackBracketVarOriginalName(code, error)\n    if detailedDebug then console.log "preprocess-26\\n" + code + " error: " + error\n    [code, error] = @beautifyCode(code, error)\n    if detailedDebug then console.log "preprocess-27\\n" + code + " error: " + error\n    \n    # unfortunately some beautification depends on the () being there\n    # so we need to put this function here after the beautification step\n    # TODO perhaps the ()-dependant beautifications are not really\n    # beautifications and can be moved outside... BEFORE beautification\n    # so we can have\n    #  - parens-dep stuff beaut\n    #  - simplifyFunctionDoingSimpleInvocation\n    #  - other beautification\n    # it would be better to have beautification as the very last step\n    [code, error] = @simplifyFunctionDoingSimpleInvocation(code, error, userDefinedFunctions)\n    if detailedDebug then console.log "preprocess-29\\n" + code + " error: " + error\n\n    [code, error] = @simplifyFunctionsAloneInParens(code, error, userDefinedFunctions, bracketsVariables)\n    if detailedDebug then console.log "preprocess-29.5\\n" + code + " error: " + error\n\n    [code, error] = @injectStrings(code, stringsTable, error)\n    if detailedDebug then console.log "preprocess-29\\n" + code + " error: " + error\n\n\n    return [code, error, userDefinedFunctions]\n\n\n  # to run the tests, just open the dev console\n  # and type:\n  #    testPreprocessor()\n  # or\n  #    testPreprocessor(rangeMin, rangeMax)\n  test: (rangeMin = undefined, rangeMax = undefined) ->\n      console.log "launching all tests"\n      failedTests = successfulTest = knownIssues = failedIdempotency = failedMootAppends = failedMootPrepends = 0\n      unless rangeMin?\n        rangeMin = 0\n        rangeMax = @testCases.length\n      console.log "launching tests: " + [rangeMin...rangeMax]\n      for testCaseNumber in [rangeMin...rangeMax]\n        testCase = @testCases[testCaseNumber]\n\n        # just like in demos and tutorials, we use an\n        # arrow to represent tabs so it\'s more\n        # readable when looking at the examples.\n        # We replace it with tabs here.\n        testCase.input = testCase.input.replace(/\\u25B6/g, "\\t")\n        if testCase.expected?\n          testCase.expected = testCase.expected.replace(/\\u25B6/g, "\\t")\n\n        [transformed, error, userDefinedFunctions] = @preprocess(testCase.input)\n        # only check idempotency if there was no error\n        # in the first step and if the test case\n        # has no "notIdempotent" flag\n        testIdempotency = !error? and !(testCase.notIdempotent?)\n        testMoots = !error? and !(testCase.failsMootAppends?)\n        #testIdempotency = false\n        if testIdempotency\n          [transformedTwice, error, ] = @preprocess(transformed.replace(/;/g,""))\n\n        expressionsAndUserDefinedFunctionsRegex = @expressionsRegex + userDefinedFunctions\n        allFunctionsRegex = @allCommandsRegex + "|" + expressionsAndUserDefinedFunctionsRegex\n        \n        if testMoots\n          appendString = \'s\'\n          prependString = \'t\'\n\n          [mootInput, ignore, errorMoot] = @stripCommentsAndStrings(testCase.input,null)\n          [mootInput, ignore, errorMoot] = @beautifyCode(mootInput,errorMoot)\n\n          if !errorMoot?\n            rx = RegExp("(("+allFunctionsRegex+"|times|doOnce)([^\\\\w\\\\d]|$))",\'gm\');\n            mootInputAppend = mootInput.replace(rx, "$2"+appendString+"$3")\n            mootInputPrepend = mootInput.replace(rx, prependString+"$2$3")\n\n            mootInputAppend = @normaliseCode(mootInputAppend,null)[0]\n            [transformedMootAppend, errorMootAppend,] = @preprocess(mootInputAppend)\n            mootInputPrepend = @normaliseCode(mootInputPrepend,null)[0]\n            [transformedMootPrepend, errorMootPrepend,] = @preprocess(mootInputPrepend)            \n\n          if !errorMootAppend?\n            if userDefinedFunctions != ""\n              rx = RegExp("("+userDefinedFunctions+")"+appendString+"\\\\(\\\\)",\'gm\');\n              transformedMootAppend = transformedMootAppend.replace(rx, "$1"+appendString)\n            transformedMootAppend = @stripCommentsAndStrings(transformedMootAppend,null)[0]\n            if mootInputAppend != transformedMootAppend\n              failedMootAppends++\n              console.log "unexpected transformation"\n              console.log "moot input:\\n" + mootInputAppend\n              console.log "transformed into:\\n" + transformedMootAppend          \n\n          if !errorMootPrepend? and testMoots\n            if userDefinedFunctions != ""\n              rx = RegExp(prependString+"("+userDefinedFunctions+")\\\\(\\\\)",\'gm\');\n              transformedMootPrepend = transformedMootPrepend.replace(rx, prependString+"$1")            \n            transformedMootPrepend = @stripCommentsAndStrings(transformedMootPrepend,null)[0]\n            if mootInputPrepend != transformedMootPrepend\n              failedMootPrepends++\n              console.log "unexpected transformation"\n              console.log "moot input:\\n" + mootInputPrepend\n              console.log "transformed into:\\n" + transformedMootPrepend          \n\n\n        if transformed == testCase.expected and\n            error == testCase.error and\n            (transformed == transformedTwice or !testIdempotency)\n          console.log "testCase #{testCaseNumber}: pass"\n          successfulTest++\n        else\n          if testCase.knownIssue\n            console.log "!!!!!!!!!! testCase #{testCaseNumber} known fail"\n            knownIssues++\n          else\n            console.log "!!!!!!!!!! testCase #{testCaseNumber} fail:"\n            if testIdempotency and transformed != transformedTwice\n              if transformed == testCase.expected\n                failedIdempotency++\n                console.log "\\nNot idempotent but 1st result OK\\n"\n              else\n                console.log "\\nNot idempotent and 1st result not OK\\n"\n              console.log "\\n 2nd run result: \\n"\n              console.log transformedTwice\n            console.log \'\\ninput: \\n\' + testCase.input \\\n              + \'\\nobtained: \\n\' + transformed \\\n              + \'\\nwith error:\\n\' + error \\\n              + \'\\ninstead of:\\n\' + testCase.expected \\\n              + \'\\nwith error:\\n\' + testCase.error\n            failedTests++\n      console.log "######### summary #######"\n      console.log "      passed: #{successfulTest}"\n      console.log "      failed: #{failedTests}"\n      console.log "      failed moot appends: #{failedMootAppends}"\n      console.log "      failed moot prepends: #{failedMootPrepends}"\n      console.log "      out of which only idempotency fails: #{failedIdempotency}"\n      console.log "known issues: #{knownIssues}"\n      return\n\n  # finds each possible block start\n  identifyBlockStarts: (code, error) ->\n    # if there is an error, just propagate it\n    return [undefined, undefined, error] if error?\n\n    sourceByLine = code.split("\\n")\n    startOfPreviousLine = ""\n    linesWithBlockStart = []\n    \n    for eachLine in [0...sourceByLine.length]\n      line = sourceByLine[eachLine]\n      #console.log "checking " + line\n      rx = RegExp("^(\\\\s*)",\'gm\')\n      match = rx.exec line\n      continue if not match?\n      startOfThisLine = match[1]\n      #console.log "start of line: >" + startOfThisLine + "<"\n      if startOfThisLine.length > startOfPreviousLine.length\n        linesWithBlockStart.push eachLine-1\n        blockStart = eachLine-1\n        #blockEnd = @identifyBlockEnd(sourceByLine, eachLine)\n        #console.log \'block \' + blockStart + \' to \' + blockEnd\n      startOfPreviousLine = startOfThisLine\n\n    #console.log "code lenght at identifyBlockStarts: " + code.split("\\n").length\n    return [code, linesWithBlockStart, undefined]\n\n  # we might not need this function, leaving it here,\n  # mute for the moment.\n  # finds where the block starting at line "startLine" ends\n  identifyBlockEnd: (sourceByLine, startLine) ->\n    # if there is an error, just propagate it\n    return [undefined, undefined, error] if error?\n\n    rx = RegExp("^(\\\\s*)",\'gm\')\n    match = rx.exec sourceByLine[startLine]\n    #console.log "start of line: >" + startOfThisLine + "<"\n    lengthToBeat = (match[1]).length\n\n    linesWithBlockStart = []\n    \n    for eachLine in [startLine...sourceByLine.length]\n      line = sourceByLine[eachLine]\n      rx = RegExp("^(\\\\s*)",\'gm\')\n      match = rx.exec line\n      continue if not match?\n      startOfThisLine = match[1]\n      if startOfThisLine.length < lengthToBeat\n        return eachLine - 1\n\n    bottomOfProgram = sourceByLine.length-1\n    return bottomOfProgram\n\n  completeImplicitFunctionPasses: (code, linesWithBlockStart, error, userDefinedFunctionsWithArguments, bracketsVariables) ->\n    # if there is an error, just propagate it\n    return [undefined, error] if error?\n\n    qualifyingFunctions = @primitivesAndMatrixRegex + userDefinedFunctionsWithArguments + bracketsVariables\n\n    sourceByLine = code.split("\\n")\n    transformedLines = []\n    \n    countingLines = -1;\n    for line in sourceByLine\n      countingLines++\n      if countingLines in linesWithBlockStart\n        #console.log "checking " + line\n        \n        # if the line already ends with an arrow\n        # then there is nothing to do\n        rx = RegExp("->\\\\s*$",\'gm\')\n        match = rx.exec line\n        if match?\n          transformedLines.push line\n          continue\n\n        # if the line already ends with "times"\n        # then stay away from this transformation\n        rx = RegExp("[^\\\\w\\\\d\\\\r\\\\n]times\\\\s*$",\'gm\')\n        match = rx.exec line\n        if match?\n          transformedLines.push line\n          continue\n\n        # case where the function-block is passed as first argument\n        # so no comma is needed\n        rx = RegExp("(^|;| )\\\\s*("+qualifyingFunctions+")\\\\s*$",\'gm\')\n        match = rx.exec line\n        if match?\n          transformedLines.push line+" ->"\n          continue\n\n        # case where the function-block is passed as argument beyond\n        # the first, so a comma is needed\n        rx = RegExp("(^|;| )\\\\s*("+qualifyingFunctions+")(?![\\\\w\\\\d])([^;\\r\\n]*)$",\'gm\')\n        match = rx.exec line\n        if match?\n          transformedLines.push line+", ->"\n          continue\n\n        # if we are here is means that there was no match\n        # meaning that there is nothing to add.\n        transformedLines.push line\n\n      else\n        transformedLines.push line\n\n    transformedCode = transformedLines.join "\\n"\n\n    #console.log "code lenght at completeImplicitFunctionPasses: " + transformedCode.split("\\n").length\n    return [transformedCode, undefined]\n\n';
