// Generated by CoffeeScript 1.10.0
window.ColorPaletteMorph_coffeSource = '# ColorPaletteMorph ///////////////////////////////////////////////////\n# REQUIRES ControllerMixin\n# REQUIRES BackBufferMixin\n\nclass ColorPaletteMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith ControllerMixin\n  @augmentWith BackBufferMixin\n\n  target: null\n  targetSetter: "color"\n  choice: null\n\n  constructor: (@target = null, sizePoint) ->\n    super()\n    @silentRawSetExtent sizePoint or new Point 80, 50\n  \n  # no changes of position or extent should be\n  # performed in here\n  createRefreshOrGetBackBuffer: ->\n    cacheKey =\n      @extent().toString()\n\n    cacheHit = world.cacheForImmutableBackBuffers.get cacheKey\n    if cacheHit? then return cacheHit\n\n    extent = @extent()\n    backBuffer = newCanvas extent.scaleBy pixelRatio\n    backBufferContext = backBuffer.getContext "2d"\n    backBufferContext.scale pixelRatio, pixelRatio\n    @choice = new Color()\n    for x in [0..extent.x]\n      h = 360 * x / extent.x\n      y = 0\n      for y in [0..extent.y]\n        l = 100 - (y / extent.y * 100)\n        # see link below for alternatives on how to set a single\n        # pixel color.\n        # You should really be using putImageData of the whole buffer\n        # here anyways. But this is clearer.\n        # http://stackoverflow.com/questions/4899799/whats-the-best-way-to-set-a-single-pixel-in-an-html5-canvas\n        backBufferContext.fillStyle = "hsl(" + h + ",100%," + l + "%)"\n        backBufferContext.fillRect x, y, 1, 1\n\n    cacheEntry = [backBuffer, backBufferContext]\n    world.cacheForImmutableBackBuffers.set cacheKey, cacheEntry\n    return cacheEntry\n\n  # you can\'t grab the colorPaletteMorph because\n  # the drag operation currently picks a color.\n  # You could change that, you could pick color\n  # only by normal click for example.\n  # Or you could have either behaviour based on\n  # preference.\n  # Or you could perhaps allow it to be grabbed\n  # if it\'s disabled, say. (but we don\'t have this\n  # "disabled" concept implemented now).\n  rootForGrab: ->\n    return null\n  \n  mouseMove: (pos, mouseButton) ->\n    # effectively takes care of drag as well\n\n    if mouseButton == "left"\n      @choice = @getPixelColor pos\n      @updateTarget()\n  \n  mouseDownLeft: (pos) ->\n    @choice = @getPixelColor pos\n    @updateTarget()\n    super\n  \n  updateTarget: ->\n    if @target instanceof Morph and @choice?\n      setterMethodString = "set" + @targetSetter.camelize()\n      if @target[setterMethodString] instanceof Function\n        @target[setterMethodString] @choice\n      else\n        alert "this shouldn\'t happen"\n  \n    \n  # ColorPaletteMorph menu:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    menu.addItem "set target", true, @, "setTarget", "choose another morph\\nwhose color property\\n will be" + " controlled by this one"\n    menu\n  \n  # setTarget: -> taken form the ControllerMixin\n\n  swapTargetsTHISNAMEISRANDOM: (ignored, ignored2, theTarget, each) ->\n    @target = theTarget\n    @targetSetter = each\n\n  setTargetSetter: (ignored, ignored2, theTarget) ->\n    choices = theTarget.colorSetters()\n    menu = new MenuMorph false, @, true, true, "choose target property:"\n    choices.forEach (each) =>\n      menu.addItem each, true, @, "swapTargetsTHISNAMEISRANDOM", null, null, null, null, null, theTarget, each\n\n    if choices.length == 0\n      menu = new MenuMorph false, @, true, true, "no target properties available"\n    menu.popUpAtHand @firstContainerMenu()\n';
