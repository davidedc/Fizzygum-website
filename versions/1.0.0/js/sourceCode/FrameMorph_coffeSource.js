// Generated by CoffeeScript 1.10.0
window.FrameMorph_coffeSource = '#| FrameMorph //////////////////////////////////////////////////////////\n#| \n#| I clip my submorphs at my bounds. Which potentially saves a lot of redrawing\n#| \n#| and event handling. \n#| \n#| It\'s a good idea to use me whenever it\'s clear that there is a  \n#| \n#| "container"/"contained" scenario going on.\n\nclass FrameMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  scrollFrame: null\n  extraPadding: 0\n  _acceptsDrops: true\n\n  # if this frame belongs to a scrollFrame, then\n  # the @scrollFrame points to it\n  constructor: (@scrollFrame = null) ->\n    super()\n    @appearance = new RectangularAppearance @\n    @color = new Color 255, 250, 245\n    if @scrollFrame\n      @noticesTransparentClick = false\n\n  setColor: (aColorOrAMorphGivingAColor, morphGivingColor) ->\n    aColor = super(aColorOrAMorphGivingAColor, morphGivingColor)\n    # keep in synch the value of the container scrollFrame\n    # if there is one. Note that the container scrollFrame\n    # is actually not painted.\n    if @scrollFrame\n      unless @scrollFrame.color.eq aColor\n        @scrollFrame.color = aColor\n    return aColor\n\n\n  setAlphaScaled: (alphaOrMorphGivingAlpha, morphGivingAlpha) ->\n    alpha = super(alphaOrMorphGivingAlpha, morphGivingAlpha)\n    if @scrollFrame\n      unless @scrollFrame.alpha == alpha\n        @scrollFrame.alpha = alpha\n    return alpha\n\n\n  # used for example:\n  # - to determine which morphs you can attach a morph to\n  # - for a SliderMorph\'s "set target" so you can change properties of another Morph\n  # - by the HandleMorph when you attach it to some other morph\n  # Note that this method has a slightly different\n  # version in Morph (because it doesn\'t clip)\n  plausibleTargetAndDestinationMorphs: (theMorph) ->\n    # find if I intersect theMorph,\n    # then check my children recursively\n    # exclude me if I\'m a child of theMorph\n    # (cause it\'s usually odd to attach a Morph\n    # to one of its submorphs or for it to\n    # control the properties of one of its submorphs)\n    result = []\n    if @visibleBasedOnIsVisibleProperty() and\n        !@isCollapsed() and\n        !theMorph.isAncestorOf(@) and\n        @areBoundsIntersecting(theMorph) and\n        !@anyParentMarkedForDestruction()\n      result = [@]\n\n    # Since the FrameMorph clips its children\n    # at its boundary, hence we need\n    # to check that we don\'t consider overlaps with\n    # morphs contained in this frame that are clipped and\n    # hence *actually* not overlapping with theMorph.\n    # So continue checking the children only if the\n    # frame itself actually overlaps.\n    if @areBoundsIntersecting theMorph\n      @children.forEach (child) ->\n        result = result.concat child.plausibleTargetAndDestinationMorphs theMorph\n\n    return result\n\n  # do nothing if the call comes from a child\n  # otherwise, if it comes from me (say, because the\n  # frame has been moved), then\n  # do invalidate the cache as normal.\n  invalidateFullBoundsCache: (morphCalling) ->\n    if morphCalling == @\n      super @\n\n  invalidateFullClippedBoundsCache: (morphCalling) ->\n    if morphCalling == @\n      super @\n  \n  # here is the magic of a Frame: the recursion\n  # stops and we can ignore the bounds of potentially\n  # hundreds of morphs that might be in here.\n  SLOWfullBounds: ->\n    shadow = @getShadowMorph()\n    if shadow?\n      result = @bounds.merge shadow.bounds\n    else\n      result = @bounds\n    result\n\n  SLOWfullClippedBounds: ->\n    shadow = @getShadowMorph()\n    if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()\n      result = Rectangle.EMPTY\n    else if shadow?\n      result = @clippedThroughBounds().merge shadow.bounds\n    else\n      result = @clippedThroughBounds()\n    #if this != world and result.corner.x > 400 and result.corner.y > 100 and result.origin.x ==0 and result.origin.y ==0\n    #  debugger\n    result\n\n  # frames clip any of their children\n  # at their boundaries\n  # so there is no need to do a deep\n  # traversal to find the bounds.\n  fullBounds: ->\n    if @cachedFullBounds?\n      if world.doubleCheckCachedMethodsResults\n        if !@cachedFullBounds.eq @SLOWfullBounds()\n          debugger\n          alert "fullBounds is broken (cached)"\n      return @cachedFullBounds\n\n    shadow = @getShadowMorph()\n    if shadow?\n      result = @bounds.merge shadow.bounds\n    else\n      result = @bounds\n\n    if world.doubleCheckCachedMethodsResults\n      if !result.eq @SLOWfullBounds()\n        debugger\n        alert "fullBounds is broken (uncached)"\n\n    @cachedFullBounds = result\n\n  fullClippedBounds: ->\n    if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()\n      result = Rectangle.EMPTY\n    else\n      if @cachedFullClippedBounds?\n        if @checkFullClippedBoundsCache == WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n          if world.doubleCheckCachedMethodsResults\n            if !@cachedFullClippedBounds.eq @SLOWfullClippedBounds()\n              debugger\n              alert "fullClippedBounds is broken"\n          return @cachedFullClippedBounds\n\n      shadow = @getShadowMorph()\n      if shadow?\n        result = @clippedThroughBounds().merge shadow.bounds\n      else\n        result = @clippedThroughBounds()\n\n    if world.doubleCheckCachedMethodsResults\n      if !result.eq @SLOWfullClippedBounds()\n        debugger\n        alert "fullClippedBounds is broken"\n\n    @checkFullClippedBoundsCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    @cachedFullClippedBounds = result\n  \n  fullBoundsNoShadow: ->\n    # answer my full bounds but ignore any shadow\n    @bounds\n\n  \n  fullPaintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle = @clippedThroughBounds(), noShadow = false) ->\n\n    if @preliminaryCheckNothingToDraw noShadow, clippingRectangle, aContext\n      return\n\n    # a FrameMorph has the special property that all of its children\n    # are actually inside its boundary.\n    # This allows\n    # us to avoid the further traversal of potentially\n    # many many morphs if we see that the rectangle we\n    # want to paint is outside its frame.\n    # If the rectangle we want to paint is inside the frame\n    # then we do have to continue traversing all the\n    # children of the Frame.\n\n    # This is why as well it\'s good to use FrameMorphs whenever\n    # it\'s clear that there is a "container" case. Think\n    # for example that you could stick a small\n    # RectangleMorph (not a Frame) on the desktop and then\n    # attach a thousand\n    # CircleBoxMorphs on it.\n    # Say that the circles are all inside the rectangle,\n    # apart from four that are at the corners of the world.\n    # that\'s a nightmare scenegraph\n    # to *completely* traverse for *any* broken rectangle\n    # anywhere on the screen.\n    # The traversal is complete because a) Morphic doesn\'t\n    # assume that the rectangle clips its children and\n    # b) the bounding rectangle (which currently is not\n    # efficiently calculated anyways) is the whole screen.\n    # So the children could be anywhere and need to be all\n    # checked for damaged areas to repaint.\n    # If the RectangleMorph is made into a frame, one can\n    # avoid the traversal for any broken rectangle not\n    # overlapping it.\n\n    # Also note that in theory you could stop recursion on any\n    # FrameMorph completely covered by a large opaque morph\n    # (or on any Morph which fullBounds are completely\n    # covered, for that matter). You could\n    # keep for example a list of the top n biggest opaque morphs\n    # (say, frames and rectangles)\n    # and check that case while you traverse the list.\n    # (see https://github.com/davidedc/Fizzygum/issues/149 )\n    \n    # the part to be redrawn could be outside the frame entirely,\n    # in which case we can stop going down the morphs inside the frame\n    # since the whole point of the frame is to clip everything to a specific\n    # rectangle.\n    # So, check which part of the Frame should be redrawn:\n    dirtyPartOfFrame = @boundingBox().intersect clippingRectangle\n    \n    # if there is no dirty part in the frame then do nothing\n    return null if dirtyPartOfFrame.isEmpty()\n    \n    if aContext == world.worldCanvasContext\n      @recordDrawnAreaForNextBrokenRects()\n\n    # this draws the background of the frame itself, which could\n    # contain an image or a pentrail    \n    @paintIntoAreaOrBlitFromBackBuffer aContext, dirtyPartOfFrame\n    \n    # this mess for the shadow is because technically\n    # the shadow would be outside the clipping area\n    # of the Freame so it wouldn\'t be drawn.\n    # So just for the shadow we do regress to the clippingRectangle\n    # which doesn\'t clip the bounds of this Frame\n    @children.forEach (child) =>\n      if (child instanceof ShadowMorph) and (!noShadow)\n        child.fullPaintIntoAreaOrBlitFromBackBuffer aContext, clippingRectangle, noShadow\n      else\n        child.fullPaintIntoAreaOrBlitFromBackBuffer aContext, dirtyPartOfFrame, noShadow\n\n\n  # FrameMorph scrolling optimization:\n  fullRawMoveBy: (delta) ->\n    #console.log "moving all morphs in the frame"\n    @bounds = @bounds.translateBy delta\n    #console.log "move 1"\n    @breakNumberOfRawMovesAndResizesCaches()\n    @children.forEach (child) ->\n      child.silentFullRawMoveBy delta\n    @changed()\n\n  reactToDropOf: ->\n    if @parent?\n      if @parent.adjustContentsBounds?\n        @parent.adjustContentsBounds()\n        @parent.adjustScrollBars()\n\n  isFloatDraggable: ->\n    if @parent?\n\n      # otherwise you could detach a Frame contained in a\n      # ScrollFrameMorph which is very strange\n      if @parent instanceof ScrollFrameMorph\n        return false\n\n      if (@parent instanceof WorldMorph) or (@parent instanceof FrameMorph)\n        return true\n    return false\n  \n  reactToGrabOf: ->\n    if @parent?\n      if @parent.adjustContentsBounds?\n        @parent.adjustContentsBounds()\n        @parent.adjustScrollBars()\n\n  # FrameMorph menus:\n  developersMenu: ->\n    menu = super()\n    if @children.length\n      menu.addLine()\n      menu.addItem "move all inside", true, @, "keepAllSubmorphsWithin", "keep all submorphs\\nwithin and visible"\n    menu\n  \n  keepAllSubmorphsWithin: ->\n    @children.forEach (m) =>\n      m.fullRawMoveWithin @\n';
