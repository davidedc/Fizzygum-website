// Generated by CoffeeScript 1.10.0
window.FridgeMagnetsCanvasMorph_coffeSource = '# FridgeMagnetsCanvasMorph //////////////////////////////////////////////////////////\n# REQUIRES BackBufferMixin\n# \n# \n# "container"/"contained" scenario going on.\n\nclass FridgeMagnetsCanvasMorph extends CanvasMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  primitiveTypes: {}\n\n  createRefreshOrGetBackBuffer: ->\n    [@backBuffer, @backBufferContext] = super\n    @paintNewFrame()\n    return [@backBuffer, @backBufferContext]\n\n  graphicsCode: ->\n\n  constructor: ->\n    super\n\n    @fps = 0\n    world.addSteppingMorph @\n\n    numberOfPrimitives = 0\n    @primitiveTypes.ambientLight = numberOfPrimitives++\n    @primitiveTypes.line = numberOfPrimitives++\n    @primitiveTypes.rect = numberOfPrimitives++\n    @primitiveTypes.box = numberOfPrimitives++\n    @primitiveTypes.peg = numberOfPrimitives++\n    @primitiveTypes.ball = numberOfPrimitives++\n\n  step: ->\n    #console.log "stepping FridgeMagnetsCanvasMorph"\n    @paintNewFrame()\n\n  paintNewFrame: ->\n    @clear()\n    context = @backBufferContext\n    context.setTransform 1, 0, 0, 1, 0, 0\n    context.scale pixelRatio, pixelRatio\n    context.translate @width()/2, @height()/2\n\n    @graphicsCode()\n\n  pulse: (frequency) ->\n\n    d = new Date()\n    n = d.getMilliseconds()\n\n    if typeof frequency != "number"\n      frequency = 1\n    return Math.exp(\n      -Math.pow(\n        Math.pow(((n/1000) * frequency) % 1, 0.3) - 0.5, 2\n      ) / 0.05\n    )\n\n  scale: (a, b = 1, c = 1, d = null) ->\n    arg_a = a\n    arg_b = b\n    arg_c = c\n    arg_d = d\n\n    appendedFunctionsStartIndex = undefined\n\n    if typeof arg_a isnt "number"\n      if isFunction arg_a then appendedFunctionsStartIndex = 0\n      arg_a = 0.5 + @pulse()\n      arg_b = arg_a\n      arg_c = arg_a\n    else if typeof arg_b isnt "number"\n      if isFunction arg_b then appendedFunctionsStartIndex = 1\n      arg_b = arg_a\n      arg_c = arg_a\n    else if typeof arg_c isnt "number"\n      if isFunction arg_c then appendedFunctionsStartIndex = 2\n      arg_c = 1\n    else if isFunction arg_d\n      appendedFunctionsStartIndex = 3\n\n\n\n    context = @backBufferContext\n    if appendedFunctionsStartIndex?\n      context.save()\n\n\n    # odd things happen setting scale to zero\n    arg_a = 0.000000001  if arg_a > -0.000000001 and arg_a < 0.000000001\n    arg_b = 0.000000001  if arg_b > -0.000000001 and arg_b < 0.000000001\n    arg_c = 0.000000001  if arg_c > -0.000000001 and arg_c < 0.000000001\n\n    context.scale arg_a, arg_b\n\n    if appendedFunctionsStartIndex?\n      while isFunction arguments[appendedFunctionsStartIndex]\n        result = arguments[appendedFunctionsStartIndex].apply @\n        # we find out that the function is actually\n        # a fake so we have to undo the push and leave\n        if result == null\n          context.restore()\n          return\n        appendedFunctionsStartIndex++\n      context.restore()\n\n  rotate: (a, b, c = 0, d = null) ->\n    arg_a = a\n    arg_b = b\n    arg_c = c\n    arg_d = d\n\n    appendedFunctionsStartIndex = undefined\n\n    if typeof arg_a isnt "number"\n      if isFunction arg_a then appendedFunctionsStartIndex = 0\n      arg_a = @pulse() * Math.PI\n      arg_b = arg_a\n      arg_c = 0\n    else if typeof arg_b isnt "number"\n      if isFunction arg_b then appendedFunctionsStartIndex = 1\n      arg_b = arg_a\n      arg_c = arg_a\n    else if typeof arg_c isnt "number"\n      if isFunction arg_c then appendedFunctionsStartIndex = 2\n      arg_c = 0\n    else if isFunction arg_d\n      appendedFunctionsStartIndex = 3\n\n    context = @backBufferContext\n    if appendedFunctionsStartIndex?\n      context.save()\n\n    context.rotate arg_a\n\n    if appendedFunctionsStartIndex?\n      while isFunction arguments[appendedFunctionsStartIndex]\n        result = arguments[appendedFunctionsStartIndex].apply @\n        # we find out that the function is actually\n        # a fake so we have to undo the push and leave\n        if result == null\n          context.restore()\n          return\n        appendedFunctionsStartIndex++\n      context.restore()\n\n  move: (a, b, c = 0, d = null) ->\n    arg_a = a\n    arg_b = b\n    arg_c = c\n    arg_d = d\n\n    appendedFunctionsStartIndex = undefined\n\n    if typeof arg_a isnt "number"\n      if isFunction arg_a then appendedFunctionsStartIndex = 0\n\n      d = new Date()\n      n = d.getTime()\n\n      arg_a = Math.sin(n/150) * 15\n      arg_b = Math.cos(n/150) * 15\n      arg_c = arg_a\n    else if typeof arg_b isnt "number"\n      if isFunction arg_b then appendedFunctionsStartIndex = 1\n      arg_b = arg_a\n      arg_c = arg_a\n    else if typeof arg_c isnt "number"\n      if isFunction arg_c then appendedFunctionsStartIndex = 2\n      arg_c = 0\n    else if isFunction arg_d\n      appendedFunctionsStartIndex = 3\n\n    context = @backBufferContext\n    if appendedFunctionsStartIndex?\n      context.save()\n\n    context.translate arg_a, arg_b\n\n    if appendedFunctionsStartIndex?\n      while isFunction arguments[appendedFunctionsStartIndex]\n        result = arguments[appendedFunctionsStartIndex].apply @\n        # we find out that the function is actually\n        # a fake so we have to undo the push and leave\n        if result == null\n          context.restore()\n          return\n        appendedFunctionsStartIndex++\n      context.restore()\n\n  box: (a, b, c, d = null) ->\n    # primitive-specific initialisations:\n    primitiveProperties =\n      canFill: true\n      primitiveType: @primitiveTypes.box\n      #sidedness: @threeJs.FrontSide\n      #threeObjectConstructor: @threeJs.Mesh\n      detailLevel: 0\n\n    # end of primitive-specific initialisations:\n    @commonPrimitiveDrawingLogic a, b, c, d, primitiveProperties\n  \n  commonPrimitiveDrawingLogic: (a, b, c, d, primitiveProperties) ->\n\n    ###\n    if @liveCodeLabCoreInstance.animationLoop.noDrawFrame\n      #console.log "skipping the frame"\n      return\n    ###\n\n    # b and c are not functional in some geometric\n    # primitives, but we handle them here in all cases\n    # to make the code uniform and unifiable\n    if typeof a isnt "number"\n      if isFunction a then appendedFunction = a\n      a = 1\n      b = 1\n      c = 1\n    else if typeof b isnt "number"\n      if isFunction b then appendedFunction = b\n      b = a\n      c = a\n    else if typeof c isnt "number"\n      if isFunction c then appendedFunction = c\n      c = 1\n    else if isFunction d\n      appendedFunction = d\n\n    ###\n    context.beginPath();\n    context.lineWidth="6";\n    context.strokeStyle="red";\n    context.rect(5,5,290,140); \n    context.stroke();\n    ###\n\n    @backBufferContext.strokeStyle = "black"\n    @backBufferContext.beginPath()\n    @backBufferContext.rect -50,-50,100,100\n    @backBufferContext.stroke()\n\n    @changed()\n\n    if appendedFunction? then appendedFunction.apply @\n    return\n\n';
