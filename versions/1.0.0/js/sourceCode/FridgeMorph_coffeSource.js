// Generated by CoffeeScript 1.10.0
window.FridgeMorph_coffeSource = '#| FridgeMorph //////////////////////////////////////////////////////////\n\nclass FridgeMorph extends FrameMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  tabs: []\n  sourceCodeHolder: null\n  codeCompiler: new CodeCompiler()\n\n  topMostMagnet: ->\n    filtered = @children.filter (m) ->\n      m.putIntoWords? and !m.putIntoWords\n    calculated = filtered.map (m) ->\n      m.top()\n    calcIndex = calculated.indexOf(Math.min(calculated...))\n    if calcIndex == -1 then return null\n    return filtered[calcIndex]\n\n  magnetToLeftOf: (aMagnet) ->\n    # first, filter all the morphs that are roughly at the same level\n    # of the passed morph\n    correctHeight = @children.filter (m) ->\n      m.putIntoWords? and !m.putIntoWords and\n      (\n        (m.bottom() >= aMagnet.top() and m.top() <= aMagnet.top()) or\n        (m.top() <= aMagnet.bottom() and m.bottom() >= aMagnet.bottom())\n      )\n    \n    # then filter all the morphs that are on the left\n    correctSide = correctHeight.filter (m) ->\n      m.right() < aMagnet.right()\n\n    # then pick the morph that minimises the distance of its right-center point\n    # with the left-center point of the passed morph\n    # (i.e. the "closest" morph to the left side)\n    calculated = correctSide.map (m) ->\n      m.rightCenter().distanceTo(aMagnet.leftCenter())\n    calcIndex = calculated.indexOf(Math.min(calculated...))\n    if calcIndex == -1 then return null\n    return correctSide[calcIndex]\n\n  # symmetric of magnetToLeftOf\n  magnetToRightOf: (aMagnet) ->\n    correctHeight = @children.filter (m) ->\n      m.putIntoWords? and !m.putIntoWords and\n      (\n        (m.bottom() >= aMagnet.top() and m.top() <= aMagnet.top()) or\n        (m.top() <= aMagnet.bottom() and m.bottom() >= aMagnet.bottom())\n      )\n    \n    correctSide = correctHeight.filter (m) ->\n      m.left() > aMagnet.left()\n\n    calculated = correctSide.map (m) ->\n      m.leftCenter().distanceTo(aMagnet.rightCenter())\n    calcIndex = calculated.indexOf(Math.min(calculated...))\n    if calcIndex == -1 then return null\n    return correctSide[calcIndex]\n\n  topLeftMostMagnet: ->\n    topMostMagnet = @topMostMagnet()\n    somethingToTheLeft = topMostMagnet\n\n    while somethingToTheLeft\n      topLeftMostMagnet = somethingToTheLeft\n      somethingToTheLeft = @magnetToLeftOf topLeftMostMagnet\n\n    return topLeftMostMagnet\n\n  clearUpTranslitteratedFlags: ->\n    for eachChild in @children\n      if eachChild.putIntoWords?\n        eachChild.putIntoWords = false\n\n  putIntoWords: ->\n    translitteration = ""\n    tabs = []\n    @clearUpTranslitteratedFlags()\n\n    topLeftMostMagnet = @topLeftMostMagnet()\n    somethingBelow = topLeftMostMagnet\n\n    while somethingBelow\n      # processing a new line\n      topLeftMostMagnet = somethingBelow\n\n      # finding out how many tabs\n      validTabsMap = tabs.filter (t) ->\n        Math.abs(t - topLeftMostMagnet.left()) < 15\n\n      if validTabsMap.length == 0\n        tabs.push topLeftMostMagnet.left()\n        tabs.sort((a, b) -> a - b)\n        howManyTabs = (tabs.indexOf topLeftMostMagnet.left())\n      else\n        howManyTabs = (tabs.indexOf validTabsMap[0])\n\n      translitteration += "\\n" + "  ".repeat(howManyTabs)\n\n      # keep going to the right of the line\n      somethingToTheRight = topLeftMostMagnet\n\n      while somethingToTheRight\n        currentTranslitteratedMagnet = somethingToTheRight\n        translitteration += currentTranslitteratedMagnet.labelString + " "\n        currentTranslitteratedMagnet.putIntoWords = true\n        somethingToTheRight = @magnetToRightOf currentTranslitteratedMagnet\n\n      somethingBelow = @topLeftMostMagnet()\n\n    return translitteration.trim()\n\n  compileTiles: ->\n   if @sourceCodeHolder?\n      cnts = new TextMorph @putIntoWords()\n      cnts.isEditable = true\n      cnts.enableSelecting()\n      @sourceCodeHolder.setContents cnts, 2\n      compiled = @codeCompiler.compileCode cnts.text\n      console.log compiled\n      console.log compiled.program\n      @parent.visualOutput.graphicsCode = @codeCompiler.lastCorrectOutput.program\n\n\n  reactToGrabOf: ->\n    @compileTiles()\n\n  reactToDropOf: ->\n    @compileTiles() \n';
