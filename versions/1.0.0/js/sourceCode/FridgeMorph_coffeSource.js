// Generated by CoffeeScript 1.10.0
window.FridgeMorph_coffeSource = '#| FridgeMorph //////////////////////////////////////////////////////////\n\nclass FridgeMorph extends FrameMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  tabs: []\n  sourceCodeHolder: null\n  fridgeMagnetsCanvas: null\n\n  topMostMagnet: (setOfMorphs = @children) ->\n    filtered = setOfMorphs.filter (m) ->\n      m.putIntoWords? and !m.putIntoWords\n\n    calculated = filtered.map (m) ->\n      m.top()\n    calcIndex = calculated.indexOf(Math.min(calculated...))\n    if calcIndex == -1 then return null\n\n    return filtered[calcIndex]\n\n  magnetToLeftOf: (aMagnet) ->\n    # first, filter all the morphs that are roughly at the same level\n    # of the passed morph\n    correctHeight = @children.filter (m) ->\n      m.putIntoWords? and !m.putIntoWords and\n      (\n        (m.bottom() >= aMagnet.top() and m.top() <= aMagnet.top()) or\n        (m.top() <= aMagnet.bottom() and m.bottom() >= aMagnet.bottom())\n      )\n    \n    # then filter all the morphs that are on the left\n    correctSide = correctHeight.filter (m) ->\n      m.right() < aMagnet.right()\n\n    # then pick the morph that minimises the distance of its right-center point\n    # with the left-center point of the passed morph\n    # (i.e. the "closest" morph to the left side)\n    calculated = correctSide.map (m) ->\n      m.rightCenter().distanceTo(aMagnet.leftCenter())\n    calcIndex = calculated.indexOf(Math.min(calculated...))\n    if calcIndex == -1 then return null\n    return correctSide[calcIndex]\n\n  # the magnet following another magnet is\n  # not necessarily the closest magnet to the right\n  # consider this case:\n  #   |   |\n  #   | A |\n  #   |   | |   |\n  #         | B |\n  #    |   ||   |\n  #    | C |\n  #    |   |\n  # \n  # A\'s closest magnet to the right is B, but it\'s not the\n  # correct one, because B\'s closest magnet to the left is NOT A\n  # (it\'s C).\n  # So in order to find the correct magnet we need to verify\n  # that they are reciprocally the closest ones.\n  magnetFollowing: (aMagnet) ->\n    correctHeight = @children.filter (m) ->\n      m.putIntoWords? and !m.putIntoWords and\n      (\n        (m.bottom() >= aMagnet.top() and m.top() <= aMagnet.top()) or\n        (m.top() <= aMagnet.bottom() and m.bottom() >= aMagnet.bottom())\n      )\n    \n    correctSide = correctHeight.filter (m) ->\n      m.left() > aMagnet.left()\n\n    # distance from the magnet to all the magnets that are\n    # about the same height and to the right\n    calculated = correctSide.map (m) ->\n      m.leftCenter().distanceTo(aMagnet.rightCenter())\n\n    comparator = (arr) ->\n      (a, b) ->\n        if arr[a] < arr[b] then 1 else if arr[a] > arr[b] then -1 else 0\n\n    # Sort by distance\n    correctSide = correctSide.sort(comparator(calculated))\n\n    # now we check each magnet K that could follow H. If we find that\n    # K\'s distance with his left is smaller than K\'s distance with H\n    # then K doesn\'t follow H and we need to check the\n    # next one.\n    # vice versa, if K\'s distance with his left is bigger, then indeed\n    # K follows H so we stop the search and we are done.\n    for eachMagnet in correctSide\n\n      left = @magnetToLeftOf eachMagnet\n      if !left? or left.rightCenter().distanceTo(eachMagnet.leftCenter()) > aMagnet.rightCenter().distanceTo(eachMagnet.leftCenter())\n        return eachMagnet\n    return null\n\n\n  # the idea is that we first find the top most one\n  # and then we filter through the ones on the left\n  # of it and we keep doing that recursively until\n  # all the ones on the left are all COMPLETELY below\n  # the top morph.\n  topLeftMostMagnet: ->\n    bag = @children.filter (m) ->\n      m.putIntoWords? and !m.putIntoWords\n\n    topMostMagnet = null\n\n    while bag.length > 0\n      topMostMagnet = @topMostMagnet bag\n      if !topMostMagnet? then return null\n\n      # filter through the ones on the left\n      bag = bag.filter (m) ->\n        m.left() < topMostMagnet.left()\n\n      # check if all the ones on the left are\n      # strictly below the topmost. If they are\n      # then we are done\n      notStrictlyBelow = bag.filter (m) ->\n        m.top() < topMostMagnet.bottom()\n\n      # if eliminating the ones on the left\n      # and eliminating the ones strictly below\n      # you remain with nothing, then the\n      # search is over\n      if notStrictlyBelow.length == 0\n        break\n\n    return topMostMagnet\n\n\n  clearUpTranslitteratedFlags: ->\n    for eachChild in @children\n      if eachChild.putIntoWords?\n        eachChild.putIntoWords = false\n\n  putIntoWords: ->\n    translitteration = ""\n    tabs = []\n    @clearUpTranslitteratedFlags()\n\n    topLeftMostMagnet = @topLeftMostMagnet()\n    somethingBelow = topLeftMostMagnet\n\n    while somethingBelow\n      # processing a new line\n      topLeftMostMagnet = somethingBelow\n\n      # finding out how many tabs\n      validTabsMap = tabs.filter (t) ->\n        Math.abs(t - topLeftMostMagnet.left()) < 15\n\n      if validTabsMap.length == 0\n        tabs.push topLeftMostMagnet.left()\n        tabs.sort((a, b) -> a - b)\n        howManyTabs = (tabs.indexOf topLeftMostMagnet.left())\n      else\n        howManyTabs = (tabs.indexOf validTabsMap[0])\n\n      translitteration += "\\n" + "  ".repeat(howManyTabs)\n\n      # keep going to the right of the line\n      somethingToTheRight = topLeftMostMagnet\n\n      while somethingToTheRight\n        currentTranslitteratedMagnet = somethingToTheRight\n        translitteration += currentTranslitteratedMagnet.labelString + " "\n        currentTranslitteratedMagnet.putIntoWords = true\n        somethingToTheRight = @magnetFollowing currentTranslitteratedMagnet\n\n      somethingBelow = @topLeftMostMagnet()\n\n    return translitteration.trim()\n\n  compileTiles: ->\n   if @sourceCodeHolder?\n      code = @putIntoWords()\n      debugger\n      @sourceCodeHolder.showCompiledCode code\n      @fridgeMagnetsCanvas?.newGraphicsCode code\n\n\n  reactToGrabOf: ->\n    @compileTiles()\n\n  reactToDropOf: ->\n    @compileTiles() \n';
