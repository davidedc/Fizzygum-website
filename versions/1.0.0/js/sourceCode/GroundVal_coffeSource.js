// Generated by CoffeeScript 1.10.0
window.GroundVal_coffeSource = '# just a draft, it\'s not meant to compile or work\n# just yet, we are just assembling things\n\n# a GroundVal holds a val that is not\n# calculated from anything: it\'s actually\n# changeable as is. It doesn\'t react to the\n# change of any other Val.\n\n# REQUIRES ProfilerData\n\nclass GroundVal\n  \n  directlyOrIndirectlyDependsOnAParentVal: false\n\n  # we use "lastCalculatedValContent" here just as a matter of\n  # uniformity. The cached val of a GroundVal\n  # is always up to date, it\'s always good for use.\n  lastCalculatedValContent: null\n\n  # always false for GroundVals, because there is never\n  # a recalculation to be done here, the val is always\n  # exactly known\n  lastCalculatedValContentMaybeOutdated: false\n  # these vals are affected by change of this\n  # val\n  localValsAffectedByChangeOfThisVal: null\n\n  args: null\n\n  constructor: (@valName, @lastCalculatedValContent, @ownerMorph) ->\n\n    # stuff to do only if we are building GroundVal and not\n    # any of its subclasses\n    if @constructor.name == "GroundVal" and\n        WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n\n      ProfilerData.reactiveValues_createdGroundVals++\n\n      if !@lastCalculatedValContent?\n        contentOfLastCalculatedVal = null\n      else\n        contentOfLastCalculatedVal = @lastCalculatedValContent\n\n      console.log "building GroundVal named " + @valName + " in morph "+ @ownerMorph.uniqueIDString() + " with content: " + contentOfLastCalculatedVal\n\n    @addMyselfToMorphsValsList valName\n    @id = @valName + @ownerMorph.uniqueIDString()\n    @localValsAffectedByChangeOfThisVal = []\n\n\n  checkAndPropagateChangeBasedOnArgChange: ->\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "checking if " + @valName + " in morph "+ @ownerMorph.uniqueIDString() + " has any damaged inputs..."\n\n    # we can check these with a counter, DON\'T do\n    # something like Object.keys(obj).length because it\'s\n    # unnecessary overhead.\n    # Note here that there is no propagation in case:\n    #  a) there is a change but we already notified our\n    #     change to the connected vals\n    #  b) there is no change and we never notified\n    #     any change to the connected vals\n    if @args.countOfDamaged > 0\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "... " + @valName  + " in morph "+ @ownerMorph.uniqueIDString() + " has some damaged inputs but it\'s already broken so nothing to do"\n      if @lastCalculatedValContentMaybeOutdated == false\n        if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n          console.log "... " + @valName  + " in morph "+ @ownerMorph.uniqueIDString() + " has some damaged inputs and wasn\'t damaged so need to propagate damage"\n        @lastCalculatedValContentMaybeOutdated = true\n        @notifyDependentParentOrLocalValsOfPotentialChange()\n    else # there are NO damaged args\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "... " + @valName  + " in morph "+ @ownerMorph.uniqueIDString() + " has NO damaged inputs"\n      @heal()\n\n\n  heal: ->\n    if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n      console.log "... now healing " + @id\n\n    if @lastCalculatedValContentMaybeOutdated\n      if WorldMorph.preferencesAndSettings.printoutsReactiveValuesCode\n        console.log "... " + @id + "\'s last calculated value was marked as broken, notifying dep values of this being healed"\n      @lastCalculatedValContentMaybeOutdated = false\n      @notifyDependentParentOrLocalValsOfPotentialChange()\n\n\n  addMyselfToMorphsValsList: (valName) ->\n    @ownerMorph.allValsInMorphByName[valName] = @\n\n  stainValCalculatedFromParent: (stainingArgVal) ->\n    # note that staining argument here could\n    # be a child argument, as it might directly or\n    # indirectly depend on\n    # a value which is in a parent\n    stainingArg = @args.getByVal stainingArgVal\n    # this might recursively stain other values\n    # depending on this value\n    stainingArg.turnIntoArgDirectlyOrIndirectlyDependingOnParent()\n\n  unstainValCalculatedFromParent: (unstainedArgVal) ->\n    # note that argument here could\n    # be a child argument, as it might directly or\n    # indirectly depend on\n    # a value which is in a parent\n    unstainedArg = @args.getByVal unstainedArgVal\n    # this might recursively un-stain other values\n    # depending on this value\n    unstainedArg.turnIntoArgNotDirectlyNorIndirectlyDependingOnParent()\n\n\n  # this is the only type of val that we\n  # can actually change directly.\n  # All other typed of vals are calculated\n  # from other vals.\n  setVal: (newVal) ->\n    @signature = newVal.signature\n\n    # comparison needs to be smarter?\n    # does this need to have multiple version for basic vals\n    # like integers and strings?\n    if @lastCalculatedValContent == newVal\n      return\n    else\n      @lastCalculatedValContent = newVal\n      @notifyDependentParentOrLocalValsOfPotentialChange()\n  \n  # note that parents never notify children\n  # of any change, because we don\'t want this\n  # operation to take long as there might be hundreds\n  # of children directly/indirectly under this morph.\n  notifyDependentParentOrLocalValsOfPotentialChange: ->\n    for cv in @localValsAffectedByChangeOfThisVal\n      cv.argMightHaveChanged @\n    if @ownerMorph.parent?\n      v = @ownerMorph.parent.morphValsDependingOnChildrenVals[@valName]\n      for k of v\n        #k.argFromChildMightHaveChanged @\n        k.argMightHaveChanged @\n\n  # no logic for recalculation needed\n  # fetchVal is an apt name because it doesn\'t necessarily\n  # recalculate the val (although it might need to) and it\n  # doesn\'t just look it up either. It\'s some sort of retrieval.\n  fetchVal: ->\n    return @lastCalculatedValContent\n\n\n';
