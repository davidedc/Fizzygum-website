// Generated by CoffeeScript 1.10.0
window.InspectorMorph_coffeSource = '# InspectorMorph //////////////////////////////////////////////////////\n\nclass InspectorMorph extends BoxMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  target: null\n  currentProperty: null\n  showing: "attributes"\n  markOwnershipOfProperties: false\n  # panes:\n  label: null\n  list: null\n  detail: null\n  work: null\n  buttonInspect: null\n  buttonClose: null\n  buttonSubset: null\n  buttonEdit: null\n  resizer: null\n  padding: null\n\n  constructor: (@target) ->\n    super()\n    # override inherited properties:\n    @silentRawSetExtent new Point(WorldMorph.preferencesAndSettings.handleSize * 20,\n      WorldMorph.preferencesAndSettings.handleSize * 20 * 2 / 3).round()\n    @padding = if WorldMorph.preferencesAndSettings.isFlat then 1 else 5\n    @color = new Color 60, 60, 60\n    @buildAndConnectChildren()  if @target\n  \n  setTarget: (target) ->\n    @target = target\n    @currentProperty = null\n    @buildAndConnectChildren()\n  \n  buildAndConnectChildren: ->\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n    attribs = []\n\n    # remove all submorhs i.e. panes and buttons\n    # THE ONES THAT ARE STILL\n    # submorphs of the inspector. If they\n    # have been peeled away, they still live\n    @fullDestroyChildren()\n\n    # label\n    @label = new TextMorph @target.toString()\n    @label.fontSize = WorldMorph.preferencesAndSettings.menuFontSize\n    @label.isBold = true\n    @label.color = new Color 255, 255, 255\n    @add @label\n    \n    # properties list. Note that this picks up ALL properties\n    # (enumerable such as strings and un-enumerable such as functions)\n    # of the whole prototype chain.\n    #\n    #   a) some of these are DECLARED as part of the class that defines the object\n    #   and are proprietary to the object. These are shown RED\n    # \n    #   b) some of these are proprietary to the object but are initialised by\n    #   code higher in the prototype chain. These are shown GREEN\n    #\n    #   c) some of these are not proprietary, i.e. they belong to an object up\n    #   the chain of prototypes. These are shown BLUE\n    #\n    # todo: show the static methods and variables in yet another color.\n    \n    for property of @target\n      # dummy condition, to be refined\n      attribs.push property  if property\n\n    attribs = switch @showing\n      when "attributes"\n        attribs.filter (prop) =>\n          not isFunction @target[prop]\n      when "methods"\n        attribs.filter (prop) =>\n          isFunction @target[prop]\n      when "all"\n        attribs\n\n    # otherwise show all properties\n    # label getter\n    # format list\n    # format element: [color, predicate(element]\n    \n    staticProperties = Object.getOwnPropertyNames(@target.constructor)\n    # get rid of all the standard fuff properties that are in classes\n    staticProperties = staticProperties.filter (prop) =>\n        prop not in ["name","length","prototype","caller","__super__","arguments"]\n\n    switch @showing\n      when "attributes"\n        staticFunctions = []\n        staticAttributes = staticProperties.filter (prop) =>\n          not isFunction @target.constructor[prop]\n      when "methods"\n        staticFunctions = staticProperties.filter (prop) =>\n          isFunction @target.constructor[prop]\n        staticAttributes = []\n      else\n        staticFunctions = staticProperties.filter (prop) =>\n          isFunction @target.constructor[prop]\n        staticAttributes = staticProperties.filter (prop) =>\n          prop not in staticFunctions\n\n    #alert "stat fun " + staticFunctions + " stat attr " + staticAttributes\n    attribs = (attribs.concat staticFunctions).concat staticAttributes\n\n    # I expected this sort of filtering based on property names to work\n    # but it doesn\'t, leaving it here as a curiosity and in case I try this\n    # again...\n    #attribs = attribs.filter((prop) => prop.indexOf("_class_injected_in") == -1)\n    #attribs = attribs.filter((prop) => prop.indexOf("function ") == -1)\n    #attribs = attribs.unique()\n    \n    # caches the own methods of the object\n    if @markOwnershipOfProperties\n      targetOwnMethods = Object.getOwnPropertyNames @target.constructor::\n      #alert targetOwnMethods\n\n    # open a new inspector, just on objects so\n    # the idea is that you can view / change\n    # its fields\n    doubleClickAction = =>\n      if !isObject @currentProperty\n        return\n      inspector = new InspectorMorph @currentProperty\n      inspector.fullRawMoveTo world.hand.position()\n      inspector.fullRawMoveWithin world\n      world.add inspector\n      inspector.changed()\n\n    @list = new ListMorph(\n      @, # target\n      "selectionFromList", #action\n      (if @target instanceof Array then attribs else attribs.sort()), #elements\n      null, #labelGetter\n      @filterProperties(staticProperties, targetOwnMethods), #format\n      doubleClickAction #doubleClickAction\n    )\n    @list.disableDrops()\n\n    # we know that the content of this list in this pane is not going to need the\n    # step function, so we disable that from here by setting it to null, which\n    # prevents the recursion to children. We could have disabled that from the\n    # constructor of MenuMorph, but who knows, maybe someone might intend to use a MenuMorph\n    # with some animated content? We know that in this specific case it won\'t need animation so\n    # we set that here. Note that the ListMorph itself does require animation because of the\n    # scrollbars, but the MenuMorph (which contains the actual list contents)\n    # in this context doesn\'t.\n    world.removeSteppingMorph @list.listContents\n    @add @list\n\n    # we add a Morph alignment here because adjusting IDs whenever\n    # we add or remove methods is a pain...\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n\n    # details pane\n    @detail = new ScrollFrameMorph()\n    @detail.disableDrops()\n    @detail.contents.disableDrops()\n    @detail.isTextLineWrapping = true\n    @detail.color = new Color 255, 255, 255\n    ctrl = new TextMorph ""\n    ctrl.isEditable = true\n    ctrl.enableSelecting()\n    ctrl.setReceiver @target\n    @detail.setContents ctrl, 2\n    @add @detail\n\n    # work (\'evaluation\') pane\n    @work = new ScrollFrameMorph()\n    @work.disableDrops()\n    @work.contents.disableDrops()\n    @work.isTextLineWrapping = true\n    @work.color = new Color 255, 255, 255\n    ev = new TextMorph ""\n    ev.isEditable = true\n    ev.enableSelecting()\n    ev.setReceiver @target\n    @work.setContents ev, 2\n    @add @work\n\n    # properties button\n    @buttonSubset = new TriggerMorph true, @\n    @buttonSubset.setLabel "show..."\n    @buttonSubset.alignCenter()\n    @buttonSubset.action = "openShowMenu"\n    @add @buttonSubset\n\n    # inspect button\n    @buttonInspect = new TriggerMorph true, @\n    @buttonInspect.setLabel "inspect"\n    @buttonInspect.alignCenter()\n    @buttonInspect.action = "openInspectorMenu"\n    @add @buttonInspect\n\n    # edit button\n    @buttonEdit = new TriggerMorph true, @\n    @buttonEdit.setLabel "edit..."\n    @buttonEdit.alignCenter()\n    @buttonEdit.action = "openEditMenu"\n    @add @buttonEdit\n\n    # close button\n    @buttonClose = new TriggerMorph true, @\n    @buttonClose.setLabel "close"\n    @buttonClose.alignCenter()\n    @buttonClose.action = "close"\n    @add @buttonClose\n\n    # resizer\n    @resizer = new HandleMorph @\n\n    # update layout\n    @layoutSubmorphs()\n\n  showAttributes: ->\n    @showing = "attributes"\n    @buildAndConnectChildren()\n\n  showMethods: ->\n    @showing = "methods"\n    @buildAndConnectChildren()\n\n  showAttributesAndMethods: ->\n    @showing = "all"\n    @buildAndConnectChildren()\n\n  highlightOwnershipOfProperties: ->\n    @markOwnershipOfProperties = not @markOwnershipOfProperties\n    @buildAndConnectChildren()\n\n\n  openShowMenu: ->\n    menu = new MenuMorph false\n    menu.addItem "attributes", true, @, "showAttributes"\n    menu.addItem "methods", true, @, "showMethods"\n    menu.addItem "all", true, @, "showAttributesAndMethods"\n    menu.addLine()\n    menu.addItem ((if @markOwnershipOfProperties then "un-mark ownership" else "mark ownership")), true, @, "highlightOwnershipOfProperties", "highlight\\nownership of properties"\n    menu.popUpAtHand @firstContainerMenu()\n\n  openInspectorMenu: ->\n    if isObject @currentProperty\n      menu = new MenuMorph false\n      menu.addItem "in new inspector...", true, @, =>\n        inspector = new @constructor @currentProperty\n        inspector.fullRawMoveTo world.hand.position()\n        inspector.fullRawMoveWithin world\n        world.add inspector\n        inspector.changed()\n\n      menu.addItem "here...", true, @, =>\n        @setTarget @currentProperty\n\n      menu.popUpAtHand @firstContainerMenu()\n    else\n      @inform ((if @currentProperty is null then "null" else typeof @currentProperty)) + "\\nis not inspectable"\n\n  openEditMenu: ->\n    menu = new MenuMorph false\n    menu.addItem "save", true, @, "save", "accept changes"\n    menu.addLine()\n    menu.addItem "add property...", true, @, "addPropertyPopout"\n    menu.addItem "rename...", true, @, "renamePropertyPopout"\n    menu.addItem "remove", true, @, "removeProperty"\n    menu.popUpAtHand @firstContainerMenu()\n\n\n  filterProperties: (staticProperties, targetOwnMethods)->\n    if @markOwnershipOfProperties\n      return [\n        # give color criteria from the most general to the most specific\n        [new Color(0, 0, 180),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            true\n        ],\n        [new Color(255, 165, 0),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            element in staticProperties\n        ],\n        [new Color(0, 180, 0),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            (Object::hasOwnProperty.call(@target, element))\n        ],\n        [new Color(180, 0, 0),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            (element in targetOwnMethods)\n        ]\n      ]\n    else\n      return null\n\n  selectionFromList: (selected) ->\n    if selected == undefined then return\n    val = @target[selected]\n    # this is for finding the static variables\n    if val is undefined\n      val = @target.constructor[selected]\n    @currentProperty = val\n    if val is null\n      txt = "null"\n    else if isString val\n      txt = \'"\'+val+\'"\'\n    else\n      txt = val.toString()\n    cnts = new TextMorph txt\n    cnts.isEditable = true\n    cnts.enableSelecting()\n    cnts.setReceiver @target\n    @detail.setContents cnts, 2\n  \n  layoutSubmorphs: (morphStartingTheChange = null) ->\n    super morphStartingTheChange\n    console.log "fixing the layout of the inspector"\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Morph. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    trackChanges.push false\n\n    # label\n    labelLeft = @left() + @padding\n    labelTop = @top() + @padding\n    labelRight = @right() - @padding\n    labelWidth = labelRight - labelLeft\n    if @label.parent == @\n      @label.fullRawMoveTo new Point labelLeft, labelTop\n      @label.rawSetWidth labelWidth\n      if @label.height() > @height() - 50\n        @silentRawSetHeight @label.height() + 50\n        # TODO run the tests when commenting this out\n        # because this one point to the Morph implementation\n        # which is empty.\n        @reLayout()\n        \n        @changed()\n        @resizer.silentUpdateResizerHandlePosition()\n\n    # list\n    labelBottom = labelTop + @label.height() + 2\n    listWidth = Math.floor(@width() / 3)\n    listWidth -= @padding\n    b = @bottom() - (2 * @padding) - WorldMorph.preferencesAndSettings.handleSize\n    listHeight = b - labelBottom\n    listBottom = labelBottom + listHeight\n    if @list.parent == @\n      @list.fullRawMoveTo new Point labelLeft, labelBottom\n      @list.rawSetExtent new Point listWidth, listHeight\n\n    # detail\n    detailLeft = labelLeft + listWidth + @padding\n    detailRight = @right() - @padding\n    detailWidth = detailRight - detailLeft\n    if @detail.parent == @\n      @detail.fullRawMoveTo new Point detailLeft, labelBottom\n      @detail.rawSetExtent new Point(detailWidth, (listHeight * 2 / 3) - @padding).round()\n\n    # work\n    workTop = Math.round labelBottom + (listHeight * 2 / 3)\n    if @work.parent == @\n      @work.fullRawMoveTo new Point detailLeft, workTop\n      @work.rawSetExtent new Point(detailWidth, listHeight / 3).round()\n\n    # properties button\n    propertiesLeft = labelLeft\n    propertiesTop = listBottom + @padding\n    propertiesWidth = listWidth\n    propertiesHeight = WorldMorph.preferencesAndSettings.handleSize\n    if @buttonSubset.parent == @\n      @buttonSubset.fullRawMoveTo new Point propertiesLeft, propertiesTop\n      @buttonSubset.rawSetExtent new Point propertiesWidth, propertiesHeight\n\n    # inspect button\n    inspectLeft = detailLeft\n    inspectWidth = detailWidth - @padding - WorldMorph.preferencesAndSettings.handleSize\n    inspectWidth = Math.round inspectWidth / 3 - @padding / 3\n    inspectRight = inspectLeft + inspectWidth\n    if @buttonInspect.parent == @\n      @buttonInspect.fullRawMoveTo new Point inspectLeft, propertiesTop\n      @buttonInspect.rawSetExtent new Point inspectWidth, propertiesHeight\n\n    # edit button\n    editLeft = inspectRight + @padding\n    editRight = editLeft + inspectWidth\n    if @buttonEdit.parent == @\n      @buttonEdit.fullRawMoveTo new Point editLeft, propertiesTop\n      @buttonEdit.rawSetExtent new Point inspectWidth, propertiesHeight\n\n    # close button\n    closeLeft = editRight + @padding\n    closeRight = detailRight - @padding - WorldMorph.preferencesAndSettings.handleSize\n    closeWidth = closeRight - closeLeft\n    if @buttonClose.parent == @\n      @buttonClose.fullRawMoveTo new Point closeLeft, propertiesTop\n      @buttonClose.rawSetExtent new Point closeWidth, propertiesHeight\n\n    trackChanges.pop()\n    @changed()\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n  \n  \n  #InspectorMorph editing ops:\n  save: ->\n    txt = @detail.contents.children[0].text.toString()\n    propertyName = @list.selected.labelString\n\n    try\n      # this.target[propertyName] = evaluate txt\n      @target.evaluateString "this." + propertyName + " = " + txt\n      @target.reLayout?()      \n      @target.changed?()\n    catch err\n      @inform err\n\n  addProperty: (ignoringThis, morphWithProperty) ->\n    prop = morphWithProperty.text.text\n    if prop?\n      if prop.getValue?\n        prop = prop.getValue()\n      @target[prop] = null\n      @buildAndConnectChildren()\n      @target.reLayout?()      \n      @target.changed?()\n  \n  addPropertyPopout: ->\n    @prompt "new property name:", @, "addProperty", "property" # Chrome cannot handle empty strings (others do)\n\n  renameProperty: (ignoringThis, morphWithProperty) ->\n    propertyName = @list.selected.labelString\n    prop = morphWithProperty.text.text\n    if prop.getValue?\n      prop = prop.getValue()\n    try\n      delete @target[propertyName]\n      @target[prop] = @currentProperty\n    catch err\n      @inform err\n    @buildAndConnectChildren()\n    @target.reLayout?()    \n    @target.changed?()\n  \n  renamePropertyPopout: ->\n    propertyName = @list.selected.labelString\n    @prompt "property name:", @, "renameProperty", propertyName\n  \n  removeProperty: ->\n    propertyName = @list.selected.labelString\n    try\n      delete @target[propertyName]\n\n      @currentProperty = null\n      @buildAndConnectChildren()\n      @target.reLayout?()      \n      @target.changed?()\n    catch err\n      @inform err\n';
