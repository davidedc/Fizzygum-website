// Generated by CoffeeScript 1.10.0
window.Klass_coffeSource = '# Klass ////////////////////////////////////////////////////////////\n\nclass Klass\n  @allKlasses: []\n  propertiesSources: null\n  staticPropertiesSources: null\n  name: ""\n  superClassName: null\n  augmentedWith: null\n  superKlass: null\n  subKlasses: null\n  instances: null\n\n  # adds code into the constructor, such that when a\n  # Morph is created, ire registers itself as in instance\n  # on the Klass it belongs to.\n  # The check:\n  #     @constructor.name == arguments.callee.name\\\n  # is added so that the morph registers itself only\n  # for the immediate klass it belongs to and not all the\n  # other superclasses (in cases for example the constructor\n  # calls "super", we want to avoid that any constructor\n  # up the chain causes the object to register itself\n  # with all the superclasses.\n  # this mechanism can be tested by opening an AnalogClockMorph and\n  # then from the console:\n  # world.children[0].constructor.klass.instances[0] === world.children[0]\n  # or\n  # AnalogClockMorph.klass.instances[0] === world.children[0]\n  _addInstancesTracker: (aString) ->\n    # the regex to get the actual spacing under the constructor\n    # is:\n    # [ \\t]*constructor:[ \\t]*->.*$\\n([ \\t]*)\n    # but let\'s keep it simple: there are going to be four spaces under for the\n    # body of the constructor\n    aString += "\\n    return\\n"\n    aString.replace(/^([ \\t]*)return/gm, "$1if @constructor.name == arguments.callee.name\\n$1  this.constructor.klass.instances.push @\\n$1  return")\n    \n  _equivalentforSuper: (fieldName, aString) ->\n    # coffeescript won\'t compile "super" unless it\'s an instance\n    # method (i.e. if it comes inside a class), so we need to\n    # translate that manually into valid CS that doesn\'t use super.\n    aString = aString.replace(/super\\(\\)/g, @name + ".__super__." + fieldName + ".call(this)")\n    aString = aString.replace(/super\\(/g, @name + ".__super__." + fieldName + ".call(this, ")\n    aString = aString.replace(/super$/gm, @name + ".__super__." + fieldName + ".apply(this, arguments)")\n\n  _removeHelperFunctions: (aString) ->\n    aString = aString.replace("var slice = [].slice;\\n", "")\n    aString = aString.replace("var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\\n", "")\n\n  _addSuperClass: (theSuperClassName) ->\n    @superKlass = window[theSuperClassName].klass\n    window[theSuperClassName].klass.subKlasses.push @\n    @superClassName = theSuperClassName\n\n  constructor: (source) ->\n    @propertiesSources = {}\n    @staticPropertiesSources = {}\n    @subKlasses = []\n    @instances = []\n    splitSource = source.split "\\n"\n    console.log "splitSource: " + splitSource\n    sourceWithoutComments = ""\n    multilineComment = false\n    for eachLine in splitSource\n      #console.log "eachLine: " + eachLine\n      if /^[ \\t]*###/m.test(eachLine)\n        multilineComment = !multilineComment\n\n      if (! /^[ \\t]*#/m.test(eachLine)) and (!multilineComment)\n        sourceWithoutComments += eachLine + "\\n"\n\n    # remove the bit we use to identify classe because it\'s going to\n    # mangle the parsing and we can add it transparently\n    sourceWithoutComments = sourceWithoutComments.replace("namedClasses[@name] = @prototype\\n","")\n\n    classRegex = /^class[ \\t]*([a-zA-Z_$][0-9a-zA-Z_$]*)/m;\n    if (m = classRegex.exec(sourceWithoutComments))?\n        m.forEach((match, groupIndex) ->\n            console.log("Found match, group #{groupIndex}: #{match}")\n        )\n        @name = m[1]\n        console.log "name: " + @name\n\n    extendsRegex = /^class[ \\t]*[a-zA-Z_$][0-9a-zA-Z_$]*[ \\t]*extends[ \\t]*([a-zA-Z_$][0-9a-zA-Z_$]*)/m;\n    if (m = extendsRegex.exec(sourceWithoutComments))?\n        m.forEach((match, groupIndex) ->\n            console.log("Found match, group #{groupIndex}: #{match}")\n        )\n        @_addSuperClass m[1]\n        console.log "superClassName: " + @superClassName\n\n    @augmentedWith = []\n    augmentRegex = /^  @augmentWith[ \\t]*([a-zA-Z_$][0-9a-zA-Z_$]*)/gm;\n    while (m = augmentRegex.exec(sourceWithoutComments))?\n        if (m.index == augmentRegex.lastIndex)\n            augmentRegex.lastIndex++\n        m.forEach((match, groupIndex) ->\n            console.log("Found match, group #{groupIndex}: #{match}");\n        )\n        @augmentedWith.push m[1]\n        console.log "augmentedWith: " + @augmentedWith\n\n\n    # remove the augmentations because we don\'t want\n    # them to mangle up the parsing\n    sourceWithoutComments = sourceWithoutComments.replace(/^  @augmentWith[ \\t]*([a-zA-Z_$][0-9a-zA-Z_$]*)/gm,"")\n\n    console.log "sourceWithoutComments ---------\\n" + sourceWithoutComments\n\n    # to match a valid JS variable name (we just ignore the keywords):\n    #    [a-zA-Z_$][0-9a-zA-Z_$]*\n    regex = /^  (@?[a-zA-Z_$][0-9a-zA-Z_$]*): ([^]*?)(?=^  (@?[a-zA-Z_$][0-9a-zA-Z_$]*):)/gm\n    lastField = null\n    while (m = regex.exec(sourceWithoutComments))?\n        if (m.index == regex.lastIndex)\n            regex.lastIndex++\n        m.forEach((match, groupIndex) ->\n            if groupIndex == 3\n              lastField = match\n            console.log("Found match, group #{groupIndex}: #{match}");\n        )\n        if m[1].substring(0, 1) == "@"\n          @staticPropertiesSources[m[1].substring(1, m[1].length)] = m[2]\n        else\n          @propertiesSources[m[1]] = m[2]\n\n    console.log "last one !!!!!!!!!!!!!!!!!!!!!!!!"\n    regexLast = ///#{lastField}:([^]*)///g\n    while (m = regexLast.exec(sourceWithoutComments))?\n        if (m.index == regexLast.lastIndex)\n            regexLast.lastIndex++\n        m.forEach((match, groupIndex) ->\n            console.log("Found match, group #{groupIndex}: #{match}");\n        )\n        if lastField.substring(0, 1) == "@"\n          @staticPropertiesSources[lastField.substring(1, lastField.length)] = m[1]\n        else\n          @propertiesSources[lastField] = m[1]\n\n    console.dir @propertiesSources\n\n    # the class itself is a function, the constructor:\n    console.log "adding the constructor"\n    if @propertiesSources["constructor"]?\n\n      constructorDeclaration = @_equivalentforSuper "constructor", @propertiesSources["constructor"]\n      constructorDeclaration = @_addInstancesTracker constructorDeclaration\n      console.log "constructor declaration CS: " + constructorDeclaration\n      constructorDeclaration = "window." + @name + " = " + CoffeeScript.compile constructorDeclaration,{"bare":true}\n      constructorDeclaration = @_removeHelperFunctions constructorDeclaration\n\n      console.log "constructor declaration JS: " + constructorDeclaration\n      #if @name == "StringMorph2" then debugger\n      eval.call window, constructorDeclaration\n    else\n      window[@name] = ->\n        # first line here is equivalent to super()\n        window[@name].__super__.constructor.call(this);\n        # register instance\n        if @constructor.name == arguments.callee.name\n          this.constructor.klass.instances.push @\n\n    # if you declare a constructor (i.e. a Function) like this then you don\'t\n    # get the "name" property set as it normally is when\n    # defining functions in ways that specify the name, so\n    # we add the name manually here.\n    # the name property is tricky, see:\n    # see http://stackoverflow.com/questions/5871040/how-to-dynamically-set-a-function-object-name-in-javascript-as-it-is-displayed-i\n    # just doing this is not sufficient: window[@name].name = @name\n    Object.defineProperty(window[@name], "name", { value: @name });\n\n    # if the class extends another one\n    if @superClassName?\n      console.log "extend: " + @name + " extends " + @superClassName\n      window[@name] = extend window[@name], window[@superClassName]\n\n\n    # if the class is augmented with one or more Mixins\n    for eachAugmentation in @augmentedWith\n      console.log "augmentedWith: " + eachAugmentation\n      window[@name].augmentWith window[eachAugmentation]\n\n    # non-static fields, which are put in the prototype\n    for own fieldName, fieldValue of @propertiesSources\n      if fieldName != "constructor" and fieldName != "augmentWith" and fieldName != "addInstanceProperties"\n        console.log "building field " + fieldName + " ===== "\n\n        fieldDeclaration = @_equivalentforSuper fieldName, fieldValue\n        fieldDeclaration = "window." + @name + ".prototype." + fieldName + " = " + CoffeeScript.compile fieldDeclaration,{"bare":true}\n        fieldDeclaration = @_removeHelperFunctions fieldDeclaration\n\n        console.log "field declaration: " + fieldDeclaration\n        #if @name == "StringMorph2" then debugger\n        eval.call window, fieldDeclaration\n\n    # now the static fields, which are put in the constructor\n    # rather than in the prototype\n    for own fieldName, fieldValue of @staticPropertiesSources\n      if fieldName != "constructor" and fieldName != "augmentWith" and fieldName != "addInstanceProperties"\n        console.log "building STATIC field " + fieldName + " ===== "\n\n        fieldDeclaration = @_equivalentforSuper fieldName, fieldValue\n        fieldDeclaration = "window." + @name + "." + fieldName + " = " + CoffeeScript.compile fieldDeclaration,{"bare":true}\n        fieldDeclaration = @_removeHelperFunctions fieldDeclaration\n\n        console.log fieldDeclaration\n        eval.call window, fieldDeclaration\n\n    # finally, add the class to the namedClasses index\n    if @name != "MorphicNode"\n      namedClasses[@name] = window[@name].prototype\n\n    window[@name].klass = @\n\n    #window[@name].prototype.toString = ->\n    #  @constructor.name + " class"\n\n\n\n  notifyInstancesOfSourceChange: (propertiesArray)->\n    for eachInstance in @instances\n      eachInstance.sourceChanged()\n  \n    for eachProperty in propertiesArray\n      for eachSubKlass in @subKlasses\n        # if a subclass redefined a property, then\n        # the change doesn\'t apply, so there is no\n        # notification to propagate\n        if !eachSubKlass.propertiesSources[eachProperty]?\n          eachSubKlass.notifyInstancesOfSourceChange([eachProperty])\n\n';
