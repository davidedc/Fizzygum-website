// Generated by CoffeeScript 1.10.0
window.Morph_coffeSource = '# Morph //////////////////////////////////////////////////////////////\n\n# A Morph (from the Greek "shape" or "form") is an interactive\n# graphical object. General information on the Morphic system\n# can be found at http://minnow.cc.gatech.edu/squeak/30. \n\n# Morphs exist in a tree, rooted at a World or at the Hand.\n# The morphs owns submorphs. Morphs are drawn recursively;\n# if a Morph has no owner it never gets drawn\n# (but note that there are other ways to hide a Morph).\n\n# this comment below is needed to figure out dependencies between classes\n# REQUIRES globalFunctions\n# REQUIRES DeepCopierMixin\n# REQUIRES LayoutSpec\n\nclass Morph extends MorphicNode\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith DeepCopierMixin\n\n  # we want to keep track of how many instances we have\n  # of each Morph for a few reasons:\n  # 1) it gives us an identifier for each Morph\n  # 2) profiling\n  # 3) generate a uniqueIDString that we can use\n  #Â    for example for hashtables\n  # each subclass of Morph has its own static\n  # instancesCounter which starts from zero. First object\n  # has instanceNumericID of 1.\n  # instanceNumericID is initialised in the constructor.\n  @instancesCounter: 0\n  # see roundNumericIDsToNextThousand method for an\n  # explanation of why we need to keep this extra\n  # count\n  @lastBuiltInstanceNumericID: 0\n  instanceNumericID: 0\n\n  # unused - can\'t afford the time right now to change a\n  # script that hangs\n  # TODO\n  aspectRatio: null\n\n  appearance: null\n\n  # Just some tests here ////////////////////\n  propertyUpTheChain: [1,2,3]\n  morphMethod: ->\n    3.14\n  @morphStaticMethod: ->\n    3.14\n  # End of tests here ////////////////////\n\n  isMorph: true\n\n  # we conveniently keep all geometry information\n  # into a single property (a Rectangle). Only\n  # a few geometry-related methods should directly\n  # access this property.\n  bounds: null\n  minimumExtent: null\n  color: new Color 80, 80, 80\n  texture: null # optional url of a fill-image\n  cachedTexture: null # internal cache of actual bg image\n  lastTime: null\n\n  # 1: fully opaque, 0: fully transparent\n  alpha: 1\n\n  # the padding area of a morph is INSIDE a morph and\n  # responds to mouse events.\n  # The padding area should be empty, not drawn, except\n  # for debugging or "interim painting" purposes such\n  # as highlights.\n  # The padding\'s purpose is to give the option to morphs\n  # to accommodate for spacing between their contents and\n  # their bounds, so to enable consecutive morphs to\n  # have some spacing in between them.\n  # Note that paddings of consecutive morphs do add up.\n  # The padding area reacts to mouse events ONLY IF\n  # it\'s filled with color. Otherwise, it doesn\'t.\n  # This is consistent with the concept that Morphs only\n  # react within their "filled" region.\n  paddingTop: 0\n  paddingBottom: 0\n  paddingLeft: 0\n  paddingRight: 0\n\n  # backgroundColor and backgroundTransparency fill the\n  # entire rectangular bounds of the morph.\n  # I.e. they area they fill is not affected by the\n  # padding or the actual design of the morph.\n  backgroundColor: null\n  backgroundTransparency: 1\n\n  # for a Morph, being visible and collapsed\n  # are two separate things.\n  # isVisible means that the morph is meant to show\n  #  as empty or without any surface. BUT the morph\n  #  will still take the usual space.\n  # Collapsed means that the morph, whatever its\n  #  content or appearance or design, is not drawn\n  #  on the desktop AND it doesn\'t occupy any space.\n  isVisible: true\n  collapsed: false\n\n  # if a morph is a "template" it means that\n  # when you floatDrag it, it creates a copy of itself.\n  # it\'s a nice shortcut instead of doing\n  # right click and then "duplicate..."\n  isTemplate: false\n  _acceptsDrops: false\n  noticesTransparentClick: false\n  fps: 0\n  customContextMenu: null\n  shadowBlur: 10\n  onNextStep: null # optional function to be run once. Not currently used in Zombie Kernel\n\n  # contains all the reactive vals\n  allValsInMorphByName: null\n  morphValsDependingOnChildrenVals: null\n  morphValsDirectlyDependingOnParentVals: null\n\n  clickOutsideMeOrAnyOfMeChildrenCallback: [null]\n  isMarkedForDestruction: false\n\n  textDescription: null\n\n  # note that not all the changed morphs have this flag set\n  # because if a parent does a fullChange, we don\'t set this\n  # flag in the children. This is intentionally so,\n  # as we don\'t want to navigate the children too many times.\n  # If you want to know whether a morph has changed its\n  # position, use the hasMaybeChangedGeometryOrPosition:\n  # method instead, which looks at this flag (and another one).\n  # See comment below on fullGeometryOrPositionPossiblyChanged\n  # for more information.\n  geometryOrPositionPossiblyChanged: false\n  clippedBoundsWhenLastPainted: null\n\n  # you\'d be tempted to check this flag to figure out\n  # whether any morph has possibly changed position but\n  # you can\'t. If a PARENT has done a fullChanged, the\n  # children are NOT set this flag. This flag is set\n  # only for the parent morph, and it\'s important that\n  # it stays that way for how the mechanism for fleshing out\n  # the broken rectangles works. We flesh out the rectangles\n  # of the "fully broken" morphs separately looking at this\n  # flag, and we remove the rectangles of the sub-morphs that\n  # have a parent with this flag since we know that they are\n  # already covered.\n  # If you want to figure out whether a morph has changed,\n  # use the hasMaybeChangedGeometryOrPosition: method,\n  # which checks recursively with the parents both the\n  # fullGeometryOrPositionPossiblyChanged flag and the\n  # geometryOrPositionPossiblyChanged flag.\n  # Another way of doing this is to mark with a special flag\n  # all the morph that touch their bounds or positions, but\n  # then it\'s sort of costly to un-set such flag in all such\n  # morphs, as we\'d have to keep the "changed" morphs in a special\n  # array to do that. Seems quite a bit more work and complication,\n  # so just use the method.\n  fullGeometryOrPositionPossiblyChanged: false\n  fullClippedBoundsWhenLastPainted: null\n\n  cachedFullBounds: null\n  childrenBoundsUpdatedAt: -1\n\n  cachedFullClippedBounds: null\n  checkFullClippedBoundsCache: null\n\n  visibleBasedOnIsVisiblePropertyCache: null\n  checkVisibleBasedOnIsVisiblePropertyCache: ""\n\n  clippedThroughBoundsCache: null\n  checkClippedThroughBoundsCache: ""\n\n  clipThroughCache: null\n  checkClipThroughCache: null\n\n  srcBrokenRect: null\n  dstBrokenRect: null\n\n  layoutIsValid: true\n  layoutSpec: LayoutSpec.ATTACHEDAS_FREEFLOATING\n\n  _showsAdders: false\n\n  highlighted: false\n  # if this morph has the purpose of highlighting\n  # another morph, then this field points to the\n  # morph that this morph is supposed to highlight\n  morphThisMorphIsHighlighting: null\n\n  destroyed: false\n\n  mouseClickRight: ->\n    world.hand.openContextMenuAtPointer @\n\n  getTextDescription: ->\n    if @textDescription?\n      #console.log "got name: " + @textDescription + "" + @constructor.name + " (adhoc description of morph)"\n      return @textDescription + "" + @constructor.name + " (adhoc description of morph)"\n    else\n      #console.log "got name: " + @constructor.name + " (class name)"\n      return @constructor.name + " (class name)"\n\n  identifyViaTextLabel: ->\n    myTextDescription = @getTextDescription()\n    allCandidateMorphsWithSameTextDescription = \n      world.allChildrenTopToBottomSuchThat (m) ->\n        m.getTextDescription() == myTextDescription\n\n    position = allCandidateMorphsWithSameTextDescription.indexOf @\n\n    theLenght = allCandidateMorphsWithSameTextDescription.length\n    #console.log [myTextDescription, position, theLenght]\n    return [myTextDescription, position, theLenght]\n\n  setTextDescription: (@textDescription) ->\n\n\n  ##\n  # Reactive Values start\n  ##\n\n  markForDestruction: ->\n    world.markedForDestruction.push @\n    @isMarkedForDestruction = true\n\n  anyParentMarkedForDestruction: ->\n    if @isMarkedForDestruction\n      return true\n    else if @parent?\n      return @parent.anyParentMarkedForDestruction() \n    return false\n\n\n  ###\n  connectValuesToAddedChild: (theChild) ->\n    #if theChild.constructor.name == "RectangleMorph"\n    #  debugger\n\n    # we have a data structure that contains,\n    # for each child valName, all vals of this\n    # morph that depend on it. Go through\n    # all child val names, find the\n    # actual val in the child, and connect all\n    # to the vals in this morph that depend on it.\n    for nameOfChildrenVar, morphValsDependingOnChildrenVals of \\\n        @morphValsDependingOnChildrenVals\n      childVal = theChild.allValsInMorphByName[ nameOfChildrenVar ]\n      if childVal?\n        for valNameNotUsed, valDependingOnChildrenVal of morphValsDependingOnChildrenVals\n          valDependingOnChildrenVal.args.connectToChildVal valDependingOnChildrenVal, childVal\n\n    # we have a data structure that contains,\n    # for each parent (me) valName, all vals of the child\n    # morph that depend on it. Go through\n    # all parent (me) val names, find the\n    # actual val in the parent (me), and connect it\n    # to the vals in the child morph that depend on it.\n    for nameOfParentVar, morphValsDirectlyDependingOnParentVals of \\\n        theChild.morphValsDirectlyDependingOnParentVals\n      parentVal = @allValsInMorphByName[ nameOfParentVar ]\n      if parentVal?\n        for valNameNotUsed, valDependingOnParentVal of morphValsDirectlyDependingOnParentVals\n          valDependingOnParentVal.args.connectToParentVal valDependingOnParentVal, parentVal\n\n  disconnectValuesFromRemovedChild: (theChild) ->\n    # we have a data structure that contains,\n    # for each child valName, all vals of this\n    # morph that depend on it. Go through\n    # all child val names, find the\n    # actual val in the child, and DISconnect it\n    # FROM the vals in this morph that depended on it.\n    for nameOfChildrenVar, morphValsDependingOnChildrenVals of \\\n        @morphValsDependingOnChildrenVals\n      for valNameNotUsed, valDependingOnChildrenVal of morphValsDependingOnChildrenVals\n        childArg = valDependingOnChildrenVal.args.argById[theChild.id]\n        if childArg?\n          childArg.disconnectChildArg()\n\n    # we have a data structure that contains,\n    # for each parent (me) valName, all vals of the child\n    # morph that depend on it. Go through\n    # all parent (me) val names, find the\n    # actual val in the parent (me), and connect it\n    # to the vals in the child morph that depend on it.\n    for nameOfParentVar, morphValsDirectlyDependingOnParentVals of \\\n        theChild.morphValsDirectlyDependingOnParentVals\n      for valNameNotUsed, valDependingOnParentVal of morphValsDirectlyDependingOnParentVals\n        parentArg = valDependingOnParentVal.args.parentArgByName[ nameOfParentVar ]\n        if parentArg?\n          parentArg.disconnectParentArg()\n  ###\n\n\n  ## ------------ end of reactive values ----------------------\n\n  uniqueIDString: ->\n    @morphClassString() + "#" + @instanceNumericID\n\n  morphClassString: ->\n    @constructor.name or @constructor.toString().split(" ")[1].split("(")[0]\n\n  @morphFromUniqueIDString: (theUniqueID) ->\n    result = world.topMorphSuchThat (m) =>\n      m.uniqueIDString() is theUniqueID\n    if not result?\n      alert "theUniqueID " + theUniqueID + " not found!"\n    return result\n\n  assignUniqueID: ->\n    @constructor.instancesCounter++\n    @constructor.lastBuiltInstanceNumericID++\n    @instanceNumericID = @constructor.lastBuiltInstanceNumericID\n\n  # some test commands specify morphs via\n  # their uniqueIDString. This means that\n  # if there is one more TextMorph anywhere during\n  # the playback, for example because\n  # one new menu item is added, then\n  # all the subsequent IDs for the TextMorph will be off.\n  # In order to sort that out, we occasionally re-align\n  # the counts to the next 1000, so the next Morphs\n  # being created will all be aligned and\n  # minor discrepancies are ironed-out\n  @roundNumericIDsToNextThousand: ->\n    console.log "@roundNumericIDsToNextThousand"\n    # this if is because zero and multiples of 1000\n    # don\'t go up to 1000\n    if @lastBuiltInstanceNumericID % 1000 == 0\n      @lastBuiltInstanceNumericID++\n    @lastBuiltInstanceNumericID = 1000 * Math.ceil @lastBuiltInstanceNumericID / 1000\n\n  constructor: ->\n    super()\n    @assignUniqueID()\n\n    if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n      arr = window.world.automatorRecorderAndPlayer.tagsCollectedWhileRecordingTest\n      if @constructor.name not in arr\n        arr.push @constructor.name\n\n    @bounds = Rectangle.EMPTY\n    @minimumExtent = new Point 5,5\n\n    @silentRawSetBounds new Rectangle 0,0,50,40\n\n    @lastTime = Date.now()\n    # Note that we don\'t call \n    # that\'s because the actual extending morph will probably\n    # set more details of how it should look (e.g. size),\n    # so we wait and we let the actual extending\n    # morph to draw itself.\n\n    @allValsInMorphByName = {}\n    @morphValsDependingOnChildrenVals = {}\n    @morphValsDirectlyDependingOnParentVals = {}\n\n    @setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 30,30)\n\n  isTransparentAt: (aPoint) ->\n    @appearance?.isTransparentAt aPoint\n\n  paintHighlight: (aContext, al, at, w, h) ->\n    @appearance?.paintHighlight aContext, al, at, w, h\n\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n    @appearance?.paintIntoAreaOrBlitFromBackBuffer aContext, clippingRectangle\n\n  addShapeSpecificMenus: (menu) ->\n    if @appearance?.addShapeSpecificMenus?\n      return @appearance.addShapeSpecificMenus menu\n    return menu\n\n  addShapeSpecificNumericalSetters: (list) ->\n    if @appearance?.addShapeSpecificNumericalSetters?\n      return @appearance.addShapeSpecificNumericalSetters list\n    return list\n\n  \n  #\n  #    damage list housekeeping\n  #\n  #	the trackChanges property of the Morph prototype is a Boolean switch\n  #	that determines whether the World\'s damage list (\'broken\' rectangles)\n  #	tracks changes. By default the switch is always on. If set to false,\n  #	changes are not stored. This can be very useful for housekeeping of\n  #	the damage list in situations where a large number of (sub-) morphs\n  #	are changed more or less at once. Instead of keeping track of every\n  #	single submorph\'s changes tremendous performance improvements can be\n  #	achieved by setting the trackChanges flag to false before propagating\n  #	the layout changes, setting it to true again and then storing the full\n  #	bounds of the surrounding morph. An an example refer to the\n  #\n  #		layoutSubmorphs()\n  #		\n  #	method of InspectorMorph\n  \n  \n  # Morph string representation: e.g. \'a Morph#2 [20@45 | 130@250]\'\n  toString: ->\n    firstPart = "a "\n\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.hidingOfMorphsNumberIDInLabels\n      firstPart = firstPart + @morphClassString()\n    else\n      firstPart = firstPart + @uniqueIDString()\n\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.hidingOfMorphsGeometryInfoInLabels\n      return firstPart\n    else\n      return firstPart + " " + @boundingBox()\n\n  # Morph string representation: e.g. \'a Morph#2\'\n  toStringWithoutGeometry: ->\n    "a " +\n      @uniqueIDString()\n\n  close: ->\n    if world.underTheCarpetMorph?\n      world.underTheCarpetMorph.scrollFrame.addInPseudoRandomPosition @\n    else\n      world.inform "There is no\\ncarpet to go under!"\n  \n  \n  # Morph deleting:\n  destroy: ->\n\n    # remove instance from the instances tracker\n    # in the class. To see this: just create an\n    # AnalogClockMorph, see that\n    # AnalogClockMorph.klass.instances[0] has one\n    # element. Then delete the clock, and see that the\n    # tracker is now an empty array.\n    @constructor.klass.instances.remove @\n\n    @destroyed = true\n    @parent?.invalidateLayout()\n    @breakNumberOfRawMovesAndResizesCaches()\n    WorldMorph.numberOfAddsAndRemoves++\n\n    world.removeSteppingMorph @\n\n    # if there is anything being edited inside\n    # what we are destroying, then also\n    # invoke stopEditing()\n    if world.caret?\n      if @isAncestorOf world.caret.target\n        world.stopEditing()\n\n    # remove callback when user clicks outside\n    # me or any of my children\n    @onClickOutsideMeOrAnyOfMyChildren null\n\n    if @parent?\n      @fullChanged()\n      @parent.removeChild @\n    return null\n  \n  fullDestroy: ->\n    WorldMorph.numberOfAddsAndRemoves++\n    # we can\'t use a normal iterator because\n    # we are iterating over an array that changes\n    # its length as we are deleting its contents\n    # while we are iterating on it.\n    until @children.length == 0\n      @children[0].fullDestroy()\n    @destroy()\n    return null\n\n  fullDestroyChildren: ->\n    WorldMorph.numberOfAddsAndRemoves++\n    # we can\'t use a normal iterator because\n    # we are iterating over an array that changes\n    # its length as we are deleting its contents\n    # while we are iterating on it.\n    until @children.length == 0\n      @children[0].fullDestroy()\n    return null\n\n\n\n  # not used within Zombie Kernel yet.\n  nextSteps: (lst = []) ->\n    nxt = lst.shift()\n    if nxt\n      @onNextStep = =>\n        nxt.call @\n        @nextSteps lst  \n  \n  # leaving this function as step means that the morph wants to do nothing\n  # but the children *are* traversed and their step function is invoked.\n  # If a Morph wants to do nothing and wants to prevent the children to be\n  # traversed, then this function should be set to null.\n  step: noOperation\n  \n  \n  # Morph accessing - geometry getting:\n  left: ->\n    @bounds.left()\n  \n  right: ->\n    @bounds.right()\n  \n  top: ->\n    @bounds.top()\n  \n  bottom: ->\n    @bounds.bottom()\n  \n  center: ->\n    @bounds.center()\n  \n  bottomCenter: ->\n    @bounds.bottomCenter()\n  \n  bottomLeft: ->\n    @bounds.bottomLeft()\n  \n  bottomRight: ->\n    @bounds.bottomRight()\n  \n  boundingBox: ->\n    @bounds\n  \n  # Morph accessing - geometry getting:\n  leftTight: ->\n    @bounds.left() + @paddingLeft\n  \n  rightTight: ->\n    @bounds.right() - @paddingRight\n  \n  topTight: ->\n    @bounds.top() + @paddingTop\n  \n  bottomTight: ->\n    @bounds.bottom() - @paddingBottom\n  \n  bottomCenterTight: ->\n    @bounds.bottomCenter().subtract new Point 0, @paddingBottom\n  \n  bottomLeftTight: ->\n    @bounds.bottomLeft().add new Point @paddingLeft, -@paddingBottom\n  \n  bottomRightTight: ->\n    @bounds.bottomRight().subtract new Point @paddingRight, @paddingBottom\n  \n  boundingBoxTight: ->\n    new Rectangle @leftTight(), @topTight(), @rightTight(), @bottomTight()\n  \n  # note that using this one, the children\n  # morphs attached as floating don\'t move\n  rawSetBounds: (newBounds) ->\n    if @bounds.eq newBounds\n      return\n\n    unless @bounds.origin.eq newBounds.origin\n      @bounds = @bounds.translateTo newBounds.origin\n      @breakNumberOfRawMovesAndResizesCaches()\n      @changed()\n\n    @rawSetExtent newBounds.extent()\n\n  setBounds: (aRectangle, morphStartingTheChange = null) ->\n    if @layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING\n      return\n    else\n      @invalidateLayout()\n      @rawSetBounds arguments...\n\n  silentRawSetBounds: (newBounds) ->\n    if @bounds.eq newBounds\n      return\n\n    unless @bounds.origin.eq newBounds.origin\n      @bounds = @bounds.translateTo newBounds.origin\n      @breakNumberOfRawMovesAndResizesCaches()\n\n    @silentRawSetExtent newBounds.extent()\n  \n  corners: ->\n    @bounds.corners()\n  \n  leftCenter: ->\n    @bounds.leftCenter()\n  \n  rightCenter: ->\n    @bounds.rightCenter()\n  \n  topCenter: ->\n    @bounds.topCenter()\n  \n  # same as position()\n  topLeft: ->\n    @bounds.origin\n  \n  topRight: ->\n    @bounds.topRight()\n  \n  position: ->\n    @bounds.origin\n  \n  extent: ->\n    @bounds.extent()\n  \n  width: ->\n    @bounds.width()\n  \n  height: ->\n    @bounds.height()\n\n  cornersTight: ->\n    [@topLeftTight(), @bottomLeftTight(), @bottomRightTight(), @topRightTight()]\n  \n  leftCenterTight: ->\n    @bounds.leftCenter().add new Point @paddingLeft, 0\n  \n  rightCenterTight: ->\n    @bounds.rightCenter().subtract new Point @paddingRight, 0\n  \n  topCenterTight: ->\n    @bounds.topCenter().add new Point 0, @paddingTop\n  \n  # same as position()\n  topLeftTight: ->\n    @bounds.origin.add new Point @paddingLeft, @paddingTop\n  \n  topRightTight: ->\n    @bounds.topRight.add new Point -@paddingRight, @paddingTop\n  \n  positionTight: ->\n    @bounds.origin.add new Point @paddingLeft, @paddingTop\n  \n  extentTight: ->\n    @bounds.extent().subtract new Point - (@paddingLeft + @paddingRight), - (@paddingTop + @paddingBottom)\n  \n  widthTight: ->\n    @bounds.width() - (@paddingLeft + @paddingRight)\n  \n  heightTight: ->\n    @bounds.height() - (@paddingTop + @paddingBottom)\n\n\n  # used for example:\n  # - to determine which morphs you can attach a morph to\n  # - for a SliderMorph\'s "set target" so you can change properties of another Morph\n  # - by the HandleMorph when you attach it to some other morph\n  # Note that this method has a slightly different\n  # version in FrameMorph (because it clips, so we need\n  # to check that we don\'t consider overlaps with\n  # morphs contained in a frame that are clipped and\n  # hence *actually* not overlapping).\n  plausibleTargetAndDestinationMorphs: (theMorph) ->\n    # find if I intersect theMorph,\n    # then check my children recursively\n    # exclude me if I\'m a child of theMorph\n    # (cause it\'s usually odd to attach a Morph\n    # to one of its submorphs or for it to\n    # control the properties of one of its submorphs)\n    result = []\n    if @visibleBasedOnIsVisibleProperty() and\n        !@isCollapsed() and\n        !theMorph.isAncestorOf(@) and\n        @areBoundsIntersecting(theMorph) and\n        !@anyParentMarkedForDestruction()\n      result = [@]\n\n    @children.forEach (child) ->\n      result = result.concat(child.plausibleTargetAndDestinationMorphs(theMorph))\n\n    return result\n\n\n  # both methods invoked in here\n  # are cached\n  # used in the method fleshOutBroken\n  # to skip the "destination" broken rects\n  # for morphs that marked themselves\n  # as broken but at moment of destination\n  # might be invisible\n  surelyNotShowingUpOnScreenBasedOnVisibilityCollapseAndOrphanage: ->\n    if !@isVisible\n      return true\n\n    if @isOrphan()\n      return true\n\n    if !@visibleBasedOnIsVisibleProperty()\n      return true\n\n    if @isCollapsed()\n      return true\n\n    return false\n\n\n  SLOWvisibleBasedOnIsVisibleProperty: ->\n    if !@isVisible\n      return false\n    if @parent?\n      return @parent.SLOWvisibleBasedOnIsVisibleProperty()\n    else\n      return true\n\n  # doesn\'t check orphanage\n  visibleBasedOnIsVisibleProperty: ->\n    if !@isVisible\n      # I\'m not sure updating the cache here does\n      # anything but it\'s two lines so let\'s do it\n      @checkVisibleBasedOnIsVisiblePropertyCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges\n      @visibleBasedOnIsVisiblePropertyCache = false\n      result = @visibleBasedOnIsVisiblePropertyCache\n    else # @isVisible is true\n      if !@parent?\n        result = true\n      else\n        if @checkVisibleBasedOnIsVisiblePropertyCache == WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges\n          #console.log "cache hit visibleBasedOnIsVisibleProperty"\n          result = @visibleBasedOnIsVisiblePropertyCache\n        else\n          #console.log "cache miss visibleBasedOnIsVisibleProperty"\n          @checkVisibleBasedOnIsVisiblePropertyCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges\n          @visibleBasedOnIsVisiblePropertyCache = @parent.visibleBasedOnIsVisibleProperty()\n          result = @visibleBasedOnIsVisiblePropertyCache\n\n    if world.doubleCheckCachedMethodsResults\n      if result != @SLOWvisibleBasedOnIsVisibleProperty()\n        debugger\n        alert "visibleBasedOnIsVisibleProperty is broken"\n\n    return result\n\n\n  # Note that in a case of a fullMove*\n  # you should also invalidate all the morphs in\n  # the subtree as well.\n  # This happens indirectly as the fullMove* methods\n  # move all the children too, so *that*\n  # invalidates them. Note that things might change\n  # if you use a different coordinate system, in which\n  # case you have to invalidate the caches in all the\n  # submorphs manually or use some other cache\n  # invalidation mechanism.\n  invalidateFullBoundsCache: ->\n    if !@cachedFullBounds?\n      return\n    @cachedFullBounds = null\n    if @parent?.cachedFullBounds?\n        @parent.invalidateFullBoundsCache @\n\n  invalidateFullClippedBoundsCache: ->\n    if !@checkFullClippedBoundsCache?\n      return\n    @checkFullClippedBoundsCache = null\n    if @parent?.checkFullClippedBoundsCache?\n        @parent.invalidateFullClippedBoundsCache @\n\n\n  # doesn\'t take into account orphanage\n  # or visibility\n  SLOWfullBounds: ->\n    result = @bounds\n    @children.forEach (child) ->\n      if child.visibleBasedOnIsVisibleProperty() and\n      !child.isCollapsed()\n        result = result.merge child.SLOWfullBounds()\n    result\n\n  SLOWfullClippedBounds: ->\n    if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()\n      return Rectangle.EMPTY\n    result = @clippedThroughBounds()\n    @children.forEach (child) ->\n      if child.visibleBasedOnIsVisibleProperty() and !child.isCollapsed()\n        result = result.merge child.SLOWfullClippedBounds()\n    #if this != world and result.corner.x > 400 and result.corner.y > 100 and result.origin.x ==0 and result.origin.y ==0\n    #  debugger\n    result\n\n  # for FrameMorph scrolling support\n  subMorphsMergedFullBounds: ->\n    result = null\n    if @children.length\n      result = @children[0].bounds\n      @children.forEach (child) ->\n        result = result.merge child.fullBounds()\n    result    \n  \n  # does not take into account orphanage or visibility\n  fullBounds: ->\n    if @cachedFullBounds?\n      if world.doubleCheckCachedMethodsResults\n        if !@cachedFullBounds.eq @SLOWfullBounds()\n          debugger\n          alert "fullBounds is broken (cached)"\n      return @cachedFullBounds\n\n    result = @bounds\n    @children.forEach (child) ->\n      if child.visibleBasedOnIsVisibleProperty() and !child.isCollapsed()\n        result = result.merge child.fullBounds()\n\n    if world.doubleCheckCachedMethodsResults\n      if !result.eq @SLOWfullBounds()\n        debugger\n        alert "fullBounds is broken (uncached)"\n\n    @cachedFullBounds = result\n\n  # this one does take into account orphanage and\n  # visibility. The reason is that this is used to\n  # find the smallest broken rectangle created by\n  # a fullChanged(), which means that really we\n  # are interested in what\'s visible on screen so\n  # we do take into account orphanage and\n  # visibility.\n  fullClippedBounds: ->\n    if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()\n      result = Rectangle.EMPTY\n    else\n      if @checkFullClippedBoundsCache == WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n        if world.doubleCheckCachedMethodsResults\n          if !@cachedFullClippedBounds.eq @SLOWfullClippedBounds()\n            debugger\n            alert "fullClippedBounds is broken"\n        return @cachedFullClippedBounds\n\n      # you\'d be thinking this is the same as\n      #   result = @fullBounds().intersect @clipThrough()\n      # but it\'s not, because fullBounds doesn\'t\n      # take into account orphanage and visibility\n\n      result = @clippedThroughBounds()\n      @children.forEach (child) ->\n        if child.visibleBasedOnIsVisibleProperty() and !child.isCollapsed()\n          result = result.merge child.fullClippedBounds()\n\n    if world.doubleCheckCachedMethodsResults\n      if !result.eq @SLOWfullClippedBounds()\n        debugger\n        alert "fullClippedBounds is broken"\n\n    @checkFullClippedBoundsCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    @cachedFullClippedBounds = result\n  \n  fullBoundsNoShadow: ->\n    # answer my full bounds but ignore any shadow\n    result = @bounds\n    @children.forEach (child) ->\n      if (child not instanceof ShadowMorph) and (child.visibleBasedOnIsVisibleProperty()) and (!child.isCollapsed()) \n        result = result.merge child.fullBoundsNoShadow()\n    result\n\n  # this one does take into account orphanage and\n  # visibility. The reason is that this is used to\n  # find the smallest broken rectangle created by\n  # a changed(), which means that really we\n  # are interested in what\'s visible on screen so\n  # we do take into account orphanage and\n  # visibility.\n  clippedThroughBounds: ->\n\n    if @checkClippedThroughBoundsCache == WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n      #console.log "cache hit @checkClippedThroughBoundsCache"\n      return @clippedThroughBoundsCache\n    #else\n    #  console.log "cache miss @checkClippedThroughBoundsCache"\n    #  #console.log (WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes) + " cache: " + @checkClippedThroughBoundsCache\n    #  #debugger\n\n    if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()\n      @checkClippedThroughBoundsCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n      @clippedThroughBoundsCache = Rectangle.EMPTY\n      return @clippedThroughBoundsCache \n\n    @checkClippedThroughBoundsCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    @clippedThroughBoundsCache = @boundingBox().intersect @clipThrough()\n    return @clippedThroughBoundsCache\n  \n  # this one does take into account orphanage and\n  # visibility. The reason is that this is used to\n  # find the "smallest broken rectangles"\n  # which means that really we\n  # are interested in what\'s visible on screen so\n  # we do take into account orphanage and\n  # visibility.\n  clipThrough: ->\n    # answer which part of me is not clipped by a Frame\n    if @ == Window\n      debugger\n\n    if @checkClipThroughCache == WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n      #console.log "cache hit @checkClipThroughCache"\n      return @clipThroughCache\n    #else\n    #  console.log "cache miss @checkClipThroughCache"\n    #  #console.log (WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes) + " cache: " + @checkClipThroughCache\n    #  #debugger\n\n    if @isOrphan() or !@visibleBasedOnIsVisibleProperty() or @isCollapsed()\n      @checkClipThroughCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n      @clipThroughCache = Rectangle.EMPTY\n      return @clipThroughCache \n\n    firstFrameParent = @firstFrameParent()\n    if !firstFrameParent?\n      firstFrameParent = world\n    firstFrameClipThroughBounds = firstFrameParent.clipThrough()\n    @checkClipThroughCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    if @ instanceof FrameMorph\n      @clipThroughCache = @boundingBox().intersect firstFrameClipThroughBounds\n    else\n      @clipThroughCache = firstFrameClipThroughBounds\n\n\n    return @clipThroughCache\n  \n  \n  # Morph accessing - simple changes:\n  fullRawMoveBy: (delta) ->\n    if delta.isZero() then return\n    # note that changed() is called two times\n    # because there are two areas of the screens\n    # that are dirty: the starting\n    # position and the end position.\n    # Both need to be repainted.\n    #console.log "move 4"\n    @breakNumberOfRawMovesAndResizesCaches()\n    @bounds = @bounds.translateBy delta\n    @children.forEach (child) ->\n      child.fullRawMoveBy delta\n    @changed()\n\n  silentFullRawMoveBy: (delta) ->\n    #console.log "move 5"\n    @breakNumberOfRawMovesAndResizesCaches()\n    @bounds = @bounds.translateBy delta\n    @children.forEach (child) ->\n      child.silentFullRawMoveBy delta\n  \n  breakNumberOfRawMovesAndResizesCaches: ->\n    @invalidateFullBoundsCache @\n    @invalidateFullClippedBoundsCache @\n    if @ instanceof HandMorph\n      if @children.length == 0\n        return\n    WorldMorph.numberOfRawMovesAndResizes++\n\n  \n  fullRawMoveTo: (aPoint) ->\n    aPoint.debugIfFloats()\n    delta = aPoint.toLocalCoordinatesOf @\n    if !delta.isZero()\n      #console.log "move 6"\n      @breakNumberOfRawMovesAndResizesCaches()\n      @fullRawMoveBy delta\n    @bounds.debugIfFloats()\n\n  fullMoveTo: (aPoint) ->\n    if @layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING\n      return\n    else\n      @invalidateLayout()\n      @fullRawMoveTo arguments...\n  \n  silentFullRawMoveTo: (aPoint) ->\n    #console.log "move 7"\n    @breakNumberOfRawMovesAndResizesCaches()\n    delta = aPoint.toLocalCoordinatesOf @\n    @silentFullRawMoveBy delta  if (delta.x isnt 0) or (delta.y isnt 0)\n  \n  fullRawMoveLeftSideTo: (x) ->\n    @fullRawMoveTo new Point x, @top()\n  \n  fullRawMoveRightSideTo: (x) ->\n    @fullRawMoveTo new Point x - @width(), @top()\n  \n  fullRawMoveTopSideTo: (y) ->\n    @fullRawMoveTo new Point @left(), y\n  \n  fullRawMoveBottomSideTo: (y) ->\n    @fullRawMoveTo new Point @left(), y - @height()\n  \n  fullRawMoveCenterTo: (aPoint) ->\n    @fullRawMoveTo aPoint.subtract @extent().floorDivideBy 2\n  \n  fullRawMoveFullCenterTo: (aPoint) ->\n    @fullRawMoveTo aPoint.subtract @fullBounds().extent().floorDivideBy 2\n  \n  # make sure I am completely within another Morph\'s bounds\n  fullRawMoveWithin: (aMorph) ->\n    leftOff = @fullBounds().left() - aMorph.left()\n    @fullRawMoveBy new Point -leftOff, 0  if leftOff < 0\n    rightOff = @fullBounds().right() - aMorph.right()\n    @fullRawMoveBy new Point -rightOff, 0  if rightOff > 0\n    topOff = @fullBounds().top() - aMorph.top()\n    @fullRawMoveBy new Point 0, -topOff  if topOff < 0\n    bottomOff = @fullBounds().bottom() - aMorph.bottom()\n    @fullRawMoveBy new Point 0, -bottomOff  if bottomOff > 0\n\n\n  notifyChildrenThatParentHasReLayouted: ->\n    for child in @children.slice()\n      child.parentHasReLayouted()\n\n  # normally morphs do nothing when the\n  # parent is layouting, as they are\n  # placed with absolute positioning.\n  # In some cases though, such as in the\n  # case of the HandleMorph, a Morph\n  # make take the occasion to do special things\n  # In the case of the HandleMorph, it\'s going\n  # to place itself in the bottom-right\n  # corner.\n  parentHasReLayouted: ->\n    @notifyChildrenThatParentHasReLayouted()\n\n  layoutInset: (morphStartingTheChange = null) ->\n    if @insetMorph?\n      if @insetMorph != morphStartingTheChange\n        @insetMorph.fullRawMoveTo @insetPosition()\n        @insetMorph.rawSetExtent @insetSpaceExtent(), @\n  \n  # the default of layoutSubmorphs\n  # is to do nothing apart from notifying\n  # the children (in case, for example,\n  # there is a HandleMorph in this morph\n  # which will cause the HandleMorph to\n  # replace itself in the new position)\n  # , but things like\n  # the inspector might well want to\n  # tweak many of their children...\n  layoutSubmorphs: (morphStartingTheChange = null) ->\n    @layoutInset morphStartingTheChange\n\n    for child in @children.slice()\n      if morphStartingTheChange != child\n        child.parentHasReLayouted()\n  \n\n  # do nothing in most cases but for example for\n  # layouts, if something inside a layout wants to\n  # change extent, then the whole layout might need to\n  # change extent.\n  childChangedExtent: (theMorphChangingTheExtent) ->\n    if @insetMorph == theMorphChangingTheExtent\n      @rawSetExtent @extentBasedOnInsetExtent(theMorphChangingTheExtent), theMorphChangingTheExtent\n\n  # more complex Morphs, e.g. layouts, might\n  # do a more complex calculation to get the\n  # minimum extent\n  getMinimumExtent: ->\n    @minimumExtent\n\n  setMinimumExtent: (@minimumExtent) ->\n\n  # Morph accessing - dimensional changes requiring a complete redraw\n  rawSetExtent: (aPoint, morphStartingTheChange = null) ->\n    #console.log "move 8"\n    if @ == morphStartingTheChange\n      return\n    if morphStartingTheChange == null\n      morphStartingTheChange = @\n    # check whether we are actually changing the extent.\n    unless aPoint.eq @extent()\n      @breakNumberOfRawMovesAndResizesCaches()\n\n      @silentRawSetExtent aPoint\n      @changed()\n      @reLayout()\n      \n      @layoutSubmorphs morphStartingTheChange\n      if @parent?\n        if @parent != morphStartingTheChange\n          @parent.childChangedExtent @\n\n  # Morph accessing - dimensional changes requiring a complete redraw\n  setExtent: (aPoint, morphStartingTheChange = null) ->\n    if @layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING\n      return\n    else\n      @invalidateLayout()\n      @rawSetExtent arguments...\n\n  \n  silentRawSetExtent: (aPoint) ->\n    aPoint = aPoint.round()\n    #console.log "move 9"\n\n    minExtent = @getMinimumExtent()\n    if ! aPoint.ge minExtent\n      aPoint = aPoint.max minExtent\n\n    newWidth = Math.max aPoint.x, 0\n    newHeight = Math.max aPoint.y, 0\n\n    newBounds = new Rectangle @bounds.origin, new Point @bounds.origin.x + newWidth, @bounds.origin.y + newHeight\n\n    unless @bounds.eq newBounds\n      @bounds = newBounds\n      @breakNumberOfRawMovesAndResizesCaches()\n  \n  rawSetWidth: (width) ->\n    #console.log "move 10"\n    @breakNumberOfRawMovesAndResizesCaches()\n    @rawSetExtent new Point(width or 0, @height())\n\n  setWidth: (width) ->\n    if @layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING\n      return\n    else\n      @invalidateLayout()\n      @rawSetWidth arguments...\n  \n  silentRawSetWidth: (width) ->\n    #console.log "move 11"\n    @breakNumberOfRawMovesAndResizesCaches()\n    w = Math.max Math.round(width or 0), 0\n    @bounds = new Rectangle @bounds.origin, new Point @bounds.origin.x + w, @bounds.corner.y\n  \n  rawSetHeight: (height) ->\n    #console.log "move 12"\n    @breakNumberOfRawMovesAndResizesCaches()\n    @rawSetExtent new Point(@width(), height or 0)\n\n  setHeight: (height) ->\n    if @layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING\n      return\n    else\n      @invalidateLayout()\n      @rawSetHeight arguments...\n\n  \n  silentRawSetHeight: (height) ->\n    #console.log "move 13"\n    @breakNumberOfRawMovesAndResizesCaches()\n    h = Math.max Math.round(height or 0), 0\n    @bounds = new Rectangle @bounds.origin, new Point @bounds.corner.x, @bounds.origin.y + h\n  \n  setColor: (aColorOrAMorphGivingAColor, morphGivingColor) ->\n    if morphGivingColor?.getColor?\n      aColor = morphGivingColor.getColor()\n    else\n      aColor = aColorOrAMorphGivingAColor\n    if aColor\n      unless @color.eq aColor\n        @color = aColor\n        @changed()\n        \n    return aColor\n  \n  setBackgroundColor: (aColorOrAMorphGivingAColor, morphGivingColor) ->\n    if morphGivingColor?.getColor?\n      aColor = morphGivingColor.getColor()\n    else\n      aColor = aColorOrAMorphGivingAColor\n    if aColor\n      unless @color.eq aColor\n        @backgroundColor = aColor\n        @changed()\n        \n    return aColor\n  \n  # Morph displaying ---------------------------------------------------------\n\n  # There are three fundamental methods for rendering and displaying anything.\n  # * updateBackBuffer: this one creates/updates the local canvas of this morph only\n  #   i.e. not the children. For example: a ColorPickerMorph is a Morph which\n  #   contains three children Morphs (a color palette, a greyscale palette and\n  #   a feedback). The updateBackBuffer method of ColorPickerMorph only creates\n  #   a canvas for the container Morph. So that\'s just a canvas with a\n  #   solid color. As the\n  #   ColorPickerMorph constructor runs, the three childredn Morphs will\n  #   run their own updateBackBuffer method, so each child will have its own\n  #   canvas with their own contents.\n  #   Note that updateBackBuffer should be called sparingly. A morph should repaint\n  #   its buffer pretty much only *after* it\'s been added to its first parent and\n  #   whenever it changes dimensions. Things like changing parent and updating\n  #   the position shouldn\'t normally trigger an update of the buffer.\n  #   Also note that before the buffer is painted for the first time, they\n  #   might not know their extent. Typically text-related Morphs know their\n  #   extensions after they painted the text for the first time...\n  # * paintIntoAreaOrBlitFromBackBuffer: takes the local canvas and paints it to a specific area in a passed\n  #   canvas. The local canvas doesn\'t contain any rendering of the children of\n  #   this morph.\n  # * fullPaintIntoAreaOrBlitFromBackBuffer: recursively draws all the local canvas of this morph and all\n  #   its children into a specific area of a passed canvas.\n\n  # tiles the texture - never used in Zombie Kernel at the moment.\n  drawCachedTexture: ->\n    bg = @cachedTexture\n    cols = Math.floor @backBuffer.width / bg.width\n    lines = Math.floor @backBuffer.height / bg.height\n    context = @backBuffer.getContext "2d"\n    for y in [0..lines]\n      for x in [0..cols]\n        context.drawImage bg, Math.round(x * bg.width), Math.round(y * bg.height)\n    @changed()\n  \n  \n  boundsContainPoint: (aPoint) ->\n    @bounds.containsPoint aPoint\n\n  areBoundsIntersecting: (aMorph) ->\n    @bounds.isIntersecting aMorph.bounds\n\n  calculateKeyValues: (aContext, clippingRectangle) ->\n    area = clippingRectangle.intersect(@bounds).round()\n    # test whether anything that we are going to be drawing\n    # is visible (i.e. within the clippingRectangle)\n    if area.isNotEmpty()\n      delta = @position().neg()\n      src = area.translateBy(delta).round()\n\n      sl = src.left() * pixelRatio\n      st = src.top() * pixelRatio\n      al = area.left() * pixelRatio\n      at = area.top() * pixelRatio\n      w = Math.min(src.width() * pixelRatio, @width() * pixelRatio - sl)\n      h = Math.min(src.height() * pixelRatio, @height() * pixelRatio - st)\n\n    return [area,sl,st,al,at,w,h]\n\n  turnOnHighlight: ->\n    if !@highlighted\n      @highlighted = true\n      world.morphsToBeHighlighted.push @\n      @changed()\n\n  turnOffHighlight: ->\n    if @highlighted\n      @highlighted = false\n      world.morphsToBeHighlighted.remove @\n      @changed()\n\n\n  # paintRectangle can work in two patterns:\n  #  * passing actual pixels, when used\n  #    outside the effect of the scope of\n  #    "scale pixelRatio, pixelRatio", or\n  #  * passing logiacl pixels, when used\n  #    inside the effect of the scope of\n  #    "scale pixelRatio, pixelRatio", or\n  # Mostly, the first pattern is used.\n  paintRectangle: (\n    aContext,\n    al, at, w, h,\n    color,\n    transparency = null,\n    pushAndPopContext = false\n  ) ->\n\n      if !color?\n        return\n\n      if pushAndPopContext\n        aContext.save()\n\n      aContext.fillStyle = color.toString()\n      if transparency?\n        aContext.globalAlpha = transparency\n\n      aContext.fillRect  Math.round(al),\n          Math.round(at),\n          Math.round(w),\n          Math.round(h)\n\n      if pushAndPopContext\n        aContext.restore()\n\n\n  preliminaryCheckNothingToDraw: (noShadow, clippingRectangle, aContext) ->\n\n    if !@isVisible\n      return true\n\n    if noShadow and (@ instanceof ShadowMorph)\n      return true\n\n    if clippingRectangle.isEmpty()\n      return true\n\n    if aContext == world.worldCanvasContext and @isOrphan()\n      return true\n\n    if aContext == world.worldCanvasContext and !@visibleBasedOnIsVisibleProperty()\n      return true\n\n    if aContext == world.worldCanvasContext and @isCollapsed()\n      return true\n\n    return false\n\n  recordDrawnAreaForNextBrokenRects: ->\n    if @childrenBoundsUpdatedAt < WorldMorph.frameCount\n      @childrenBoundsUpdatedAt = WorldMorph.frameCount\n      @clippedBoundsWhenLastPainted = @clippedThroughBounds()\n      #if (@ != world) and (@clippedBoundsWhenLastPainted.containsPoint (new Point(10,10)))\n      #  debugger\n      @fullClippedBoundsWhenLastPainted = @fullClippedBounds()\n      #if (@ != world) and (@fullClippedBoundsWhenLastPainted.containsPoint (new Point(10,10)))\n      #  debugger\n      #if (@ instanceof MenuMorph) and (@fullClippedBoundsWhenLastPainted.containsPoint (new Point(10,10)))\n      #  debugger\n\n\n  fullPaintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle = @fullClippedBounds(), noShadow = false) ->\n\n    if @preliminaryCheckNothingToDraw noShadow, clippingRectangle, aContext\n      return\n\n    # in general, the children of a Morph could be outside the\n    # bounds of the parent (they could also be much larger\n    # then the parent). This means that we have to traverse\n    # all the children to find out whether any of those overlap\n    # the clipping rectangle. Note that we can be smarter with\n    # FrameMorphs, as their children are actually all contained\n    # within the parent\'s boundary.\n\n    # Note that if we could dynamically and cheaply keep an updated\n    # fullBounds property, then we could be smarter\n    # in discarding whole sections of the scene graph.\n    # (see https://github.com/davidedc/Zombie-Kernel/issues/150 )\n    \n\n    if aContext == world.worldCanvasContext\n      @recordDrawnAreaForNextBrokenRects()\n    @paintIntoAreaOrBlitFromBackBuffer aContext, clippingRectangle\n    @children.forEach (child) ->\n      child.fullPaintIntoAreaOrBlitFromBackBuffer aContext, clippingRectangle, noShadow\n  \n\n  hide: ->\n    @isVisible = false\n    WorldMorph.numberOfVisibilityFlagsChanges++\n    @invalidateFullBoundsCache @\n    @invalidateFullClippedBoundsCache @\n    @fullChanged()\n\n  show: ->\n    if @isVisible\n      return\n    if @visibleBasedOnIsVisibleProperty() == true\n      return\n    @isVisible = true\n    WorldMorph.numberOfVisibilityFlagsChanges++\n    @invalidateFullBoundsCache @\n    @invalidateFullClippedBoundsCache @\n    @fullChanged()\n  \n  toggleVisibility: ->\n    @isVisible = not @isVisible\n    WorldMorph.numberOfVisibilityFlagsChanges++\n    @invalidateFullBoundsCache @\n    @invalidateFullClippedBoundsCache @\n    @fullChanged()\n\n  collapse: ->\n    @collapsed = true\n    WorldMorph.numberOfCollapseFlagsChanges++\n    @invalidateFullBoundsCache @\n    @invalidateFullClippedBoundsCache @\n    @invalidateLayout()\n    @fullChanged()\n\n  unCollapse: ->\n    if !@collapsed\n      return\n    if !@isCollapsed()\n      return\n    @collapsed = false\n    WorldMorph.numberOfCollapseFlagsChanges++\n    @invalidateFullBoundsCache @\n    @invalidateFullClippedBoundsCache @\n    @invalidateLayout()\n    @fullChanged()\n\n  \n  isCollapsed: ->\n    if @collapsed\n      return true\n    else\n      if @parent?\n        return @parent.isCollapsed()\n      else\n        return false\n  \n  removeFromTree: ->\n    @parent?.invalidateLayout()\n    @breakNumberOfRawMovesAndResizesCaches()\n    WorldMorph.numberOfAddsAndRemoves++\n    @parent.removeChild @\n    @fullChanged()\n\n  createPointerMorph: ->\n    myPosition = @positionAmongSiblings()\n    morphToAdd = new PointerMorph @\n    @parent.add morphToAdd, myPosition\n    morphToAdd.fullMoveTo @position()\n    morphToAdd.setExtent new Point 150, 20\n    morphToAdd.fullChanged()\n    @removeFromTree()\n\n    \n  # Morph full image:\n  # Fixes https://github.com/jmoenig/morphic.js/issues/7\n  # and https://github.com/davidedc/Zombie-Kernel/issues/160\n  fullImage: (bounds, noShadow = false) ->\n    if !bounds?\n      bounds = @fullBounds()\n\n    img = newCanvas bounds.extent().scaleBy pixelRatio\n    ctx = img.getContext "2d"\n    # ctx.scale pixelRatio, pixelRatio\n    # we are going to draw this morph and its children into "img".\n    # note that the children are not necessarily geometrically\n    # contained in the morph (in which case it would be ok to\n    # translate the context so that the origin of *this* morph is\n    # at the top-left of the "img" canvas).\n    # Hence we have to translate the context\n    # so that the origin of the entire bounds is at the\n    # very top-left of the "img" canvas.\n    ctx.translate -bounds.origin.x * pixelRatio , -bounds.origin.y * pixelRatio\n    @fullPaintIntoAreaOrBlitFromBackBuffer ctx, bounds, noShadow\n    img\n\n  fullImageNoShadow: ->\n    boundsWithNoShadow = @fullBoundsNoShadow()\n    return @fullImage boundsWithNoShadow, true\n\n  fullImageData: ->\n    # returns a string like "data:image/png;base64,iVBORw0KGgoAA..."\n    # note that "image/png" below could be omitted as it\'s\n    # the default, but leaving it here for clarity.\n    @fullImage().toDataURL "image/png"\n\n  # the way we take a picture here is different\n  # than the way we usually take a picture.\n  # Usually we ask the morph and submorphs to\n  # paint themselves anew into a new canvas.\n  # This is different: we take the area of the\n  # screen *as it is* and we crop the part of\n  # interest where the extent of our selected\n  # morph is. This means that the morph might\n  # be occluded by other things.\n  # The advantage here is that we capture\n  # the screen absolutely as is, without\n  # causing any repaints. If streaks are on the\n  # screen due to bad painting, we capture them\n  # exactly as the user sees them.\n  fullImageAsItAppearsOnScreen: ->\n    fullExtentOfMorph = @fullBounds()\n    destCanvas = newCanvas fullExtentOfMorph.extent().scaleBy pixelRatio\n    destCtx = destCanvas.getContext \'2d\'\n    destCtx.drawImage world.worldCanvas,\n      fullExtentOfMorph.topLeft().x * pixelRatio,\n      fullExtentOfMorph.topLeft().y * pixelRatio,\n      fullExtentOfMorph.width() * pixelRatio,\n      fullExtentOfMorph.height() * pixelRatio,\n      0,\n      0,\n      fullExtentOfMorph.width() * pixelRatio,\n      fullExtentOfMorph.height() * pixelRatio\n\n    return destCanvas.toDataURL "image/png"\n\n  fullImageHashCode: ->\n    return hashCode @fullImageData()\n  \n  # Morph shadow.\n  # The canvas with the shadow is completely\n  # transparent apart from the shadow\n  # "overflowing" from the edges.\n  # For example if you create the shadow for\n  # a blue rectangle by running this method,\n  # you\'ll get a canvas with\n  # a transparent rectangle in the middle and the\n  # "leaking" shadow.\n  # The "completely" transparent bit is actually\n  # partially transparent if the fill of the\n  # rectangle is semi-transparent, i.e. you can\n  # see the shadow through a semitransparent\n  # morph.\n  # So, the shadow of a blue semi-transparent box\n  # *will* contain some semi-transparent fill of\n  # the box.\n  shadowImage: (\n    offset = (new Point 7, 7),\n    clr = (new Color 0, 0, 0),\n    blurred\n    ) ->\n    \n    blur = @shadowBlur\n    fb = @fullBoundsNoShadow().extent().add blur * 2\n\n    # take "the image" which is the image of all the\n    # morphs. This image contains no shadows, the shadow\n    # will be made starting from this image in a second.\n    img = @fullImageNoShadow()\n\n    # draw the image in special "shadowBlur" mode\n    # http://www.w3schools.com/tags/canvas_shadowblur.asp\n    sha = newCanvas fb.scaleBy pixelRatio\n    ctx = sha.getContext "2d"\n    #ctx.scale pixelRatio, pixelRatio\n    ctx.shadowOffsetX = offset.x * pixelRatio\n    ctx.shadowOffsetY = offset.y * pixelRatio\n    if blurred\n      ctx.shadowBlur = blur * pixelRatio\n    ctx.shadowColor = clr.toString()\n    ctx.drawImage img, Math.round((blur - offset.x)*pixelRatio), Math.round((blur - offset.y)*pixelRatio)\n    # now redraw the image in destination-out mode so that\n    # it "cuts-out" everything that is not the actual shadow\n    # around the edges. This is so we can draw the shadow ON TOP\n    # of the morph and it\'s gonna loook OK (cause there is a hole\n    # where the morph can peek through as it\'s drawn after the\n    # shadow)\n    ctx.shadowOffsetX = 0\n    ctx.shadowOffsetY = 0\n    ctx.shadowBlur = 0\n    ctx.globalCompositeOperation = "destination-out"\n    ctx.drawImage img, Math.round((blur - offset.x)*pixelRatio), Math.round((blur - offset.y)*pixelRatio)\n    sha\n  \n  isBeingFloatDragged: ->\n\n    if !world.hand?\n      return false\n\n    # first check if the hand is floatdragging\n    # anything, in that case if it\'s floatdragging\n    # it can\'t be non-floatdragging\n    if world.hand.nonFloatDraggedMorph?\n      return false\n\n    # then check if my root is the hand\n    if @root() instanceof HandMorph\n      return true\n\n    # if we are here it means we are not being\n    # nonfloatdragged\n    return false\n\n  # shadow is added to a morph by\n  # the HandMorph while floatDragging\n  addFullShadow: (offset, alpha, color) ->\n    shadow = @silentAddFullShadow offset, alpha, color\n    shadow.reLayout()\n    \n    @fullChanged()\n    shadow\n\n  silentAddFullShadow: (offset, alpha, color) ->\n    @removeShadowMorph()\n    shadow = new ShadowMorph @, offset, alpha, color\n    @addChildFirst shadow\n    shadow\n  \n  getShadowMorph: ->\n    return @topmostChildSuchThat (child) ->\n      child instanceof ShadowMorph\n  \n  removeShadowMorph: ->\n    shadow = @getShadowMorph()\n    if shadow?\n      @fullChanged()\n      @removeChild shadow\n  \n  \n  \n  # Morph updating ///////////////////////////////////////////////////////////////\n  changed: ->\n    if trackChanges[trackChanges.length - 1]\n\n      # if the morph is attached to a hand then\n      # there is also a shadow to change, so we\n      # change everything that is attached\n      # to the hand, which means we issue a\n      # fullChanged()\n      if @isBeingFloatDragged()\n        world.hand.fullChanged()\n        return\n\n      # you could check directly if it\'s in the array\n      # but we use a flag because it\'s faster.\n      if !@geometryOrPositionPossiblyChanged\n        window.morphsThatMaybeChangedGeometryOrPosition.push @\n        @geometryOrPositionPossiblyChanged = true\n\n    @parent.childChanged @  if @parent\n\n  # to actually make sure if a morph has changed\n  # position, you need to check it and all its\n  # parents.\n  # See comment on the fullGeometryOrPositionPossiblyChanged\n  # property above for more info.\n  hasMaybeChangedGeometryOrPosition: ->\n    if @fullGeometryOrPositionPossiblyChanged or @geometryOrPositionPossiblyChanged\n      return true\n    else\n      if @parent?\n        return @parent.hasMaybeChangedGeometryOrPosition()\n      else\n        return false\n  \n  # See comment on the fullGeometryOrPositionPossiblyChanged\n  # property above for more info.\n  fullChanged: ->\n    if trackChanges[trackChanges.length - 1]\n      if !@fullGeometryOrPositionPossiblyChanged\n        window.morphsThatMaybeChangedFullGeometryOrPosition.push @\n        @fullGeometryOrPositionPossiblyChanged = true\n  \n  childChanged: ->\n    # react to a  change in one of my children,\n    # default is to just pass this message on upwards\n    # override this method for Morphs that need to adjust accordingly\n    @parent.childChanged @  if @parent\n  \n  \n  # Morph accessing - structure //////////////////////////////////////////////\n\n  # EXPLANATION of "silent" vs. "raw" vs. "normal" hyerarchy/bounds change methods\n  # ------------------------------------------------------------------------------\n  # ânormalâ: these are the highest-level methods and take into account layouts.\n  #           Should use these ones as much as possible. Call the "raw"\n  #           versions below\n  # ârawâ: lower level. This is what the re-layout routines use. Usually call the\n  #        silent version below.\n  # âsilentâ: doesnât mark the morph as changed\n  #\n  # It\'s important that lower-level functions don\'t ever call the higher-level\n  # functions, as that\'s architecturally incorrect and can cause infinite loops in\n  # the invocations.\n\n  imBeingAddedTo: (newParentMorph) ->\n    @reLayout()\n\n  addAsSiblingAfterMe: (aMorph, position = null, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING) ->\n    myPosition = @positionAmongSiblings()\n    @parent.add aMorph, (myPosition + 1), layoutSpec\n\n  addAsSiblingBeforeMe: (aMorph, position = null, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING) ->\n    myPosition = @positionAmongSiblings()\n    @parent.add aMorph, myPosition, layoutSpec\n\n  # this level of indirection is needed because\n  # you have a "raw" "tree" need of adding stuff\n  # and a higher level way to "add".\n  # For example, a ScrollFrameMorph does a "high-level"\n  # add of things in a different way, as it actually adds\n  # stuff to a frame inside it. Hence a need to have\n  # both a high-level and a low-level.\n  # For most morphs the two things coincide, and the\n  # high-level just calls the low-level.\n  add: (aMorph, position = null, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING) ->\n    @addRaw arguments...\n  \n  # attaches submorph on top\n  # ??? TODO you should handle the case of Morph\n  #     being added to itself and the case of\n  # ??? TODO a Morph being added to one of its\n  #     children\n  addRaw: (aMorph, position = null, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING) ->\n\n    # let\'s check if we are trying to add\n    # an ancestor of me below me.\n    # That would be impossible to do,\n    # so we return null to signal the error.\n    if aMorph.isAncestorOf @\n      return null\n\n    aMorph.parent?.invalidateLayout()\n\n    aMorph.layoutSpec = layoutSpec\n    if layoutSpec != LayoutSpec.ATTACHEDAS_FREEFLOATING\n      @invalidateLayout()\n\n    aMorph.fullChanged()\n    @silentAdd aMorph, true, position\n    aMorph.imBeingAddedTo @\n    return aMorph\n\n  addInset: (aMorph) ->\n\n    if aMorph.parent?\n      aMorph.changed()\n\n    @insetMorph = aMorph\n\n    if @children.length > 0\n      if @children[0] instanceof ShadowMorph\n        @add aMorph, 1\n      else\n        @add aMorph, 0\n    else\n      @add aMorph, 0\n\n    aMorph.fullRawMoveTo @insetPosition()\n    aMorph.rawSetExtent @insetSpaceExtent(), @\n\n\n  sourceChanged: ->\n    @reLayout?() \n    @changed?()\n\n\n  # this is done before the updating of the\n  # backing store in some morphs that\n  # need to figure out their whole\n  # layout (which depends on the children)\n  # before painting themselves\n  # e.g. the MenuMorph\n  reLayout: ->\n\n\n  calculateAndUpdateExtent: ->\n\n  silentAdd: (aMorph, avoidExtentCalculation, position = null) ->\n    # the morph that is being\n    # attached might be attached to\n    # a clipping morph. So we\n    # need to do a "changed" here\n    # to make sure that anything that\n    # is outside the clipping Morph gets\n    # painted over.\n    owner = aMorph.parent\n    if owner?\n      owner.removeChild aMorph\n    aMorph.isMarkedForDestruction = false\n    @addChild aMorph, position\n    if !avoidExtentCalculation\n      aMorph.calculateAndUpdateExtent()\n  \n  \n\n  # never currently used in ZK\n  # TBD whether this is 100% correct,\n  # see "topMorphUnderPointer" implementation in\n  # HandMorph.\n  # Also there must be a quicker implementation\n  # cause there is no need to create the entire\n  # morph list. It would be sufficient to\n  # navigate the structure and just return\n  # at the first morph satisfying the test.\n  morphAt: (aPoint) ->\n    morphs = @allChildrenTopToBottom()\n    result = null\n    morphs.forEach (m) ->\n      if m.fullBounds().containsPoint(aPoint) and (result is null)\n        result = m\n\n    result\n  \n  #\n  #	potential alternative - solution for morphAt.\n  #	Has some issues, commented out for now...\n  #\n  #Morph::morphAt = function (aPoint) {\n  #	return this.topMorphSuchThat(function (m) {\n  #		return m.fullBounds().containsPoint(aPoint);\n  #	});\n  #};\n  #\n  \n\n  # Duplication and Serialization /////////////////////////////////////////\n\n\n  duplicateMenuAction: ->\n    aFullCopy = @fullCopy()\n    aFullCopy.pickUp()\n\n  # in case we copy a morph, if the original was in some\n  # data structures related to broken morphs, then\n  # we have to add the copy too.\n  alignCopiedMorphToBrokenInfoDataStructures: (copiedMorph) ->\n    if window.morphsThatMaybeChangedGeometryOrPosition.indexOf(@) != -1 and\n     window.morphsThatMaybeChangedGeometryOrPosition.indexOf(copiedMorph) == -1\n      window.morphsThatMaybeChangedGeometryOrPosition.push copiedMorph\n\n    if window.morphsThatMaybeChangedFullGeometryOrPosition.indexOf(@) != -1 and\n     window.morphsThatMaybeChangedFullGeometryOrPosition.indexOf(copiedMorph) == -1\n      window.morphsThatMaybeChangedFullGeometryOrPosition.push copiedMorph\n\n  # in case we copy a morph, if the original was in some\n  # stepping structures, then we have to add the copy too.\n  alignCopiedMorphToSteppingStructures: (copiedMorph) ->\n    if world.steppingMorphs.indexOf(@) != -1\n      world.addSteppingMorph copiedMorph\n\n  # note that the entire copying mechanism\n  # should also take care of inserting the copied\n  # morph in whatever other data structures where the\n  # original morph was.\n  # For example, if the Morph appeared in a data\n  # structure related to the broken rectangles mechanism,\n  # we should place the copied morph there.\n  fullCopy: ()->\n    allMorphsInStructure = @allChildrenBottomToTop()\n    copiedMorph = @deepCopy false, [], [], allMorphsInStructure\n    if copiedMorph instanceof MenuMorph\n      copiedMorph.onClickOutsideMeOrAnyOfMyChildren null\n      copiedMorph.killThisMenuIfClickOnDescendantsTriggers = false\n      copiedMorph.killThisMenuIfClickOutsideDescendants = false\n\n    return copiedMorph\n\n  serialize: ()->\n    allMorphsInStructure = @allChildrenBottomToTop()\n    arr1 = []\n    arr2 = []\n    @deepCopy true, arr1, arr2, allMorphsInStructure\n    totalJSON = ""\n\n    for element in arr2\n      try\n        console.log JSON.stringify(element) + "\\n// --------------------------- \\n"\n      catch e\n        debugger\n\n      totalJSON = totalJSON + JSON.stringify(element) + "\\n// --------------------------- \\n"\n    return totalJSON\n\n\n  # Deserialization /////////////////////////////////////////\n\n\n  deserialize: (serializationString) ->\n    # this is to ignore all the comment strings\n    # that might be there for reading purposes\n    objectsSerializations = serializationString.split /^\\/\\/.*$/gm\n    # the serialization ends with a comment so\n    # last element is empty, pop it\n    objectsSerializations.pop()\n\n    createdObjects = []\n    for eachSerialization in objectsSerializations\n      createdObjects.push JSON.parse eachSerialization\n\n    clonedMorphs = []\n    for eachObject in createdObjects\n      # note that the constructor method is not run!\n      #console.log "cloning:" + eachMorph.className\n      #console.log "with:" + namedClasses[eachMorph.className]\n      if eachObject.className == "Canvas"\n        theClone = newCanvas new Point eachObject.width, eachObject.height\n        ctx = theClone.getContext "2d"\n\n        image = new Image();\n        image.src = eachObject.data\n        # if something doesn\'t get painted here,\n        # it might be because the allocation of the image\n        # would actually be asynchronous, in theory\n        # you\'d have to do the drawImage in a callback\n        # on onLoad of the image...\n        ctx.drawImage image, 0, 0\n\n      else if eachObject.constructor != Array\n        theClone = Object.create namedClasses[eachObject.className]\n        if theClone.assignUniqueID?\n          theClone.assignUniqueID()\n      else\n        theClone = []\n      clonedMorphs.push theClone\n      #theClone.constructor()\n\n    for i in [0... clonedMorphs.length]\n      eachClonedMorph = clonedMorphs[i]\n      if eachClonedMorph.constructor == HTMLCanvasElement\n        # do nothing\n      else if eachClonedMorph.constructor != Array\n        for property of createdObjects[i]\n          # also includes the "parent" property\n          if createdObjects[i].hasOwnProperty property\n            console.log "looking at property: " + property\n            clonedMorphs[i][property] = createdObjects[i][property]\n            if typeof clonedMorphs[i][property] is "string"\n              if (clonedMorphs[i][property].indexOf "$") == 0\n                referenceNumberAsString = clonedMorphs[i][property].substring(1)\n                referenceNumber = parseInt referenceNumberAsString\n                clonedMorphs[i][property] = clonedMorphs[referenceNumber]\n      else\n        for j in [0... createdObjects[i].length]\n          eachArrayElement = createdObjects[i][j]\n          clonedMorphs[i][j] = createdObjects[i][j]\n          if typeof eachArrayElement is "string"\n            if (eachArrayElement.indexOf "$") == 0\n              referenceNumberAsString = eachArrayElement.substring(1)\n              referenceNumber = parseInt referenceNumberAsString\n              clonedMorphs[i][j] = clonedMorphs[referenceNumber]\n\n\n    return clonedMorphs[0]\n\n  # Injecting code /////////////////////////////////////////\n\n  # if a function, the txt must contain the parameters and\n  # the arrow and the body\n  injectProperty: (propertyName, txt) ->\n    try\n      # this.target[propertyName] = evaluate txt\n      @evaluateString "@" + propertyName + " = " + txt\n      # if we are saving a function, we\'d like to\n      # keep the source code so we can edit Coffeescript\n      # again.\n      if isFunction @[propertyName]\n        @[propertyName + "_source"] = txt\n      @sourceChanged()\n    catch err\n      @inform err\n\n  injectProperties: (codeBlurb) ->\n\n    codeBlurb = codeBlurb.replace(/^[ \\t]*$/gm,"\\n")\n    codeBlurb = codeBlurb + "\\n# end injected code"\n\n    # ([a-zA-Z_$][0-9a-zA-Z_$]*) is the variable name\n    regex = /^([a-zA-Z_$][0-9a-zA-Z_$]*)[ \\t]*=[ \\t]*([^]*?)(?=^[\\w#$])/gm\n\n    while (m = regex.exec(codeBlurb)) != null\n      # This is necessary to avoid infinite loops with zero-width matches\n      if m.index == regex.lastIndex\n        regex.lastIndex++\n      # The result can be accessed through the `m`-variable.\n      #m.forEach (match, groupIndex) ->\n      #  console.log \'\'\n      @injectProperty m[1],m[2]\n  \n  # Morph floatDragging and dropping /////////////////////////////////////////\n  \n  isFloatDraggable: ->\n    if @parent?\n\n      # an instance of ScrollFrameMorph is also an instance of FrameMorph\n      # so gotta do this check first ahead of next paragraph.\n      maybeScrollFrameMorphAncestor = @parentThatIsA ScrollFrameMorph\n      if maybeScrollFrameMorphAncestor?\n        maybeScrollFrameMorphAncestor = maybeScrollFrameMorphAncestor[0]\n        if maybeScrollFrameMorphAncestor.canScrollByDraggingForeground and\n        maybeScrollFrameMorphAncestor.anyScrollBarShowing()\n          return false\n        else\n          return true\n\n      if (@parent instanceof WorldMorph) or (@parent instanceof FrameMorph)\n        return true\n    return false\n\n  rootForGrab: ->\n    if @ instanceof ShadowMorph\n      return @parent.rootForGrab()\n    if @parent is null or\n      @parent instanceof WorldMorph or\n      ((@parent instanceof FrameMorph) and !(@parent instanceof ScrollFrameMorph))\n        return @  \n    @parent.rootForGrab()\n\n  firstContainerMenu: ->\n    scanningMorphs = @\n    while scanningMorphs.parent?\n      scanningMorphs = scanningMorphs.parent\n      if scanningMorphs instanceof MenuMorph\n        if !scanningMorphs.isMarkedForDestruction\n          return scanningMorphs\n    return scanningMorphs\n\n    if @ instanceof ShadowMorph\n      return @parent.rootForFocus()\n    if @parent is null or\n      @parent instanceof WorldMorph\n        return @  \n    @parent.rootForFocus()\n\n  rootForFocus: ->\n    if @ instanceof ShadowMorph\n      return @parent.rootForFocus()\n    if @parent is null or\n      @parent instanceof WorldMorph\n        return @  \n    @parent.rootForFocus()\n\n  moveInFrontOfSiblings: ->\n    @moveAsLastChild()\n    @fullChanged()\n\n  bringToForegroud: ->\n    @rootForFocus()?.moveAsLastChild()\n    @rootForFocus()?.fullChanged()\n\n  propagateKillMenus: ->\n    if @parent?\n      @parent.propagateKillMenus()\n\n  mouseDownLeft: (pos) ->\n    @bringToForegroud()\n    @escalateEvent "mouseDownLeft", pos\n\n  mouseClickLeft: (pos) ->\n    @escalateEvent "mouseClickLeft", pos\n\n  onClickOutsideMeOrAnyOfMyChildren: (functionName, arg1, arg2, arg3)->\n    if functionName?\n      @clickOutsideMeOrAnyOfMeChildrenCallback = [functionName, arg1, arg2, arg3]\n      if @ not in world.morphsDetectingClickOutsideMeOrAnyOfMeChildren\n        world.morphsDetectingClickOutsideMeOrAnyOfMeChildren.push @\n    else\n      #console.log "****** onClickOutsideMeOrAnyOfMyChildren removing element"\n      world.morphsDetectingClickOutsideMeOrAnyOfMeChildren.remove @\n\n  justDropped: ->\n      @removeShadowMorph()\n    \n  wantsDropOf: (aMorph) ->\n    return @_acceptsDrops\n\n  enableDrops: ->\n    @_acceptsDrops = true\n\n  disableDrops: ->\n    @_acceptsDrops = false\n  \n  pickUp: ->\n    world.hand.grab @\n    @fullRawMoveTo world.hand.position().subtract @fullBoundsNoShadow().extent().floorDivideBy 2\n  \n  # note how this verified that\n  # at *any point* up in the\n  # morphs hierarchy there is a HandMorph\n  isPickedUp: ->\n    @parentThatIsA(HandMorph)?\n  \n  situation: ->\n    # answer a dictionary specifying where I am right now, so\n    # I can slide back to it if I\'m dropped somewhere else\n    if @parent\n      return (\n        origin: @parent\n        position: @position().subtract @parent.position()\n      )\n    null\n  \n  slideBackTo: (situation, steps = 5) ->\n    pos = situation.origin.position().add situation.position\n    xStep = -(@left() - pos.x) / steps\n    yStep = -(@top() - pos.y) / steps\n    stepCount = 0\n    oldStep = @step\n    oldFps = @fps\n    @fps = 0\n    world.addSteppingMorph @\n    @step = =>\n      @silentFullRawMoveBy new Point xStep, yStep\n      @fullChanged()\n      stepCount += 1\n      if stepCount is steps\n        situation.origin.add @\n        situation.origin.reactToDropOf @  if situation.origin.reactToDropOf\n        @step = oldStep\n        @fps = oldFps\n        if @step == noOperation or !@step?\n          world.removeSteppingMorph @\n  \n  \n  # Morph utilities ////////////////////////////////////////////////////////\n  \n  showResizeAndMoveHandlesAndLayoutAdjusters: ->\n    if @layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING\n      world.temporaryHandlesAndLayoutAdjusters.push new HandleMorph(@, "resizeHorizontalHandle")\n      world.temporaryHandlesAndLayoutAdjusters.push new HandleMorph(@, "resizeVerticalHandle")\n      world.temporaryHandlesAndLayoutAdjusters.push new HandleMorph(@, "moveHandle")\n      world.temporaryHandlesAndLayoutAdjusters.push new HandleMorph(@, "resizeBothDimensionsHandle")\n    else\n      if (@lastSiblingBeforeMeSuchThat((m) -> m.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED)?) and !@siblingBeforeMeIsA(StackElementsSizeAdjustingMorph)\n        world.temporaryHandlesAndLayoutAdjusters.push \\\n          @addAsSiblingBeforeMe \\\n            new StackElementsSizeAdjustingMorph(),\n            null,\n            LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n\n      console.log "@: " + @.toString() + " amITheLastSibling: " + @amITheLastSibling()\n\n      if (@firstSiblingAfterMeSuchThat((m) -> m.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED)?) and !@siblingAfterMeIsA(StackElementsSizeAdjustingMorph)\n        world.temporaryHandlesAndLayoutAdjusters.push \\\n          @addAsSiblingAfterMe \\\n            new StackElementsSizeAdjustingMorph(),\n            null,\n            LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n      if @parent?\n        @parent.showResizeAndMoveHandlesAndLayoutAdjusters()\n  \n  showMoveHandle: ->\n    world.temporaryHandlesAndLayoutAdjusters.push new HandleMorph @, "moveHandle"\n  \n  hint: (msg) ->\n    text = msg\n    if msg\n      text = msg.toString()  if msg.toString\n    else\n      text = "NULL"\n    m = new MenuMorph false, @, true, true, text\n    m.popUpCenteredAtHand world\n  \n  inform: (msg) ->\n    text = msg\n    if msg\n      text = msg.toString()  if msg.toString\n    else\n      text = "NULL"\n    m = new MenuMorph false, @, true, true, text\n    m.addItem "Ok"\n    m.popUpCenteredAtHand world\n\n  prompt: (msg, target, callback, defaultContents, width, floorNum,\n    ceilingNum, isRounded) ->\n\n    prompt = new PromptMorph(msg, target, callback, defaultContents, width, floorNum,\n    ceilingNum, isRounded)\n\n    prompt.popUpAtHand @firstContainerMenu()\n    prompt.tempPromptEntryField.text.edit()\n\n  textPrompt: (msg, target, callback, defaultContents, width, floorNum,\n    ceilingNum, isRounded) ->\n\n    prompt = new TextPromptMorph(msg, target, callback, defaultContents, width, floorNum,\n    ceilingNum, isRounded)\n\n    prompt.setExtent new Point 600,400\n\n    world.add prompt\n    prompt.fullMoveTo world.hand.position().subtract new Point 50, 100\n    prompt.fullRawMoveWithin world\n\n    #prompt.popUpAtHand @firstContainerMenu()\n    #prompt.tempPromptEntryField.edit()\n\n  reactToSliderAction1: (num, theMenu) ->\n    theMenu.tempPromptEntryField.changed()\n    theMenu.tempPromptEntryField.text.text = Math.round(num).toString()\n    theMenu.tempPromptEntryField.text.reLayout()\n    \n    theMenu.tempPromptEntryField.text.changed()\n    theMenu.tempPromptEntryField.text.edit()\n\n  reactToSliderAction2: (num, theMenu) ->\n    alert "I thought this wasn\'t used, add a note in the code about how this comes about"\n    theMenu.tempPromptEntryField.changed()\n    theMenu.tempPromptEntryField.text.text = num.toString()\n    theMenu.tempPromptEntryField.text.reLayout()\n    \n    theMenu.tempPromptEntryField.text.changed()\n  \n  pickColor: (msg, callback, defaultContents) ->\n    colorPicker = new ColorPickerMorph defaultContents\n    menu = new MenuMorph false, @, true, true, msg or "", colorPicker\n    menu.items.push colorPicker\n    menu.addLine 2\n    menu.addItem "Ok", true, @, callback\n\n    menu.addItem "Cancel", true, @, ->\n      null\n\n    menu.popUpAtHand @firstContainerMenu()\n\n  inspect: (anotherObject) ->\n    @spawnInspector @\n\n  inspect2: (anotherObject) ->\n    @spawnInspector2 @\n\n  spawnInspector: (inspectee) ->\n    inspector = new InspectorMorph inspectee\n    inspector.fullRawMoveTo world.hand.position()\n    inspector.fullRawMoveWithin world\n    world.add inspector\n    inspector.changed()\n\n  spawnInspector2: (inspectee) ->\n    inspector = new InspectorMorph2 inspectee\n    inspector.fullRawMoveTo world.hand.position()\n    inspector.setExtent new Point 560, 410\n    inspector.fullRawMoveWithin world\n    world.add inspector\n    inspector.changed()\n\n  spawnNextTo: (morphToBeNextTo) ->\n    morphToBeNextTo.parent.add @\n    @fullRawMoveTo \\\n      morphToBeNextTo.topRight().translateBy new Point 5, -5\n    @fullRawMoveWithin morphToBeNextTo.parent\n    \n  \n  # Morph menus ////////////////////////////////////////////////////////////////\n  \n  contextMenu: ->\n    # Spacial multiplexing\n    # (search "multiplexing" for the other parts of\n    # code where this matters)\n    # There are two interpretations of what this\n    # list should be:\n    #   1) all morphs "pierced through" by the pointer\n    #   2) all morphs parents of the topmost morph under the pointer\n    # 2 is what is used in Cuis\n    \n    # commented-out addendum for the implementation of 1):\n    #show the normal menu in case there is text selected,\n    #otherwise show the spacial multiplexing list\n    #if !@world().caret\n    #  if @world().hand.allMorphsAtPointer().length > 2\n    #    return @hierarchyMenu()\n    if @customContextMenu\n      return @customContextMenu()\n    if world.isDevMode\n      if @parent is world\n        return @developersMenu()\n      return @hierarchyMenu()\n    @userMenu() or (@parent and @parent.userMenu())\n  \n  # When user right-clicks on a morph that is a child of other morphs,\n  # then it\'s ambiguous which of the morphs she wants to operate on.\n  # An example is right-clicking on a SpeechBubbleMorph: did she\n  # mean to operate on the BubbleMorph or did she mean to operate on\n  # the TextMorph contained in it?\n  # This menu lets her disambiguate.\n  hierarchyMenu: ->\n    # Spacial multiplexing\n    # (search "multiplexing" for the other parts of\n    # code where this matters)\n    # There are two interpretations of what this\n    # list should be:\n    #   1) all morphs "pierced through" by the pointer\n    #   2) all morphs parents of the topmost morph under the pointer\n    # 2 is what is used in Cuis\n    # commented-out addendum for the implementation of 1):\n    # parents = @world().hand.allMorphsAtPointer().reverse()\n    parents = @allParentsTopToBottom()\n    menu = new MenuMorph false, @, true, true, null\n    # show an entry for each of the morphs in the hierarchy.\n    # each entry will open the developer menu for each morph.\n    parents.forEach (each) ->\n      if (each.developersMenu) and (each isnt world) and (!each.anyParentMarkedForDestruction())\n        textLabelForMorph = each.toString().slice 0, 50\n        menu.addItem textLabelForMorph + " â", false, each, "popupDeveloperMenu", null, null, null, null, null, null, null, true\n\n    menu\n\n  popupDeveloperMenu: (morphTriggeringThis)->\n    @developersMenu().popUpAtHand morphTriggeringThis.firstContainerMenu()\n\n\n  popUpColorSetter: ->\n    @pickColor "color:", "setColor", new Color 0,0,0\n\n  transparencyPopout: (menuItem)->\n    @prompt menuItem.parent.title + "\\nalpha\\nvalue:",\n      @,\n      "setAlphaScaled",\n      (@alpha * 100).toString(),\n      null,\n      1,\n      100,\n      true\n\n  createNewStringMorph2WithBackground: ->\n    newMorph = new StringMorph2 "Hello World! â²Æâ³â· â¸â¹ aaa",null,null,null,null,null,null,null, new Color(255, 255, 54), 0.5\n    newMorph.isEditable = true\n    world.create newMorph\n\n  createNewStringMorph2WithoutBackground: ->\n    newMorph = new StringMorph2 "Hello World! â²Æâ³â· â¸â¹ aaa"\n    newMorph.isEditable = true\n    world.create newMorph\n\n  createNewTextMorph2WithBackground: ->\n    newMorph = new TextMorph2(\n      "Lorem ipsum dolor sit amet, consectetur adipiscing " +\n      "elit. Integer rhoncus pharetra nulla, vel maximus " +\n      "lectus posuere a. Phasellus finibus blandit ex vitae " +\n      "varius. Vestibulum blandit velit elementum, ornare " +\n      "ipsum sollicitudin, blandit nunc. Mauris a sapien " +\n      "nibh. Nulla nec bibendum quam, eu condimentum nisl. " +\n      "Cras consequat efficitur nisi sed ornare. " +\n      "Pellentesque vitae urna vitae libero malesuada " +\n      "pharetra." +\n      "\\n\\n" +\n      "Pellentesque commodo, nulla mattis vulputate " +\n      "porttitor, elit augue vestibulum est, nec congue " +\n      "ex dui a velit. Nullam lectus leo, lobortis eget " +\n      "erat ac, lobortis dignissim magna. Morbi ac odio " +\n      "in purus blandit dignissim. Maecenas at sagittis " +\n      "odio. Suspendisse tempus mattis erat id euismod. " +\n      "Duis semper mauris nec odio sagittis vulputate. " +\n      "Praesent varius ac erat id fringilla. Suspendisse " +\n      "porta sollicitudin bibendum. Pellentesque imperdiet " +\n      "at eros nec euismod. Etiam ac mattis odio, ac finibus " +\n      "nisi.",null,null,null,null,null,new Color(255, 255, 54), 0.5)\n    newMorph.isEditable = true\n    #newMorph.maxTextWidth = 300\n    world.create newMorph\n\n  createDestroyIconMorph: ->\n    world.create new DestroyIconMorph()\n\n  createUnderCarpetIconMorph: ->\n    world.create new UnderCarpetIconMorph()\n\n  createUncollapsedStateIconMorph: ->\n    world.create new UncollapsedStateIconMorph()\n\n  createCollapsedStateIconMorph: ->\n    world.create new CollapsedStateIconMorph()\n\n  createCloseIconButtonMorph: ->\n    world.create new CloseIconButtonMorph()\n\n  createScratchAreaIconMorph: ->\n    world.create new ScratchAreaIconMorph()\n\n  createFloraIconMorph: ->\n    world.create new FloraIconMorph()\n\n  createScooterIconMorph: ->\n    world.create new ScooterIconMorph()\n\n  createHeartIconMorph: ->\n    world.create new HeartIconMorph()\n\n  showOutputPins: (a,b,c,d) ->\n    world.morphsToBePinouted.push b\n\n  removeOutputPins: (a,b,c,d) ->\n    world.morphsToBePinouted.remove b\n\n  testMenu: (a,targetMorph)->\n    menu = new MenuMorph false, targetMorph, true, true, null\n    menu.addItem "serialise morph to memory", true, targetMorph, "serialiseToMemory"\n    menu.addItem "deserialize from memory and attach to world", true, targetMorph, "deserialiseFromMemoryAndAttachToWorld"\n    menu.addItem "deserialize from memory and attach to hand", true, targetMorph, "deserialiseFromMemoryAndAttachToHand"\n    menu.addItem "attach with horizontal layout", true, @, "attachWithHorizLayout"\n    menu.addItem "make spacers transparent", true, @, "makeSpacersTransparent"\n    menu.addItem "make spacers opaque", true, @, "makeSpacersOpaque"\n    menu.addItem "show adders", true, @, "showAdders"\n    menu.addItem "remove adders", true, @, "removeAdders"\n    menu.addItem "StringMorph2 without background", true, @, "createNewStringMorph2WithoutBackground"\n    menu.addItem "StringMorph2 with background", true, @, "createNewStringMorph2WithBackground"\n    menu.addItem "TextMorph2 with background", true, @, "createNewTextMorph2WithBackground"\n    if targetMorph in world.morphsToBePinouted\n      menu.addItem "remove output pins", true, @, "removeOutputPins"\n    else\n      menu.addItem "show output pins", true, @, "showOutputPins"\n    \n    # unclear whether the "un-collapse" entry would ever be\n    # visible.\n    if targetMorph.collapsed\n      menu.addItem "un-collapse", true, @, "unCollapse"\n    else\n      menu.addItem "collapse", true, @, "collapse"\n\n    menu.addItem "create pointer", true, @, "createPointerMorph"\n    menu.addItem "others â", false, @, "popUpSecondMenu", "others"\n\n\n    menu.popUpAtHand a.firstContainerMenu()\n\n  underTheCarpetIconAndText: ->\n    world.create new UnderTheCarpetOpenerMorph()\n\n  analogClock: ->\n    world.create new AnalogClockMorph()\n\n  popUpIconsMenu: (morphTriggeringThis) ->\n    menu = new MenuMorph false, @, true, true, "icons"\n    menu.addItem "Destroy icon", true, @, "createDestroyIconMorph"\n    menu.addItem "Under the carpet icon", true, @, "createUnderCarpetIconMorph"\n    menu.addItem "Collapsed state icon", true, @, "createCollapsedStateIconMorph"\n    menu.addItem "Uncollapsed state icon", true, @, "createUncollapsedStateIconMorph"\n    menu.addItem "Close icon", true, @, "createCloseIconButtonMorph"\n    menu.addItem "Scratch area icon", true, @, "createScratchAreaIconMorph"\n    menu.addItem "Flora icon", true, @, "createFloraIconMorph"\n    menu.addItem "Scooter icon", true, @, "createScooterIconMorph"\n    menu.addItem "Heart icon", true, @, "createHeartIconMorph"\n\n    menu.popUpAtHand morphTriggeringThis.firstContainerMenu()\n\n  popUpSecondMenu: (morphTriggeringThis) ->\n    menu = new MenuMorph false, @, true, true, "others"\n    menu.addItem "icons â", false, @, "popUpIconsMenu", "icons"\n    menu.addItem "under the carpet", true, @, "underTheCarpetIconAndText"\n    menu.addItem "analog clock", true, @, "analogClock"\n    menu.addItem "inspect 2", true, @, "inspect2", "open a window\\non all properties"\n    menu.addItem "fizzytiles", true, menusHelper, "createFridgeMagnets"\n    menu.addItem "fizzypaint", true, menusHelper, "createReconfigurablePaint"\n    menu.addItem "simple button", true, menusHelper, "createSimpleButton"\n    menu.addItem "switch button", true, menusHelper, "createSwitchButtonMorph"\n    \n\n    menu.popUpAtHand morphTriggeringThis.firstContainerMenu()\n\n  serialiseToMemory: ->\n    world.lastSerializationString = @serialize()\n\n  deserialiseFromMemoryAndAttachToHand: ->\n    derezzedObject = world.deserialize world.lastSerializationString\n    derezzedObject.pickUp()\n\n  deserialiseFromMemoryAndAttachToWorld: ->\n    derezzedObject = world.deserialize world.lastSerializationString\n    world.add derezzedObject\n\n  developersMenuOfMorph: ->\n    # \'name\' is not an official property of a function, hence:\n    userMenu = @userMenu() or (@parent and @parent.userMenu())\n    menu = new MenuMorph(false, \n      @,\n      true,\n      true,\n      @constructor.name or @constructor.toString().split(" ")[1].split("(")[0])\n\n    if window.location.href.contains "worldWithSystemTestHarness"\n      if userMenu\n        menu.addItem "user features...", true, @, ->\n          userMenu.popUpAtHand @firstContainerMenu()\n\n        menu.addLine()\n      menu.addItem "color...", true, @, "popUpColorSetter" , "choose another color \\nfor this morph"\n      menu.addItem "transparency...", true, @, "transparencyPopout", "set this morph\'s\\nalpha value"\n      menu.addItem "resize/move...", true, @, "showResizeAndMoveHandlesAndLayoutAdjusters", "show a handle\\nwhich can be floatDragged\\nto change this morph\'s" + " extent"\n      menu.addLine()\n      menu.addItem "duplicate", true, @, "duplicateMenuAction" , "make a copy\\nand pick it up"\n      menu.addItem "pick up", true, @, "pickUp", "disattach and put \\ninto the hand"\n      menu.addItem "attach...", true, @, "attach", "stick this morph\\nto another one"\n      menu.addItem "move", true, @, "showMoveHandle", "show a handle\\nwhich can be floatDragged\\nto move this morph"\n      menu.addItem "inspect", true, @, "inspect", "open a window\\non all properties"\n\n      # A) normally, just take a picture of this morph\n      # and open it in a new tab.\n      # B) If a test is being recorded, then the behaviour\n      # is slightly different: a system test command is\n      # triggered to take a screenshot of this particular\n      # morph.\n      # C) If a test is being played, then the screenshot of\n      # the particular morph is put in a special place\n      # in the test player. The command recorded at B) is\n      # going to replay but *waiting* for that screenshot\n      # first.\n      takePic = =>\n        switch AutomatorRecorderAndPlayer.state\n          when AutomatorRecorderAndPlayer.RECORDING\n            # While recording a test, just trigger for\n            # the takeScreenshot command to be recorded. \n            window.world.automatorRecorderAndPlayer.takeScreenshot @\n          when AutomatorRecorderAndPlayer.PLAYING\n            # While playing a test, this command puts the\n            # screenshot of this morph in a special\n            # variable of the system test runner.\n            # The test runner will wait for this variable\n            # to contain the morph screenshot before\n            # doing the comparison as per command recorded\n            # in the case above.\n            window.world.automatorRecorderAndPlayer.imageDataOfAParticularMorph = @fullImageData()\n          else\n            # no system tests recording/playing ongoing,\n            # just open new tab with image of morph.\n            window.open @fullImageData()\n      menu.addItem "take pic", true, @, "takePic", "open a new window\\nwith a picture of this morph"\n\n      menu.addItem "test menu â", false, @, "testMenu", "debugging and testing operations"\n\n      menu.addLine()\n      if @isFloatDraggable()\n        menu.addItem "lock", true, @, "toggleIsfloatDraggable", "make this morph\\nunmovable"\n      else\n        menu.addItem "unlock", true, @, "toggleIsfloatDraggable", "make this morph\\nmovable"\n      menu.addItem "hide", true, @, "hide"\n      menu.addItem "delete", true, @, "fullDestroy"\n    else\n      menu.addItem "color...", true, @, "popUpColorSetter" , "choose another color \\nfor this morph"\n      menu.addItem "transparency...", true, @, "transparencyPopout", "set this morph\'s\\nalpha value"\n      menu.addItem "resize/move...", true, @, "showResizeAndMoveHandlesAndLayoutAdjusters", "show a handle\\nwhich can be floatDragged\\nto change this morph\'s" + " extent"\n      menu.addLine()\n      menu.addItem "duplicate", true, @, "duplicateMenuAction" , "make a copy\\nand pick it up"\n      menu.addItem "pick up", true, @, "pickUp", "disattach and put \\ninto the hand"\n      menu.addItem "attach...", true, @, "attach", "stick this morph\\nto another one"\n      menu.addItem "inspect", true, @, "inspect2", "open a window\\non all properties"\n      menu.addLine()\n      if @isFloatDraggable()\n        menu.addItem "lock", true, @, "toggleIsfloatDraggable", "make this morph\\nunmovable"\n      else\n        menu.addItem "unlock", true, @, "toggleIsfloatDraggable", "make this morph\\nmovable"\n      menu.addItem "hide", true, @, "hide"\n      menu.addItem "delete", true, @, "fullDestroy"\n\n\n    menu\n\n  developersMenu: ->\n    menu = @developersMenuOfMorph()\n    if @addShapeSpecificMenus?\n      menu = @addShapeSpecificMenus menu\n    menu\n\n  userMenu: ->\n    null  \n  \n  # Morph menu actions\n  calculateAlphaScaled: (alpha) ->\n    if typeof alpha is "number"\n      unscaled = alpha / 100\n      return Math.min Math.max(unscaled, 0.1), 1\n    else\n      newAlpha = parseFloat alpha\n      unless isNaN newAlpha\n        unscaled = newAlpha / 100\n        return Math.min Math.max(unscaled, 0.1), 1\n\n  setPadding: (paddingOrMorphGivingPadding, morphGivingPadding) ->\n    if morphGivingPadding?.getValue?\n      padding = morphGivingPadding.getValue()\n    else\n      padding = paddingOrMorphGivingPadding\n\n    console.log " >>>>>>>>>>>>> padding: " + padding\n    #if padding == 1\n    #  debugger\n    if @paddingTop != padding or @paddingBottom != padding or @paddingLeft != padding or @paddingRight != padding\n      @paddingTop = padding\n      @paddingBottom = padding\n      @paddingLeft = padding\n      @paddingRight = padding\n      @changed()\n\n    return padding\n\n  setPaddingTop: (paddingOrMorphGivingPadding, morphGivingPadding) ->\n    if morphGivingPadding?.getValue?\n      padding = morphGivingPadding.getValue()\n    else\n      padding = paddingOrMorphGivingPadding\n\n    if padding\n      unless @paddingTop == padding\n        @paddingTop = padding\n        @changed()\n\n    return padding\n\n  setPaddingBottom: (paddingOrMorphGivingPadding, morphGivingPadding) ->\n    if morphGivingPadding?.getValue?\n      padding = morphGivingPadding.getValue()\n    else\n      padding = paddingOrMorphGivingPadding\n\n    if padding\n      unless @paddingBottom == padding\n        @paddingBottom = padding\n        @changed()\n\n    return padding\n\n  setPaddingLeft: (paddingOrMorphGivingPadding, morphGivingPadding) ->\n    if morphGivingPadding?.getValue?\n      padding = morphGivingPadding.getValue()\n    else\n      padding = paddingOrMorphGivingPadding\n\n    if padding\n      unless @paddingLeft == padding\n        @paddingLeft = padding\n        @changed()\n\n    return padding\n\n  setPaddingRight: (paddingOrMorphGivingPadding, morphGivingPadding) ->\n    if morphGivingPadding?.getValue?\n      padding = morphGivingPadding.getValue()\n    else\n      padding = paddingOrMorphGivingPadding\n\n    if padding\n      unless @paddingRight == padding\n        @paddingRight = padding\n        @changed()\n\n    return padding\n\n  setAlphaScaled: (alphaOrMorphGivingAlpha, morphGivingAlpha) ->\n    if morphGivingAlpha?.getValue?\n      alpha = morphGivingAlpha.getValue()\n    else\n      alpha = alphaOrMorphGivingAlpha\n\n    if alpha\n      alpha = @calculateAlphaScaled alpha\n      unless @alpha == alpha\n        @alpha = alpha\n        @changed()\n\n    return alpha\n\n  newParentChoice: (ignored, theMorphToBeAttached) ->\n    # this is what happens when "each" is\n    # selected: we attach the selected morph\n    @add theMorphToBeAttached\n    if @ instanceof ScrollFrameMorph\n      @adjustContentsBounds()\n      @adjustScrollBars()\n\n  newParentChoiceWithHorizLayout: (ignored, theMorphToBeAttached) ->\n    # this is what happens when "each" is\n    # selected: we attach the selected morph\n    @add theMorphToBeAttached, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    if @ instanceof ScrollFrameMorph\n      @adjustContentsBounds()\n      @adjustScrollBars()\n\n  attach: ->\n    choices = world.plausibleTargetAndDestinationMorphs @\n\n    # my direct parent might be in the\n    # options which is silly, leave that one out\n    choicesExcludingParent = []\n    choices.forEach (each) =>\n      if each != @parent\n        choicesExcludingParent.push each\n\n    if choicesExcludingParent.length > 0\n      menu = new MenuMorph false, @, true, true, "choose new parent:"\n      choicesExcludingParent.forEach (each) =>\n        menu.addItem each.toString().slice(0, 50), true, each, "newParentChoice", null, null, null, null, null, null, null, true\n    else\n      # the ideal would be to not show the\n      # "attach" menu entry at all but for the\n      # time being it\'s quite costly to\n      # find the eligible morphs to attach\n      # to, so for now let\'s just calculate\n      # this list if the user invokes the\n      # command, and if there are no good\n      # morphs then show some kind of message.\n      menu = new MenuMorph false, @, true, true, "no morphs to attach to"\n    menu.popUpAtHand @firstContainerMenu()\n\n  attachWithHorizLayout: ->\n    choices = world.plausibleTargetAndDestinationMorphs @\n\n    # my direct parent might be in the\n    # options which is silly, leave that one out\n    choicesExcludingParent = []\n    choices.forEach (each) =>\n      if each != @parent\n        choicesExcludingParent.push each\n\n    if choicesExcludingParent.length > 0\n      menu = new MenuMorph false, @, true, true, "choose new parent:"\n      choicesExcludingParent.forEach (each) =>\n        menu.addItem each.toString().slice(0, 50), true, each, "newParentChoiceWithHorizLayout", null, null, null, null, null, null, null, true\n    else\n      # the ideal would be to not show the\n      # "attach" menu entry at all but for the\n      # time being it\'s quite costly to\n      # find the eligible morphs to attach\n      # to, so for now let\'s just calculate\n      # this list if the user invokes the\n      # command, and if there are no good\n      # morphs then show some kind of message.\n      menu = new MenuMorph false, @, true, true, "no morphs to attach to"\n    menu.popUpAtHand @firstContainerMenu()\n  \n  # does nothing, keeping it for the peace of\n  # some tests\n  toggleIsfloatDraggable: ->\n  #  # for context menu demo purposes\n  #  @isfloatDraggable = not @isfloatDraggable\n  \n  colorSetters: ->\n    # for context menu demo purposes\n    ["color", "backgroundColor"]\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    list = ["fullRawMoveLeftSideTo", "fullRawMoveTopSideTo", "rawSetWidth", "rawSetHeight", "setAlphaScaled", "setPadding", "setPaddingTop", "setPaddingBottom", "setPaddingLeft", "setPaddingRight"]\n    if @addShapeSpecificNumericalSetters?\n      list = @addShapeSpecificNumericalSetters list\n    list\n\n  \n  # Morph entry field tabbing //////////////////////////////////////////////\n  \n  allEntryFields: ->\n    @collectAllChildrenBottomToTopSuchThat (each) ->\n      each.isEditable and\n      (each instanceof StringMorph or\n        each instanceof StringMorph2 or\n        each instanceof TextMorph)\n  \n  \n  nextEntryField: (current) ->\n    fields = @allEntryFields()\n    idx = fields.indexOf current\n    if idx isnt -1\n      if fields.length > (idx + 1)\n        return fields[idx + 1]\n    return fields[0]\n  \n  previousEntryField: (current) ->\n    fields = @allEntryFields()\n    idx = fields.indexOf current\n    if idx isnt -1\n      if idx > 0\n        return fields[idx - 1]\n      return fields[fields.length - 1]\n    return fields[0]\n  \n  tab: (editField) ->\n    #\n    #	the <tab> key was pressed in one of my edit fields.\n    #	invoke my "nextTab()" function if it exists, else\n    #	propagate it up my owner chain.\n    #\n    if @nextTab\n      @nextTab editField\n    else @parent.tab editField  if @parent\n  \n  backTab: (editField) ->\n    #\n    #	the <back tab> key was pressed in one of my edit fields.\n    #	invoke my "previousTab()" function if it exists, else\n    #	propagate it up my owner chain.\n    #\n    if @previousTab\n      @previousTab editField\n    else @parent.backTab editField  if @parent\n  \n  \n  #\n  #	the following are examples of what the navigation methods should\n  #	look like. Insert these at the World level for fallback, and at lower\n  #	levels in the Morphic tree (e.g. dialog boxes) for a more fine-grained\n  #	control over the tabbing cycle.\n  #\n  #Morph::nextTab = function (editField) {\n  #	var	next = this.nextEntryField(editField);\n  #	editField.clearSelection();\n  #	next.selectAll();\n  #	next.edit();\n  #};\n  #\n  #Morph::previousTab = function (editField) {\n  #	var	prev = this.previousEntryField(editField);\n  #	editField.clearSelection();\n  #	prev.selectAll();\n  #	prev.edit();\n  #};\n  #\n  #\n  \n  # Morph events:\n  escalateEvent: (functionName, arg) ->\n    handler = @parent\n    if handler?\n      handler = handler.parent  while not handler[functionName] and handler.parent?\n      handler[functionName] arg  if handler[functionName]\n  \n  \n  # Morph eval. Used by the Inspector and the TextMorph.\n  evaluateString: (code) ->\n    try\n      result = eval CoffeeScript.compile code, {"bare":true}\n      @reLayout()\n      \n      @changed()\n    catch err\n      @inform err\n    result\n  \n  \n  # Morph collision detection - not used anywhere at the moment ////////////////////////\n  \n  isTouching: (otherMorph) ->\n    oImg = @overlappingImage otherMorph\n    data = oImg.getContext("2d").getImageData(1, 1, oImg.width, oImg.height).data\n    detect(data, (each) ->\n      each isnt 0\n    ) isnt null\n  \n  overlappingImage: (otherMorph) ->\n    fb = @fullBounds()\n    otherFb = otherMorph.fullBounds()\n    oRect = fb.intersect(otherFb)\n    oImg = newCanvas oRect.extent().scaleBy pixelRatio\n    ctx = oImg.getContext "2d"\n    ctx.scale pixelRatio, pixelRatio\n    if oRect.width() < 1 or oRect.height() < 1\n      return newCanvas (new Point 1, 1).scaleBy pixelRatio\n    ctx.drawImage @fullImage(),\n      Math.round(oRect.origin.x - fb.origin.x),\n      Math.round(oRect.origin.y - fb.origin.y)\n    ctx.globalCompositeOperation = "source-in"\n    ctx.drawImage otherMorph.fullImage(),\n      Math.round(otherFb.origin.x - oRect.origin.x),\n      Math.round(otherFb.origin.y - oRect.origin.y)\n    oImg\n\n\n  # ------------------------------------------------------------------------------------\n  # Layouts\n  # ------------------------------------------------------------------------------------\n  # So layouts in ZK work the following way:\n  #  1) Any Morph can contain a number of other morphs\n  #     according to a number of layouts *simultaneously*\n  #     e.g. you can have two morphs being horizontally stacked\n  #     and two other morphs being inset for example\n  #  2) There is no need for an explicit special container. Any\n  #     Morph can be a container when needed.\n  #  3) The default attaching of Morphs to a Morph puts them\n  #     under the effect of the most basic layout: the FREEFLOATING\n  #     layout.\n  #  3) A user can only do a high-level resize or move to a FREEFLOATING\n  #     Morph. All other Morphs are under the effect of more complex\n  #     layout strategies so they can\'t be moved willy nilly\n  #     directly by the user via some high-level "resize" or "move"\n  #     Control of size and placement can be done, but indirectly via other\n  #     means below.\n  #  4) You CAN control the size and location of Morphs under the\n  #     effect of complex layouts, but only indirectly: by programmatically\n  #     changing their layout spec properties.\n  #  5) You CAN also manually control the size and location of Morphs\n  #     under the effect of complex layouts by using special Adjusting\n  #     Morphs, which are provided by the container, and give handles\n  #     to manually control the content. These manual controls\n  #     under the courtains go and programmatically modify the layout\n  #     spec properties of the content.\n\n\n  minWidth: 10\n  desiredWidth: 20\n  maxWidth: 100\n\n  minHeight: 10\n  desiredHeight: 20\n  maxHeight: 100\n\n  makeSpacersTransparent: ->\n    for C in @children\n      C.makeSpacersTransparent()\n\n  makeSpacersOpaque: ->\n    for C in @children\n      C.makeSpacersOpaque()\n\n  invalidateLayout: ->\n    if @layoutIsValid\n      window.morphsThatMaybeChangedLayout.push @\n    @layoutIsValid = false\n    if @parent?\n      @parent.invalidateLayout()\n\n  setMinAndMaxBoundsAndSpreadability: (minBounds, desiredBounds, spreadability = LayoutSpec.SPREADABILITY_MEDIUM) ->\n    @minWidth = minBounds.x\n    @minHeight = minBounds.y\n\n    @desiredWidth = desiredBounds.x\n    @desiredHeight = desiredBounds.y\n\n    maxWidth = desiredBounds.x + spreadability * desiredBounds.x/100\n    maxHeight = desiredBounds.y + spreadability * desiredBounds.y/100\n    @setMaxDim new Point maxWidth, maxHeight\n\n    @invalidateLayout()\n\n\n  setMaxDim: (overridingMaxDim) ->\n\n    ###\n    currentMax = @getRecursiveMaxDim()\n    ratio = currentMax.x / overridingMaxDim.x\n\n    for C in @children\n      if C.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n        C.setMaxDim C.getRecursiveMaxDim().divideBy ratio\n    ###\n\n\n    @maxWidth = overridingMaxDim.x\n    @maxHeight = overridingMaxDim.y\n\n    @invalidateLayout()\n\n  # if you use this paragraph, then\n  # we have a system where you CAN easily resize things to any\n  # size, so to have maximum flexibility we are not binding the\n  # minimum of a container to the minimums of the contents.\n  ###\n  getDesiredDim: ->\n    desiredDim = new Point @desiredWidth, @desiredHeight\n    return desiredDim.min @getMaxDim()\n  getMinDim: ->\n    minDim = new Point @minWidth, @minHeight\n    return minDim.min @getMaxDim()\n  getMaxDim: ->\n    maxDim = new Point @maxWidth, @maxHeight\n    return maxDim\n  ###\n\n  # if you use this paragraph, then the container of further\n  # layouts will have a minimum equal to the sum of minimums\n  # of the contents.\n  getDesiredDim: ->\n    if @isCollapsed() then return new Point 0,0\n    @getRecursiveDesiredDim()\n  getMinDim: ->\n    if @isCollapsed() then return new Point 0,0\n    @getRecursiveMinDim()\n  getMaxDim: ->\n    if @isCollapsed() then return new Point 0,0\n    maxDim = new Point @maxWidth, @maxHeight\n    return maxDim.max @getDesiredDim()\n\n\n  getRecursiveDesiredDim: ->\n    if @isCollapsed() then return new Point 0,0\n    \n    # TBD the exact shape of @checkDesiredDimCache\n    #if @checkDesiredDimCache\n    #  return @desiredDimCache\n\n    desiredWidth = null\n    desiredHeight = null\n    for C in @children\n      if C.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n        childSize = C.getDesiredDim()\n        if !desiredWidth? then desiredWidth = 0\n        desiredWidth += childSize.width()\n        if desiredHeight < childSize.height()\n          if !desiredHeight? then desiredHeight = 0\n          desiredHeight = childSize.height()\n\n    if !desiredWidth?\n      desiredWidth = @desiredWidth\n\n    if !desiredHeight?\n      desiredHeight = @desiredHeight\n\n    # TBD the exact shape of @checkDesiredDimCache\n    @checkDesiredDimCache = true\n    @desiredDimCache = new Point desiredWidth, desiredHeight\n\n    return @desiredDimCache.min @getRecursiveMaxDim()\n\n\n  getRecursiveMinDim: ->\n    if @isCollapsed() then return new Point 0,0\n    # TBD the exact shape of @checkMinDimCache\n    #if @checkMinDimCache\n    #  # the user might have forced the "desired" to\n    #  # be smaller than the standard minimum set by\n    #  # the widget\n    #  return Math.min @minDimCache, @getRecursiveDesiredDim()\n\n    minWidth = null\n    minHeight = null\n    for C in @children\n      if C.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n        childSize = C.getMinDim()\n        minWidth += childSize.width()\n        if minHeight < childSize.height()\n          minHeight = childSize.height()\n\n    if !minWidth?\n      minWidth = @minWidth\n\n    if !minHeight?\n      minHeight = @minHeight\n\n    # TBD the exact shape of @checkMinDimCache\n    @checkMinDimCache = true\n    @minDimCache = new Point minWidth, minHeight\n\n    # the user might have forced the "desired" to\n    # be smaller than the standard minimum set by\n    # the widget\n    return @minDimCache.min @getRecursiveMaxDim()\n\n  getRecursiveMaxDim: ->\n    if @isCollapsed() then return new Point 0,0\n\n    # TBD the exact shape of @checkMaxDimCache\n    #if @checkMaxDimCache\n    #  # the user might have forced the "desired" to\n    #  # be bigger than the standard maximum set by\n    #  # the widget\n    #  return Math.max @maxDimCache, @getRecursiveDesiredDim()\n\n    maxWidth = null\n    maxHeight = null\n    for C in @children\n      if C.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n        childSize = C.getMaxDim()\n        maxWidth += childSize.width()\n        if maxHeight < childSize.height()\n          maxHeight = childSize.height()\n\n    if !maxWidth?\n      maxWidth = @maxWidth\n\n    if !maxHeight?\n      maxHeight = @maxHeight\n\n    # TBD the exact shape of @checkMaxDimCache\n    @checkMaxDimCache = true\n    @maxDimCache = new Point maxWidth, maxHeight\n\n    # the user might have forced the "desired" to\n    # be bigger than the standard maximum set by\n    # the widget\n    return @maxDimCache\n\n  countOfChildrenToLayout: ->\n    if @isCollapsed() then return 0\n    count = 0\n    for C in @children\n      if C.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED and\n      !C.isCollapsed()\n        count++\n    return count\n\n  doLayout: (newBoundsForThisLayout = @boundingBox()) ->\n    if @isCollapsed()\n      @layoutIsValid = true\n      @notifyChildrenThatParentHasReLayouted()\n      return\n\n    #if (@ instanceof LayoutableMorph) and (newBoundsForThisLayout.eq @boundingBox())\n    #  debugger\n\n    # freefloating layouts never need\n    # adjusting. We marked the @layoutIsValid\n    # to false because it\'s an important breadcrumb\n    # for finding the morphs that actually have a\n    # layout to be recalculated but this Morph\n    # now needs to do nothing.\n    #if @layoutSpec == LayoutSpec.ATTACHEDAS_FREEFLOATING\n    #  @layoutIsValid = true\n    #  return\n    \n    # todo should we do a fullChanged here?\n    # rather than breaking what could be many\n    # rectangles?\n\n    # the fullRawMoveTo makes sure that all children\n    # that are float-attached move together with the\n    # morph.\n    @fullRawMoveTo newBoundsForThisLayout.origin\n    \n    # bad kludge here but I think there will be more\n    # of these as we move over to the new layouts, we\'ll\n    # probably have split Morphs for the new layouts mechanism\n    if @ instanceof TextMorph\n      @rawSetBounds newBoundsForThisLayout\n    else\n      @rawSetExtent newBoundsForThisLayout.extent()\n\n    if @countOfChildrenToLayout() == 0\n      @layoutIsValid = true\n      return\n\n    @addOrRemoveAdders()\n\n\n    min = @getRecursiveMinDim()\n    desired = @getRecursiveDesiredDim()\n    max = @getRecursiveMaxDim()\n    \n    # we are forced to be in a space smaller\n    # than the minimum. We obey.\n    if min.width() >= newBoundsForThisLayout.width()\n      if @parent == world then console.log "case 1"\n      # Give all children under minimum\n      # this is unfortunate but\n      # we don\'t want to rely on clipping what\'s\n      # beyond the allocated space. Clipping\n      # in this Morphic implementation has special\n      # status and we don\'t want to meddle with\n      # that.\n      # example: if newBoundsForThisLayout.width() is 10 and min.width() is 50\n      # then reductionFraction = 1/5 , i.e. all the minimums\n      # will be further reduced to fit\n      reductionFraction = newBoundsForThisLayout.width() / min.width()\n      childLeft = newBoundsForThisLayout.left()\n      for C in @children\n        if C.layoutSpec != LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED then continue\n        childBounds = new Rectangle \\\n          childLeft,\n          newBoundsForThisLayout.top(),\n          childLeft + C.getMinDim().width() * reductionFraction,\n          newBoundsForThisLayout.top() + newBoundsForThisLayout.height()\n        childLeft += childBounds.width()\n        C.doLayout childBounds\n\n    # the min is within the bounds but the desired is just\n    # equal or larger than the bounds.\n    # give min to all and then what is left available\n    # redistribute proportionally based on desired\n    else if desired.width() >= newBoundsForThisLayout.width()\n      if @parent == world then console.log "case 2"\n      desiredMargin = desired.width() - min.width()\n      if desiredMargin != 0\n        fraction = (newBoundsForThisLayout.width() - min.width()) / desiredMargin\n      else\n        fraction = 0      \n      childLeft = newBoundsForThisLayout.left()\n      for C in @children\n        if C.layoutSpec != LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED then continue\n        minWidth = C.getMinDim().width()\n        desWidth = C.getDesiredDim().width()\n        childBounds = new Rectangle \\\n          childLeft,\n          newBoundsForThisLayout.top(),\n          childLeft + minWidth + (desWidth - minWidth) * fraction,\n          newBoundsForThisLayout.top() + newBoundsForThisLayout.height()\n        childLeft += childBounds.width()\n        C.doLayout childBounds\n\n    # min and desired are strictly less than the bounds\n    # hence we have more space than needed,\n    # allocate all the desired spaces, and on top of that\n    # give extra space based on maximum widths\n    else\n      maxMargin = max.width() - desired.width()\n      totDesWidth = desired.width()\n      maxWidth = null\n      desWidth = null\n      extraSpace = newBoundsForThisLayout.width() - desired.width()\n      if extraSpace < 0\n        alert "extraSpace is negative"\n      if @parent == world then console.log "case 3 maxMargin: " + maxMargin\n\n      if maxMargin > 0\n        ssss = 0\n      else if maxMargin == 0\n        ssss = 1\n      else\n        alert "maxMargin negative"\n\n      childLeft = newBoundsForThisLayout.left()\n      for C in @children\n        if C.layoutSpec != LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED then continue\n        maxWidth = C.getMaxDim().width()\n        desWidth = C.getDesiredDim().width()\n        if (maxWidth - desWidth) > 0\n          xtra = extraSpace * ((maxWidth - desWidth)/maxMargin)\n        else\n          xtra = 0\n        childBounds = new Rectangle \\\n          childLeft,\n          newBoundsForThisLayout.top(),\n          childLeft + desWidth + xtra + ssss * (newBoundsForThisLayout.width()-desired.width()) * (desWidth / totDesWidth),\n          newBoundsForThisLayout.top() + newBoundsForThisLayout.height()\n        childLeft += childBounds.width()\n        if childLeft > newBoundsForThisLayout.right() + 5\n          debugger\n        C.doLayout childBounds\n\n    @layoutIsValid = true\n    @notifyChildrenThatParentHasReLayouted()\n\n  removeAdders: ->\n    @_showsAdders = false\n    @invalidateLayout()\n\n  showAdders: ->\n    @_showsAdders = true\n    if @children.length == 0\n      @add \\\n        new LayoutElementAdderOrDropletMorph(),\n        null,\n        LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    @invalidateLayout()\n\n  addOrRemoveAdders: ->\n\n    if !@_showsAdders\n      allAddersToBeDestroyed =\n        @collectAllChildrenBottomToTopSuchThat(\n          (m) ->\n            m.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED and\n            m instanceof LayoutElementAdderOrDropletMorph\n        )\n      for C in allAddersToBeDestroyed\n        C.destroy()\n      return\n\n    if @children.length == 0\n      @add \\\n        new LayoutElementAdderOrDropletMorph(),\n        null,\n        LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n\n    while true\n      leftToDo = @firstChildSuchThat(\n        (m) ->\n          if m.layoutSpec != LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n            return false\n          if m instanceof LayoutElementAdderOrDropletMorph\n            return false\n          debugger\n          kkk = m.lastSiblingBeforeMeSuchThat(\n              (mm) ->\n                mm.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n            )\n          debugger\n          if !kkk?\n            return true\n          if kkk instanceof LayoutElementAdderOrDropletMorph\n            return false\n          return true            \n      )\n      debugger\n      if !leftToDo?\n        break\n      leftToDo.addAsSiblingBeforeMe \\\n            new LayoutElementAdderOrDropletMorph(),\n            null,\n            LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n\n    # this code is duplicate of the one above and is only needed for\n    # adding the last adder/droplet.\n\n    while true\n      leftToDo = @firstChildSuchThat(\n        (m) ->\n          if m.layoutSpec != LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n            return false\n          if m instanceof LayoutElementAdderOrDropletMorph\n            return false\n          debugger\n          kkk = m.firstSiblingAfterMeSuchThat(\n              (mm) ->\n                mm.layoutSpec == LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n            )\n          debugger\n          if !kkk?\n            return true\n          if kkk instanceof LayoutElementAdderOrDropletMorph\n            return false\n          return true            \n      )\n      debugger\n      if !leftToDo?\n        break\n      leftToDo.addAsSiblingAfterMe \\\n            new LayoutElementAdderOrDropletMorph(),\n            null,\n            LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n\n\n\n  @setupTestScreen1: ->\n\n    ## draw some reference patterns to see the sizes\n\n    for i in [0..5]\n      lmHolder = new RectangleMorph()\n      lmHolder.setExtent new Point 10 + i*10,10 + i*10\n      lmHolder.fullRawMoveTo new Point 10 + 60 * i, 10 + 50 * 0\n\n      world.add lmHolder\n\n    # ----------------------------------------------\n\n    lmHolder = new RectangleMorph()\n    lmContent1 = new RectangleMorph()\n    lmAdj = new StackElementsSizeAdjustingMorph()\n    lmContent2 = new RectangleMorph()\n\n    lmHolder.add lmContent1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    \n    lmContent1.setColor new Color 0, 255, 0\n    lmContent2.setColor new Color 0, 0, 255\n\n    lmContent1.setMinAndMaxBoundsAndSpreadability (new Point 10,10) , (new Point 20,20)\n    lmContent2.setMinAndMaxBoundsAndSpreadability (new Point 10,10) , (new Point 20,20), 2* LayoutSpec.SPREADABILITY_MEDIUM\n\n    lmHolder.fullRawMoveTo new Point 10 + 60 * 0, 30 + 50 * 1\n\n    world.add lmHolder\n    new HandleMorph lmHolder \n\n    # ----------------------------------------------\n\n    lmHolder = new RectangleMorph()\n    lmContent1 = new RectangleMorph()\n    lmAdj = new StackElementsSizeAdjustingMorph()\n    lmContent2 = new RectangleMorph()\n\n    lmHolder.add lmContent1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    \n    lmContent1.setColor new Color 0, 255, 0\n    lmContent2.setColor new Color 0, 0, 255\n\n    lmContent1.setMinAndMaxBoundsAndSpreadability (new Point 10,10) , (new Point 10,10)\n    lmContent2.setMinAndMaxBoundsAndSpreadability (new Point 10,10) , (new Point 10,10)\n\n    lmHolder.fullRawMoveTo new Point 10 + 60 * 1, 30 + 50 * 1\n\n    world.add lmHolder\n    new HandleMorph lmHolder\n\n    # ----------------------------------------------\n\n    lmHolder = new RectangleMorph()\n    lmContent1 = new RectangleMorph()\n    lmAdj = new StackElementsSizeAdjustingMorph()\n    lmContent2 = new RectangleMorph()\n    lmContent3 = new RectangleMorph()\n\n    lmHolder.add lmContent1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent3, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    \n    lmContent1.setColor new Color 0, 255, 0\n    lmContent2.setColor new Color 0, 0, 255\n    lmContent3.setColor new Color 255, 255, 0\n\n    lmContent1.setMinAndMaxBoundsAndSpreadability (new Point 10,10) , (new Point 10,10)\n    lmContent2.setMinAndMaxBoundsAndSpreadability (new Point 10,10) , (new Point 10,10)\n    lmContent3.setMinAndMaxBoundsAndSpreadability (new Point 10,10) , (new Point 10,10)\n\n    lmHolder.fullRawMoveTo new Point 10 + 60 * 2, 30 + 50 * 1\n\n    world.add lmHolder\n    new HandleMorph lmHolder\n\n    # ----------------------------------------------\n\n    lmHolder = new RectangleMorph()\n    lmContent1 = new RectangleMorph()\n    lmAdj = new StackElementsSizeAdjustingMorph()\n    lmContent2 = new RectangleMorph()\n    lmAdj2 = new StackElementsSizeAdjustingMorph()\n    lmContent3 = new RectangleMorph()\n\n    lmHolder.add lmContent1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent3, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    \n    lmContent1.setColor new Color 0, 255, 0\n    lmContent2.setColor new Color 0, 0, 255\n    lmContent3.setColor new Color 255, 255, 0\n\n    lmContent1.setMinAndMaxBoundsAndSpreadability (new Point 10,10) , (new Point 10,10)\n    lmContent2.setMinAndMaxBoundsAndSpreadability (new Point 10,10) , (new Point 10,10)\n    lmContent3.setMinAndMaxBoundsAndSpreadability (new Point 10,10) , (new Point 10,10)\n\n    lmHolder.fullRawMoveTo new Point 10 + 60 * 3, 30 + 50 * 1\n\n    world.add lmHolder\n    new HandleMorph lmHolder\n\n    # ----------------------------------------------\n\n    lmHolder = new RectangleMorph()\n\n    lmSpacer1 = new LayoutSpacerMorph()\n    lmAdj = new StackElementsSizeAdjustingMorph()\n    lmContent1 = new RectangleMorph()\n    lmAdj2 = new StackElementsSizeAdjustingMorph()\n    lmContent2 = new RectangleMorph()\n    lmAdj3 = new StackElementsSizeAdjustingMorph()\n    lmContent3 = new RectangleMorph()\n    lmAdj4 = new StackElementsSizeAdjustingMorph()\n    lmSpacer2 = new LayoutSpacerMorph()\n\n    lmHolder.add lmSpacer1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj3, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent3, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj4, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmSpacer2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    \n    lmContent1.setColor new Color 0, 255, 0\n    lmContent2.setColor new Color 0, 0, 255\n    lmContent3.setColor new Color 255, 255, 0\n\n    lmContent1.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 30,30)\n    lmContent2.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 30,30)\n    lmContent3.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 30,30)\n\n    lmHolder.fullRawMoveTo new Point 10 + 60 * 4, 30 + 50 * 1\n\n    world.add lmHolder\n    new HandleMorph lmHolder\n\n    # ----------------------------------------------\n\n    lmHolder = new RectangleMorph()\n\n    lmSpacer1 = new LayoutSpacerMorph()\n    lmAdj = new StackElementsSizeAdjustingMorph()\n    lmContent1 = new RectangleMorph()\n    lmAdj2 = new StackElementsSizeAdjustingMorph()\n    lmContent2 = new RectangleMorph()\n    lmAdj3 = new StackElementsSizeAdjustingMorph()\n    lmContent3 = new RectangleMorph()\n    lmAdj4 = new StackElementsSizeAdjustingMorph()\n    lmSpacer2 = new LayoutSpacerMorph 2\n\n    lmHolder.add lmSpacer1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj3, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent3, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj4, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmSpacer2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    \n    lmContent1.setColor new Color 0, 255, 0\n    lmContent2.setColor new Color 0, 0, 255\n    lmContent3.setColor new Color 255, 255, 0\n\n    lmContent1.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 30,30)\n    lmContent2.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 30,30)\n    lmContent3.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 30,30)\n\n    lmHolder.fullRawMoveTo new Point 10 + 60 * 5, 30 + 50 * 1\n\n    world.add lmHolder\n    new HandleMorph lmHolder\n\n    # ----------------------------------------------\n\n    lmHolder = new RectangleMorph()\n\n    lmSpacer1 = new LayoutSpacerMorph()\n    lmAdj = new StackElementsSizeAdjustingMorph()\n    lmContent1 = new RectangleMorph()\n    lmAdj2 = new StackElementsSizeAdjustingMorph()\n    lmContent2 = new RectangleMorph()\n    lmAdj3 = new StackElementsSizeAdjustingMorph()\n    lmContent3 = new RectangleMorph()\n    lmAdj4 = new StackElementsSizeAdjustingMorph()\n    lmSpacer2 = new LayoutSpacerMorph 2\n\n    lmHolder.add lmSpacer1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj3, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent3, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj4, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmSpacer2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    \n    lmContent1.setColor new Color 0, 255, 0\n    lmContent2.setColor new Color 0, 0, 255\n    lmContent3.setColor new Color 255, 255, 0\n\n    lmContent1.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 60,60), LayoutSpec.SPREADABILITY_NONE\n    lmContent2.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 60,60)\n    lmContent3.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 60,60), 2 * LayoutSpec.SPREADABILITY_MEDIUM\n\n    lmHolder.fullRawMoveTo new Point 10 + 60 * 6, 30 + 50 * 1\n\n    world.add lmHolder\n    new HandleMorph lmHolder\n\n    # ----------------------------------------------\n\n    lmHolder = new RectangleMorph()\n\n    lmSpacer1 = new LayoutSpacerMorph()\n    lmAdj = new StackElementsSizeAdjustingMorph()\n    lmContent1 = new RectangleMorph()\n    lmAdj2 = new StackElementsSizeAdjustingMorph()\n    lmContent2 = new RectangleMorph()\n    lmAdj3 = new StackElementsSizeAdjustingMorph()\n    lmContent3 = new RectangleMorph()\n    lmAdj4 = new StackElementsSizeAdjustingMorph()\n    lmSpacer2 = new LayoutSpacerMorph 2\n\n    lmHolder.add lmSpacer1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent1, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj3, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmContent3, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmAdj4, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    lmHolder.add lmSpacer2, null, LayoutSpec.ATTACHEDAS_STACK_HORIZONTAL_VERTICALALIGNMENTS_UNDEFINED\n    \n    lmContent1.setColor new Color 0, 255, 0\n    lmContent2.setColor new Color 0, 0, 255\n    lmContent3.setColor new Color 255, 255, 0\n\n    lmContent1.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 30,30), LayoutSpec.SPREADABILITY_NONE\n    lmContent2.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 30,30), LayoutSpec.SPREADABILITY_NONE\n    lmContent3.setMinAndMaxBoundsAndSpreadability (new Point 30,30) , (new Point 30,30), LayoutSpec.SPREADABILITY_NONE\n\n    lmHolder.fullRawMoveTo new Point 10 + 60 * 7, 30 + 50 * 1 \n\n    world.add lmHolder\n    new HandleMorph lmHolder';
