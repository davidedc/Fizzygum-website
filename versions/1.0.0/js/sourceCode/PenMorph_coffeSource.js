// Generated by CoffeeScript 1.10.0
window.PenMorph_coffeSource = '# PenMorph ////////////////////////////////////////////////////////////\n\n# I am a simple LOGO-wise turtle. Note that this morph\'s graphical\n# representation is ONLY the turtle, not the graphics that come\n# out of it. The graphics generated by the pen are located in the\n# canvas it was attached to when the graphics commands have\n# been issued.\n#\n# example code to run:\n#   this.sierpinski(400,40);\n\nclass PenMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n  \n  heading: 0\n  penSize: null\n  isDown: true\n  penPoint: \'tip\' # or \'center\'\n  \n  constructor: ->\n    @penSize = WorldMorph.preferencesAndSettings.handleSize * 4\n    super()\n    @rawSetExtent new Point @penSize, @penSize\n    # todo we need to change the size two times, for getting the right size\n    # of the arrow and of the line. Probably should make the two distinct\n    @penSize = 1\n    #alert @morphMethod() # works\n    # doesn\'t work cause coffeescript doesn\'t support static inheritance\n    #alert @morphStaticMethod()\n\n    # no need to call  because @rawSetExtent does it.\n    # (should it?)\n    #\n\n\n  imBeingAddedTo: (newParentMorph) ->\n    if !(newParentMorph instanceof HandMorph or newParentMorph instanceof CanvasMorph)\n      @inform "a pen will only\\nwork on a canvas..."\n\n\n  # NOTE: here we are painting the turtle/pen,\n  # NOT what the turtle/pen is drawing!\n    \n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if @preliminaryCheckNothingToDraw false, clippingRectangle, aContext\n      return\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      aContext.save()\n\n      # clip out the dirty rectangle as we are\n      # going to paint the whole of the box\n      aContext.clipToRectangle al,at,w,h\n\n      aContext.globalAlpha = @alpha\n\n      aContext.scale pixelRatio, pixelRatio\n      morphPosition = @position()\n      aContext.translate morphPosition.x, morphPosition.y\n\n      direction = @heading\n      len = @width() / 2\n      start = @center().subtract(@position())\n\n      if @penPoint is "tip"\n        dest = start.distanceAngle(len * 0.75, direction - 180)\n        left = start.distanceAngle(len, direction + 195)\n        right = start.distanceAngle(len, direction - 195)\n      else # \'middle\'\n        dest = start.distanceAngle(len * 0.75, direction)\n        left = start.distanceAngle(len * 0.33, direction + 230)\n        right = start.distanceAngle(len * 0.33, direction - 230)\n\n      aContext.fillStyle = @color.toString()\n      aContext.beginPath()\n\n      aContext.moveTo start.x, start.y\n      aContext.lineTo left.x, left.y\n      aContext.lineTo dest.x, dest.y\n      aContext.lineTo right.x, right.y\n\n      aContext.closePath()\n      aContext.strokeStyle = "white"\n      aContext.lineWidth = 3\n      aContext.stroke()\n      aContext.strokeStyle = "black"\n      aContext.lineWidth = 1\n      aContext.stroke()\n      aContext.fill()\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio (i.e. after the restore)\n      @paintHighlight aContext, al, at, w, h\n\n  \n  \n  # PenMorph access:\n  setHeading: (degrees) ->\n    @heading = parseFloat(degrees) % 360\n    @changed()\n    \n  \n  # PenMorph turtle ops:\n  turn: (degrees) ->\n    @setHeading @heading + parseFloat degrees\n  \n  forward: (steps) ->\n    if !@parent.backBuffer?\n      return\n\n    start = @center()\n    dist = parseFloat steps\n    if dist >= 0\n      dest = @position().distanceAngle dist, @heading\n    else\n      dest = @position().distanceAngle(Math.abs(dist), (@heading - 180))\n    @fullRawMoveTo dest.round()\n    if @isDown\n      @parent.drawLine start.subtract(@parent.position()), @center().subtract(@parent.position()), @penSize, @color\n  \n  down: ->\n    @isDown = true\n  \n  up: ->\n    @isDown = false\n  \n  # TODO I don\'t think this is going to\n  # work. Needs to clear the canvas, not\n  # to change it.\n  clear: ->\n    if !@parent.backBuffer?\n      return\n    @parent.clear()\n    \n  \n  # PenMorph demo ops:  \n  sierpinski: (length, min) ->\n    if length > min\n      for i in [0...3]\n        @sierpinski length * 0.5, min\n        @turn 120\n        @forward length\n  \n  tree: (level, length, angle) ->\n    if level > 0\n      @penSize = level\n      @forward length\n      @turn angle\n      @tree level - 1, length * 0.75, angle\n      @turn angle * -2\n      @tree level - 1, length * 0.75, angle\n      @turn angle\n      @forward -length\n';
