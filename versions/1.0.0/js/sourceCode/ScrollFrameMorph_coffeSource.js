// Generated by CoffeeScript 1.10.0
window.ScrollFrameMorph_coffeSource = '# ScrollFrameMorph ////////////////////////////////////////////////////\n\n# this comment below is needed to figure out dependencies between classes\n# REQUIRES globalFunctions\n\nclass ScrollFrameMorph extends FrameMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  autoScrollTrigger: null\n  hasVelocity: true # dto.\n  padding: 0 # around the scrollable area\n  growth: 0 # pixels or Point to grow right/left when near edge\n  isTextLineWrapping: false\n  isScrollingByfloatDragging: true\n  scrollBarSize: null\n  contents: null\n  vBar: null\n  hBar: null\n\n  # there are several ways in which we allow\n  # scrolling when a scrollframe is scrollable\n  # (i.e. the scrollbars are showing).\n  # You can choose to scroll it by dragging the\n  # contents or by dragging the background,\n  # independently. Which could be useful for\n  # example when showing a geographic map.\n  canScrollByDraggingBackground: false\n  canScrollByDraggingForeground: false\n\n  constructor: (\n    @contents,\n    @scrollBarSize = (WorldMorph.preferencesAndSettings.scrollBarSize),\n    @sliderColor\n    ) ->\n    # super() paints the scrollframe, which we don\'t want,\n    # so we set 0 opacity here.\n    @alpha = 0\n    super()\n\n    @contents = new FrameMorph @ unless @contents?\n    @addRaw @contents\n\n    # the scrollFrame is never going to paint itself,\n    # but its values are going to mimick the values of the\n    # contained frame\n    @color = @contents.color\n    @alpha = @contents.alpha\n    \n    #@setColor = @contents.setColor\n    #@setAlphaScaled = @contents.setAlphaScaled\n\n    @hBar = new SliderMorph null, null, null, null, @sliderColor\n    @hBar.rawSetHeight @scrollBarSize\n\n    @hBar.target = @\n    @addRaw @hBar\n\n    @vBar = new SliderMorph null, null, null, null, @sliderColor\n    @vBar.rawSetWidth @scrollBarSize\n    @vBar.target = @\n    @addRaw @vBar\n\n    @hBar.target = @\n    @hBar.action = "adjustContentsBasedOnHBar"\n    @vBar.target = @\n    @vBar.action = "adjustContentsBasedOnVBar"\n\n    @adjustScrollBars()\n\n  adjustContentsBasedOnHBar: (num) ->\n    @contents.fullRawMoveTo new Point @left() - num, @contents.position().y\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  adjustContentsBasedOnVBar: (num) ->\n    @contents.fullRawMoveTo new Point @contents.position().x, @top() - num\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  setColor: (aColorOrAMorphGivingAColor, morphGivingColor) ->\n    aColor = super\n    # keep in synch the color of the content.\n    # Note that the container scrollFrame.\n    # is actually not painted.\n    @contents.setColor aColorOrAMorphGivingAColor, morphGivingColor\n    return aColor\n\n  setAlphaScaled: (alphaOrMorphGivingAlpha, morphGivingAlpha) ->\n    alpha = super\n    # update the alpha of the scrollFrame - note\n    # that we are never going to paint the scrollFrame\n    # we are updating the alpha so that its value is the same as the\n    # contained frame\n    @contents.setAlphaScaled alphaOrMorphGivingAlpha, morphGivingAlpha\n    return alpha\n\n  anyScrollBarShowing: ->\n    if (@hBar.visibleBasedOnIsVisibleProperty() and !@hBar.isCollapsed()) or\n    (@vBar.visibleBasedOnIsVisibleProperty() and !@vBar.isCollapsed())\n      return true\n    return false\n\n  isFloatDraggable: ->\n    if @canScrollByDraggingBackground and @anyScrollBarShowing()\n      return false\n    true\n\n  adjustScrollBars: ->\n    hWidth = @width() - @scrollBarSize\n    vHeight = @height() - @scrollBarSize\n    unless @parent instanceof ListMorph\n      @changed()\n\n    # this check is to see whether the bar actually belongs to this\n    # scrollframe. The reason why the bar could belong to another\n    # scrollframe is the following: the bar could have been detached\n    # from a scrollframe A. The scrollframe A (which is still fully\n    # working albeit detached) is then duplicated into\n    # a scrollframe B. What happens is that because the bar is not\n    # a child of A (rather, it\'s only referenced as a property),\n    # the duplication mechanism does not duplicate the bar and it does\n    # not update the reference to it. This is correct because one cannot\n    # just change all the references to other objects that are not children\n    # , a good example being the targets, i.e. if you duplicate a colorPicker\n    # which targets a Morph you want the duplication of the colorPicker to\n    # still change color of that same Morph.\n    # So: the scrollframe B could still reference the scrollbar\n    # detached from A and that causes a problem because changes to B would\n    # change the dimensions and hiding/unhiding of the scrollbar.\n    # So here we avoid that by actually checking what the scrollbar is\n    # attached to.\n    if @hBar.target == @ \n      if @contents.width() >= @width() + 1\n        @hBar.show()\n        @hBar.rawSetWidth hWidth  if @hBar.width() isnt hWidth\n        # we check whether the bar has been detached. If it\'s still\n        # attached then we possibly move it, together with the\n        # scrollframe, otherwise we don\'t move it.\n        if @hBar.parent == @\n          @hBar.fullRawMoveTo new Point @left(), @bottom() - @hBar.height()\n        stopValue = @contents.width() - @width()\n        @hBar.updateSpecs(\n          0, # start\n          stopValue, # stop\n          @left() - @contents.left(), # value\n          @width() / @contents.width() * stopValue # size\n        )\n      else\n        @hBar.hide()\n\n    # see comment on equivalent if line above.\n    if @vBar.target == @ \n      if @contents.height() >= @height() + 1\n        @vBar.show()\n        @vBar.rawSetHeight vHeight  if @vBar.height() isnt vHeight\n        # we check whether the bar has been detached. If it\'s still\n        # attached then we possibly move it, together with the\n        # scrollframe, otherwise we don\'t move it.\n        if @vBar.parent == @\n          @vBar.fullRawMoveTo new Point @right() - @vBar.width(), @top()\n        stopValue = @contents.height() - @height()\n        @vBar.updateSpecs(\n          0, # start\n          stopValue, # stop\n          @top() - @contents.top(), # value\n          @height() / @contents.height() * stopValue # size\n        )\n      else\n        @vBar.hide()\n  \n  add: (aMorph) ->\n    @contents.add aMorph\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  # puts the morph in the scrollframe\n  # in some sparse manner and keeping it\n  # "in view"\n  addInPseudoRandomPosition: (aMorph) ->\n    @contents.add aMorph\n    posx = Math.abs(hashCode(aMorph.toString())) % @width()\n    posy = Math.abs(hashCode(aMorph.toString() + "x")) % @height()\n    position = @contents.position().add new Point posx, posy\n    aMorph.fullMoveTo position\n    aMorph.fullRawMoveWithin @contents\n    @adjustContentsBounds()\n    @adjustScrollBars()\n  \n  \n  setContents: (aMorph, extraPadding) ->\n    @extraPadding = extraPadding\n    @contents.fullDestroyChildren()\n\n    aMorph.fullRawMoveTo @position().add @padding + @extraPadding\n    @add aMorph\n  \n  rawSetExtent: (aPoint) ->\n    unless aPoint.eq @extent()\n      #console.log "move 15"\n      @breakNumberOfRawMovesAndResizesCaches()\n      @contents.fullRawMoveTo @position()  if @isTextLineWrapping\n      super aPoint\n      @contents.rawSetExtent aPoint\n      @adjustContentsBounds()\n      @adjustScrollBars()\n\n\n  reactToDropOf: ->\n    @adjustContentsBounds()\n    @adjustScrollBars()\n  \n  reactToGrabOf: ->\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  adjustContentsBounds: ->\n    # if FrameMorph is of type isTextLineWrapping\n    # it means that you don\'t want the TextMorph to\n    # extend indefinitely as you are typing. Rather,\n    # the width will be constrained and the text will\n    # wrap.\n    if @isTextLineWrapping\n      @contents.children.forEach (morph) =>\n        if morph instanceof TextMorph\n          totalPadding = 2*(@extraPadding + @padding)\n          # this re-layouts the text to fit the width.\n          # The new height of the TextMorph will then be used\n          # to redraw the vertical slider.\n          morph.maxTextWidth = 0\n          morph.rawSetWidth @contents.width() - totalPadding\n          morph.maxTextWidth = @contents.width() - totalPadding\n          @contents.rawSetHeight Math.max morph.height(), @height() - totalPadding\n\n    subBounds = @contents.subMorphsMergedFullBounds()\n    if subBounds\n      newBounds = subBounds.expandBy(@padding + @extraPadding).merge(@boundingBox())\n    else\n      newBounds = @boundingBox()\n\n    unless @contents.boundingBox().eq newBounds\n      @contents.silentRawSetBounds newBounds\n      @contents.reLayout()\n      \n      @keepContentsInScrollFrame()\n\n  keepContentsInScrollFrame: ->\n    if @contents.left() > @left()\n      @contents.fullRawMoveBy new Point @left() - @contents.left(), 0\n    if @contents.right() < @right()\n      @contents.fullRawMoveBy new Point @right() - @contents.right(), 0\n    if @contents.top() > @top()\n      @contents.fullRawMoveBy new Point 0, @top() - @contents.top()\n    if @contents.bottom() < @bottom()\n      @contents.fullRawMoveBy 0, new Point @bottom() - @contents.bottom(), 0\n  \n  # ScrollFrameMorph scrolling by floatDragging:\n  scrollX: (steps) ->\n    cl = @contents.left()\n    l = @left()\n    cw = @contents.width()\n    r = @right()\n    newX = cl + steps\n    newX = r - cw  if newX + cw < r\n    newX = l  if newX > l\n    # return true if any movement of\n    # the scrollbar button is\n    # actually happening, otherwise\n    # false. We use this to figure\n    # out in some places whether\n    # we need to trigger a bunch of\n    # updates of the content and scrollbars\n    # or not.\n    if newX isnt cl\n      @contents.fullRawMoveLeftSideTo newX\n      return true\n    else\n      return false\n  \n  scrollY: (steps) ->\n    ct = @contents.top()\n    t = @top()\n    ch = @contents.height()\n    b = @bottom()\n    newY = ct + steps\n    if newY + ch < b\n      newY = b - ch\n    # prevents content to be scrolled to the frame\'s\n    # bottom if the content is otherwise empty\n    newY = t  if newY > t\n    # return true if any movement of\n    # the scrollbar button is\n    # actually happening, otherwise\n    # false. We use this to figure\n    # out in some places whether\n    # we need to trigger a bunch of\n    # updates of the content and scrollbars\n    # or not.\n    if newY isnt ct\n      @contents.fullRawMoveTopSideTo newY\n      return true\n    else\n      return false\n  \n  # sometimes you can scroll the contents of a scrollframe\n  # by floatDragging its contents. This is particularly\n  # useful in touch devices.\n  mouseDownLeft: (pos) ->\n    return null  unless @isScrollingByfloatDragging\n    oldPos = pos\n    deltaX = 0\n    deltaY = 0\n    friction = 0.8\n    world.addSteppingMorph @\n    @step = =>\n      scrollbarJustChanged = false\n      if world.hand.mouseButton and\n        !world.hand.floatDraggingSomething() and\n        @boundsContainPoint(world.hand.position())\n          newPos = world.hand.position()\n          if @hBar.visibleBasedOnIsVisibleProperty() and\n          !@hBar.isCollapsed()\n            deltaX = newPos.x - oldPos.x\n            if deltaX isnt 0\n              scrollbarJustChanged ||= @scrollX deltaX\n          if @vBar.visibleBasedOnIsVisibleProperty() and\n          !@vBar.isCollapsed()\n            deltaY = newPos.y - oldPos.y\n            if deltaY isnt 0\n              scrollbarJustChanged ||= @scrollY deltaY\n          oldPos = newPos\n      else\n        unless @hasVelocity\n          @step = noOperation\n          world.removeSteppingMorph @\n        else\n          if (Math.abs(deltaX) < 0.5) and (Math.abs(deltaY) < 0.5)\n            @step = noOperation\n            world.removeSteppingMorph @\n          else\n            if @hBar.visibleBasedOnIsVisibleProperty() and\n            !@hBar.isCollapsed()\n              deltaX = deltaX * friction\n              if deltaX isnt 0\n                scrollbarJustChanged ||= @scrollX Math.round deltaX\n            if @vBar.visibleBasedOnIsVisibleProperty() and\n            !@vBar.isCollapsed()\n              deltaY = deltaY * friction\n              if deltaY isnt 0\n                scrollbarJustChanged ||= @scrollY Math.round deltaY\n      if scrollbarJustChanged\n        @adjustContentsBounds()\n        @adjustScrollBars()\n    super\n  \n  startAutoScrolling: ->\n    inset = WorldMorph.preferencesAndSettings.scrollBarSize * 3\n    if @isOrphan() then return null\n    hand = world.hand\n    @autoScrollTrigger = Date.now()  unless @autoScrollTrigger\n    world.addSteppingMorph @\n    @step = =>\n      pos = hand.position()\n      inner = @boundingBox().insetBy inset\n      if @boundsContainPoint(pos) and\n        !inner.containsPoint(pos) and\n        hand.floatDraggingSomething()\n          @autoScroll pos\n      else\n        @step = noOperation\n        world.removeSteppingMorph @\n        @autoScrollTrigger = null\n  \n  autoScroll: (pos) ->\n    return null  if Date.now() - @autoScrollTrigger < 500\n    inset = WorldMorph.preferencesAndSettings.scrollBarSize * 3\n    area = @topLeft().extent new Point @width(), inset\n    scrollbarJustChanged = false\n    if area.containsPoint(pos)\n      scrollbarJustChanged ||= @scrollY inset - (pos.y - @top())\n    area = @topLeft().extent new Point inset, @height()\n    if area.containsPoint(pos)\n      scrollbarJustChanged ||= @scrollX inset - (pos.x - @left())\n    area = (new Point(@right() - inset, @top())).extent new Point inset, @height()\n    if area.containsPoint(pos)\n      scrollbarJustChanged ||= @scrollX -(inset - (@right() - pos.x))\n    area = (new Point(@left(), @bottom() - inset)).extent new Point @width(), inset\n    if area.containsPoint(pos)\n      scrollbarJustChanged ||= @scrollY -(inset - (@bottom() - pos.y))\n    if scrollbarJustChanged\n      @adjustContentsBounds()\n      @adjustScrollBars()  \n  \n  # ScrollFrameMorph scrolling when editing text\n  # so to bring the caret fully into view.\n  scrollCaretIntoView: (caretMorph) ->\n    txt = caretMorph.target\n    offset = txt.position().subtract @contents.position()\n    ft = @top() + @padding\n    fb = @bottom() - @padding\n    fl = @left() + @padding\n    fr = @right() - @padding\n    @adjustContentsBounds()\n    if caretMorph.top() < ft\n      @contents.fullRawMoveTopSideTo @contents.top() + ft - caretMorph.top()\n      caretMorph.fullRawMoveTopSideTo ft\n    else if caretMorph.bottom() > fb\n      @contents.fullRawMoveBottomSideTo @contents.bottom() + fb - caretMorph.bottom()\n      caretMorph.fullRawMoveBottomSideTo fb\n    if caretMorph.left() < fl\n      @contents.fullRawMoveLeftSideTo @contents.left() + fl - caretMorph.left()\n      caretMorph.fullRawMoveLeftSideTo fl\n    else if caretMorph.right() > fr\n      @contents.fullRawMoveRightSideTo @contents.right() + fr - caretMorph.right()\n      caretMorph.fullRawMoveRightSideTo fr\n    @adjustContentsBounds()\n    @adjustScrollBars()\n\n  # ScrollFrameMorph events:\n  mouseScroll: (y, x) ->\n    scrollbarJustChanged = false\n\n    # this paragraph prevents too much\n    # diagonal movement when the intention\n    # is clearly to just move vertically or\n    # horizontally. Doesn\'t need to be always\n    # the case though.\n    if Math.abs(y) < Math.abs(x)\n      y = 0\n    if Math.abs(x) < Math.abs(y)\n      x = 0\n\n    if y\n      scrollbarJustChanged = true\n      @scrollY y * WorldMorph.preferencesAndSettings.mouseScrollAmount\n    if x\n      scrollbarJustChanged = true\n      @scrollX x * WorldMorph.preferencesAndSettings.mouseScrollAmount  \n    if scrollbarJustChanged\n      @adjustContentsBounds()\n      @adjustScrollBars()\n  \n  \n  developersMenu: ->\n    menu = super()\n    if @isTextLineWrapping\n      menu.addItem "auto line wrap off...", true, @, "toggleTextLineWrapping", "turn automatic\\nline wrapping\\noff"\n    else\n      menu.addItem "auto line wrap on...", true, @, "toggleTextLineWrapping", "enable automatic\\nline wrapping"\n    menu\n  \n  toggleTextLineWrapping: ->\n    @isTextLineWrapping = not @isTextLineWrapping\n';
