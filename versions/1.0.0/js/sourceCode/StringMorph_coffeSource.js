// Generated by CoffeeScript 1.10.0
window.StringMorph_coffeSource = '# StringMorph /////////////////////////////////////////////////////////\n\n# A StringMorph is a single line of text. It can only be left-aligned.\n# REQUIRES WorldMorph\n# REQUIRES BackBufferMixin\n\nclass StringMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  @augmentWith BackBufferMixin\n\n  text: ""\n  fontSize: null\n  fontName: null\n  fontStyle: null\n  isBold: null\n  isItalic: null\n  isEditable: false\n  isNumeric: null\n  isPassword: false\n  isShowingBlanks: false\n  # careful: Objects are shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  blanksColor: new Color 180, 140, 140\n\n  # Properties for text-editing\n  isScrollable: true\n  currentlySelecting: false\n  startMark: null\n  endMark: null\n  # see note above about Colors and shared objects\n  markedTextColor: new Color 255, 255, 255\n  # see note above about Colors and shared objects\n  markedBackgoundColor: new Color 60, 60, 120\n\n  constructor: (\n      @text = (if text is "" then "" else "StringMorph"),\n      @fontSize = 12,\n      @fontStyle = "sans-serif",\n      @isBold = false,\n      @isItalic = false,\n      @isNumeric = false,\n      @color = (new Color 0, 0, 0),\n      @fontName = ""\n      ) ->\n\n    super()\n\n    # override inherited properties:\n    @noticesTransparentClick = true\n\n  setText: (theTextContent,a) ->\n    if a?\n      theTextContent = a.text.text\n    theTextContent = theTextContent + ""\n    if @text != theTextContent\n      @text = theTextContent\n      @reLayout()\n      \n      @changed()\n\n  actualFontSizeUsedInRendering: ->\n    @fontSize\n  \n  toString: ->\n    # e.g. \'a StringMorph("Hello World")\'\n    firstPart = super()\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.hidingOfMorphsContentExtractInLabels\n      return firstPart\n    else\n      return firstPart + " (\\"" + @text.slice(0, 30) + "...\\")"\n\n  getTextDescription: ->\n    if @textDescription?\n      return @textDescription + " (adhoc description of string)"\n    textWithoutLocationOrInstanceNo = @text.replace /\\[\\d*@\\d*[ ]*\\|[ ]*\\d*@\\d*\\]/, ""\n    textWithoutLocationOrInstanceNo = textWithoutLocationOrInstanceNo.replace /#\\d*/, ""\n    return textWithoutLocationOrInstanceNo.slice(0, 30) + " (content of string)"\n  \n  password: (letter, length) ->\n    ans = ""\n    for i in [0...length]\n      ans += letter\n    ans\n\n  buildCanvasFontProperty: ->\n    # answer a font string, e.g. \'bold italic 12px sans-serif\'\n    font = ""\n    font = font + "bold "  if @isBold\n    font = font + "italic "  if @isItalic\n    font + @fontSize + "px " + ((if @fontName then @fontName + ", " else "")) + @fontStyle\n\n\n  widthOfText: (text = @text)->\n    text = (if @isPassword then @password("*", text.length) else text)\n    world.canvasContextForTextMeasurements.font = @buildCanvasFontProperty()\n    return Math.ceil Math.max world.canvasContextForTextMeasurements.measureText(text).width, 1\n\n  reLayout: ->\n    super()\n    width = @widthOfText @text\n    @silentRawSetExtent new Point width, fontHeight @fontSize\n    @notifyChildrenThatParentHasReLayouted()\n\n  reflowText: ->\n    @reLayout()\n  \n  # no changes of position or extent should be\n  # performed in here\n  createRefreshOrGetBackBuffer: ->\n\n    cacheKey =\n      @extent().toString()  + "-" +\n      @isPassword  + "-" +\n      @isShowingBlanks  + "-" +\n      @buildCanvasFontProperty()  + "-" +\n      @alignment  + "-" +\n      @color.toString()  + "-" +\n      hashCode(@text)  + "-" +\n      @startMark  + "-" +\n      @endMark  + "-" +\n      @markedBackgoundColor.toString()\n\n    cacheHit = world.cacheForImmutableBackBuffers.get cacheKey\n    if cacheHit? then return cacheHit\n\n    text = (if @isPassword then @password("*", @text.length) else @text)\n    # initialize my surface property\n    width = @widthOfText @text\n    backBuffer = newCanvas (new Point width, @height()).scaleBy pixelRatio\n    backBufferContext = backBuffer.getContext "2d"\n\n    backBufferContext.scale pixelRatio, pixelRatio\n    backBufferContext.font = @buildCanvasFontProperty()\n    backBufferContext.textAlign = "left"\n    backBufferContext.textBaseline = "bottom"\n\n    backBufferContext.fillStyle = @color.toString()\n    if @isShowingBlanks\n      @renderWithBlanks backBufferContext, 0, fontHeight @fontSize\n    else\n      backBufferContext.fillText text, 0, fontHeight @fontSize\n\n    # draw the selection\n    start = Math.min @startMark, @endMark\n    stop = Math.max @startMark, @endMark\n    for i in [start...stop]\n      p = @slotCoordinates(i).subtract @position()\n      c = text.charAt(i)\n      backBufferContext.fillStyle = @markedBackgoundColor.toString()\n      backBufferContext.fillRect p.x, p.y, Math.ceil(backBufferContext.measureText(c).width) + 1,\n        fontHeight @fontSize\n      backBufferContext.fillStyle = @markedTextColor.toString()\n      backBufferContext.fillText c, p.x, fontHeight @fontSize\n\n    cacheEntry = [backBuffer, backBufferContext]\n    world.cacheForImmutableBackBuffers.set cacheKey, cacheEntry\n    return cacheEntry\n  \n  renderWithBlanks: (context, x = 0, y) ->\n    # create the blank form\n    drawBlank = ->\n      context.drawImage blank, Math.round(x), 0\n      x += space\n    space = Math.ceil context.measureText(" ").width\n    blank = newCanvas new Point(space, @height()).scaleBy pixelRatio\n    ctx = blank.getContext "2d"\n    words = @text.split " "\n    isFirst = true\n    ctx.fillStyle = @blanksColor.toString()\n    ctx.arc space / 2, blank.height / 2, space / 2, degreesToRadians(0), degreesToRadians(360)\n    ctx.fill()\n\n    # render my text inserting blanks\n    words.forEach (word) ->\n      drawBlank()  unless isFirst\n      isFirst = false\n      if word isnt ""\n        context.fillText word, x, y\n        x += Math.ceil context.measureText(word).width\n  \n  \n  # StringMorph measuring:\n  slotCoordinates: (slot) ->\n    # answer the position point of the given index ("slot")\n    # where the caret should be placed\n    text = (if @isPassword then @password("*", @text.length) else @text)\n\n    # let\'s be defensive and check that the\n    # slot is in the right interval\n    checkedSlot = Math.min Math.max(slot, 0), text.length\n    if slot != checkedSlot\n      alert "something wrong - slot is out of range"\n    slot = checkedSlot\n\n    xOffset = Math.ceil @widthOfText text.substring 0, slot\n    x = @left() + xOffset\n    y = @top()\n    new Point x, y\n  \n  slotAt: (aPoint) ->\n    # answer the slot (index) closest to the given point\n    # so the caret can be moved accordingly\n    text = (if @isPassword then @password("*", @text.length) else @text)\n    idx = 0\n    charX = 0\n\n    while aPoint.x - @left() > charX\n      charX += Math.ceil @widthOfText text[idx]\n      idx += 1\n      if idx is text.length\n        if (Math.ceil(@widthOfText(text)) - (Math.ceil(@widthOfText(text[idx-1])) / 2)) < (aPoint.x - @left())  \n          return idx\n    idx - 1\n  \n  upFrom: (slot) ->\n    @startOfLine()\n  \n  downFrom: (slot) ->\n    @endOfLine()\n\n  startOfLine: ->\n    # answer the first slot (index) of the line for the given slot\n    0\n  \n  endOfLine: ->\n    # answer the slot (index) indicating the EOL for the given slot\n    @text.length\n    \n  fontSizePopup: (menuItem)->\n    @prompt menuItem.parent.title + "\\nfont\\nsize:",\n      @,\n      "setFontSize",\n      @fontSize.toString(),\n      null, 6, 500, true\n\n  # StringMorph menus:\n  developersMenu: ->\n    menu = super()\n    menu.addLine()\n    menu.addItem "edit", true, @, "edit"\n    menu.addItem "font size...", true, @, "fontSizePopup", "set this String\'s\\nfont point size"\n    menu.addItem "serif", true, @, "setSerif"  if @fontStyle isnt "serif"\n    menu.addItem "sans-serif", true, @, "setSansSerif"  if @fontStyle isnt "sans-serif"\n\n    if @isBold\n      menu.addItem "normal weight", true, @, "toggleWeight"\n    else\n      menu.addItem "bold", true, @, "toggleWeight"\n\n    if @isItalic\n      menu.addItem "normal style", true, @, "toggleItalic"\n    else\n      menu.addItem "italic", true, @, "toggleItalic"\n\n    if @isShowingBlanks\n      menu.addItem "hide blanks", true, @, "toggleShowBlanks"\n    else\n      menu.addItem "show blanks", true, @, "toggleShowBlanks"\n\n    if @isPassword\n      menu.addItem "show characters", true, @, "toggleIsPassword"\n    else\n      menu.addItem "hide characters", true, @, "toggleIsPassword"\n\n    menu\n  \n  toggleIsfloatDraggable: ->\n  #  # for context menu demo purposes\n  #  @isfloatDraggable = not @isfloatDraggable\n  #  if @isfloatDraggable\n  #    @disableSelecting()\n  #  else\n  #    @enableSelecting()\n  \n  toggleShowBlanks: ->\n    @isShowingBlanks = not @isShowingBlanks\n    @reLayout()\n    \n    @changed()\n  \n  toggleWeight: ->\n    @isBold = not @isBold\n    @reLayout()\n    \n    @changed()\n  \n  toggleItalic: ->\n    @isItalic = not @isItalic\n    @reLayout()\n    \n    @changed()\n  \n  toggleIsPassword: ->\n    @isPassword = not @isPassword\n    @reLayout()\n    \n    @changed()\n  \n  setSerif: ->\n    @fontStyle = "serif"\n    @reLayout()\n    \n    @changed()\n  \n  setSansSerif: ->\n    @fontStyle = "sans-serif"\n    @reLayout()\n    \n    @changed()\n  \n  setFontSize: (sizeOrMorphGivingSize, morphGivingSize) ->\n    if morphGivingSize?.getValue?\n      size = morphGivingSize.getValue()\n    else\n      size = sizeOrMorphGivingSize\n\n    # for context menu demo purposes\n    if typeof size is "number"\n      @fontSize = Math.round(Math.min(Math.max(size, 4), 500))\n    else\n      newSize = parseFloat size\n      @fontSize = Math.round Math.min Math.max(newSize, 4), 500  unless isNaN newSize\n    @reLayout()\n    \n    @changed()\n  \n  numericalSetters: ->\n    # for context menu demo purposes\n    ["fullRawMoveLeftSideTo", "fullRawMoveTopSideTo", "setAlphaScaled", "setFontSize", "setText"]\n  \n  \n  # StringMorph editing:\n  edit: ->\n    world.edit @\n\n  selection: ->\n    start = Math.min @startMark, @endMark\n    stop = Math.max @startMark, @endMark\n    @text.slice start, stop\n  \n  firstSelectedSlot: ->\n    Math.min @startMark, @endMark\n    if !@startMark? or !@endMark?\n      return null\n    return Math.min @startMark, @endMark\n\n  lastSelectedSlot: ->\n    if !@startMark? or !@endMark?\n      return null\n    return Math.max @startMark, @endMark\n\n  clearSelection: ->\n    @currentlySelecting = false\n    @startMark = null\n    @endMark = null\n    \n    @changed()\n\n  setEndMark: (slot) ->\n    @endMark = slot\n    @changed()\n  \n  selectBetween: (start, end) ->\n    @startMark = Math.min start, end\n    @endMark = Math.max start, end\n    @changed()  \n\n  deleteSelection: ->\n    text = @text\n    start = Math.min @startMark, @endMark\n    stop = Math.max @startMark, @endMark\n    @text = text.slice(0, start) + text.slice(stop)\n    \n    @changed()\n    @clearSelection()\n  \n  selectAll: ->\n    @startMark = 0\n    @endMark = @text.length\n    \n    @changed()\n\n  # Every time the user clicks on the text, a new edit()\n  # is triggered, which creates a new caret.\n  mouseClickLeft: (pos) ->\n    @bringToForegroud()\n    caret = world.caret\n    if @isEditable\n      @edit()  unless @currentlySelecting\n      if caret then caret.gotoPos pos\n      world.caret.gotoPos pos\n      @currentlySelecting = true\n    else\n      @escalateEvent "mouseClickLeft", pos\n  \n  enableSelecting: ->\n    @mouseDownLeft = (pos) ->\n      @clearSelection()\n      if @isEditable and !@isFloatDraggable()\n        @edit()\n        world.caret.gotoPos pos\n        @startMark = @slotAt pos\n        @endMark = @startMark\n        @currentlySelecting = true\n    \n    @mouseMove = (pos) ->\n      if @isEditable and @currentlySelecting\n        newMark = @slotAt pos\n        if newMark isnt @endMark\n          @endMark = newMark\n          \n          @changed()\n      else\n        @disableSelecting()\n  \n  disableSelecting: ->\n    # re-establish the original definition of the method\n    @clearSelection()\n    @mouseDownLeft = StringMorph::mouseDownLeft\n    delete @mouseMove\n\n\n  ';
