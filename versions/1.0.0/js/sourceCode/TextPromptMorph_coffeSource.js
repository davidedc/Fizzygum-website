// Generated by CoffeeScript 1.10.0
window.TextPromptMorph_coffeSource = '# TextPromptMorph ///////////////////////////////////////////////////\n\nclass TextPromptMorph extends WindowMorph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  tempPromptEntryField: null\n  defaultContents: ""\n  textMorph: null\n\n  cancelButton: null\n  saveButton: null\n  okButton: null\n\n  constructor: (@msg, @target, @callback, @defaultContents) ->\n    super "Edit tool code"\n\n  popup: (morphToAttachTo, pos) ->\n    # console.log "menu popup"\n    @silentFullRawMoveTo pos\n    morphToAttachTo.add @\n    # the @fullRawMoveWithin method\n    # needs to know the extent of the morph\n    # so it must be called after the morphToAttachTo.add\n    # method. If you call before, there is\n    # nopainting happening and the morph doesn\'t\n    # know its extent.\n    @fullRawMoveWithin world\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n    # shadow must be added after the morph\n    # has been placed somewhere because\n    # otherwise there is no visible image\n    # to base the shadow on\n    # P.S. this is the thing that causes the MenuMorph buffer\n    # to be painted after the creation.\n    @addFullShadow()\n    @fullChanged()\n\n\n  popUpAtHand: (morphToAttachTo)->\n    if !morphToAttachTo?\n      morphToAttachTo = world\n    @popup morphToAttachTo, world.hand.position()\n\n  buildAndConnectChildren: ->\n    debugger\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n    # remove all submorhs i.e. panes and buttons\n    # THE ONES THAT ARE STILL\n    # submorphs of the inspector. If they\n    # have been peeled away, they still live\n    #@fullDestroyChildren()\n\n    super\n    \n    #@tempPromptEntryField = new TextMorph2 @defaultContents,null,null,null,null,null,new Color(255, 255, 54), 0.5\n    #@tempPromptEntryField.isEditable = true\n    #@add @tempPromptEntryField\n\n\n    @tempPromptEntryField = new ScrollFrameMorph()\n    @tempPromptEntryField.disableDrops()\n    @tempPromptEntryField.contents.disableDrops()\n    @tempPromptEntryField.isTextLineWrapping = true\n    @tempPromptEntryField.color = new Color 255, 255, 255\n\n    @textMorph = new TextMorph @defaultContents\n    @textMorph.isEditable = true\n    @textMorph.enableSelecting()\n\n    @tempPromptEntryField.setContents @textMorph, 2\n    @add @tempPromptEntryField\n\n    # buttons -------------------------------\n    @cancelButton = new SimpleButtonMorph true, @, "fullDestroy", (new StringMorph2 "cancel").alignCenter()\n    @add @cancelButton\n\n    @saveButton = new SimpleButtonMorph true, @, "informTarget", (new StringMorph2 "save").alignCenter()\n    @add @saveButton\n\n    @okButton = new SimpleButtonMorph true, @, "informTargetAndDestroy", (new StringMorph2 "ok").alignCenter()\n    @add @okButton\n\n\n\n    @layoutSubmorphs()\n\n  informTarget: ->\n    debugger\n    @target[@callback].call @target, null, @textMorph\n\n  informTargetAndDestroy: ->\n    @informTarget()\n    @fullDestroy()\n\n  layoutSubmorphs: (morphStartingTheChange = null) ->\n    super morphStartingTheChange\n    console.log "fixing the layout of the inspector"\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Morph. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    trackChanges.push false\n\n    # label\n    labelLeft = @left() + @padding\n    labelTop = @top() + @padding\n    labelRight = @right() - @padding\n    labelWidth = labelRight - labelLeft\n    labelBottom = labelTop + @label.height() + 2\n\n    eachPaneWidth = Math.floor(@width() / 2) - @padding\n\n\n    mainCanvasWidth = eachPaneWidth\n    b = @bottom() - (2 * @padding) - WorldMorph.preferencesAndSettings.handleSize\n    mainCanvasHeight = b - labelBottom - Math.floor(@padding / 2)\n    mainCanvasBottom = labelBottom + mainCanvasHeight + Math.floor(@padding / 2)\n    mainCanvasLeft = @left() + eachPaneWidth\n\n    if @tempPromptEntryField.parent == @\n      @tempPromptEntryField.fullRawMoveTo new Point labelLeft, labelBottom + Math.floor(@padding / 2)\n      @tempPromptEntryField.rawSetExtent new Point @width() - 2 * @padding, mainCanvasHeight\n\n\n    # buttons -------------------------------\n    \n\n    eachButtonWidth = (@width() - 5* @padding - WorldMorph.preferencesAndSettings.handleSize) / 3\n\n    if @cancelButton.parent == @\n      @cancelButton.fullRawMoveTo new Point @left() + @padding + 0*(eachButtonWidth + @padding), mainCanvasBottom + @padding\n      @cancelButton.rawSetExtent new Point eachButtonWidth, 15\n\n    if @saveButton.parent == @\n      @saveButton.fullRawMoveTo new Point @left() + @padding + 1*(eachButtonWidth + @padding), mainCanvasBottom + @padding\n      @saveButton.rawSetExtent new Point eachButtonWidth, 15\n\n    if @okButton.parent == @\n      @okButton.fullRawMoveTo new Point @left() + @padding + 2*(eachButtonWidth + @padding), mainCanvasBottom + @padding\n      @okButton.rawSetExtent new Point eachButtonWidth, 15\n\n    # ----------------------------------------------\n\n\n    trackChanges.pop()\n    @changed()\n    if AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n';
