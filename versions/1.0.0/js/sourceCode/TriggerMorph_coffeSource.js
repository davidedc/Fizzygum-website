// Generated by CoffeeScript 1.10.0
window.TriggerMorph_coffeSource = '# TriggerMorph ////////////////////////////////////////////////////////\n\n# I provide basic button functionality.\n# All menu items and buttons are TriggerMorphs.\n# The handling of the triggering is not\n# trivial, as the concepts of\n# dataSourceMorphForTarget, target and action\n# are used - see comments.\n\nclass TriggerMorph extends Morph\n  # this is so we can create objects from the object class name \n  # (for the deserialization process)\n  namedClasses[@name] = @prototype\n\n  target: null\n  action: null\n  dataSourceMorphForTarget: null\n  morphEnv: null\n  label: null\n  labelString: null\n  labelColor: null\n  labelBold: null\n  labelItalic: null\n  doubleClickAction: null\n  argumentToAction1: null\n  argumentToAction2: null\n  hint: null\n  fontSize: null\n  fontStyle: null\n  # careful: Objects are shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  highlightColor: new Color 192, 192, 192\n  # see note above about Colors and shared objects\n  pressColor: new Color 128, 128, 128\n  centered: false\n  closesUnpinnedMenus: true\n  \n  # tells if the button represents a morph, in which\n  # case we are going to highlight the Morph on hover\n  representsAMorph: false\n\n  state: 0\n  STATE_NORMAL: 0\n  STATE_HIGHLIGHTED: 1\n  STATE_PRESSED: 2\n\n  # overrides to superclass\n  color: new Color 255, 255, 255\n\n  constructor: (\n      @closesUnpinnedMenus = true,\n      @target = null,\n      @action = null,\n      @labelString = null,\n      @fontSize = (WorldMorph.preferencesAndSettings.menuFontSize),\n      @fontStyle = "sans-serif",\n      @centered = false,\n      @dataSourceMorphForTarget = null,\n      @morphEnv,\n      @hint = null,\n      @labelColor = (new Color 0, 0, 0),\n      @labelBold = false,\n      @labelItalic = false,\n      @doubleClickAction = null,\n      @argumentToAction1 = null,\n      @argumentToAction2 = null,\n      @representsAMorph = false\n      ) ->\n\n    # additional properties:\n\n    super()\n\n    #@color = new Color 255, 152, 152\n    #@color = new Color 255, 255, 255\n    if @labelString?\n      @layoutSubmorphs()\n  \n  layoutSubmorphs: (morphStartingTheChange = null) ->\n    super()\n    if not @label?\n      @createLabel()\n    if @centered\n      @label.fullRawMoveTo @center().subtract @label.extent().floorDivideBy 2\n\n  getTextDescription: ->\n    if @textDescription?\n      return @textDescription + " (adhoc description of button)"\n    if @labelString\n      textWithoutLocationOrInstanceNo = @labelString.replace  /\\[\\d*@\\d*[ ]*\\|[ ]*\\d*@\\d*\\]/, ""\n      textWithoutLocationOrInstanceNo = textWithoutLocationOrInstanceNo.replace /#\\d*/, ""\n      return textWithoutLocationOrInstanceNo + " (text in button)"\n    else\n      return super()\n\n\n  setLabel: (@labelString) ->\n    # just recreated the label\n    # from scratch\n    if @label?\n      @label = @label.destroy()\n    @layoutSubmorphs()\n\n  alignCenter: ->\n    if !@centered\n      @centered = true\n      @layoutSubmorphs()\n\n  alignLeft: ->\n    if @centered\n      @centered = false\n      @layoutSubmorphs()\n  \n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle) ->\n\n    if !@visibleBasedOnIsVisibleProperty() or @isCollapsed()\n      return null\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return null\n\n      color = switch @state\n        when @STATE_NORMAL\n          @color\n        when @STATE_HIGHLIGHTED\n          @highlightColor\n        when @STATE_PRESSED\n          @pressColor\n\n      # paintRectangle is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio\n      @paintRectangle \\\n        aContext,\n        al, at, w, h,\n        color,\n        @alpha,\n        true # push and pop the context\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio\n      @paintHighlight aContext, al, at, w, h\n\n  createLabel: ->\n    # bold\n    # italic\n    # numeric\n    # shadow offset\n    # shadow color\n    @label = new StringMorph(\n      @labelString or "",\n      @fontSize,\n      @fontStyle,\n      @labelBold,\n      @labelItalic,\n      false,\n      @labelColor      \n    )\n    @add @label\n    \n  \n  # TriggerMorph action:\n  trigger: ->\n    if @action\n      if typeof @action is "function"\n        console.log "trigger invoked with function"\n        debugger\n        @action.call @target, @dataSourceMorphForTarget\n      else # assume it\'s a String\n        #console.log "@target: " + @target + " @morphEnv: " + @morphEnv\n        @target[@action].call @target, @dataSourceMorphForTarget, @morphEnv, @argumentToAction1, @argumentToAction2\n    return\n\n  triggerDoubleClick: ->\n    # same as trigger() but use doubleClickAction instead of action property\n    # note that specifying a doubleClickAction is optional\n    return  unless @doubleClickAction\n    if typeof @target is "function"\n      if typeof @doubleClickAction is "function"\n        @target.call @dataSourceMorphForTarget, @doubleClickAction.call(), this\n      else\n        @target.call @dataSourceMorphForTarget, @doubleClickAction, this\n    else\n      if typeof @doubleClickAction is "function"\n        @doubleClickAction.call @target\n      else # assume it\'s a String\n        @target[@doubleClickAction]()  \n  \n  # TriggerMorph events:\n  mouseEnter: ->\n    @state = @STATE_HIGHLIGHTED\n    @changed()\n    @startCountdownForBubbleHelp @hint  if @hint\n  \n  mouseLeave: ->\n    @state = @STATE_NORMAL\n    @changed()\n    world.hand.destroyTemporaries()  if @hint\n  \n  mouseDownLeft: ->\n    @state = @STATE_PRESSED\n    @changed()\n    super\n  \n  mouseClickLeft: ->\n    @bringToForegroud()\n    @state = @STATE_HIGHLIGHTED\n    @changed()\n    if @closesUnpinnedMenus\n      @propagateKillMenus()\n    @trigger()\n\n  mouseDoubleClick: ->\n    @triggerDoubleClick()\n\n  # you shouldn\'t be able to floatDragging a compound\n  # morphs containing a trigger by dragging the trigger\n  # User might still move the trigger itself though\n  # (if it\'s unlocked)\n  rootForGrab: ->\n    if @isFloatDraggable()\n      return super()\n    null\n  \n  # TriggerMorph bubble help:\n  startCountdownForBubbleHelp: (contents) ->\n    SpeechBubbleMorph.createInAWhileIfHandStillContainedInMorph @, contents\n';
