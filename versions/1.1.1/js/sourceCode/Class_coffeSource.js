// Generated by CoffeeScript 1.12.7
window.Class_coffeSource = 'class Class\n  @allClasses: []\n  nonStaticPropertiesSources: nil\n  staticPropertiesSources: nil\n  name: ""\n  superClassName: nil\n  augmentedWith: nil\n  superClass: nil\n  subClasses: nil\n  \n\n  # adds code into the constructor, such that when a\n  # Widget is created, it registers itself as in instance\n  # on the Class it belongs to AND TO ALL THE SUPERKLASSES\n  # The way it\'s added to all the superclasses is via\n  # the constructor always calling "super", so constructors\n  # up the chain cause the object to register itself\n  # with all the superclasses.\n  # this mechanism can be tested by opening an AnalogClockWdgt and\n  # then from the console:\n  #  world.children[0].constructor.instances[0] === world.children[0]\n  # or\n  #  AnalogClockWdgt.instances[0] === world.children[0]\n  # or\n  #  AnalogClockWdgt.instances\n  # to check whether AnalogClockWdgt was removed from the superclass\'\n  # (i.e. Widget) list:\n  #  AnalogClockWdgt.__super__.instances.map((elem)=>elem.constructor.name).filter((name)=>name === "AnalogClockWdgt");\n  # Note that only Widgets have that kind\n  # of tracking and hence the existence check of\n  # the registerThisInstance function\n  _addInstancesTracker: (aString) ->\n    # the regex to get the actual spacing under the constructor\n    # is:\n    # [ \\t]*constructor:[ \\t]*->.*$\\n([ \\t]*)\n    # but let\'s keep it simple: there are going to be four spaces under for the\n    # body of the constructor\n    aString += "\\n    return\\n"\n    aString.replace(/^([ \\t]*)return/gm, "$1this.registerThisInstance?();\\n$1return")\n    \n  _equivalentforSuper: (fieldName, aString) ->\n    if window.srcLoadCompileDebugWrites then console.log "removing super from: " + aString\n    # coffeescript won\'t compile "super" unless it\'s an instance\n    # method (i.e. if it comes inside a class), so we need to\n    # translate that manually into valid CS that doesn\'t use super.\n    aString = aString.replace(/super\\(\\)/g, @name + ".__super__." + fieldName + ".call(this)")\n    aString = aString.replace(/super /g, @name + ".__super__." + fieldName + ".call this, ")\n    aString = aString.replace(/super\\(/g, @name + ".__super__." + fieldName + ".call(this, ")\n    aString = aString.replace(/super$/gm, @name + ".__super__." + fieldName + ".apply(this, arguments)")\n\n  # Coffeescript adds some helper functions at the top of the compiled code:\n  #\n  #  slice = [].slice\n  #  indexOf = [].indexOf\n  #  hasProp = {}.hasOwnProperty\n  #\n  # here we remove them them all, because they mangle the code,\n  # also we just have them all in the global scope by now so\n  # they are not needed multiple times\n\n  _removeHelperFunctions: (aString) ->\n    aString = aString.replace /^var(.|\\n)*?\\(function/, "(function"\n\n    if (aString.indexOf "[].indexOf") != -1 or\n     (aString.indexOf "{}.hasProp") != -1 or\n     (aString.indexOf "[].slice") != -1\n      alert "code contains a helper var, it shouldn\'t: " +  aString\n      debugger\n\n    return aString\n\n  # not used as of now because we prefer to load the comments\n  # as part of the sources. Note that the presence of multiline\n  # comments (and strings, for that matter) could mangle the\n  # parsing.\n  # Maybe a more correct way of doing this is to remove\n  # only multiline comments and strings into a "clean version",\n  # and maintaining line-to-line correspondence between this\n  # "clean" version and the original version.\n  # Then do the regexing on the "clean"\n  # version, but getting the source from the "original"\n  # version (which should be relatively easy if we know from which\n  # line to which line each field is defined in)\n  removeComments: (source) ->\n    splitSource = source.split "\\n"\n    sourceWithoutComments = ""\n    multilineComment = false\n    for eachLine in splitSource\n      #console.log "eachLine: " + eachLine\n      if /^[ \\t]*###/m.test(eachLine)\n        multilineComment = !multilineComment\n\n      if (! /^[ \\t]*#/m.test(eachLine)) and (!multilineComment)\n        sourceWithoutComments += eachLine + "\\n"\n    return sourceWithoutComments\n\n  # You can create a Class in 3 main "modes" of use:\n  #  1. you want to load up the CS source, turn it to JS\n  #     and eval the JS so to create the class:\n  #        generatePreCompiledJS == true\n  #        createClass == true\n  #  2. you want to load up the CS source, turn it to JS\n  #     and just store the JS somewhere to generate the\n  #     pre-compiled JS sources:\n  #        generatePreCompiledJS == true\n  #        createClass == false\n  #  3. you want to just load up the CS source so it\n  #     appears all neat in the inspectors:\n  #        generatePreCompiledJS == false\n  #        createClass == false\n  constructor: (source, generatePreCompiledJS, createClass) ->\n\n    if !window.classDefinitionAsJS?\n      window.classDefinitionAsJS = []\n\n    @nonStaticPropertiesSources = {}\n    @staticPropertiesSources = {}\n    @subClasses = []\n\n    # find the class name\n    classRegex = /^class[ \\t]*([a-zA-Z_$][0-9a-zA-Z_$]*)/m\n    if (m = classRegex.exec(source))?\n        m.forEach((match, groupIndex) ->\n            if window.srcLoadCompileDebugWrites then console.log("Found match, group #{groupIndex}: #{match}")\n        )\n        @name = m[1]\n        if window.srcLoadCompileDebugWrites then console.log "name: " + @name\n\n    # find if it extends some other class\n    extendsRegex = /^class[ \\t]*[a-zA-Z_$][0-9a-zA-Z_$]*[ \\t]*extends[ \\t]*([a-zA-Z_$][0-9a-zA-Z_$]*)/m\n    if (m = extendsRegex.exec(source))?\n        m.forEach((match, groupIndex) ->\n            if window.srcLoadCompileDebugWrites then console.log("Found match, group #{groupIndex}: #{match}")\n        )\n        @superClassName = m[1]\n        @superClass = window[@superClassName].class\n\n        if window.srcLoadCompileDebugWrites then console.log "superClassName: " + @superClassName\n\n    # find which mixins need to be mixed-in\n    @augmentedWith = []\n    augmentRegex = /^  @augmentWith[ \\t]*([a-zA-Z_$][0-9a-zA-Z_$]*)/gm\n    while (m = augmentRegex.exec(source))?\n        if (m.index == augmentRegex.lastIndex)\n            augmentRegex.lastIndex++\n        m.forEach((match, groupIndex) ->\n            if window.srcLoadCompileDebugWrites then console.log("Found match, group #{groupIndex}: #{match}")\n        )\n        @augmentedWith.push m[1]\n        if window.srcLoadCompileDebugWrites then console.log "augmentedWith: " + @augmentedWith\n\n\n    # remove the augmentations because we don\'t want\n    # them to mangle up the parsing\n    source = source.replace(/^  @augmentWith[ \\t]*([a-zA-Z_$][0-9a-zA-Z_$, @]*)/gm,"")\n\n    if window.srcLoadCompileDebugWrites then console.log "source ---------\\n" + source\n\n    source += "\\n  $$$STOPTOKEN_LASTFIELD :"\n\n    # Now find all the fields definitions\n    # note that the constructor, methods, properties and static properties\n    # are ALL fields definitions, so we are basically going to cycle through\n    # everything\n\n    # to match a valid JS variable name (we just ignore the keywords):\n    #    [a-zA-Z_$][0-9a-zA-Z_$]*\n    regex = /^  (@?[a-zA-Z_$][0-9a-zA-Z_$]*) *: *([^]*?)(?=^  (@?[a-zA-Z_$][0-9a-zA-Z_$]*) *:)/gm\n    while (m = regex.exec(source))?\n        if (m.index == regex.lastIndex)\n            regex.lastIndex++\n        m.forEach((match, groupIndex) ->\n            if window.srcLoadCompileDebugWrites then console.log("Found match, group #{groupIndex}: #{match}")\n        )\n\n        if m[1].valueOf() == "$$$STOPTOKEN_LASTFIELD "\n          break\n        else\n          if window.srcLoadCompileDebugWrites then console.log "not the stop field: " + m[1].valueOf()\n\n        if m[1].substring(0, 1) == "@"\n          @staticPropertiesSources[m[1].substring(1, m[1].length)] = m[2]\n        else\n          @nonStaticPropertiesSources[m[1]] = m[2]\n\n\n    if generatePreCompiledJS or createClass\n      # --------------------\n      # OK we collected all the fields definitions, now go through them\n      # and put them into action\n      # --------------------\n\n      # collect all the definitions in JS form here\n      JS_string_definitions = "// class " + @name + "\\n\\n"\n\n      # the class itself is a constructor function, the constructor.\n      # we have to find its source (if it exists), and\n      # we have to slightly modify it and then we have to\n      # actually create this function, hence creating the class.\n      if window.srcLoadCompileDebugWrites then console.log "adding the constructor"\n      if @nonStaticPropertiesSources.hasOwnProperty(\'constructor\')\n\n        if window.srcLoadCompileDebugWrites then console.log "CS sources of constructor: " + @nonStaticPropertiesSources["constructor"]\n        # if there is a source for the constructor\n        constructorDeclaration = @_equivalentforSuper "constructor", @nonStaticPropertiesSources["constructor"]\n        constructorDeclaration = @_addInstancesTracker constructorDeclaration\n        if window.srcLoadCompileDebugWrites then console.log "constructor declaration CS:\\n" + constructorDeclaration\n\n        compiled = compileFGCode constructorDeclaration, true\n\n        constructorDeclaration = @_removeHelperFunctions compiled\n        constructorDeclaration = "window." + @name + " = " + constructorDeclaration\n      else\n        # there is no constructor source, so we\n        # just have to synthesize one that does:\n        #  constructor ->\n        #    super\n        #    register instance\n        constructorDeclaration = """\n          window.#{@name} = ->\n            # first line here is equivalent to "super" the one\n            # passing all the arguments\n            window.#{@name}.__super__.constructor.apply this, arguments\n            # register instance (only Widgets have this method)\n            @registerThisInstance?()\n            return\n        """\n        if window.srcLoadCompileDebugWrites then console.log "constructor declaration CS:\\n" + constructorDeclaration\n        constructorDeclaration = compileFGCode constructorDeclaration, true\n\n      if window.srcLoadCompileDebugWrites then console.log "constructor declaration JS: " + constructorDeclaration\n      #if @name == "StringMorph2" then debugger\n      JS_string_definitions += constructorDeclaration + "\\n"\n\n      # if you declare a constructor (i.e. a Function) like this then you don\'t\n      # get the "name" property set as it normally is when\n      # defining functions in ways that specify the name, so\n      # we add the name manually here.\n      # the name property is tricky, see:\n      # see http://stackoverflow.com/questions/5871040/how-to-dynamically-set-a-function-object-name-in-javascript-as-it-is-displayed-i\n      # just doing this is not sufficient: window[@name].name = @name\n\n      # analogous to\n      # Object.defineProperty(window[@name], \'name\', { value: @name })\n      JS_string_definitions += "Object.defineProperty(window.#{@name}, \'name\', { value: \'#{@name}\' });" + "\\n"\n\n      # analogous to\n      # window[@name].instances = []\n      JS_string_definitions += "window.#{@name}.instances = [];" + "\\n"\n\n      # if the class extends another one\n      if @superClassName?\n        if window.srcLoadCompileDebugWrites then console.log "extend: " + @name + " extends " + @superClassName\n        # analogous to\n        #window[@name].__super__ = window[@superClassName].prototype\n        #window[@name] = extend window[@name], window[@superClassName]\n        JS_string_definitions += "window.#{@name}.__super__ = window.#{@superClassName}.prototype;" + "\\n"\n        JS_string_definitions += "window.#{@name} = extend(window.#{@name}, window.#{@superClassName});" + "\\n"\n      else\n        if window.srcLoadCompileDebugWrites then console.log "no extension (extends Object) for " + @name\n        # analogous to\n        #window[@name].__super__ = Object.prototype\n        JS_string_definitions += "window.#{@name}.__super__ = Object.prototype;" + "\\n\\n"\n\n\n      # if the class is augmented with one or more Mixins\n      for eachAugmentation in @augmentedWith\n        if window.srcLoadCompileDebugWrites then console.log "augmentedWith: " + eachAugmentation\n        # analogous to\n        #window[@name].augmentWith window[eachAugmentation], @name\n        JS_string_definitions += "window.#{@name}.augmentWith(window.#{eachAugmentation}, \'#{@name}\');" + "\\n"\n\n      # non-static fields, which are put in the prototype\n      for own fieldName, fieldValue of @nonStaticPropertiesSources\n        if fieldName != "constructor" and fieldName != "augmentWith" and fieldName != "addInstanceProperties"\n          if window.srcLoadCompileDebugWrites then console.log "building field " + fieldName + " ===== "\n\n          #if fieldName == "invalidateFullBoundsCache"\n          #  debugger\n\n          fieldDeclaration = @_equivalentforSuper fieldName, fieldValue\n\n          compiled = compileFGCode fieldDeclaration, true\n\n          fieldDeclaration = @_removeHelperFunctions compiled\n          fieldDeclaration = "window." + @name + ".prototype." + fieldName + " = " + fieldDeclaration\n\n          if window.srcLoadCompileDebugWrites then console.log "field declaration: " + fieldDeclaration\n          #if @name == "StringMorph2" then debugger\n          JS_string_definitions += fieldDeclaration + "\\n"\n\n      # now the static fields, which are put in the constructor\n      # rather than in the prototype\n      for own fieldName, fieldValue of @staticPropertiesSources\n        if fieldName != "constructor" and fieldName != "augmentWith" and fieldName != "addInstanceProperties"\n          if window.srcLoadCompileDebugWrites then console.log "building STATIC field " + fieldName + " ===== "\n\n          fieldDeclaration = @_equivalentforSuper fieldName, fieldValue\n\n          compiled = compileFGCode fieldDeclaration, true\n\n          fieldDeclaration = @_removeHelperFunctions compiled\n          fieldDeclaration = "window." + @name + "." + fieldName + " = " + fieldDeclaration\n\n          if window.srcLoadCompileDebugWrites then console.log fieldDeclaration\n          JS_string_definitions += fieldDeclaration + "\\n"\n\n\n      JSSourcesContainer.content += JS_string_definitions + "\\n"\n\n      if createClass\n        try\n          if window.srcLoadCompileDebugWrites then console.log "actually evalling " + @name + " to crete Class"\n          eval.call window, JS_string_definitions\n        catch err\n          console.log " error " + err + " evaling : " + JS_string_definitions\n          alert " error " + err + " evaling : " + JS_string_definitions\n\n\n      window.classDefinitionAsJS.push JS_string_definitions\n\n    # OK now that we have created the Class\n    # (or if already created anyways, in pre-compiled mode)\n    # then add the .class field\n    window[@name].class = @\n    if @superclass? \n      @superclass.subClasses.push @\n\n\n    #if @name == "LCLCodePreprocessor" then debugger\n\n  notifyInstancesOfSourceChange: (propertiesArray)->\n    for eachInstance in window[@name].instances\n      eachInstance.sourceChanged()\n  \n    for eachProperty in propertiesArray\n      for eachSubClass in @subClasses\n        # if a subclass redefined a property, then\n        # the change doesn\'t apply, so there is no\n        # notification to propagate\n        if !eachSubClass.nonStaticPropertiesSources[eachProperty]?\n          eachSubClass.notifyInstancesOfSourceChange([eachProperty])\n\n';
