// Generated by CoffeeScript 1.12.7
window.ListMorph_coffeSource = 'class ListMorph extends ScrollPanelWdgt\n  \n  elements: nil\n  labelGetter: nil\n  format: nil\n  listContents: nil # a MenuMorph with the contents of the list\n  selected: nil # actual element currently selected\n  active: nil # menu item representing the selected element\n  action: nil\n  target: nil\n  doubleClickAction: nil\n\n  constructor: (\n    @target,\n    @action,\n    @elements = [],\n    @labelGetter = (element) ->\n        return element  if isString element\n        return element.toSource()  if element.toSource\n        element.toString()\n    ,\n\n    @format = [],\n    @doubleClickAction = nil\n    ) ->\n    #\n    #    passing a format is optional. If the format parameter is specified\n    #    it has to be of the following pattern:\n    #\n    #        [\n    #            [<color>, <single-argument predicate>],\n    #            [\'bold\', <single-argument predicate>],\n    #            [\'italic\', <single-argument predicate>],\n    #            ...\n    #        ]\n    #\n    #    multiple conditions can be passed in such a format list, the\n    #    last predicate to evaluate true when given the list element sets\n    #    the given format category (color, bold, italic).\n    #    If no condition is met, the default format (color black, non-bold,\n    #    non-italic) will be assigned.\n    #    \n    #    An example of how to use formats can be found in the InspectorMorph\'s\n    #    "markOwnProperties" mechanism.\n    #\n    #debugger\n    super()\n    @contents.disableDrops()\n    @color = new Color 255, 255, 255\n    @buildAndConnectChildren() # builds the list contents\n    # it\'s important to leave the step as the default noOperation\n    # instead of nil because the scrollbars (inherited from ScrollPanel)\n    # need the step function to react to mouse floatDrag.\n  \n  # builds the list contents\n  buildAndConnectChildren: ->\n    @listContents = new MenuMorph @, true, @, false, false, nil, nil\n    @listContents.isLockingToPanels = true\n    @elements = ["(empty)"]  if !@elements.length\n    trackChanges.push false\n    @elements.forEach (element) =>\n      color = nil\n      bold = false\n      italic = false\n      @format.forEach (pair) ->\n        if pair[1].call nil, element\n          switch pair[0]\n            when \'bold\'\n              bold = true\n            when \'italic\'\n              italic = true\n            else # assume it\'s a color\n              color = pair[0]\n\n      #labelString,\n      #action,\n      #toolTipMessage,\n      #color,\n      #bold = false,\n      #italic = false,\n      #doubleClickAction # optional, when used as list contents\n\n      #console.log "@labelGetter(element): " + @labelGetter(element)\n      @listContents.addMenuItem(\n        @labelGetter(element), # labelString\n        true,\n        @, # target\n        "select", # action\n        nil, # toolTipMessage\n        color, # color\n        bold, # bold\n        italic, # italic\n        @doubleClickAction # doubleClickAction\n      )\n\n    trackChanges.pop()\n    @listContents.silentFullRawMoveTo @contents.position()\n    @listContents.reLayout()\n    \n    @add @listContents\n  \n  select: (item, trigger) ->\n    @selected = item\n    @active = trigger\n    if @action? and @action != ""\n      @target[@action].call @target, item.labelString\n    return\n\n  \n  rawSetExtent: (aPoint) ->\n    unless aPoint.eq @extent()\n      #console.log "move 3"\n      @breakNumberOfRawMovesAndResizesCaches()\n      lb = @listContents.boundingBox()\n      nb = @bounds.origin.corner @bounds.origin.add aPoint\n      if nb.right() > lb.right() and nb.width() <= lb.width()\n        @listContents.fullRawMoveRightSideTo nb.right()\n      if nb.bottom() > lb.bottom() and nb.height() <= lb.height()\n        @listContents.fullRawMoveBottomSideTo nb.bottom()\n      super aPoint\n';
