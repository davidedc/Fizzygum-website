// Generated by CoffeeScript 1.12.7
window.PopUpWdgt_coffeSource = '# PopUp widgets are special Widgets that have quite complex logic for\n# opening themselves, closing themseves when users click outside,\n# popping up, opening sub-widgets, and pinning them down.\n# They don\'t specify their own "look" (apart from shadowsn, see below),\n# nor the contents or the look of the contents.\n#\n# PopUps have 3 different shadows: "normal", "when dragged" and\n# "pinned on desktop", plus no shadow when pinned on anything\n# else other than the desktop.\n\nclass PopUpWdgt extends Widget\n\n  killThisPopUpIfClickOnDescendantsTriggers: true\n  killThisPopUpIfClickOutsideDescendants: true\n  isPopUpMarkedForClosure: false\n  # the morphOpeningThePopUp is only useful to get the "parent" pop-up.\n  # the "parent" pop-up is the menu that this menu is attached to,\n  # but we need this extra property because it\'s not the\n  # actual parent. The reason is that menus are actually attached\n  # to the world morph. This is for a couple of reasons:\n  # 1) they can still appear at the top even if the "parent menu"\n  #    or the parent object are not in the foreground. This is\n  #    what happens for example in OSX, you can right-click on a\n  #    morph that is not in the background but the menu that comes up\n  #    will be in the foreground.\n  # 2) they can appear unoccluded if the "parent morph" or "parent object"\n  #    are in a morph that clips at its boundaries.\n  morphOpeningThePopUp: nil\n\n  constructor: (@morphOpeningThePopUp, @killThisPopUpIfClickOutsideDescendants = true, @killThisPopUpIfClickOnDescendantsTriggers = true) ->\n    super()\n    @isLockingToPanels = false\n    world.freshlyCreatedPopUps.push @\n    world.openPopUps.push @\n\n  hierarchyOfPopUps: ->\n    ascendingMorphs = @\n    hierarchy = [ascendingMorphs]\n    while ascendingMorphs?.getParentPopUp?\n      ascendingMorphs = ascendingMorphs.getParentPopUp()\n      if ascendingMorphs?\n        hierarchy.push ascendingMorphs\n    return hierarchy\n\n  # for pop ups, the propagation happens through the getParentPopUp method\n  # rather than the parent property, but for other normal widgets it goes\n  # up the parent property\n  propagateKillPopUps: ->\n    if @killThisPopUpIfClickOnDescendantsTriggers\n      @getParentPopUp()?.propagateKillPopUps()\n      @markPopUpForClosure()\n\n  markPopUpForClosure: ->\n    world.popUpsMarkedForClosure.push @\n    @isPopUpMarkedForClosure = true\n\n  # why introduce a new flag when you can calculate\n  # from existing flags?\n  isPopUpPinned: ->\n    return !(@killThisPopUpIfClickOnDescendantsTriggers or @killThisPopUpIfClickOutsideDescendants)\n\n  getParentPopUp: ->\n    if @isPopUpPinned()\n      return @parent\n    else\n      if @morphOpeningThePopUp?\n        return @morphOpeningThePopUp.firstParentThatIsAPopUp()\n    return nil\n\n  firstParentThatIsAPopUp: ->\n    if !@isPopUpMarkedForClosure or !@parent? then return @\n    return @parent.firstParentThatIsAPopUp()\n\n  # this is invoked on the menu morph to be\n  # pinned. The triggering menu item is the first\n  # parameter.\n  pinPopUp: (pinMenuItem)->\n    @killThisPopUpIfClickOnDescendantsTriggers = false\n    @killThisPopUpIfClickOutsideDescendants = false\n    @onClickOutsideMeOrAnyOfMyChildren nil\n    if pinMenuItem?\n      pinMenuItem.firstParentThatIsAPopUp().propagateKillPopUps()\n    else\n      @getParentPopUp()?.propagateKillPopUps()\n    world.closePopUpsMarkedForClosure()\n    \n    # leave the menu attached to whatever it\'s attached,\n    # just change the shadow.\n    @updatePopUpShadow()\n\n\n  fullCopy: ->\n    copiedMorph = super\n    copiedMorph.onClickOutsideMeOrAnyOfMyChildren nil\n    copiedMorph.killThisPopUpIfClickOnDescendantsTriggers = false\n    copiedMorph.killThisPopUpIfClickOutsideDescendants = false\n    return copiedMorph\n\n\n  addMorphSpecificMenuEntries: (unused_morphOpeningThePopUp, menu) ->\n    super\n    menu.addLine()\n    menu.addMenuItem "pin", false, @, "pin"\n \n  justDropped: (whereIn) ->\n    super\n    if whereIn != world\n      @pinPopUp()\n\n    @updatePopUpShadow()\n\n  updatePopUpShadow: ->\n    if @isPopUpPinned()\n      if @parent == world\n        @addShadow()\n      else\n        @removeShadow()\n    else \n      @addShadow()\n\n  # shadow is added to a morph by\n  # the HandMorph while floatDragging\n  addShadow: (offset = new Point(5, 5), alpha = 0.2, color) ->\n\n    if @isPopUpPinned() and @parent == world\n      super new Point(3, 3), 0.3\n      return\n\n    super offset, alpha\n  \n  popUpCenteredAtHand: (world) ->\n    @popUp (world.hand.position().subtract @extent().floorDivideBy 2), world\n  \n  # currently unused\n  popUpCenteredInWorld: (world) ->\n    @popUp (world.center().subtract @extent().floorDivideBy 2), world\n\n  popUpAtHand: ->\n    @popUp world.hand.position(), world\n\n  popUp: (pos, morphToAttachTo) ->\n    # console.log "menu popup"\n    @silentFullRawMoveTo pos\n    morphToAttachTo.add @\n    # the @fullRawMoveWithin method\n    # needs to know the extent of the morph\n    # so it must be called after the morphToAttachTo.add\n    # method. If you call before, there is\n    # nopainting happening and the morph doesn\'t\n    # know its extent.\n    @fullRawMoveWithin world\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n    # shadow must be added after the morph\n    # has been placed somewhere because\n    # otherwise there is no visible image\n    # to base the shadow on\n    # P.S. this is the thing that causes the MenuMorph buffer\n    # to be painted after the creation.\n    @addShadow()\n    @fullChanged()\n\n  destroy: ->\n    super()\n    world.openPopUps.remove @\n\n  close: ->\n    super()\n    world.openPopUps.remove @\n\n';
