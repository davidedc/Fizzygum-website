// Generated by CoffeeScript 1.12.7
window.ToolPanelWdgt_coffeSource = 'class ToolPanelWdgt extends PanelWdgt\n\n  # TODO pretty sure that we don\'t need numberOfIconsOnPanel\n  numberOfIconsOnPanel: 0\n  internalPadding: 5\n  externalPadding: 10\n  thumbnailSize: 30\n\n  addMany: (widgetsToBeAdded) ->\n\n    for eachWidget in widgetsToBeAdded\n      @add eachWidget, nil, nil, nil, nil, nil, true\n    @reLayout()\n\n  add: (aMorph, position = nil, layoutSpec = LayoutSpec.ATTACHEDAS_FREEFLOATING, beingDropped, unused, positionOnScreen, dontLayout) ->\n\n    if (aMorph instanceof ModifiedTextTriangleAnnotationWdgt) or\n     (aMorph instanceof HandleMorph)\n      super\n    else\n      # if aMorph specifies a non-default switcharoo then it\n      # means it\'s like the TextBoxCreatorButtonWdgt, which creates a textbox\n      # when dragged. So in that case we DON\'T set it as a template\n      # otherwise we do.\n      if aMorph.grabbedWidgetSwitcheroo == Widget::grabbedWidgetSwitcheroo\n        aMorph.isTemplate = true\n\n      if !aMorph.extentToGetWhenDraggedFromGlassBox?\n        aMorph.extentToGetWhenDraggedFromGlassBox = aMorph.extent()\n\n      if !(aMorph instanceof GlassBoxBottomWdgt)\n        glassBoxBottom = new GlassBoxBottomWdgt()\n        glassBoxBottom.add aMorph\n\n        if !aMorph.actionableAsThumbnail\n          glassBoxTop = new GlassBoxTopWdgt()\n          glassBoxTop.toolTipMessage = aMorph.toolTipMessage\n          glassBoxBottom.add glassBoxTop\n\n        glassBoxBottom.fullRawMoveTo @topLeft().add new Point @externalPadding, @externalPadding\n        glassBoxBottom.rawSetExtent new Point @thumbnailSize, @thumbnailSize\n        glassBoxBottom.reLayout()\n\n        aMorph = glassBoxBottom\n\n\n      childrenNotHandlesNorCarets = @children.filter (m) ->\n        !((m instanceof HandleMorph) or (m instanceof CaretMorph))\n\n      foundDrop = false\n\n      if positionOnScreen? and childrenNotHandlesNorCarets.length > 0\n        positionNumberAmongSiblings = 0\n\n        for eachChild in childrenNotHandlesNorCarets\n          if eachChild.bounds.growBy(@internalPadding).containsPoint positionOnScreen\n            foundDrop = true\n            if eachChild.bounds.growBy(@internalPadding).rightHalf().containsPoint positionOnScreen\n              positionNumberAmongSiblings++\n            break\n          positionNumberAmongSiblings++\n      \n      if foundDrop\n        super aMorph, positionNumberAmongSiblings, layoutSpec, beingDropped\n      else\n        super aMorph, @numberOfIconsOnPanel, layoutSpec, beingDropped\n\n      @numberOfIconsOnPanel++\n\n      unless dontLayout\n        @reLayout()\n\n\n  rawSetExtent: (aPoint) ->\n    super\n    @reLayout()\n\n  reLayout: ->\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Widget. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    trackChanges.push false\n\n    childrenNotHandlesNorCarets = @children.filter (m) ->\n      !((m instanceof HandleMorph) or (m instanceof CaretMorph))\n\n    scanningChildrenX = 0\n    scanningChildrenY = 0\n    numberOfEntries = 0\n\n    # The ToolPanel if often inside a scroll panel,\n    # in which case the panel width stays the same as the scroll panel\n    # is resized (because that\'s what scrollpanels do, they change\n    # dimensions but the contents remain the same).\n    # BUT we want the toolpanel to never scroll horizontally\n    # (only vertically), i.e. we want it to fit the contents\n    # of the scroll panel parent\n    if @parent?\n      if @parent instanceof ScrollPanelWdgt\n        widthINeedToFitContentIn = @parent.width()\n      else\n        widthINeedToFitContentIn = @width()\n\n    for eachChild in childrenNotHandlesNorCarets\n\n      xPos = scanningChildrenX * (@thumbnailSize + @internalPadding)\n      yPos = scanningChildrenY * (@thumbnailSize + @internalPadding)\n\n      if @externalPadding + xPos + @thumbnailSize + @externalPadding > widthINeedToFitContentIn\n        scanningChildrenX = 0\n        if numberOfEntries != 0\n          scanningChildrenY++\n\n        xPos = scanningChildrenX * (@thumbnailSize + @internalPadding)\n        yPos = scanningChildrenY * (@thumbnailSize + @internalPadding)\n\n      horizAdj = (@thumbnailSize - eachChild.width()) / 2\n      vertAdj = (@thumbnailSize - eachChild.height()) / 2\n      eachChild.fullRawMoveTo @position().add(new Point @externalPadding, @externalPadding).add(new Point xPos, yPos).add(new Point horizAdj, vertAdj).round()\n      scanningChildrenX++\n      numberOfEntries++\n\n    trackChanges.pop()\n    @layoutIsValid = true\n    @fullChanged()\n\n';
