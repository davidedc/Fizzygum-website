// Generated by CoffeeScript 1.12.7
window.TriggerMorph_coffeSource = '# **************************************\n# This Widget is now deprecated, use the\n# SimpleButton instead\n# **************************************\n\n# I provide basic button functionality.\n# All menu items and buttons are TriggerMorphs.\n# The handling of the triggering is not\n# trivial, as the concepts of\n# dataSourceMorphForTarget, target and action\n# are used - see comments.\n\nclass TriggerMorph extends Widget\n\n  target: nil\n  action: nil\n  dataSourceMorphForTarget: nil\n  morphEnv: nil\n  label: nil\n  labelString: nil\n  labelColor: nil\n  labelBold: nil\n  labelItalic: nil\n  doubleClickAction: nil\n  argumentToAction1: nil\n  argumentToAction2: nil\n  toolTipMessage: nil\n  fontSize: nil\n  fontStyle: nil\n  # careful: Objects are shared with all the instances of this class.\n  # if you modify it, then all the objects will get the change\n  # but if you replace it with a new Color, then that will only affect the\n  # specific object instance. Same behaviour as with arrays.\n  # see: https://github.com/jashkenas/coffee-script/issues/2501#issuecomment-7865333\n  highlightColor: new Color 192, 192, 192\n  # see note above about Colors and shared objects\n  pressColor: new Color 128, 128, 128\n  centered: false\n  ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked: true\n  \n  # tells if the button represents a morph, in which\n  # case we are going to highlight the Widget on hover\n  representsAMorph: false\n\n  state: 0\n  STATE_NORMAL: 0\n  STATE_HIGHLIGHTED: 1\n  STATE_PRESSED: 2\n\n\n  constructor: (\n      @ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked = true,\n      @target = nil,\n      @action = nil,\n      @labelString = nil,\n      @fontSize = WorldMorph.preferencesAndSettings.menuFontSize,\n      @fontStyle = "sans-serif",\n      @centered = false,\n      @dataSourceMorphForTarget = nil,\n      @morphEnv,\n      @toolTipMessage = nil,\n      @labelColor = WorldMorph.preferencesAndSettings.menuButtonsLabelColor,\n      @labelBold = false,\n      @labelItalic = false,\n      @doubleClickAction = nil,\n      @argumentToAction1 = nil,\n      @argumentToAction2 = nil,\n      @representsAMorph = false\n      ) ->\n\n    # additional properties:\n\n    super()\n\n    # you shouldn\'t be able to drag a compound\n    # morphs containing a trigger by dragging the trigger\n    # (because you expect buttons attached to anything but the\n    # world to be "slippery", i.e.\n    # you can "skid" your drag over it in case you change\n    # your mind on pressing it)\n    # and at the same time (again if it\'s not on the desktop)\n    # you don\'t want it to be "floating"\n    # either\n    @defaultRejectDrags = true\n\n    @color = WorldMorph.preferencesAndSettings.menuBackgroundColor\n    if @labelString?\n      @layoutSubmorphs()\n  \n  layoutSubmorphs: (morphStartingTheChange = nil) ->\n    super()\n    if not @label?\n      @createLabel()\n    if @centered\n      @label.fullRawMoveTo @center().subtract @label.extent().floorDivideBy 2\n\n  getTextDescription: ->\n    if @textDescription?\n      return @textDescription + " (adhoc description of button)"\n    if @labelString\n      textWithoutLocationOrInstanceNo = @labelString.replace /#\\d*/, ""\n      return textWithoutLocationOrInstanceNo + " (text in button)"\n    else\n      return super()\n\n\n  setLabel: (@labelString) ->\n    # just recreated the label\n    # from scratch\n    if @label?\n      @label = @label.fullDestroy()\n    @layoutSubmorphs()\n\n  alignCenter: ->\n    if !@centered\n      @centered = true\n      @layoutSubmorphs()\n\n  alignLeft: ->\n    if @centered\n      @centered = false\n      @layoutSubmorphs()\n  \n\n  # This method only paints this very morph\'s "image",\n  # it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer, which\n  # eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->\n\n    if !@visibleBasedOnIsVisibleProperty() or @isCollapsed()\n      return nil\n\n    [area,sl,st,al,at,w,h] = @calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return nil\n\n      if appliedShadow?\n        color = "black"\n      else\n        color = switch @state\n          when @STATE_NORMAL\n            @color\n          when @STATE_HIGHLIGHTED\n            @highlightColor\n          when @STATE_PRESSED\n            @pressColor\n\n      # paintRectangle is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio\n      @paintRectangle \\\n        aContext,\n        al, at, w, h,\n        color,\n        @alpha,\n        true, # push and pop the context\n        appliedShadow\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio\n      @paintHighlight aContext, al, at, w, h\n\n  createLabel: ->\n    # bold\n    # italic\n    # numeric\n    # shadow offset\n    # shadow color\n    @label = new StringMorph(\n      @labelString or "",\n      @fontSize,\n      @fontStyle,\n      @labelBold,\n      @labelItalic,\n      false,\n      @labelColor      \n    )\n    @add @label\n    \n  # you shouldn\'t be able to drag a compound\n  # morphs containing a button by dragging the button\n  # (because you expect buttons attached to anything but the\n  # world to be "slippery", i.e.\n  # you can "skid" your drag over it in case you change\n  # your mind on pressing it)\n  # and you shouldn\'t be able to drag the button away either\n  # so the drag is entirely rejected\n  rejectDrags: ->\n    if @parent instanceof WorldMorph\n      return false\n    else\n      return @defaultRejectDrags\n  \n  # TriggerMorph action:\n  trigger: ->\n    if @action and @action != ""\n      #console.log "@target: " + @target + " @morphEnv: " + @morphEnv\n      @target[@action].call @target, @dataSourceMorphForTarget, @morphEnv, @argumentToAction1, @argumentToAction2\n    return\n\n  triggerDoubleClick: ->\n    # same as trigger() but use doubleClickAction instead of action property\n    # note that specifying a doubleClickAction is optional\n    return  unless @doubleClickAction\n    @target[@doubleClickAction]()  \n  \n  # TriggerMorph events:\n  mouseEnter: ->\n    @state = @STATE_HIGHLIGHTED\n    @changed()\n    @startCountdownForBubbleHelp @toolTipMessage  if @toolTipMessage\n  \n  # a copied trigger usually wants to un-highlight\n  # itself. This happens for example when you duplicate\n  # by clicking on a "duplicate" button INSIDE it.\n  justBeenCopied: ->\n    @mouseLeave()\n\n  mouseLeave: ->\n    @state = @STATE_NORMAL\n    @changed()\n    world.hand.destroyToolTips()  if @toolTipMessage\n  \n  mouseDownLeft: ->\n    @state = @STATE_PRESSED\n    @changed()\n    super\n  \n  mouseClickLeft: ->\n    @bringToForeground()\n    @state = @STATE_HIGHLIGHTED\n    @changed()\n    if @ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked\n      @propagateKillPopUps()\n    @trigger()\n\n  mouseDoubleClick: ->\n    @triggerDoubleClick()\n\n';
