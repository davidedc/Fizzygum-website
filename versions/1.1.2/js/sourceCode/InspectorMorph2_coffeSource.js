// Generated by CoffeeScript 1.12.7
window.InspectorMorph2_coffeSource = 'class InspectorMorph2 extends Widget\n\n  target: nil\n  currentProperty: nil\n  showing: "attributes"\n  markOwnershipOfProperties: true\n  # panes:\n  list: nil\n  detail: nil\n\n  classesButtons: nil\n  classesNames: nil\n  angledArrows: nil\n  hierarchyHeaderString: nil\n  propertyHeaderString: nil\n\n  showMethodsOnButton: nil\n  showMethodsOffButton: nil\n  showMethodsToggle: nil\n\n  showFieldsOnButton: nil\n  showFieldsOffButton: nil\n  showFieldsToggle: nil\n\n  showInheritedOnButton: nil\n  showInheritedOffButton: nil\n  showInheritedToggle: nil\n\n  showOwnPropsOnlyOnButton: nil\n  showOwnPropsOnlyOffButton: nil\n  showOwnPropsOnlyToggle: nil\n\n  lastLabelInHierarchy: nil\n  lastArrowInHierarchy: nil\n\n  hierarchyBackgroundPanel: nil\n\n  showingFields: true\n  showingMethods: true\n  showingInherited: false\n  showingOwnPropsOnly: false\n\n  addPropertyButton: nil\n  renamePropertyButton: nil\n  removePropertyButton: nil\n  saveButton: nil\n  saveTextWdgt: nil\n\n  externalPadding: 0\n  internalPadding: 5\n  padding: nil\n\n  # normally buttons only contain centered lower case text\n  # so we can get away with just no padding between button\n  # bounds and text. Some of these buttons however contain\n  # left-aligned class names (with capital letters) so we\n  # do need to add some padding...\n  classNamesTextPadding: 2\n\n  colloquialName: ->\n    "Object Inspector (" + @target.colloquialName() + ")"\n\n  showFields: ->\n    if !@showingFields\n      @showingFields = true\n      @buildAndConnectChildren()\n\n  showMethods: ->\n    if !@showingMethods\n      @showingMethods = true\n      @buildAndConnectChildren()\n\n  showInherited: ->\n    if !@showingInherited\n      @showingInherited = true\n      @buildAndConnectChildren()\n\n  showOwnPropsOnly: ->\n    if !@showingOwnPropsOnly\n      @showingOwnPropsOnly = true\n      @buildAndConnectChildren()\n\n  hideFields: ->\n    if @showingFields\n      @showingFields = false\n      @buildAndConnectChildren()\n\n  hideMethods: ->\n    if @showingMethods\n      @showingMethods = false\n      @buildAndConnectChildren()\n\n  hideInherited: ->\n    if @showingInherited\n      @showingInherited = false\n      @buildAndConnectChildren()\n\n  hideOwnPropsOnly: ->\n    if @showingOwnPropsOnly\n      @showingOwnPropsOnly = false\n      @buildAndConnectChildren()\n\n  constructor: (@target) ->\n    @classesButtons = []\n    @classesNames = []\n    @angledArrows = []\n    super new Point 300, 300\n    @buildAndConnectChildren()\n  \n  inspectObject: (objectToBeInspected) ->\n    @target = objectToBeInspected\n    @currentProperty = nil\n    @buildAndConnectChildren()\n  \n  buildAndConnectChildren: ->\n    debugger\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n    # remove all submorhs i.e. panes and buttons\n    # THE ONES THAT ARE STILL\n    # submorphs of the inspector. If they\n    # have been peeled away, they still live\n    @fullDestroyChildren()\n\n    attribs = []\n    @classesButtons = []\n    @classesNames = []\n    @angledArrows = []\n\n    # properties list. Note that this picks up ALL properties\n    # (enumerable such as strings and un-enumerable such as functions)\n    # of the whole prototype chain.\n    #\n    #   a) some of these are DECLARED as part of the class that defines the object\n    #   and are proprietary to the object. These are shown RED\n    # \n    #   b) some of these are proprietary to the object but are initialised by\n    #   code higher in the prototype chain. These are shown GREEN\n    #\n    #   c) some of these are not proprietary, i.e. they belong to an object up\n    #   the chain of prototypes. These are shown BLUE\n    #\n    # todo: show the static methods and variables in yet another color.\n    \n    for property of @target\n      # dummy condition, to be refined\n      attribs.push property  if property\n\n    if !@showingMethods\n      attribs = attribs.filter (prop) => !isFunction @target[prop]\n\n    if !@showingFields\n      attribs = attribs.filter (prop) => isFunction @target[prop]\n\n    # if we don\'t show inherited props, then we let through two types of props (each side of the "or"\n    # takes care of one type):\n    #   1) the ones that are defined in the immediate class of the object (i.e. are own properties of the prototype)\n    #   2) the ones that are just stitched to the object but are in none of the classes upwards i.e.\n    #      are not a reachable property from the prototype\n    if !@showingInherited\n      attribs = attribs.filter (prop) => @target.constructor.prototype.hasOwnProperty(prop) or (prop not of @target.constructor.prototype)\n\n    if @showingOwnPropsOnly\n      attribs = attribs.filter (prop) => @target.hasOwnProperty(prop)\n\n    console.log "attribs: " + attribs\n\n\n    # caches the own methods of the object\n    if @markOwnershipOfProperties\n      targetOwnMethods = Object.getOwnPropertyNames @target.constructor::\n      #alert targetOwnMethods\n\n    if @target?\n      goingUpTargetProtChain = @target.__proto__\n      while goingUpTargetProtChain.constructor.name != "Object"\n        @classesNames.push goingUpTargetProtChain.constructor.name\n        goingUpTargetProtChain = goingUpTargetProtChain.__proto__\n\n    @hierarchyBackgroundPanel = new RectangleMorph()\n    @hierarchyBackgroundPanel.setColor new Color 255,255,255,.2\n    @add @hierarchyBackgroundPanel\n\n    counter = 0\n    for eachNamedClass in @classesNames\n      classButton = new SimpleButtonMorph true, @, "openClassInspector", (new StringMorph2 eachNamedClass, WorldMorph.preferencesAndSettings.textInButtonsFontSize),nil,nil,nil,nil,eachNamedClass,nil,nil,@classNamesTextPadding\n      @classesButtons.push classButton\n      @add classButton\n\n      # the top class doesn\'t get an arrow pointing upwards\n      if counter > 0\n        angledArrow = new AngledArrowUpLeftIconMorph new Color 0,0,0\n        @angledArrows.push angledArrow\n        @add angledArrow\n\n      counter++\n\n    @lastLabelInHierarchy = new TextMorph "this object"\n    @add @lastLabelInHierarchy\n    @lastArrowInHierarchy = new AngledArrowUpLeftIconMorph new Color 0,0,0\n    @add @lastArrowInHierarchy\n\n    @showMethodsOnButton = new SimpleButtonMorph true, @, "hideMethods", "methods: on"\n    @showMethodsOffButton = new SimpleButtonMorph true, @, "showMethods", "methods: off"\n    @showMethodsToggle = new ToggleButtonMorph @showMethodsOnButton, @showMethodsOffButton, if @showingMethods then 0 else 1\n    @add @showMethodsToggle\n\n    @showFieldsOnButton = new SimpleButtonMorph true, @, "hideFields", "fields: on"\n    @showFieldsOffButton = new SimpleButtonMorph true, @, "showFields", "fields: off"\n    @showFieldsToggle = new ToggleButtonMorph @showFieldsOnButton, @showFieldsOffButton, if @showingFields then 0 else 1\n    @add @showFieldsToggle\n\n    @showInheritedOnButton = new SimpleButtonMorph true, @, "hideInherited", "inherited: on"\n    @showInheritedOffButton = new SimpleButtonMorph true, @, "showInherited", "inherited: off"\n    @showInheritedToggle = new ToggleButtonMorph @showInheritedOnButton, @showInheritedOffButton, if @showingInherited then 0 else 1\n    @add @showInheritedToggle\n\n    @buildAndConnectObjOwnPropsButton()\n\n    @addPropertyButton = new SimpleButtonMorph true, @, "addPropertyPopout", "add..."\n    @add @addPropertyButton\n    @renamePropertyButton = new SimpleButtonMorph true, @, "renamePropertyPopout", "rename..."\n    @add @renamePropertyButton\n    @removePropertyButton = new SimpleButtonMorph true, @, "removeProperty", "remove"\n    @add @removePropertyButton\n\n    @saveTextWdgt = (new StringMorph2 "save", WorldMorph.preferencesAndSettings.textInButtonsFontSize).alignCenter()\n    @saveButton = new SimpleButtonMorph true, @, "save", @saveTextWdgt\n    @add @saveButton\n\n\n\n    # open a new inspector, just on objects so\n    # the idea is that you can view / change\n    # its fields\n    doubleClickAction = =>\n      if !isObject @currentProperty\n        return\n      inspector = new @constructor @currentProperty\n      inspector.fullRawMoveTo world.hand.position()\n      inspector.fullRawMoveWithin world\n      world.add inspector\n      inspector.changed()\n\n    @list = new ListMorph(\n      @, # target\n      "selectionFromList", #action\n      (if @target instanceof Array then attribs else attribs.sort()), #elements\n      nil, #labelGetter\n      @filterProperties(targetOwnMethods), #format\n      doubleClickAction #doubleClickAction\n    )\n    @list.disableDrops()\n\n    # we know that the content of this list in this pane is not going to need the\n    # step function, so we disable that from here by setting it to nil, which\n    # prevents the recursion to children. We could have disabled that from the\n    # constructor of MenuMorph, but who knows, maybe someone might intend to use a MenuMorph\n    # with some animated content? We know that in this specific case it won\'t need animation so\n    # we set that here. Note that the ListMorph itself does require animation because of the\n    # scrollbars, but the MenuMorph (which contains the actual list contents)\n    # in this context doesn\'t.\n    world.removeSteppingMorph @list.listContents\n    @add @list\n\n    # we add a Widget alignment here because adjusting IDs whenever\n    # we add or remove methods is a pain...\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n\n    # details pane\n    @detail = new SimplePlainTextScrollPanelWdgt "", false, 5\n    @detail.disableDrops()\n    @detail.contents.disableDrops()\n    @detail.color = new Color 255, 255, 255\n    @detail.addModifiedContentIndicator()\n    \n    # when there is no selected item in the list\n    # (for example when the inspector is started)\n    # we need to manually remove the "modified" indicator\n    # and disable the "save" button\n    if !@list.selected?\n      @detail.modifiedTextTriangleAnnotation?.hide()\n      @saveTextWdgt.setColor new Color 200, 200, 200\n\n    # register this wdgt as one to be notified when the text\n    # changes/unchanges from "reference" content\n    # so we can enable/disable the "save" button\n    @detail.widgetToBeNotifiedOfTextModificationChange = @\n\n    @textMorph = @detail.textWdgt\n    @textMorph.backgroundColor = new Color 0,0,0,0\n    @textMorph.setFontName nil, nil, @textMorph.monoFontStack\n    @textMorph.isEditable = false\n\n    @add @detail\n\n\n\n    @hierarchyHeaderString = new StringMorph2 "Hierarchy", WorldMorph.preferencesAndSettings.textInButtonsFontSize\n    @hierarchyHeaderString.toggleHeaderLine()\n    @hierarchyHeaderString.alignCenter()\n    @add @hierarchyHeaderString\n\n\n    @propertyHeaderString = new StringMorph2 "Properties", WorldMorph.preferencesAndSettings.textInButtonsFontSize\n    @propertyHeaderString.toggleHeaderLine()\n    @propertyHeaderString.alignCenter()\n    @add @propertyHeaderString\n\n    # resizer\n    @resizer = new HandleMorph @\n\n    # update layout\n    @invalidateLayout()\n\n  textContentModified: ->\n    debugger\n    # TODO this would stand for enabling/disabling the button\n    # but really we are just changing the color and the button\n    # still works. Need some better enabling/disabling\n    @saveTextWdgt.setColor new Color 0,0,0\n\n  textContentUnmodified: ->\n    debugger\n    # TODO this would stand for enabling/disabling the button\n    # but really we are just changing the color and the button\n    # still works. Need some better enabling/disabling\n    @saveTextWdgt.setColor new Color 200, 200, 200\n\n\n  buildAndConnectObjOwnPropsButton: ->\n    @showOwnPropsOnlyOnButton = new SimpleButtonMorph true, @, "hideOwnPropsOnly", "obj own props only: on"\n    @showOwnPropsOnlyOffButton = new SimpleButtonMorph true, @, "showOwnPropsOnly", "obj own props only: off"\n    @showOwnPropsOnlyToggle = new ToggleButtonMorph @showOwnPropsOnlyOnButton, @showOwnPropsOnlyOffButton, if @showingOwnPropsOnly then 0 else 1\n    @add @showOwnPropsOnlyToggle\n\n  openClassInspector: (ignored,ignored2,className) ->\n    classInspector = new ClassInspectorMorph window[className].prototype\n    wm = new WindowWdgt nil, nil, classInspector\n    wm.setExtent new Point 560, 410\n    wm.fullRawMoveTo world.hand.position().subtract new Point 50, 100\n    wm.fullRawMoveWithin world\n    world.add wm\n    wm.changed()\n\n  showAttributes: ->\n    @showing = "attributes"\n    @buildAndConnectChildren()\n\n  showAttributesAndMethods: ->\n    @showing = "all"\n    @buildAndConnectChildren()\n\n  highlightOwnershipOfProperties: ->\n    @markOwnershipOfProperties = not @markOwnershipOfProperties\n    @buildAndConnectChildren()\n\n  filterProperties: (targetOwnMethods)->\n    if @markOwnershipOfProperties\n      return [\n        # give color criteria from the most general to the most specific\n        [new Color(0, 0, 180),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            true\n        ],\n        [new Color(0, 180, 0),\n          (element) =>\n            # if the element is either an enumerable property of the object\n            # or it belongs to the own methods, then it is highlighted.\n            # Note that hasOwnProperty doesn\'t pick up non-enumerable properties such as\n            # functions.\n            # In theory, getOwnPropertyNames should give ALL the properties but the methods\n            # are still not picked up, maybe because of the coffeescript construction system, I am not sure\n            @target.constructor.prototype.hasOwnProperty(element)\n        ]\n      ]\n    else\n      return nil\n\n  selectionFromList: (selected) ->\n    if selected == undefined then return\n\n    val = @target[selected]\n    @currentProperty = val\n\n    # functions should have a source somewhere\n    # either in the object or in a superclass,\n    # try to find it.\n    if isFunction(val)\n      if @target[selected + "_source"]?\n          val = @target[selected + "_source"]\n      else\n        goingUpTargetProtChain = @target\n        while goingUpTargetProtChain != Object\n          if goingUpTargetProtChain.constructor.class.nonStaticPropertiesSources[selected]?\n            val = goingUpTargetProtChain.constructor.class.nonStaticPropertiesSources[selected]\n            break\n          goingUpTargetProtChain = goingUpTargetProtChain.__proto__\n      txt = val.toString()\n    else\n      # this is for finding the static variables\n      if val is undefined\n        val = @target.constructor[selected]\n      \n      if !val?\n        txt = "nil"\n      else if isString val\n        txt = \'"\'+val+\'"\'\n      else\n        txt = val.toString()\n\n    cnts = @detail.textWdgt\n    cnts.setText txt\n    cnts.setReceiver @target\n    cnts.isEditable = true\n    cnts.enableSelecting()\n    cnts.considerCurrentTextAsReferenceText()\n    @detail.checkIfTextContentWasModifiedFromTextAtStart()\n  \n  doLayout: (newBoundsForThisLayout) ->\n    debugger\n    if !window.recalculatingLayouts\n      debugger\n\n    if @isCollapsed()\n      @layoutIsValid = true\n      @notifyChildrenThatParentHasReLayouted()\n      return\n\n    super\n\n    # here we are disabling all the broken\n    # rectangles. The reason is that all the\n    # submorphs of the inspector are within the\n    # bounds of the parent Widget. This means that\n    # if only the parent morph breaks its rectangle\n    # then everything is OK.\n    # Also note that if you attach something else to its\n    # boundary in a way that sticks out, that\'s still\n    # going to be painted and moved OK.\n    trackChanges.push false\n\n\n    classDiagrHeight = Math.floor(@height() / 3)\n\n\n    headerBounds = new Rectangle new Point(Math.round(@left() + @externalPadding), Math.round(@top() + @externalPadding))\n    headerBounds = headerBounds.setBoundsWidthAndHeight @width() - 2 * @externalPadding, 15\n    @hierarchyHeaderString.doLayout headerBounds\n\n\n    # classes diagram\n    justAcounter = 0\n    anotherCount = 0\n    # reverse works in-place, so we need to remember\n    # to put them back right after we are done\n    @classesButtons.reverse()\n    for eachClassButton in @classesButtons\n      if eachClassButton.parent == @\n        buttonBounds = new Rectangle new Point(Math.round(@left() + @externalPadding + @internalPadding + justAcounter), Math.round(@hierarchyHeaderString.bottom() + 2*@internalPadding + justAcounter))\n        buttonBounds = buttonBounds.setBoundsWidthAndHeight 120 + @classNamesTextPadding * 2, 15 + @classNamesTextPadding * 2\n        eachClassButton.doLayout buttonBounds\n\n        # the top class doesn\'t get an arrow pointing upwards\n        if anotherCount > 0\n          @angledArrows[anotherCount-1].parent == @\n          @angledArrows[anotherCount-1].fullRawMoveTo new Point(eachClassButton.left() - 15, Math.round(eachClassButton.top()))\n          @angledArrows[anotherCount-1].rawSetExtent new Point 15, 15\n\n        justAcounter += 20\n\n      anotherCount++\n    @classesButtons.reverse()\n    @layoutLastLabelInHierarchy Math.round(@left() + @externalPadding + @internalPadding + justAcounter), Math.round(@hierarchyHeaderString.bottom() + 2 * @internalPadding + justAcounter)\n\n    @hierarchyBackgroundPanel.fullRawMoveTo new Point @left() + @externalPadding, @hierarchyHeaderString.bottom() + @internalPadding\n    @hierarchyBackgroundPanel.rawSetExtent new Point @width() - 2 * @externalPadding, justAcounter + 20 + @internalPadding\n\n    headerBounds = new Rectangle new Point @left() + @externalPadding , @hierarchyBackgroundPanel.bottom()+ @internalPadding\n    headerBounds = headerBounds.setBoundsWidthAndHeight @width() - 2 * @externalPadding , 15\n    @propertyHeaderString.doLayout headerBounds\n\n    listWidth = Math.floor((@width() - 2 * @externalPadding - @internalPadding ) / 3)\n    detailWidth = 2*listWidth\n\n    @layoutOwnPropsOnlyToggle @propertyHeaderString.bottom() + @internalPadding, listWidth, detailWidth\n\n    # list\n    listHeight = (@bottom() - @externalPadding - @internalPadding - 15) - (@showMethodsToggle.bottom() + @internalPadding)\n    if @list.parent == @\n      @list.fullRawMoveTo new Point @left() + @externalPadding, @showMethodsToggle.bottom() + @internalPadding\n      @list.rawSetExtent new Point listWidth, listHeight\n\n    # detail\n    if @detail.parent == @\n      @detail.fullRawMoveTo new Point @list.right() + @internalPadding, @list.top()\n      @detail.rawSetExtent (new Point detailWidth, listHeight).round()\n\n    widthOfButtonsUnderList = Math.round((listWidth - 2 * @internalPadding)/3)\n\n    buttonBounds = new Rectangle new Point @left() + @externalPadding, @bottom() - 15 - @externalPadding\n    buttonBounds = buttonBounds.setBoundsWidthAndHeight widthOfButtonsUnderList, 15\n    @addPropertyButton.doLayout buttonBounds\n\n    buttonBounds = new Rectangle new Point @addPropertyButton.right() + @internalPadding, @bottom() - 15 - @externalPadding\n    buttonBounds = buttonBounds.setBoundsWidthAndHeight widthOfButtonsUnderList, 15\n    @renamePropertyButton.doLayout buttonBounds\n\n    buttonBounds = new Rectangle new Point @renamePropertyButton.right() + @internalPadding, @bottom() - 15 - @externalPadding\n    buttonBounds = buttonBounds.setBoundsWidthAndHeight widthOfButtonsUnderList, 15\n    @removePropertyButton.doLayout buttonBounds\n\n    buttonBounds = new Rectangle new Point Math.round(@right() - @width()/4 - @externalPadding - @internalPadding - WorldMorph.preferencesAndSettings.handleSize), @bottom() - 15 - @externalPadding\n    buttonBounds = buttonBounds.setBoundsWidthAndHeight Math.round(@width()/4), 15\n    @saveButton.doLayout buttonBounds\n\n    trackChanges.pop()\n    @fullChanged()\n\n    @layoutIsValid = true\n    @notifyChildrenThatParentHasReLayouted()\n\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n\n  layoutOwnPropsOnlyToggle: (height, listWidth, detailWidth) ->\n\n    toggleBounds = new Rectangle new Point @left()+@externalPadding , height\n    toggleBounds = toggleBounds.setBoundsWidthAndHeight (new Point (listWidth-@internalPadding)/ 2,15).round()\n    @showMethodsToggle.doLayout toggleBounds\n\n    toggleBounds = new Rectangle new Point @showMethodsToggle.right() + @internalPadding, height\n    toggleBounds = toggleBounds.setBoundsWidthAndHeight (new Point (listWidth-@internalPadding)/ 2,15).round()\n    @showFieldsToggle.doLayout toggleBounds\n \n    toggleBounds = new Rectangle new Point @showFieldsToggle.right() + @internalPadding, height\n    toggleBounds = toggleBounds.setBoundsWidthAndHeight (new Point (detailWidth-@internalPadding)/ 2,15).round()\n    @showInheritedToggle.doLayout toggleBounds\n\n    toggleBounds = new Rectangle new Point @showInheritedToggle.right() + @internalPadding, height\n    toggleBounds = toggleBounds.setBoundsWidthAndHeight (new Point (detailWidth-@internalPadding)/ 2,15).round()\n    @showOwnPropsOnlyToggle.doLayout toggleBounds\n\n\n  layoutLastLabelInHierarchy: (posx, posy) ->\n    if @lastLabelInHierarchy.parent == @\n      @lastLabelInHierarchy.fullRawMoveTo new Point posx, posy\n      @lastLabelInHierarchy.rawSetExtent new Point 150, 15\n\n    if @lastArrowInHierarchy.parent == @\n      @lastArrowInHierarchy.fullRawMoveTo new Point posx - 15, posy\n      @lastArrowInHierarchy.rawSetExtent new Point 15, 15\n\n\n  notifyInstancesOfSourceChange: (propertiesArray)->\n    @target.sourceChanged()\n  \n  #InspectorMorph2 editing ops:\n  save: ->\n    if !@list.selected? then return\n    txt = @detail.contents.children[0].text.toString()\n    propertyName = @list.selected.labelString\n    # inject code will also break the layout and the morph\n    @target.injectProperty propertyName, txt\n\n    @detail.textWdgt.considerCurrentTextAsReferenceText()\n    @detail.checkIfTextContentWasModifiedFromTextAtStart()\n\n    # it\'s possible that the user might have fixed\n    # a "painting" error, so give another chance to all\n    # "banned" widgets (banned from repainting)\n    for eachWidget in world.widgetsGivingErrorWhileRepainting\n      eachWidget.show()\n    world.widgetsGivingErrorWhileRepainting = []\n\n\n  # TODO should have a removeProperty method in Widget (and in the classes somehow)\n  # rather than here \n  addProperty: (ignoringThis, morphWithProperty) ->\n    prop = morphWithProperty.text.text\n    if prop?\n      if prop.getValue?\n        prop = prop.getValue()\n      @target[prop] = nil\n      @buildAndConnectChildren()\n      @notifyInstancesOfSourceChange([prop])\n  \n  addPropertyPopout: ->\n    @prompt "new property name:", @, "addProperty", "property" # Chrome cannot handle empty strings (others do)\n\n  # TODO should have a removeProperty method in Widget (and in the classes somehow)\n  # rather than here \n  renameProperty: (ignoringThis, morphWithProperty) ->\n    propertyName = @list.selected.labelString\n    prop = morphWithProperty.text.text\n    if prop.getValue?\n      prop = prop.getValue()\n    \n    delete @target[propertyName]\n    @target[prop] = @currentProperty\n\n    @buildAndConnectChildren()\n    @notifyInstancesOfSourceChange([prop, propertyName])\n  \n  renamePropertyPopout: ->\n    propertyName = @list.selected.labelString\n    @prompt "property name:", @, "renameProperty", propertyName\n  \n  # TODO should have a removeProperty method in Widget (and in the classes somehow)\n  # rather than here \n  removeProperty: ->\n    propertyName = @list.selected.labelString\n\n    delete @target[propertyName]\n\n    @currentProperty = nil\n    @buildAndConnectChildren()\n    @notifyInstancesOfSourceChange([propertyName])\n';
