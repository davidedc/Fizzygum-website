// Generated by CoffeeScript 1.12.7
window.HandMorph_coffeSource = '# The mouse cursor. Note that it\'s not a child of the WorldMorph, this Widget\n# is never added to any other morph. [TODO] Find out why and write explanation.\n# Not to be confused with the HandleMorph\n\nclass HandMorph extends Widget\n\n  world: nil\n  mouseButton: nil\n  # used for example to check that\n  # mouseDown and mouseUp happen on the\n  # same Widget (otherwise clicks happen for\n  # example when resizing a button via the\n  # handle)\n  mouseDownMorph: nil\n  mouseDownPosition: nil\n  morphToGrab: nil\n  grabOrigin: nil\n  mouseOverList: nil\n  toolTipsList: nil\n  touchHoldTimeout: nil\n  doubleClickMorph: nil\n  tripleClickMorph: nil\n  nonFloatDraggedMorph: nil\n  nonFloatDragPositionWithinMorphAtStart: nil\n  # this is useful during nonFloatDrags to pass the morph\n  # the delta position since the last invokation\n  previousNonFloatDraggingPos: nil\n\n  constructor: (@world) ->\n    @mouseOverList = []\n    @toolTipsList = []\n    super()\n    @minimumExtent = new Point 0,0\n    @silentRawSetBounds Rectangle.EMPTY\n\n  clippedThroughBounds: ->\n    @checkClippedThroughBoundsCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    @clippedThroughBoundsCache = @boundingBox()\n    return @clippedThroughBoundsCache\n\n  clipThrough: ->\n    @checkClipThroughCache = WorldMorph.numberOfAddsAndRemoves + "-" + WorldMorph.numberOfVisibilityFlagsChanges + "-" + WorldMorph.numberOfCollapseFlagsChanges + "-" + WorldMorph.numberOfRawMovesAndResizes\n    @clipThroughCache = @boundingBox()\n    return @clipThroughCache\n  \n  # HandMorph navigation:\n  topMorphUnderPointer: ->\n    result = @world.topMorphSuchThat (m) =>\n      m.clippedThroughBounds().containsPoint(@position()) and\n        m.visibleBasedOnIsVisibleProperty() and\n        !m.isCollapsed() and\n        (m.noticesTransparentClick or (not m.isTransparentAt(@position()))) and\n        # we exclude the Caret here because\n        #  a) it messes up things on double-click as it appears under\n        #     the mouse after the first clicks\n        #  b) the caret disappears as soon as a menu appears, so it\n        #     would be confusing to select a caret.\n        # I drafted an alternative implementation where we manage\n        # those situations without being radical in this filtering-out\n        # but it was quite a bit more complicated.\n        (m not instanceof CaretMorph) and\n        # exclude morphs we use for highlighting\n        # other morphs\n        !m.morphThisMorphIsHighlighting? and\n        !m.morphThisMorphIsPinouting?\n    if result?\n      return result\n    else\n      return @world\n\n  menuAtPointer: ->\n    result = @world.topMorphSuchThat (m) =>\n      m.clippedThroughBounds().containsPoint(@position()) and\n        m.visibleBasedOnIsVisibleProperty() and\n        !m.isCollapsed() and\n        (m.noticesTransparentClick or\n        (not m.isTransparentAt(@position()))) and (m instanceof MenuMorph)\n    return result\n\n\n\n  openContextMenuAtPointer: (morphTheMenuIsAbout) ->\n    # note that the morphs that the menu\n    # belongs to might not be under the mouse.\n    # It usually is, but in cases\n    # where a system test is playing against\n    # a world setup that has varied since the\n    # recording, this could be the case.\n\n    # these three are checks and actions that normally\n    # would happen on MouseDown event, but we\n    # removed that event as we collapsed the down and up\n    # into this coalesced higher-level event,\n    # but we still need to make these checks and actions\n    @destroyTemporaryHandlesAndLayoutAdjustersIfHandHasNotActionedThem morphTheMenuIsAbout\n    @stopEditingIfWidgetDoesntNeedCaretOrActionIsElsewhere morphTheMenuIsAbout\n\n    if AutomatorRecorderAndPlayer? and\n     AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      fade \'rightMouseButtonIndicator\', 0, 1, 10, new Date().getTime()\n      setTimeout \\\n        =>\n          fade \'rightMouseButtonIndicator\', 1, 0, 500, new Date().getTime()\n        , 100\n    \n    contextMenu = morphTheMenuIsAbout.buildContextMenu()\n    while !contextMenu and morphTheMenuIsAbout.parent\n      morphTheMenuIsAbout = morphTheMenuIsAbout.parent\n      contextMenu = morphTheMenuIsAbout.buildContextMenu()\n\n    if contextMenu\n      contextMenu.popUpAtHand()\n\n\n  # not used in ZK yet\n  allMorphsAtPointer: ->\n    return @world.collectAllChildrenBottomToTopSuchThat (m) =>\n      m.visibleBasedOnIsVisibleProperty() and\n      !m.isCollapsed() and\n      m.clippedThroughBounds().containsPoint @position()\n  \n  \n  \n  # HandMorph floatDragging and dropping:\n  #\n  # floatDrag \'n\' drop events, method(arg) -> receiver:\n  #\n  #   prepareToBeGrabbed() -> grabTarget\n  #   reactToGrabOf(grabbedMorph) -> oldParent\n  #   wantsDropOf(morphToDrop) ->  newParent\n  #   justDropped(handMorph) -> droppedMorph\n  #   reactToDropOf(droppedMorph, handMorph) -> newParent\n  #\n  dropTargetFor: (aMorph) ->\n    target = @topMorphUnderPointer()\n    until target.wantsDropOf aMorph\n      target = target.parent\n    target\n  \n  grab: (aMorph, displacementDueToGrabDragThreshold,  switcherooHappened) ->\n    return nil  if aMorph instanceof WorldMorph\n    oldParent = aMorph.parent\n    if !@floatDraggingSomething()\n\n      if AutomatorRecorderAndPlayer?\n        @world.automatorRecorderAndPlayer.addGrabCommand()\n        if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n          action = "grab"\n          arr = window.world.automatorRecorderAndPlayer.tagsCollectedWhileRecordingTest\n          if action not in arr\n            arr.push action\n\n\n      @world.stopEditing()\n\n      # this paragraph deals with how to resize/reposition the widget\n      # that we are grabbing in respect to the hand\n      if switcherooHappened\n        # in this case the widget being grabbed is created on the fly\n        # so just like the next case it\'s OK to center it under the pointer\n        aMorph.fullRawMoveTo @position().subtract aMorph.extent().floorDivideBy 2\n        aMorph.fullRawMoveWithin world\n      else if aMorph.extentToGetWhenDraggedFromGlassBox? and (oldParent instanceof GlassBoxBottomWdgt)\n        # in this case the widget is "inflating". So, all\n        # visual references that the user might have around the\n        # position of the grab go out of the window: just center\n        # the widget under the pointer and fit it within the\n        # desktop bounds since we are at it (useful in case the\n        # widget is inflating near the screen edges)\n        aMorph.rawSetExtent aMorph.extentToGetWhenDraggedFromGlassBox\n        aMorph.fullRawMoveTo @position().subtract aMorph.extent().floorDivideBy 2\n        aMorph.fullRawMoveWithin world\n      else if displacementDueToGrabDragThreshold?\n        # in this case keep some visual consistency and move\n        # the widget accordingly to where the grab started\n        # (remember: we actually grab a while after the user has\n        # pressed, because we want to see an actual significant move\n        # before we resolve that this is a grab)\n        # Don\'t fit the widget within the world because it often\n        # happens to pick up a widget that is partially outside the\n        # screen and it\'s no good to make it jump within the screen\n        # - I tried and it looks really strange -\n        aMorph.fullMoveTo aMorph.position().add displacementDueToGrabDragThreshold\n\n      @grabOrigin = aMorph.situation()\n      aMorph.prepareToBeGrabbed?()\n\n      @add aMorph\n      aMorph.justBeenGrabbed? oldParent\n      # you must add the shadow\n      # after the morph has been added\n      # because "@add aMorph" causes\n      # the morph to be painted potentially\n      # for the first time.\n      # The shadow needs the image of the\n      # morph to make the shadow, so\n      # this is why we add the shadow after\n      # the morph has been added.\n      # Note that Widgets can specify the look\n      # (i.e. offset blur and color)\n      # of their shadow (e.g. Menus have a particular one\n      # so they all seem to float at a particular height)\n      # but here when we grab morphs we\n      # specify a particular look for the shadow.\n      # This is a particularly "floaty" shadow\n      # which illustrates how things being dragged\n      # are above anything else.\n\n      aMorph.addShadow new Point(6, 6), 0.1\n      \n      #debugger\n      @fullChanged()\n      # this gives an occasion to the old parent\n      # morph to adjust itself e.g. the ScrollPanelWdgt\n      # readjusts itself if you take some morphs\n      # out of it.\n      oldParent?.reactToGrabOf? aMorph\n\n  draggingSomething: ->\n    @floatDraggingSomething() or @nonFloatDraggingSomething()\n\n  floatDraggingSomething: ->\n    if @children.length > 0 then true else false\n\n  nonFloatDraggingSomething: ->\n    return @nonFloatDraggedMorph?\n\n\n  drop: ->\n    if @floatDraggingSomething()\n\n      if AutomatorRecorderAndPlayer?\n        @world.automatorRecorderAndPlayer.addDropCommand()\n        if AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.RECORDING\n          action = "drop"\n          arr = window.world.automatorRecorderAndPlayer.tagsCollectedWhileRecordingTest\n          if action not in arr\n            arr.push action\n\n      morphToDrop = @children[0]\n\n      if morphToDrop.rejectsBeingDropped?()\n        target = world\n      else\n        target = @dropTargetFor morphToDrop\n\n      @fullChanged()\n      morphToDrop.aboutToBeDropped? target\n      target.aboutToDrop? morphToDrop\n      target.add morphToDrop, nil, nil, true, nil, @position()\n      morphToDrop.fullChanged()\n\n      # when you click the buttons, sometimes you end up\n      # clicking between the buttons, and so the "proper"\n      # widget "loses focus" so to speak. So avoiding that here.\n      if !(morphToDrop instanceof HorizontalMenuPanelWdgt)\n        world.lastNonTextPropertyChangerButtonClickedOrDropped = morphToDrop\n\n      @children = []\n      @rawSetExtent new Point()\n\n      # first we notify the recipient of the drop\n      # this gives the chance to the recipient to\n      # initialise a layout spec for the dropped widget\n      target.reactToDropOf? morphToDrop, @\n\n      # then we notify the dropped widget. This currently\n      # is used to let the dropped morph tweak the layout\n      # spec (some widgets suddenly become constrained by ratio\n      # when they are dropped into a document)\n      morphToDrop.justDropped? target\n\n    #else\n    #  alert "if you never see this alert then you can delete the test"\n  \n  # HandMorph event dispatching:\n  #\n  #    mouse events:\n  #\n  #   mouseDownLeft\n  #   mouseDownRight\n  #   mouseClickLeft\n  #   mouseClickRight\n  #   mouseDoubleClick\n  #   mouseEnter\n  #   mouseLeave\n  #   mouseEnterfloatDragging\n  #   mouseLeavefloatDragging\n  #   mouseMove\n  #   wheel\n  #\n  # Note that some handlers don\'t want the event but the\n  # interesting parameters of the event. This is because\n  # the testing harness only stores the interesting parameters\n  # rather than a multifaceted and sometimes browser-specific\n  # event object.\n\n  destroyTemporaryHandlesAndLayoutAdjustersIfHandHasNotActionedThem: (actionedMorph) ->\n    if @world.temporaryHandlesAndLayoutAdjusters.length > 0\n      if actionedMorph not in @world.temporaryHandlesAndLayoutAdjusters\n        for eachTemporaryHandlesAndLayoutAdjusters in @world.temporaryHandlesAndLayoutAdjusters\n          eachTemporaryHandlesAndLayoutAdjusters.fullDestroy()\n        @world.temporaryHandlesAndLayoutAdjusters = []\n\n  stopEditingIfWidgetDoesntNeedCaretOrActionIsElsewhere: (actionedMorph) ->\n    if @world.caret?\n\n      # some actioning widgets rely on the\n      # caret, for example to change the properties\n      # of text (e.g. make it bold)\n      if actionedMorph.editorContentPropertyChangerButton? and actionedMorph.editorContentPropertyChangerButton\n        return\n\n      # if you click anything directly inside a button that has\n      # "editorContentPropertyChangerButton" set, then do nothing\n      # This is needed because you might "down" on the label of the\n      # button and you don\'t want to stopEditing in that case\n      # either...\n      if actionedMorph.parent? and\n       (actionedMorph.parent instanceof SimpleButtonMorph) and\n       actionedMorph.parent.editorContentPropertyChangerButton? and\n       actionedMorph.parent.editorContentPropertyChangerButton\n        return\n\n      # there is a caret on the screen\n      # depending on what the user is clicking on,\n      # we might need to close an ongoing edit\n      # operation, which means deleting the\n      # caret and un-selecting anything that was selected.\n      #\n      # This check is because we don\'t want to interrupt\n      # an edit if the user is invoking/clicking on anything\n      # inside a menu regarding text that is being edited\n      # because the invoked function\n      # might do something with the selection\n      # (for example doSelection takes the current selection).\n      #\n      # In other words, if we are actioning on something that has\n      # the text as an ancestor, then don\'t stop the\n      # editing.\n      if actionedMorph isnt @world.caret.target\n        # user clicked on something other than what the\n        # caret is attached to\n        mostRecentlyCreatedPopUp = world.mostRecentlyCreatedPopUp()\n        if mostRecentlyCreatedPopUp?\n          unless mostRecentlyCreatedPopUp.isAncestorOf actionedMorph\n            # only dismiss editing if the actionedMorph the user\n            # clicked on is not part of a menu.\n            @world.stopEditing()\n        # there is no menu at all, in which case\n        # we know there was an editing operation going\n        # on that we need to stop\n        else\n          @world.stopEditing()\n\n\n  processMouseDown: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    @destroyToolTips()\n    @morphToGrab = nil\n\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      if button is 2 or ctrlKey\n        fade \'rightMouseButtonIndicator\', 0, 1, 10, new Date().getTime()\n      else\n        fade \'leftMouseButtonIndicator\', 0, 1, 10, new Date().getTime()\n\n\n    @mouseDownPosition = @position()\n\n    # check whether we are in the middle\n    # of a floatDrag/drop operation\n    if @floatDraggingSomething()\n      @drop()\n      @mouseButton = nil\n    else\n      morph = @topMorphUnderPointer()\n\n      @destroyTemporaryHandlesAndLayoutAdjustersIfHandHasNotActionedThem morph\n      # TODO it seems a little aggressive to stop any editing\n      # just on the "down", probably something higher level\n      # would be better? Like if any other object is brought to the\n      # foreground?\n      @stopEditingIfWidgetDoesntNeedCaretOrActionIsElsewhere morph\n\n      # if we are doing a mousedown on anything outside a menu\n      # then all the menus must go, whether or not they have\n      # been freshly created or not. This came about because\n      # small movements of the mouse while clicking on the\n      # desktop would not dismiss menus.\n      if !(morph.firstParentThatIsAPopUp() instanceof MenuMorph)\n        @cleanupMenuMorphs nil, morph, true\n\n      @morphToGrab = morph.findRootForGrab()\n      if button is 2 or ctrlKey\n        @mouseButton = "right"\n        actualClick = "mouseDownRight"\n        expectedClick = "mouseClickRight"\n      else\n        @mouseButton = "left"\n        actualClick = "mouseDownLeft"\n        expectedClick = "mouseClickLeft"\n\n      @mouseDownMorph = morph\n      @mouseDownMorph = @mouseDownMorph.parent  until @mouseDownMorph[expectedClick]\n\n      \n      while !morph[actualClick]?\n        if morph.parent?\n          morph = morph.parent\n        else\n          break\n\n      if morph[actualClick]?\n        morph[actualClick] @position()\n      #morph = morph.parent  until morph[actualClick]\n      #morph[actualClick] @position()\n  \n  # touch events, see:\n  # https://developer.apple.com/library/safari/documentation/appleapplications/reference/safariwebcontent/HandlingEvents/HandlingEvents.html\n  # A long touch emulates a right click. This is done via\n  # setting a timer 400ms after the touch which triggers\n  # a right mouse click. Any touch event before then just\n  # resets the timer (if far enough from the touch start point,\n  # to "de-noise" the hold).\n  processTouchStart: (event) ->\n\n    # don\'t send emulated mouse events for this touch event\n    event.preventDefault()\n\n    #WorldMorph.preferencesAndSettings.isTouchDevice = true\n    clearInterval @touchHoldTimeout\n    if event.touches.length is 1\n      # simulate mouseRightClick\n      touch = event.touches[0]\n      @touchStartPosition = new Point touch.pageX, touch.pageY\n      @touchHoldTimeout = setInterval(=>\n        @processMouseDown 2 # button 2 is the right one\n        @processMouseUp 2 # button 2 is the right one, we don\'t use this parameter\n        event.preventDefault() # I don\'t think that this is needed\n        clearInterval @touchHoldTimeout\n      , 400)\n      @processMouseMove touch.pageX, touch.pageY # update my position\n      @processMouseDown 0 # button zero is the left button\n  \n  processTouchMove: (event) ->\n\n    # Prevent scrolling on this element and\n    # don\'t send emulated mouse events for this touch event\n    event.preventDefault()\n\n    if event.touches.length is 1\n      touch = event.touches[0]\n      @processMouseMove touch.pageX, touch.pageY\n      if ((new Point touch.pageX, touch.pageY).distanceTo @touchStartPosition) > WorldMorph.preferencesAndSettings.grabDragThreshold\n        clearInterval @touchHoldTimeout\n\n  processTouchEnd: (event) ->\n\n    # don\'t send emulated mouse events for this touch event\n    event.preventDefault()\n\n    # note that the mouse down event handler\n    # that is calling this method has ALREADY\n    # added a mousedown command\n\n    #WorldMorph.preferencesAndSettings.isTouchDevice = true\n    clearInterval @touchHoldTimeout\n    @processMouseUp 0 # button zero is the left button, we don\'t use this parameter\n    \n    # no need to set this to nil, but let\'s just clean up\n    @touchStartPosition = nil\n  \n   # note that the button param is not used,\n   # but adding it for consistency...\n  processMouseUp: (button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      if button is 2\n        fade \'rightMouseButtonIndicator\', 1, 0, 500, new Date().getTime()\n      else\n        fade \'leftMouseButtonIndicator\', 1, 0, 500, new Date().getTime()\n\n    morph = @topMorphUnderPointer()\n\n    alreadyRecordedLeftOrRightClickOnMenuItem = false\n    @destroyToolTips()\n    world.freshlyCreatedPopUps = []\n\n\n    if @floatDraggingSomething()\n      @drop()\n    else\n\n      # used right now for the slider button:\n      # it\'s likely that the non-float drag will end\n      # up outside of its bounds, and yet we need to\n      # notify the button that the drag is over so it\n      # can repaint itself of another color.\n      if @nonFloatDraggingSomething()\n        @nonFloatDraggedMorph.endOfNonFloatDrag?()\n\n      @previousNonFloatDraggingPos = nil\n      # let\'s check if the user clicked on a menu item,\n      # in which case we add a special dedicated command\n      # [TODO] you need to do some of this only if you\n      # are recording a test, it\'s worth saving\n      # these steps...\n      #debugger\n      ignored = nil\n      toDestructure = morph.parentThatIsA MenuItemMorph\n      if toDestructure?\n        [menuItemMorph, ignored]= toDestructure\n        if menuItemMorph\n          # we check whether the menuitem is actually part\n          # of an activeMenu. Keep in mind you could have\n          # detached a menuItem and placed it on any other\n          # morph so you need to ascertain that you\'ll\n          # find it in the activeMenu later on...\n          mostRecentlyCreatedPopUp = world.mostRecentlyCreatedPopUp()\n          if mostRecentlyCreatedPopUp == menuItemMorph.parent\n            labelString = menuItemMorph.labelString\n            occurrenceNumber = menuItemMorph.howManySiblingsBeforeMeSuchThat (m) ->\n              m.labelString == labelString\n            # this method below is also going to remove\n            # the mouse down/up commands that have\n            # recently/just been added.\n            if AutomatorRecorderAndPlayer?\n              @world.automatorRecorderAndPlayer.addCommandLeftOrRightClickOnMenuItem(@mouseButton, labelString, occurrenceNumber + 1)\n            alreadyRecordedLeftOrRightClickOnMenuItem = true\n\n      # TODO check if there is any other\n      # possibility other than mouseButton being "left"\n      # or "right". If it can only be one of those\n      # that you can simplify this nested if below\n      # and avoid using actionAlreadyProcessed\n      if @mouseButton is "left"\n        expectedClick = "mouseClickLeft"\n      else\n        expectedClick = "mouseClickRight"\n        if @mouseButton\n          if !alreadyRecordedLeftOrRightClickOnMenuItem\n            # this being a right click, pop\n            # up a menu as needed.\n            if AutomatorRecorderAndPlayer?\n              @world.automatorRecorderAndPlayer.addOpenContextMenuCommand morph.uniqueIDString()\n\n      # trigger the action\n      until morph[expectedClick]\n        morph = morph.parent\n        if not morph?\n          break\n      if morph?\n        if morph == @mouseDownMorph\n\n          switch expectedClick\n            when "mouseClickLeft"\n              pointerAndMorphInfo = world.getPointerAndMorphInfo()\n              if AutomatorRecorderAndPlayer?\n                world.automatorRecorderAndPlayer.addMouseClickCommand 0, nil, pointerAndMorphInfo...\n              morph.mouseUpLeft? @position(), button, buttons, ctrlKey, shiftKey, altKey, metaKey\n            when "mouseClickRight"\n              pointerAndMorphInfo = world.getPointerAndMorphInfo()\n              if AutomatorRecorderAndPlayer?\n                world.automatorRecorderAndPlayer.addMouseClickCommand 2, nil, pointerAndMorphInfo...\n              morph.mouseUpRight? @position(), button, buttons, ctrlKey, shiftKey, altKey, metaKey\n\n          # also send doubleclick if the\n          # two clicks happen on the same morph\n          doubleClickInvocation = false\n\n          if @doubleClickMorph?\n            # three conditions:\n            #  - both clicks are left-button clicks\n            #  - both clicks on same widget\n            #  - both clicks nearby\n            if @mouseButton == "left" and\n             @doubleClickMorph == morph and\n             ((@doubleClickPosition.distanceTo @position()) < WorldMorph.preferencesAndSettings.grabDragThreshold)\n              #console.log "@doubleClickPosition.distanceTo @position():" + @doubleClickPosition.distanceTo @position()\n              #console.log "WorldMorph.preferencesAndSettings.grabDragThreshold:" + WorldMorph.preferencesAndSettings.grabDragThreshold\n              @doubleClickMorph = nil\n              disableConsecutiveClicksFromSingleClicksDueToFastTests = false\n              if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n                if !window.world.automatorRecorderAndPlayer.runningInSlowMode()\n                  disableConsecutiveClicksFromSingleClicksDueToFastTests = true\n              if !disableConsecutiveClicksFromSingleClicksDueToFastTests\n                # remember we are going to send a double click\n                # but let\'s do it after. That\'s because we first\n                # want to send the normal click AND we want to tell\n                # in the normal click that that normal click is part\n                # of a double click\n                doubleClickInvocation = true\n                # triple-click detection starts here, it\'s just\n                # like chaining a second double-click detection\n                # once this double-click has just been detected\n                # right here.\n                @rememberTripleClickMorphsForAWhile morph\n            else\n              @forgetDoubleClickMorphs()\n          else\n            @rememberDoubleClickMorphsForAWhile morph\n\n          tripleClickInvocation = false\n\n          # also send tripleclick if the\n          # three clicks happen on the same morph\n          # Don\'t do anything if a double-click has\n          # just been invoked because you\'d immediately\n          # fire a tripleClick\n          # This pargraph of code is basically the same\n          # as the previous one.\n          if !doubleClickInvocation\n            # same three conditions as double click\n            if @mouseButton == "left" and\n             @tripleClickMorph == morph and\n             ((@tripleClickPosition.distanceTo @position()) < WorldMorph.preferencesAndSettings.grabDragThreshold)\n              #debugger\n              if @tripleClickMorph == morph\n                @tripleClickMorph = nil\n                disableConsecutiveClicksFromSingleClicksDueToFastTests = false\n                if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n                  if !window.world.automatorRecorderAndPlayer.runningInSlowMode()\n                    disableConsecutiveClicksFromSingleClicksDueToFastTests = true\n                if !disableConsecutiveClicksFromSingleClicksDueToFastTests\n                  # remember we are going to send a triple click\n                  # but let\'s do it after. That\'s because we first\n                  # want to send the normal click AND we want to tell\n                  # in the normal click that that normal click is part\n                  # of a triple click\n                  tripleClickInvocation = true\n              else\n                @forgetTripleClickMorphs()\n\n          # fire the click, sending info on whether this was part\n          # of a double/triple click\n          if !morph.editorContentPropertyChangerButton and !(morph instanceof HorizontalMenuPanelWdgt)\n            world.lastNonTextPropertyChangerButtonClickedOrDropped = morph\n          morph[expectedClick] @position(), button, buttons, ctrlKey, shiftKey, altKey, metaKey, doubleClickInvocation, tripleClickInvocation\n          #console.log ">>> sent event " + expectedClick + " to: " + morph\n\n          # now send the double/triple clicks\n          if doubleClickInvocation\n            @processDoubleClick morph\n          if tripleClickInvocation\n            @processTripleClick morph\n\n\n      # some pop-overs can contain horizontal sliders\n      # and when the user interacts with them, it\'s easy\n      # that she can "drag" them outside the range and\n      # do the mouse-up outside the boundaries\n      # of the pop-over. So we avoid that here, if there\n      # is a non-float drag ongoing then we avoid\n      # cleaning-up the pop-overs\n      if !@nonFloatDraggedMorph?\n        @cleanupMenuMorphs expectedClick, morph\n\n    @mouseButton = nil\n    @nonFloatDraggedMorph = nil\n\n\n  forgetDoubleClickMorphs: ->\n    @doubleClickMorph = nil\n    @doubleClickPosition = nil\n\n  rememberDoubleClickMorphsForAWhile: (morph) ->\n    @doubleClickMorph = morph\n    @doubleClickPosition = @position()\n    setTimeout (=>\n      #if @doubleClickMorph?\n      #  console.log "single click"\n      @forgetDoubleClickMorphs()\n      return false\n    ), 300\n\n  # basically the same as rememberDoubleClickMorphsForAWhile\n  forgetTripleClickMorphs: ->\n    @tripleClickMorph = nil\n    @tripleClickPosition = nil\n\n  rememberTripleClickMorphsForAWhile: (morph) ->\n    @tripleClickMorph = morph\n    @tripleClickPosition = @position()\n    setTimeout (=>\n      #if @tripleClickMorph?\n      #  console.log "not a triple click, just a double click"\n      @forgetTripleClickMorphs()\n      return false\n    ), 300\n\n  cleanupMenuMorphs: (expectedClick, morph, alsoKillFreshMenus)->\n\n    world.hierarchyOfClickedMorphs = []\n    world.hierarchyOfClickedMenus = []\n\n    # note that all the actions due to the clicked\n    # morphs have been performed, now we can destroy\n    # morphs queued up for closure\n    # which might include menus...\n    # if we destroyed menus earlier, the\n    # actions that come from the click\n    # might be mangled, e.g. adding a menu\n    # to a destroyed menu, etc.\n    world.closePopUpsMarkedForClosure()\n\n    # remove menus that have requested\n    # to be removed when a click happens outside\n    # of their bounds OR the bounds of their\n    # children\n    #if expectedClick == "mouseClickLeft"\n    # collect all morphs up the hierarchy of\n    # the one the user clicked on.\n    # (including the one the user clicked on)\n    ascendingMorphs = morph\n    world.hierarchyOfClickedMorphs = [ascendingMorphs]\n    while ascendingMorphs.parent?\n      ascendingMorphs = ascendingMorphs.parent\n      world.hierarchyOfClickedMorphs.push ascendingMorphs\n\n    # remove menus that have requested\n    # to be removed when a click happens outside\n    # of their bounds OR the bounds of their\n    # children\n    #if expectedClick == "mouseClickLeft"\n    # collect all the menus up the hierarchy of\n    # the one the user clicked on.\n    # (including the one the user clicked on)\n    # note that the hierarchy of the menus is actually\n    # via the getParentPopUp method\n    firstParentThatIsAPopUp = morph.firstParentThatIsAPopUp()\n    if firstParentThatIsAPopUp?.hierarchyOfPopUps?\n      world.hierarchyOfClickedMenus = firstParentThatIsAPopUp.hierarchyOfPopUps()\n    \n    # go through the morphs that wanted a notification\n    # in case there is a click outside of them or any\n    # of their children.\n    # i.e. check from the notification list which ones are not\n    # in the hierarchy of the clicked morphs\n    # and call their callback.\n    #console.log "morphs wanting to be notified: " + world.morphsDetectingClickOutsideMeOrAnyOfMeChildren\n    #console.log "hierarchy of clicked morphs: " + world.hierarchyOfClickedMorphs\n    #console.log "hierarchy of clicked menus: " + world.hierarchyOfClickedMenus\n    \n\n    # here we do a shallow copy of world.morphsDetectingClickOutsideMeOrAnyOfMeChildren\n    # because we might remove elements of the array while we\n    # iterate on it (as we destroy menus that want to be destroyed\n    # when the user clicks outside of them or their children)\n    # so we need to do a shallow copy to avoid to mangle the for loop\n    morphsDetectingClickOutsideMeOrAnyOfMeChildren = arrayShallowCopy world.morphsDetectingClickOutsideMeOrAnyOfMeChildren\n    for eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren in morphsDetectingClickOutsideMeOrAnyOfMeChildren\n      if (eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren not in world.hierarchyOfClickedMenus) and\n         (eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren not in world.hierarchyOfClickedMorphs)\n        # skip the freshly created menus as otherwise we might\n        # destroy them immediately\n        if alsoKillFreshMenus or eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren not in world.freshlyCreatedPopUps\n          if eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[0]?\n            eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren[eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[0]].call eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren, eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[1], eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[2], eachMorphWantingToBeNotifiedIfClickOutsideThemOrTheirChildren.clickOutsideMeOrAnyOfMeChildrenCallback[3]\n\n  processDoubleClick: (morph = @topMorphUnderPointer()) ->\n    pointerAndMorphInfo = world.getPointerAndMorphInfo morph\n    if AutomatorRecorderAndPlayer?\n      world.automatorRecorderAndPlayer.addMouseDoubleClickCommand nil, pointerAndMorphInfo...\n\n    @destroyToolTips()\n    if @floatDraggingSomething()\n      @drop()\n    else\n      morph = morph.parent  while morph and not morph.mouseDoubleClick\n      morph.mouseDoubleClick @position() if morph\n    @mouseButton = nil\n\n  processTripleClick: (morph = @topMorphUnderPointer()) ->\n    pointerAndMorphInfo = world.getPointerAndMorphInfo morph\n    if AutomatorRecorderAndPlayer?\n      world.automatorRecorderAndPlayer.addMouseTripleClickCommand nil, pointerAndMorphInfo...\n\n    @destroyToolTips()\n    if @floatDraggingSomething()\n      @drop()\n    else\n      morph = morph.parent  while morph and not morph.mouseTripleClick\n      morph.mouseTripleClick @position() if morph\n    @mouseButton = nil\n  \n  # see https://developer.mozilla.org/en-US/docs/Web/Events/wheel\n  processWheel: (deltaX, deltaY, deltaZ, altKey, button, buttons) ->\n    morph = @topMorphUnderPointer()\n    morph = morph.parent  while morph and not morph.wheel\n\n    if morph?\n      morph.wheel deltaX, deltaY, deltaZ, altKey, button, buttons\n  \n  \n  #\n  # drop event:\n  #\n  #        droppedImage\n  #        droppedSVG\n  #        droppedAudio\n  #        droppedText\n  #\n  processDrop: (event) ->\n    #\n    #    find out whether an external image or audio file was dropped\n    #    onto the world canvas, turn it into an offscreen canvas or audio\n    #    element and dispatch the\n    #    \n    #        droppedImage(canvas, name)\n    #        droppedSVG(image, name)\n    #        droppedAudio(audio, name)\n    #    \n    #    events to interested Widgets at the mouse pointer\n    #    if none of the above content types can be determined, the file contents\n    #    is dispatched as an ArrayBuffer to interested Widgets:\n    #\n    #    ```droppedBinary(anArrayBuffer, name)```\n\n    files = (if event instanceof FileList then event else (event.target.files || event.dataTransfer.files))\n    url = (if event.dataTransfer then event.dataTransfer.getData("URL") else nil)\n    txt = (if event.dataTransfer then event.dataTransfer.getData("Text/HTML") else nil)\n    targetDrop = @topMorphUnderPointer()\n    img = new Image()\n\n    readSVG = (aFile) ->\n      pic = new Image()\n      frd = new FileReader()\n      target = target.parent  until target.droppedSVG\n      pic.onload = ->\n        target.droppedSVG pic, aFile.name\n      frd = new FileReader()\n      frd.onloadend = (e) ->\n        pic.src = e.target.result\n      frd.readAsDataURL aFile\n\n    readImage = (aFile) ->\n      pic = new Image()\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedImage\n      pic.onload = ->\n        canvas = newCanvas new Point pic.width, pic.height\n        canvas.getContext("2d").drawImage pic, 0, 0\n        targetDrop.droppedImage canvas, aFile.name\n\n      frd = new FileReader()\n      frd.onloadend = (e) ->\n        pic.src = e.target.result\n\n      frd.readAsDataURL aFile\n\n    readAudio = (aFile) ->\n      snd = new Audio()\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedAudio\n      frd.onloadend = (e) ->\n        snd.src = e.target.result\n        targetDrop.droppedAudio snd, aFile.name\n      frd.readAsDataURL aFile\n    \n    readText = (aFile) ->\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedText\n      frd.onloadend = (e) ->\n        targetDrop.droppedText e.target.result, aFile.name\n      frd.readAsText aFile\n\n\n    readBinary = (aFile) ->\n      frd = new FileReader()\n      targetDrop = targetDrop.parent  until targetDrop.droppedBinary\n      frd.onloadend = (e) ->\n        targetDrop.droppedBinary e.target.result, aFile.name\n      frd.readAsArrayBuffer aFile\n\n    parseImgURL = (html) ->\n      url = ""\n      start = html.indexOf "<img src=\\""\n      return nil  if start is -1\n      start += 10\n      for i in [start...html.length]\n        c = html[i]\n        return url  if c is "\\""\n        url = url.concat c\n      nil\n    \n    if files.length\n      for file in files\n        if file.type.contains("svg") && !WorldMorph.preferencesAndSettings.rasterizeSVGs\n          readSVG file\n        else if file.type.indexOf("image") is 0\n          readImage file\n        else if file.type.indexOf("audio") is 0\n          readAudio file\n        else if file.type.indexOf("text") is 0\n          readText file\n        else\n          readBinary file\n    else if url\n      if url.slice(url.lastIndexOf(".") + 1).toLowerCase() in ["gif", "png", "jpg", "jpeg", "bmp"]\n        target = target.parent  until target.droppedImage\n        img = new Image()\n        img.onload = ->\n          canvas = newCanvas new Point img.width, img.height\n          canvas.getContext("2d").drawImage img, 0, 0\n          target.droppedImage canvas\n        img.src = url\n    else if txt\n      targetDrop = targetDrop.parent  until targetDrop.droppedImage\n      img = new Image()\n      img.onload = ->\n        canvas = newCanvas new Point img.width, img.height\n        canvas.getContext("2d").drawImage img, 0, 0\n        targetDrop.droppedImage canvas\n      src = parseImgURL txt\n      img.src = src  if src\n  \n  \n  # HandMorph tools\n  destroyToolTips: ->\n\n    # "toolTipsList" keeps a list of widgets which will be deleted upon\n    # the next mouse click, or whenever another temporary Widget decides\n    # that it needs to remove them.\n    # Note that we actually destroy toolTipsList because we are not expecting\n    # anybody to revive them once they are gone (as opposed to menus)\n\n    # use a shallow copy of the list because we are\n    # removing elements while iterating through it\n    scanningTemporaries = arrayShallowCopy @toolTipsList\n    scanningTemporaries.forEach (morph) =>\n      unless morph.boundsContainPoint @position()\n        morph.fullDestroy()\n        @toolTipsList.remove morph\n  \n  \n  # HandMorph floatDragging optimization\n  fullRawMoveBy: (delta) ->\n    if delta.isZero() then return\n    trackChanges.push false\n    #console.log "move 2"\n    @breakNumberOfRawMovesAndResizesCaches()\n    super delta\n    trackChanges.pop()\n    @fullChanged()\n\n  processMouseMove: (worldX, worldY, button, buttons, ctrlKey, shiftKey, altKey, metaKey) ->\n    #startProcessMouseMove = new Date().getTime()\n    pos = new Point worldX, worldY\n    @fullRawMoveTo pos\n\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      mousePointerIndicator = document.getElementById "mousePointerIndicator"\n      mousePointerIndicator.style.display = \'block\'\n      posInDocument = getDocumentPositionOf @world.worldCanvas\n      mousePointerIndicator.style.left = (posInDocument.x + worldX - (mousePointerIndicator.clientWidth/2)) + \'px\'\n      mousePointerIndicator.style.top = (posInDocument.y + worldY - (mousePointerIndicator.clientHeight/2)) + \'px\'\n\n    # determine the new mouse-over-list.\n    # Spacial multiplexing\n    # (search "multiplexing" for the other parts of\n    # code where this matters)\n    # There are two interpretations of what this\n    # list should be:\n    #   1) all morphs "pierced through" by the pointer\n    #   2) all morphs parents of the topmost morph under the pointer\n    # 2 is what is used in Cuis\n    \n    # commented-out implementation of 1):\n    # mouseOverNew = @allMorphsAtPointer().reverse()\n    topMorph = @topMorphUnderPointer()\n    mouseOverNew = topMorph.allParentsTopToBottom()\n\n    @determineGrabs pos, topMorph, mouseOverNew\n\n    @dispatchEventsFollowingMouseMove mouseOverNew\n\n  checkDraggingTreshold: ->\n    # UNFORTUNATELY OLD tests didn\'t take the correction into account,\n    # pointers inevitably have some "noise", so to avoid that\n    # a simple clicking (which could be done for example for\n    # selection purposes or to pick a position for a cursor)\n    # turns into a drag, so we add\n    # a grab/drag distance threshold.\n    # Note that even if the mouse moves a bit, we are still\n    # picking up the correct morph that was under the mouse when\n    # the mouse down happened.\n    # Also we correct for the initial displacement\n    # due to the threshold, so really when user starts dragging\n    # it should pick up the EXACT point where the click happened,\n    # not a "later" point once the threshold is passed.\n\n    # so we have to bypass this mechanism for those.\n    displacementDueToGrabDragThreshold = nil\n    skipGrabDragThreshold = false\n    \n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state == AutomatorRecorderAndPlayer.PLAYING\n      currentlyPlayingTestName = world.automatorRecorderAndPlayer.currentlyPlayingTestName\n      if !window["#{currentlyPlayingTestName}"].grabDragThreshold?\n        skipGrabDragThreshold = true\n\n    if !skipGrabDragThreshold\n      if @morphToGrab.parent != world or (!@morphToGrab.isEditable? or @morphToGrab.isEditable )\n        if (@mouseDownPosition.distanceTo @position()) < WorldMorph.preferencesAndSettings.grabDragThreshold\n          return [true,nil]\n      displacementDueToGrabDragThreshold = @position().subtract @mouseDownPosition\n\n    return [false, displacementDueToGrabDragThreshold]\n\n  determineGrabs: (pos, topMorph, mouseOverNew) ->\n    if !@draggingSomething() and (@mouseButton is "left")\n      morph = topMorph.findRootForGrab()\n      topMorph.mouseMove pos  if topMorph.mouseMove\n\n      # if a morph is marked for grabbing, grab it\n      if @morphToGrab\n        \n        # these first two cases are for float dragging\n        # the third case is non-float drag\n        if @morphToGrab.isTemplate\n          [skipDragging, displacementDueToGrabDragThreshold] = @checkDraggingTreshold()\n          if skipDragging then return\n\n          morph = @morphToGrab.fullCopy()\n          morph.isTemplate = false\n          @grab morph, displacementDueToGrabDragThreshold\n          @grabOrigin = @morphToGrab.situation()\n\n        else if @morphToGrab.detachesWhenDragged()\n          [skipDragging, displacementDueToGrabDragThreshold] = @checkDraggingTreshold()\n          if skipDragging then return\n\n          originalMorphToGrab = @morphToGrab\n          @morphToGrab = @morphToGrab.grabbedWidgetSwitcheroo()\n          morph = @morphToGrab\n          @grab morph, displacementDueToGrabDragThreshold, (originalMorphToGrab != morph)\n\n        else\n          # non-float drags are for things such as sliders\n          # and resize handles.\n          # you could have the concept of de-noising, but\n          # actually it seems nicer to have a "springy"\n          # reaction to a slider with some noise.\n          # Users don\'t seem to click on a slider for any other\n          # reason than to move it (as opposed to selecting them\n          # or picking a position for a cursor), so it\'s OK.\n          @nonFloatDraggedMorph = @morphToGrab         \n          @nonFloatDragPositionWithinMorphAtStart =\n            # if we ever will need to compensate for the grab/drag\n            # treshold here, just add .subtract displacementDueToGrabDragThreshold\n            (pos.subtract @nonFloatDraggedMorph.position())\n\n\n        # if the mouse has left its fullBounds, center it\n        if morph\n          fb = morph.fullBounds()\n          unless fb.containsPoint pos\n            @rawSetExtent @extent().subtract fb.extent().floorDivideBy 2\n            @grab morph\n            @fullRawMoveTo pos\n    #endProcessMouseMove = new Date().getTime()\n    #timeProcessMouseMove = endProcessMouseMove - startProcessMouseMove\n    #console.log(\'Execution time ProcessMouseMove: \' + timeProcessMouseMove)\n\n\n    if @nonFloatDraggingSomething()\n      #console.log "nonFloatDraggedMorph: " + @nonFloatDraggedMorph\n\n      # OK so this is an interesting choice. You can avoid\n      # this next line and have ZK to behave like OSX where you\n      # can scroll on a panel without bringing its window in the\n      # foreground. OR you can have the window to automatically\n      # pop into the foreground. I\'m liking the OSX style\n      # so I\'m leaving this commented-out, but it\'s there.\n      # TODO this could be a setting somewhere in ZK.\n      # @nonFloatDraggedMorph.bringToForeground()\n\n      if @mouseButton\n        if @previousNonFloatDraggingPos?\n          deltaDragFromPreviousCall = pos.subtract @previousNonFloatDraggingPos\n        else\n          deltaDragFromPreviousCall = nil\n        @previousNonFloatDraggingPos = pos.copy()\n        @nonFloatDraggedMorph.nonFloatDragging?(@nonFloatDragPositionWithinMorphAtStart, pos, deltaDragFromPreviousCall)\n    \n    #\n    # original, more cautious code for grabbing Widgets,\n    # retained in case of needing to fall back:\n    #\n    #   if (morph === this.morphToGrab) {\n    #     if (morph.grabsToParentWhenDragged) {\n    #       this.grab(morph);\n    #     } else if (morph.isTemplate) {\n    #       morph = morph.fullCopy();\n    #       morph.isTemplate = false;\n    #       morph.grabsToParentWhenDragged = true;\n    #       this.grab(morph);\n    #     }\n    #   }\n    #\n\n  # this is used by the ScrollMorph: clicking on the slider\n  # (but OUTSIDE of the button), the (center of the) button\n  # is immediately non-float dragged to where clicked.\n  nonFloatDragMorphFarAwayToHere: (morphFarAway, pos) ->\n    mouseOverNew = morphFarAway.allParentsTopToBottom()\n    @previousNonFloatDraggingPos = morphFarAway.center()\n    @nonFloatDragPositionWithinMorphAtStart = (new Point morphFarAway.width()/2, morphFarAway.height()/2).round()\n    @nonFloatDraggedMorph = morphFarAway\n    # this one calls the morphFarAway\'s nonFloatDragging method,\n    # for example in case of a SliderMorph invoking this on its\n    # button, this causes the movement of the button\n    # and adjusting of the Slider values and potentially\n    # adjusting scrollpanel etc.\n    @determineGrabs pos, morphFarAway, mouseOverNew\n\n  reCheckMouseEntersAndMouseLeavesAfterPotentialGeometryChanges: ->\n    topMorph = @topMorphUnderPointer()\n    mouseOverNew = topMorph.allParentsTopToBottom()\n    @dispatchEventsFollowingMouseMove mouseOverNew\n\n  dispatchEventsFollowingMouseMove: (mouseOverNew) ->\n\n    @mouseOverList.forEach (old) =>\n      unless old in mouseOverNew\n        old.mouseLeave?()\n        old.mouseLeavefloatDragging?()  if @mouseButton\n\n    mouseOverNew.forEach (newMorph) =>\n      \n      # send mouseMove only if mouse actually moved,\n      # otherwise it will fire also when the user\n      # simply clicks\n      if !@mouseDownPosition? or !@mouseDownPosition.eq @position()\n        newMorph.mouseMove?(@position(), @mouseButton)\n      \n      unless newMorph in @mouseOverList\n        newMorph.mouseEnter?()\n        newMorph.mouseEnterfloatDragging?()  if @mouseButton\n\n      # autoScrolling support:\n      if @floatDraggingSomething()\n        widgetBeingFloatDragged = @children[0]\n        # if we are dragging stuff that can\'t be dropped\n        # (e.g. external windows) then nothing happens\n        if !widgetBeingFloatDragged.rejectsBeingDropped? or !widgetBeingFloatDragged.rejectsBeingDropped()\n          if newMorph instanceof ScrollPanelWdgt\n              if !newMorph.boundingBox().insetBy(\n                WorldMorph.preferencesAndSettings.scrollBarsThickness * 3\n                ).containsPoint @position()\n                  newMorph.startAutoScrolling()\n\n    @mouseOverList = mouseOverNew\n';
