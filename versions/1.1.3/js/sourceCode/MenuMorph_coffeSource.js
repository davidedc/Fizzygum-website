// Generated by CoffeeScript 1.12.7
window.MenuMorph_coffeSource = '# MenuMorphs is a Pop-up with basically a vertical stack of buttons\n\nclass MenuMorph extends PopUpWdgt\n\n  target: nil\n  title: nil\n  environment: nil\n  fontSize: nil\n  label: nil\n  isListContents: false\n\n  constructor: (@morphOpeningThePopUp, @isListContents = false, @target, @killThisPopUpIfClickOutsideDescendants = true, @killThisPopUpIfClickOnDescendantsTriggers = true, @title = nil, @environment = nil, @fontSize = nil) ->\n    # console.log "menu constructor"\n    # console.log "menu super"\n    if AutomatorRecorderAndPlayer? and AutomatorRecorderAndPlayer.state != AutomatorRecorderAndPlayer.IDLE and AutomatorRecorderAndPlayer.alignmentOfMorphIDsMechanism\n      world.alignIDsOfNextMorphsInSystemTests()\n    if !@isListContents\n      if @killThisPopUpIfClickOutsideDescendants\n        @onClickOutsideMeOrAnyOfMyChildren "close"\n    super @morphOpeningThePopUp, @killThisPopUpIfClickOutsideDescendants, @killThisPopUpIfClickOnDescendantsTriggers\n    @isLockingToPanels = false\n    @appearance = new MenuAppearance @\n    @strokeColor = WorldMorph.preferencesAndSettings.menuStrokeColor\n\n\n    if @isListContents\n      world.freshlyCreatedPopUps.remove @\n      world.openPopUps.remove @\n    # important not to traverse all the children for stepping through, because\n    # there could be a lot of entries for example in the inspector the number\n    # of properties of an object - there could be a 100 of those and we don\'t\n    # want to traverse them all. Setting step to nil (as opposed to nop)\n    # achieves that.\n\n    unless @isListContents\n      if @title\n        @createLabel()\n        @silentAdd @label\n\n  colloquialName: ->\n    toBeReturned = "menu"\n    if @title\n      return "\\"" + @title + "\\" menu"\n    else\n      return "menu"\n\n  initialiseDefaultWindowContentLayoutSpec: ->\n    @layoutSpecDetails = new WindowContentLayoutSpec PreferredSize.THIS_ONE_I_HAVE_NOW , PreferredSize.THIS_ONE_I_HAVE_NOW, 0\n    @layoutSpecDetails.canSetHeightFreely = false\n\n\n  createLine: (height = 1) ->\n    item = new RectangleMorph()\n    item.setMinimumExtent new Point 5,1\n    item.color = new Color 230,230,230\n    item.rawSetHeight height + 2\n    item\n\n  addLine: (height) ->\n    item = @createLine height\n    @silentAdd item\n\n  prependLine: (height) ->\n    item = @createLine height\n    @silentAdd item,nil,0\n  \n  createLabel: ->\n    @label = new MenuHeader @title\n\n  createMenuItem: (label, ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked = true, target, action, toolTipMessage, color, bold = false, italic = false,doubleClickAction, arg1, arg2,representsAMorph = false)->\n    # console.log "menu creating MenuItemMorph "\n    item = new MenuItemMorph(\n      ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, # closes unpinned menus\n      target, # target\n      action, # action\n      (label or "close"), # label\n      @fontSize or WorldMorph.preferencesAndSettings.menuFontSize,\n      WorldMorph.preferencesAndSettings.menuFontName,\n      false,\n      @target, # environment\n      @environment, # environment2\n      toolTipMessage, # bubble help toolTipMessage\n      color, # color\n      bold, # bold\n      italic, # italic\n      doubleClickAction,  # doubleclick action\n      arg1,  # argument to action 1\n      arg2,  # argument to action 2\n      representsAMorph  # does it represent a Widget?\n      )\n    if !@environment?\n      item.dataSourceMorphForTarget = item\n      item.morphEnv = @target\n\n    item\n\n  removeMenuItem: (label) ->\n    item = @firstChildSuchThat (m) ->\n      m.label? and m.label.text == label\n    if item?\n      item.fullDestroy()\n\n  removeConsecutiveLines: ->\n    # have to copy the array with slice()\n    # because we are removing items from it\n    # while looping over it\n    destroyNextLines = false\n    for item in @children.slice()\n      if destroyNextLines and item instanceof RectangleMorph\n        item.fullDestroy()\n      if item instanceof RectangleMorph\n        destroyNextLines = true\n        continue\n      else\n        destroyNextLines = false\n\n  addMenuItem: (label, ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, target, action, toolTipMessage, color, bold, italic,doubleClickAction, arg1, arg2,representsAMorph)->\n    # console.log "menu creating MenuItemMorph "\n    item = @createMenuItem label, ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, target, action, toolTipMessage, color, bold, italic,doubleClickAction, arg1, arg2,representsAMorph\n    @silentAdd item\n\n  prependMenuItem: (label, ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, target, action, toolTipMessage, color, bold, italic,doubleClickAction, arg1, arg2,representsAMorph)->\n    # console.log "menu creating MenuItemMorph "\n    item = @createMenuItem label, ifInsidePopUpThenClosesUnpinnedPopUpsWhenClicked, target, action, toolTipMessage, color, bold, italic,doubleClickAction, arg1, arg2,representsAMorph\n    @silentAdd item, nil, 0\n\n  # this is used by the test system to check that the menu\n  # has the correct number of items. Note that we count the\n  # children, but we don\'t count the top label and we don\'t\n  # count the shadow.\n  testNumberOfItems: ->\n    @testItems().length\n\n  # this is used by the test system to check that the menu\n  # has the correct items. Note that we consider the\n  # children, but we don\'t consider the top label and we don\'t\n  # consider the shadow.\n  testItems: ->\n    items = []\n    for item in @children\n      if item != @label\n        items.push item\n    items\n\n  reLayout: ->\n    # console.log "menu update rendering"\n    super()\n\n    # no point in breaking a rectangle for each menu entry,\n    # let\'s hold on the broken rects and then issue\n    # a fullChanged() at the end.\n    trackChanges.push false\n\n\n    # we are going to re-build the\n    # children list from the @items.\n    # If the list of @items has changed, we\n    # make sure we destroy the children that\n    # are going away.\n    #for eachChild in @children\n    #  if @items.indexOf(eachChild) == -1\n    #    eachChild.fullDestroy()\n\n    #@children = []\n\n    unless @isListContents\n      @cornerRadius = if WorldMorph.preferencesAndSettings.isFlat then 0 else 5\n    @color = new Color 238, 238, 238\n    @silentRawSetExtent new Point 0, 0\n    y = @top()\n    x = @left() + 2\n    @notifyChildrenThatParentHasReLayouted()\n\n\n    unless @isListContents\n      if @title\n        @label.fullRawMoveTo @position().add 2\n        y = @label.bottom()\n      else\n        y = @top()\n    y += 1\n\n    @removeShadow()\n\n    # note that menus can contain:\n    # strings, colorpickers,\n    # sliders, menuItems (which are buttons)\n    # and divider lines.\n    # console.log "menu @items.length " + @items.length\n    for item in @children\n      if item == @label then continue\n      item.fullRawMoveTo new Point x, y\n      #console.log "item added: " + item.bounds\n      y = y + item.height()\n  \n    @adjustWidthsOfMenuEntries()\n    fb = @fullBounds()\n    #console.log "fb: " + fb\n    # add some padding to the right and bottom of the menu\n    @silentRawSetExtent fb.extent().add 2\n    trackChanges.pop()\n    @fullChanged()\n  \n  maxWidthOfMenuEntries: ->\n    w = 0\n    #if @parent instanceof PanelWdgt\n    #  if @parent.scrollPanel instanceof ScrollPanelWdgt\n    #    w = @parent.scrollPanel.width()    \n    @children.forEach (item) ->\n      if item instanceof MenuItemMorph\n        if !item.children[0]? then debugger\n        w = Math.max(w, item.children[0].width() + 8)\n      else if (item instanceof StringFieldMorph) or\n        (item instanceof ColorPickerMorph) or\n        (item instanceof SliderMorph)\n          w = Math.max w, item.width()\n      #console.log "maxWidthOfMenuEntries: width of item " + item + " : " + w\n\n    if @label\n      w = Math.max w, @label.width()\n      #console.log "maxWidthOfMenuEntries: label width : " + w\n    w\n  \n  # makes all the elements of this menu the\n  # right width.\n  adjustWidthsOfMenuEntries: ->\n    w = @maxWidthOfMenuEntries()\n    #console.log "maxWidthOfMenuEntries " + w\n    @children.forEach (item) =>\n      trackChanges.push false\n      item.rawSetWidth w\n      #console.log "new width of " + item + " : " + item.width()\n      trackChanges.pop()\n\n  \n  unselectAllItems: ->\n    @children.forEach (item) ->\n      if item instanceof MenuItemMorph\n        item.state = item.STATE_NORMAL\n\n    @changed()\n\n\n\n';
