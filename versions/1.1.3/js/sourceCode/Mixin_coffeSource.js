// Generated by CoffeeScript 1.12.7
window.Mixin_coffeSource = 'class Mixin\n  @allMixines: []\n  nonStaticPropertiesSources: nil\n  staticPropertiesSources: nil\n  name: ""\n\n  _equivalentforSuper: (aString) ->\n    console.log "removing super from: " + aString\n\n    # coffeescript won\'t compile "super" unless it\'s an instance\n    # method (i.e. if it comes inside a class), so we need to\n    # translate that manually into valid CS that doesn\'t use super.\n\n    # rephrasing "super" here...\n    # we can\'t compile "super" in a mixin because we can\'t tell which\n    # class this will be mixed in in advance, i.e. at compile time it doesn\'t\n    # belong to a class, so at compile time it doesn\'t know which class\n    # it will be injected in.\n    # So that\'s why _at time of injection_ we need\n    # to store the class it\'s injected in in a special\n    # variable... and then at runtime here we use that variable to\n    # implement super\n\n    aString = aString.replace(/super$/gm, "window[@[arguments.callee.name + \'_class_injected_in\']].__super__[arguments.callee.name].apply(this, arguments)")\n    aString = aString.replace(/super /g, "window[@[arguments.callee.name + \'_class_injected_in\']].__super__[arguments.callee.name].call this, ")\n\n    # TODO un-translated cases as of yet\n    # /super\\(\\)/g -> ...???...\n    # /super\\(/g -> ...???...\n\n  # Coffeescript adds some helper functions at the top of the compiled code:\n  #\n  #  slice = [].slice\n  #  indexOf = [].indexOf\n  #  hasProp = {}.hasOwnProperty\n  #\n  # here we remove them them all, because they mangle the code,\n  # also we just have them all in the global scope by now so\n  # they are not needed multiple times\n\n  _removeHelperFunctions: (aString) ->\n    aString = aString.replace /indexOf = [].indexOf/, "$$$$$$"\n    aString = aString.replace /hasProp = {}.hasProp/, "$$$$$$"\n    aString = aString.replace /slice = [].slice/, "$$$$$$"\n\n    if (aString.indexOf "[].indexOf") != -1 or\n     (aString.indexOf "{}.hasProp") != -1 or\n     (aString.indexOf "[].slice") != -1\n      alert "code contains a helper var, it shouldn\'t: " +  aString\n      debugger\n\n    return aString\n\n  constructor: (source, generatePreCompiledJS, createMixin) ->\n\n    @nonStaticPropertiesSources = {}\n    @staticPropertiesSources = {}\n\n    # find the Mixin name\n    mixinRegex = /^([a-zA-Z_$][0-9a-zA-Z_$]*)Mixin *=/m\n    if (m = mixinRegex.exec(source))?\n        m.forEach((match, groupIndex) ->\n            console.log("Found match, group #{groupIndex}: #{match}")\n        )\n        @name = m[1]\n        console.log "mixin name: " + @name\n\n    console.log "source ---------\\n" + source\n\n    sourceToBeParsed = source + "\\n      $$$STOPTOKEN_LASTFIELD :"\n\n    # Now find all the fields definitions\n    # note that the constructor, methods, properties and static properties\n    # are ALL fields definitions, so we are basically going to cycle through\n    # everything\n\n    # to match a valid JS variable name (we just ignore the keywords):\n    #    [a-zA-Z_$][0-9a-zA-Z_$]*\n    regex = /^      ([a-zA-Z_$][0-9a-zA-Z_$]*) *: *([^]*?)(?=^      ([a-zA-Z_$][0-9a-zA-Z_$]*) *:)/gm\n\n    while (m = regex.exec(sourceToBeParsed))?\n        if (m.index == regex.lastIndex)\n            regex.lastIndex++\n        m.forEach (match, groupIndex) ->\n            console.log "Found match, group #{groupIndex}: #{match}"\n\n        if m[1].valueOf() == "$$$STOPTOKEN_LASTFIELD "\n          break\n        else\n          console.log "not the stop field: " + m[1].valueOf()\n\n        @nonStaticPropertiesSources[m[1]] = m[2]\n\n    if generatePreCompiledJS or createMixin\n      JS_string_definitions = compileFGCode (@_equivalentforSuper source), true\n      JSSourcesContainer.content += JS_string_definitions + "\\n"\n      if createMixin\n        try\n          eval.call window, JS_string_definitions\n        catch err\n          console.log " error " + err + " evaling : " + JS_string_definitions\n          debugger\n\n\n    #if @name == "LCLCodePreprocessor" then debugger\n\n';
