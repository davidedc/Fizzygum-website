// Generated by CoffeeScript 1.12.7
window.RectangularAppearance_coffeSource = 'class RectangularAppearance extends Appearance\n\n  isTransparentAt: (aPoint) ->\n    if @morph.boundingBoxTight().containsPoint aPoint\n      return false\n    if @morph.backgroundTransparency? and @morph.backgroundColor?\n      if @morph.backgroundTransparency > 0\n        if @morph.boundsContainPoint aPoint\n          return false\n    return true\n\n  # paintHighlight can work in two patterns:\n  #  * passing actual pixels, when used\n  #    outside the effect of the scope of\n  #    "scale pixelRatio, pixelRatio", or\n  #  * passing logical pixels, when used\n  #    inside the effect of the scope of\n  #    "scale pixelRatio, pixelRatio", or\n  # Mostly, the first pattern is used.\n  #\n  # useful for example when hovering over references\n  # to morphs. Can only modify the rendering of a morph,\n  # so any highlighting is only visible in the measure that\n  # the morph is visible (as opposed to HighlighterMorph being\n  # used to highlight a morph)\n  paintHighlight: (aContext, al, at, w, h) ->\n    return\n    \n    #if !@morph.highlighted\n    #  return\n    #\n    # paintRectangle here is usually made to work with\n    # al, at, w, h which are actual pixels\n    # rather than logical pixels.\n    #@morph.paintRectangle \\\n    #  aContext,\n    #  al, at, w, h,\n    #  "orange",\n    #  0.5,\n    #  true # push and pop the context\n\n\n  # This method only paints this very morph\n  # i.e. it doesn\'t descend the children\n  # recursively. The recursion mechanism is done by fullPaintIntoAreaOrBlitFromBackBuffer,\n  # which eventually invokes paintIntoAreaOrBlitFromBackBuffer.\n  # Note that this morph might paint something on the screen even if\n  # it\'s not a "leaf".\n  paintIntoAreaOrBlitFromBackBuffer: (aContext, clippingRectangle, appliedShadow) ->\n\n    if @morph.preliminaryCheckNothingToDraw clippingRectangle, aContext\n      return nil\n\n    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return nil\n\n      @morph.justBeforeBeingPainted?()\n\n      aContext.save()\n      aContext.globalAlpha = (if appliedShadow? then appliedShadow.alpha else 1) * @morph.alpha\n      aContext.fillStyle = @morph.color.toString()\n\n      if !@morph.color?\n        debugger\n\n\n      # paintRectangle is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio\n\n      # paint the background\n      toBePainted = new Rectangle al, at, al + w, at + h\n\n      if @morph.backgroundColor?\n        color = @morph.backgroundColor\n        if appliedShadow?\n          color = "black"\n        @morph.paintRectangle aContext, toBePainted.left(), toBePainted.top(), toBePainted.width(), toBePainted.height(), color\n\n\n      # now paint the actual morph, which is a rectangle\n      # (potentially inset because of the padding)\n      toBePainted = toBePainted.intersect @morph.boundingBoxTight().scaleBy pixelRatio\n\n      color = @morph.color\n      if appliedShadow?\n        color = "black"\n\n      @morph.paintRectangle aContext, toBePainted.left(), toBePainted.top(), toBePainted.width(), toBePainted.height(), color\n\n      @drawAdditionalPartsOnBaseShape? false, false, appliedShadow, aContext, al, at, w, h\n\n      if !appliedShadow?\n        @paintStroke aContext, clippingRectangle\n\n      aContext.restore()\n\n      # paintHighlight is usually made to work with\n      # al, at, w, h which are actual pixels\n      # rather than logical pixels, so it\'s generally used\n      # outside the effect of the scaling because\n      # of the pixelRatio\n      @paintHighlight aContext, al, at, w, h\n\n  paintStroke: (aContext, clippingRectangle) ->\n\n    if @morph.preliminaryCheckNothingToDraw clippingRectangle, aContext\n      return nil\n\n    [area,sl,st,al,at,w,h] = @morph.calculateKeyValues aContext, clippingRectangle\n    if area.isNotEmpty()\n      if w < 1 or h < 1\n        return nil\n\n      @morph.justBeforeBeingPainted?()\n\n      aContext.save()\n\n      toBePainted = new Rectangle al, at, al + w, at + h\n      toBePainted = toBePainted.intersect @morph.boundingBoxTight().scaleBy pixelRatio\n\n      if @morph.strokeColor?\n\n        aContext.beginPath()\n        aContext.rect Math.round(toBePainted.left()),\n          Math.round(toBePainted.top()),\n          Math.round(toBePainted.width()),\n          Math.round(toBePainted.height())\n        aContext.clip()\n\n        aContext.globalAlpha = @morph.alpha\n        aContext.lineWidth = 1\n        aContext.strokeStyle = @morph.strokeColor.toString()\n        # half-pixel adjustments are needed in HTML5 Canvas to draw\n        # pixel-perfect lines. Also note how we have to multiply the\n        # morph metrics to bring them to physical pixels coords.\n        aContext.strokeRect  (Math.round(@morph.left() * pixelRatio)+0.5),\n            (Math.round(@morph.top() * pixelRatio)+0.5),\n            (Math.round(@morph.width() * pixelRatio)-1),\n            (Math.round(@morph.height() * pixelRatio)-1)\n\n      aContext.restore()\n\n';
